//! Generated code! Take a look at the generator-crate for changing this file!
#![allow(clippy::too_many_lines, reason = "Generated code")]
use serde::{Serialize, Deserialize};
use super::super::types::{Coding, CodingInner, CodeableConcept, CodeableConceptInner};
#[doc = "**[AbstractType](http://hl7.org/fhir/ValueSet/abstract-types)**. A type defined by FHIR that is an abstract type\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AbstractType {
    /** **Any**

Any. A place holder that means any kind of resource */
    Any,
    /** **Type**

Type. A place holder that means any kind of data type */
    Type,
}
impl ::core::str::FromStr for AbstractType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Any" => Ok(Self::Any),
            "Type" => Ok(Self::Type),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AbstractType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Any => "Any",
            Self::Type => "Type",
        }
    }
}
impl ::std::fmt::Debug for AbstractType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AbstractType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AbstractType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AbstractType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AbstractType> for Coding {
    fn from(code: AbstractType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/abstract-types".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AbstractType> for CodeableConcept {
    fn from(code: AbstractType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AccountStatus](http://hl7.org/fhir/ValueSet/account-status)**. Indicates whether the account is available to be used.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AccountStatus {
    /** **active**

Active. This account is active and may be used. */
    Active,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **inactive**

Inactive. This account is inactive and should not be used to track financial information. */
    Inactive,
}
impl ::core::str::FromStr for AccountStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AccountStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Debug for AccountStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AccountStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AccountStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AccountStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AccountStatus> for Coding {
    fn from(code: AccountStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/account-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AccountStatus> for CodeableConcept {
    fn from(code: AccountStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionCardinalityBehavior](http://hl7.org/fhir/ValueSet/action-cardinality-behavior)**. Defines behavior for an action or a group for how many times that item may be repeated\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionCardinalityBehavior {
    /** **multiple**

Multiple. The action may be selected multiple times */
    Multiple,
    /** **single**

Single. The action may only be selected one time */
    Single,
}
impl ::core::str::FromStr for ActionCardinalityBehavior {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "multiple" => Ok(Self::Multiple),
            "single" => Ok(Self::Single),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionCardinalityBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::Multiple => "multiple",
            Self::Single => "single",
        }
    }
}
impl ::std::fmt::Debug for ActionCardinalityBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionCardinalityBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionCardinalityBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionCardinalityBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionCardinalityBehavior> for Coding {
    fn from(code: ActionCardinalityBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-cardinality-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionCardinalityBehavior> for CodeableConcept {
    fn from(code: ActionCardinalityBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionConditionKind](http://hl7.org/fhir/ValueSet/action-condition-kind)**. Defines the kinds of conditions that can appear on actions\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionConditionKind {
    /** **applicability**

Applicability. The condition describes whether or not a given action is applicable */
    Applicability,
    /** **start**

Start. The condition is a starting condition for the action */
    Start,
    /** **stop**

Stop. The condition is a stop, or exit condition for the action */
    Stop,
}
impl ::core::str::FromStr for ActionConditionKind {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "applicability" => Ok(Self::Applicability),
            "start" => Ok(Self::Start),
            "stop" => Ok(Self::Stop),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionConditionKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Applicability => "applicability",
            Self::Start => "start",
            Self::Stop => "stop",
        }
    }
}
impl ::std::fmt::Debug for ActionConditionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionConditionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionConditionKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionConditionKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionConditionKind> for Coding {
    fn from(code: ActionConditionKind) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-condition-kind".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionConditionKind> for CodeableConcept {
    fn from(code: ActionConditionKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionGroupingBehavior](http://hl7.org/fhir/ValueSet/action-grouping-behavior)**. Defines organization behavior of a group\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionGroupingBehavior {
    /** **logical-group**

Logical Group. A group with this behavior logically groups its sub-elements, and may be shown as a visual group to the end user, but it is not required to do so */
    LogicalGroup,
    /** **sentence-group**

Sentence Group. A group of related alternative actions is a sentence group if the target referenced by the action is the same in all the actions and each action simply constitutes a different variation on how to specify the details for the target. For example, two actions that could be in a SentenceGroup are "aspirin, 500 mg, 2 times per day" and "aspirin, 300 mg, 3 times per day". In both cases, aspirin is the target referenced by the action, and the two actions represent different options for how aspirin might be ordered for the patient. Note that a SentenceGroup would almost always have an associated selection behavior of "AtMostOne", unless it's a required action, in which case, it would be "ExactlyOne" */
    SentenceGroup,
    /** **visual-group**

Visual Group. Any group marked with this behavior should be displayed as a visual group to the end user */
    VisualGroup,
}
impl ::core::str::FromStr for ActionGroupingBehavior {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "logical-group" => Ok(Self::LogicalGroup),
            "sentence-group" => Ok(Self::SentenceGroup),
            "visual-group" => Ok(Self::VisualGroup),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionGroupingBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::LogicalGroup => "logical-group",
            Self::SentenceGroup => "sentence-group",
            Self::VisualGroup => "visual-group",
        }
    }
}
impl ::std::fmt::Debug for ActionGroupingBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionGroupingBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionGroupingBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionGroupingBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionGroupingBehavior> for Coding {
    fn from(code: ActionGroupingBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-grouping-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionGroupingBehavior> for CodeableConcept {
    fn from(code: ActionGroupingBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionList](http://hl7.org/fhir/ValueSet/actionlist)**. List of allowable action which this resource can request.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionList {
    /** **cancel**

Cancel, Reverse or Nullify. Cancel, reverse or nullify the target resource. */
    Cancel,
    /** **poll**

Poll. Check for previously un-read/ not-retrieved resources. */
    Poll,
    /** **reprocess**

Re-Process. Re-process the target resource. */
    Reprocess,
    /** **status**

Status Check. Retrieve the processing status of the target resource. */
    Status,
}
impl ::core::str::FromStr for ActionList {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cancel" => Ok(Self::Cancel),
            "poll" => Ok(Self::Poll),
            "reprocess" => Ok(Self::Reprocess),
            "status" => Ok(Self::Status),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionList {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cancel => "cancel",
            Self::Poll => "poll",
            Self::Reprocess => "reprocess",
            Self::Status => "status",
        }
    }
}
impl ::std::fmt::Debug for ActionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionList> for Coding {
    fn from(code: ActionList) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/actionlist".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionList> for CodeableConcept {
    fn from(code: ActionList) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionParticipantType](http://hl7.org/fhir/ValueSet/action-participant-type)**. The type of participant for the action\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionParticipantType {
    /** **patient**

Patient. The participant is the patient under evaluation */
    Patient,
    /** **practitioner**

Practitioner. The participant is a practitioner involved in the patient's care */
    Practitioner,
    /** **related-person**

Related Person. The participant is a person related to the patient */
    RelatedPerson,
}
impl ::core::str::FromStr for ActionParticipantType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "patient" => Ok(Self::Patient),
            "practitioner" => Ok(Self::Practitioner),
            "related-person" => Ok(Self::RelatedPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Patient => "patient",
            Self::Practitioner => "practitioner",
            Self::RelatedPerson => "related-person",
        }
    }
}
impl ::std::fmt::Debug for ActionParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionParticipantType> for Coding {
    fn from(code: ActionParticipantType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-participant-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionParticipantType> for CodeableConcept {
    fn from(code: ActionParticipantType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionPrecheckBehavior](http://hl7.org/fhir/ValueSet/action-precheck-behavior)**. Defines selection frequency behavior for an action or group\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionPrecheckBehavior {
    /** **no**

No. An action with this behavior is one of the less frequent actions included by the end user, for the particular context in which the action occurs. The system displaying the actions to the end user would typically not "pre-check" such an action */
    No,
    /** **yes**

Yes. An action with this behavior is one of the most frequent action that is, or should be, included by an end user, for the particular context in which the action occurs. The system displaying the action to the end user should consider "pre-checking" such an action as a convenience for the user */
    Yes,
}
impl ::core::str::FromStr for ActionPrecheckBehavior {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "no" => Ok(Self::No),
            "yes" => Ok(Self::Yes),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionPrecheckBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::No => "no",
            Self::Yes => "yes",
        }
    }
}
impl ::std::fmt::Debug for ActionPrecheckBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionPrecheckBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionPrecheckBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionPrecheckBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionPrecheckBehavior> for Coding {
    fn from(code: ActionPrecheckBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-precheck-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionPrecheckBehavior> for CodeableConcept {
    fn from(code: ActionPrecheckBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionRelationshipType](http://hl7.org/fhir/ValueSet/action-relationship-type)**. Defines the types of relationships between actions\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionRelationshipType {
    /** **after**

After. The action must be performed after the related action */
    After,
    /** **after-end**

After End. The action must be performed after the end of the related action */
    AfterEnd,
    /** **after-start**

After Start. The action must be performed after the start of the related action */
    AfterStart,
    /** **before**

Before. The action must be performed before the related action */
    Before,
    /** **before-end**

Before End. The action must be performed before the end of the related action */
    BeforeEnd,
    /** **before-start**

Before Start. The action must be performed before the start of the related action */
    BeforeStart,
    /** **concurrent**

Concurrent. The action must be performed concurrent with the related action */
    Concurrent,
    /** **concurrent-with-end**

Concurrent With End. The action must be performed concurrent with the end of the related action */
    ConcurrentWithEnd,
    /** **concurrent-with-start**

Concurrent With Start. The action must be performed concurrent with the start of the related action */
    ConcurrentWithStart,
}
impl ::core::str::FromStr for ActionRelationshipType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "after" => Ok(Self::After),
            "after-end" => Ok(Self::AfterEnd),
            "after-start" => Ok(Self::AfterStart),
            "before" => Ok(Self::Before),
            "before-end" => Ok(Self::BeforeEnd),
            "before-start" => Ok(Self::BeforeStart),
            "concurrent" => Ok(Self::Concurrent),
            "concurrent-with-end" => Ok(Self::ConcurrentWithEnd),
            "concurrent-with-start" => Ok(Self::ConcurrentWithStart),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::After => "after",
            Self::AfterEnd => "after-end",
            Self::AfterStart => "after-start",
            Self::Before => "before",
            Self::BeforeEnd => "before-end",
            Self::BeforeStart => "before-start",
            Self::Concurrent => "concurrent",
            Self::ConcurrentWithEnd => "concurrent-with-end",
            Self::ConcurrentWithStart => "concurrent-with-start",
        }
    }
}
impl ::std::fmt::Debug for ActionRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionRelationshipType> for Coding {
    fn from(code: ActionRelationshipType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-relationship-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionRelationshipType> for CodeableConcept {
    fn from(code: ActionRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionRequiredBehavior](http://hl7.org/fhir/ValueSet/action-required-behavior)**. Defines requiredness behavior for selecting an action or an action group\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionRequiredBehavior {
    /** **could**

Could. An action with this behavior may be included in the set of actions processed by the end user */
    Could,
    /** **must**

Must. An action with this behavior must be included in the actions processed by the end user; the end user may not choose not to include this action */
    Must,
    /** **must-unless-documented**

Must Unless Documented. An action with this behavior must be included in the set of actions processed by the end user, unless the end user provides documentation as to why the action was not included */
    MustUnlessDocumented,
}
impl ::core::str::FromStr for ActionRequiredBehavior {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "could" => Ok(Self::Could),
            "must" => Ok(Self::Must),
            "must-unless-documented" => Ok(Self::MustUnlessDocumented),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionRequiredBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::Could => "could",
            Self::Must => "must",
            Self::MustUnlessDocumented => "must-unless-documented",
        }
    }
}
impl ::std::fmt::Debug for ActionRequiredBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionRequiredBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionRequiredBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionRequiredBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionRequiredBehavior> for Coding {
    fn from(code: ActionRequiredBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-required-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionRequiredBehavior> for CodeableConcept {
    fn from(code: ActionRequiredBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionSelectionBehavior](http://hl7.org/fhir/ValueSet/action-selection-behavior)**. Defines selection behavior of a group\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionSelectionBehavior {
    /** **all**

All. All the actions in the group must be selected as a single unit */
    All,
    /** **all-or-none**

All Or None. All the actions in the group are meant to be chosen as a single unit: either all must be selected by the end user, or none may be selected */
    AllOrNone,
    /** **any**

Any. Any number of the actions in the group may be chosen, from zero to all */
    Any,
    /** **at-most-one**

At Most One. The end user may choose zero or at most one of the actions in the group */
    AtMostOne,
    /** **exactly-one**

Exactly One. The end user must choose one and only one of the selectable actions in the group. The user may not choose none of the actions in the group */
    ExactlyOne,
    /** **one-or-more**

One Or More. The end user must choose a minimum of one, and as many additional as desired */
    OneOrMore,
}
impl ::core::str::FromStr for ActionSelectionBehavior {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "all-or-none" => Ok(Self::AllOrNone),
            "any" => Ok(Self::Any),
            "at-most-one" => Ok(Self::AtMostOne),
            "exactly-one" => Ok(Self::ExactlyOne),
            "one-or-more" => Ok(Self::OneOrMore),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionSelectionBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::All => "all",
            Self::AllOrNone => "all-or-none",
            Self::Any => "any",
            Self::AtMostOne => "at-most-one",
            Self::ExactlyOne => "exactly-one",
            Self::OneOrMore => "one-or-more",
        }
    }
}
impl ::std::fmt::Debug for ActionSelectionBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionSelectionBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionSelectionBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionSelectionBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionSelectionBehavior> for Coding {
    fn from(code: ActionSelectionBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-selection-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionSelectionBehavior> for CodeableConcept {
    fn from(code: ActionSelectionBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionType](http://hl7.org/fhir/ValueSet/action-type)**. The type of action to be performed\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionType {
    /** **create**

Create. The action is to create a new resource */
    Create,
    /** **fire-event**

Fire Event. The action is to fire a specific event */
    FireEvent,
    /** **remove**

Remove. The action is to remove an existing resource */
    Remove,
    /** **update**

Update. The action is to update an existing resource */
    Update,
}
impl ::core::str::FromStr for ActionType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "create" => Ok(Self::Create),
            "fire-event" => Ok(Self::FireEvent),
            "remove" => Ok(Self::Remove),
            "update" => Ok(Self::Update),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Create => "create",
            Self::FireEvent => "fire-event",
            Self::Remove => "remove",
            Self::Update => "update",
        }
    }
}
impl ::std::fmt::Debug for ActionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionType> for Coding {
    fn from(code: ActionType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/action-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionType> for CodeableConcept {
    fn from(code: ActionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActivityDefinitionCategory](http://hl7.org/fhir/ValueSet/activity-definition-category)**. High-level categorization of the type of activity\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActivityDefinitionCategory {
    /** **assessment**

Assessment. The activity is intended to perform or is related to assessment of the patient */
    Assessment,
    /** **education**

Education. The activity is intended to provide or is related to education of the patient */
    Education,
    /** **treatment**

Treatment. The activity is intended to provide or is related to treatment of the patient */
    Treatment,
}
impl ::core::str::FromStr for ActivityDefinitionCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assessment" => Ok(Self::Assessment),
            "education" => Ok(Self::Education),
            "treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActivityDefinitionCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assessment => "assessment",
            Self::Education => "education",
            Self::Treatment => "treatment",
        }
    }
}
impl ::std::fmt::Debug for ActivityDefinitionCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActivityDefinitionCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActivityDefinitionCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActivityDefinitionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActivityDefinitionCategory> for Coding {
    fn from(code: ActivityDefinitionCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/activity-definition-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActivityDefinitionCategory> for CodeableConcept {
    fn from(code: ActivityDefinitionCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AddressType](http://hl7.org/fhir/ValueSet/address-type)**. The type of an address (physical / postal)\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AddressType {
    /** **both**

Postal & Physical. An address that is both physical and postal. */
    Both,
    /** **physical**

Physical. A physical address that can be visited. */
    Physical,
    /** **postal**

Postal. Mailing addresses - PO Boxes and care-of addresses. */
    Postal,
}
impl ::core::str::FromStr for AddressType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "both" => Ok(Self::Both),
            "physical" => Ok(Self::Physical),
            "postal" => Ok(Self::Postal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AddressType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Both => "both",
            Self::Physical => "physical",
            Self::Postal => "postal",
        }
    }
}
impl ::std::fmt::Debug for AddressType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AddressType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AddressType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AddressType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AddressType> for Coding {
    fn from(code: AddressType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/address-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AddressType> for CodeableConcept {
    fn from(code: AddressType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AddressUse](http://hl7.org/fhir/ValueSet/address-use)**. The use of an address\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AddressUse {
    /** **home**

Home. A communication address at a home. */
    Home,
    /** **old**

Old / Incorrect. This address is no longer in use (or was never correct, but retained for records). */
    Old,
    /** **temp**

Temporary. A temporary address. The period can provide more detailed information. */
    Temp,
    /** **work**

Work. An office address. First choice for business related contacts during business hours. */
    Work,
}
impl ::core::str::FromStr for AddressUse {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "home" => Ok(Self::Home),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "work" => Ok(Self::Work),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AddressUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Home => "home",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Work => "work",
        }
    }
}
impl ::std::fmt::Debug for AddressUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AddressUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AddressUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AddressUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AddressUse> for Coding {
    fn from(code: AddressUse) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/address-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AddressUse> for CodeableConcept {
    fn from(code: AddressUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdministrativeGender](http://hl7.org/fhir/ValueSet/administrative-gender)**. The gender of a person used for administrative purposes.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdministrativeGender {
    /** **female**

Female. Female */
    Female,
    /** **male**

Male. Male */
    Male,
    /** **other**

Other. Other */
    Other,
    /** **unknown**

Unknown. Unknown */
    Unknown,
}
impl ::core::str::FromStr for AdministrativeGender {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "female" => Ok(Self::Female),
            "male" => Ok(Self::Male),
            "other" => Ok(Self::Other),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdministrativeGender {
    fn as_ref(&self) -> &str {
        match self {
            Self::Female => "female",
            Self::Male => "male",
            Self::Other => "other",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for AdministrativeGender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdministrativeGender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdministrativeGender {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdministrativeGender {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdministrativeGender> for Coding {
    fn from(code: AdministrativeGender) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/administrative-gender".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdministrativeGender> for CodeableConcept {
    fn from(code: AdministrativeGender) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdmitSource](http://hl7.org/fhir/ValueSet/encounter-admit-source)**. This value set defines a set of codes that can be used to indicate from where the patient came in.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdmitSource {
    /** **born**

Born in hospital. The patient is a newborn and the encounter will track the baby related activities (as opposed to the Mothers encounter - that may be associated using the newborn encounters partof property) */
    Born,
    /** **emd**

From accident/emergency department. The patient has been transferred from the emergency department within the hospital. This is typically used in the transition to an inpatient encounter */
    Emd,
    /** **gp**

General Practitioner referral. The patient has been admitted due to a referred from a General Practitioner. */
    Gp,
    /** **hosp-trans**

Transferred from other hospital. The Patient has been transferred from another hospital for this encounter. */
    HospTrans,
    /** **mp**

Medical Practitioner/physician referral. The patient has been admitted due to a referred from a Specialist (as opposed to a General Practitioner). */
    Mp,
    /** **nursing**

From nursing home. The patient has been transferred from a nursing home. */
    Nursing,
    /** **other**

Other. The patient has been admitted from a source otherwise not specified here. */
    Other,
    /** **outp**

From outpatient department. The patient has been transferred from an outpatient department within the hospital. */
    Outp,
    /** **psych**

From psychiatric hospital. The patient has been transferred from a psychiatric facility. */
    Psych,
    /** **rehab**

From rehabilitation facility. The patient has been transferred from a rehabilitiation facility or clinic. */
    Rehab,
}
impl ::core::str::FromStr for AdmitSource {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "born" => Ok(Self::Born),
            "emd" => Ok(Self::Emd),
            "gp" => Ok(Self::Gp),
            "hosp-trans" => Ok(Self::HospTrans),
            "mp" => Ok(Self::Mp),
            "nursing" => Ok(Self::Nursing),
            "other" => Ok(Self::Other),
            "outp" => Ok(Self::Outp),
            "psych" => Ok(Self::Psych),
            "rehab" => Ok(Self::Rehab),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdmitSource {
    fn as_ref(&self) -> &str {
        match self {
            Self::Born => "born",
            Self::Emd => "emd",
            Self::Gp => "gp",
            Self::HospTrans => "hosp-trans",
            Self::Mp => "mp",
            Self::Nursing => "nursing",
            Self::Other => "other",
            Self::Outp => "outp",
            Self::Psych => "psych",
            Self::Rehab => "rehab",
        }
    }
}
impl ::std::fmt::Debug for AdmitSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdmitSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdmitSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdmitSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdmitSource> for Coding {
    fn from(code: AdmitSource) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/encounter-admit-source".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdmitSource> for CodeableConcept {
    fn from(code: AdmitSource) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventCategory](http://hl7.org/fhir/ValueSet/adverse-event-category)**. Overall categorization of the event, e.g. real or potential\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventCategory {
    /** **AE**

Adverse Event. */
    Ae,
    /** **PAE**

Potential Adverse Event. */
    Pae,
}
impl ::core::str::FromStr for AdverseEventCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AE" => Ok(Self::Ae),
            "PAE" => Ok(Self::Pae),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ae => "AE",
            Self::Pae => "PAE",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventCategory> for Coding {
    fn from(code: AdverseEventCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventCategory> for CodeableConcept {
    fn from(code: AdverseEventCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventCausality](http://hl7.org/fhir/ValueSet/adverse-event-causality)**. TODO\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventCausality {
    /** **causality1**

causality1 placeholder. */
    Causality1,
    /** **causality2**

causality2 placeholder. */
    Causality2,
}
impl ::core::str::FromStr for AdverseEventCausality {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "causality1" => Ok(Self::Causality1),
            "causality2" => Ok(Self::Causality2),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCausality {
    fn as_ref(&self) -> &str {
        match self {
            Self::Causality1 => "causality1",
            Self::Causality2 => "causality2",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventCausality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventCausality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventCausality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCausality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventCausality> for Coding {
    fn from(code: AdverseEventCausality) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-causality".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventCausality> for CodeableConcept {
    fn from(code: AdverseEventCausality) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventCausalityAssessment](http://hl7.org/fhir/ValueSet/adverse-event-causality-assess)**. TODO\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventCausalityAssessment {
    /** **assess1**

assess1 placeholder. */
    Assess1,
    /** **assess2**

assess2 placeholder. */
    Assess2,
}
impl ::core::str::FromStr for AdverseEventCausalityAssessment {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assess1" => Ok(Self::Assess1),
            "assess2" => Ok(Self::Assess2),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCausalityAssessment {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assess1 => "assess1",
            Self::Assess2 => "assess2",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventCausalityAssessment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventCausalityAssessment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventCausalityAssessment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCausalityAssessment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventCausalityAssessment> for Coding {
    fn from(code: AdverseEventCausalityAssessment) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-causality-assess".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventCausalityAssessment> for CodeableConcept {
    fn from(code: AdverseEventCausalityAssessment) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventCausalityMethod](http://hl7.org/fhir/ValueSet/adverse-event-causality-method)**. TODO\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventCausalityMethod {
    /** **method1**

placeholder. */
    Method1,
    /** **method2**

placeholder. */
    Method2,
}
impl ::core::str::FromStr for AdverseEventCausalityMethod {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "method1" => Ok(Self::Method1),
            "method2" => Ok(Self::Method2),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCausalityMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Method1 => "method1",
            Self::Method2 => "method2",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventCausalityMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventCausalityMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventCausalityMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCausalityMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventCausalityMethod> for Coding {
    fn from(code: AdverseEventCausalityMethod) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-causality-method".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventCausalityMethod> for CodeableConcept {
    fn from(code: AdverseEventCausalityMethod) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventCausalityResult](http://hl7.org/fhir/ValueSet/adverse-event-causality-result)**. TODO\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventCausalityResult {
    /** **result1**

placeholder. */
    Result1,
    /** **result2**

placeholder. */
    Result2,
}
impl ::core::str::FromStr for AdverseEventCausalityResult {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "result1" => Ok(Self::Result1),
            "result2" => Ok(Self::Result2),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCausalityResult {
    fn as_ref(&self) -> &str {
        match self {
            Self::Result1 => "result1",
            Self::Result2 => "result2",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventCausalityResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventCausalityResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventCausalityResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCausalityResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventCausalityResult> for Coding {
    fn from(code: AdverseEventCausalityResult) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-causality-result".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventCausalityResult> for CodeableConcept {
    fn from(code: AdverseEventCausalityResult) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventOutcome](http://hl7.org/fhir/ValueSet/adverse-event-outcome)**. TODO (and should this be required?)\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventOutcome {
    /** **fatal**

Fatal. */
    Fatal,
    /** **ongoing**

Ongoing. */
    Ongoing,
    /** **recovering**

Recovering. */
    Recovering,
    /** **resolved**

Resolved. */
    Resolved,
    /** **resolvedWithSequelae**

Resolved with Sequelae. */
    ResolvedWithSequelae,
    /** **unknown**

Unknown. */
    Unknown,
}
impl ::core::str::FromStr for AdverseEventOutcome {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fatal" => Ok(Self::Fatal),
            "ongoing" => Ok(Self::Ongoing),
            "recovering" => Ok(Self::Recovering),
            "resolved" => Ok(Self::Resolved),
            "resolvedWithSequelae" => Ok(Self::ResolvedWithSequelae),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fatal => "fatal",
            Self::Ongoing => "ongoing",
            Self::Recovering => "recovering",
            Self::Resolved => "resolved",
            Self::ResolvedWithSequelae => "resolvedWithSequelae",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventOutcome> for Coding {
    fn from(code: AdverseEventOutcome) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-outcome".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventOutcome> for CodeableConcept {
    fn from(code: AdverseEventOutcome) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventSeriousness](http://hl7.org/fhir/ValueSet/adverse-event-seriousness)**. Overall seriousness of this event for the patient\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventSeriousness {
    /** **Mild**

Mild. */
    Mild,
    /** **Moderate**

Moderate. */
    Moderate,
    /** **Severe**

Severe. */
    Severe,
}
impl ::core::str::FromStr for AdverseEventSeriousness {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Mild" => Ok(Self::Mild),
            "Moderate" => Ok(Self::Moderate),
            "Severe" => Ok(Self::Severe),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventSeriousness {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mild => "Mild",
            Self::Moderate => "Moderate",
            Self::Severe => "Severe",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventSeriousness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventSeriousness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventSeriousness {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventSeriousness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventSeriousness> for Coding {
    fn from(code: AdverseEventSeriousness) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-seriousness".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventSeriousness> for CodeableConcept {
    fn from(code: AdverseEventSeriousness) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AggregationMode](http://hl7.org/fhir/ValueSet/resource-aggregation-mode)**. How resource references can be aggregated.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AggregationMode {
    /** **bundled**

Bundled. The resource the reference points to will be found in the same bundle as the resource that includes the reference. */
    Bundled,
    /** **contained**

Contained. The reference is a local reference to a contained resource. */
    Contained,
    /** **referenced**

Referenced. The reference to a resource that has to be resolved externally to the resource that includes the reference. */
    Referenced,
}
impl ::core::str::FromStr for AggregationMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bundled" => Ok(Self::Bundled),
            "contained" => Ok(Self::Contained),
            "referenced" => Ok(Self::Referenced),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AggregationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bundled => "bundled",
            Self::Contained => "contained",
            Self::Referenced => "referenced",
        }
    }
}
impl ::std::fmt::Debug for AggregationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AggregationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AggregationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AggregationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AggregationMode> for Coding {
    fn from(code: AggregationMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/resource-aggregation-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AggregationMode> for CodeableConcept {
    fn from(code: AggregationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceCategory](http://hl7.org/fhir/ValueSet/allergy-intolerance-category)**. Category of an identified substance.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceCategory {
    /** **biologic**

Biologic. A preparation that is synthesized from living organisms or their products, especially a human or animal protein, such as a hormone or antitoxin, that is used as a diagnostic, preventive, or therapeutic agent. Examples of biologic medications include: vaccines; allergenic extracts, which are used for both diagnosis and treatment (for example, allergy shots); gene therapies; cellular therapies.  There are other biologic products, such as tissues, that are not typically associated with allergies. */
    Biologic,
    /** **environment**

Environment. Any substances that are encountered in the environment, including any substance not already classified as food, medication, or biologic. */
    Environment,
    /** **food**

Food. Any substance consumed to provide nutritional support for the body. */
    Food,
    /** **medication**

Medication. Substances administered to achieve a physiological effect. */
    Medication,
}
impl ::core::str::FromStr for AllergyIntoleranceCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "biologic" => Ok(Self::Biologic),
            "environment" => Ok(Self::Environment),
            "food" => Ok(Self::Food),
            "medication" => Ok(Self::Medication),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Biologic => "biologic",
            Self::Environment => "environment",
            Self::Food => "food",
            Self::Medication => "medication",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceCategory> for Coding {
    fn from(code: AllergyIntoleranceCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergy-intolerance-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceCategory> for CodeableConcept {
    fn from(code: AllergyIntoleranceCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceCertainty](http://hl7.org/fhir/ValueSet/reaction-event-certainty)**. Statement about the degree of clinical certainty that a specific substance was the cause of the manifestation in a reaction event.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceCertainty {
    /** **confirmed**

Confirmed. There is a very high level of clinical certainty that the reaction was due to the identified substance, which may include clinical evidence by testing or rechallenge. */
    Confirmed,
    /** **likely**

Likely. There is a high level of clinical certainty that the reaction was caused by the identified substance. */
    Likely,
    /** **unknown**

Unknown. The clinical certainty that the reaction was caused by the identified substance is unknown.  It is an explicit assertion that certainty is not known. */
    Unknown,
    /** **unlikely**

Unlikely. There is a low level of clinical certainty that the reaction was caused by the identified substance. */
    Unlikely,
}
impl ::core::str::FromStr for AllergyIntoleranceCertainty {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(Self::Confirmed),
            "likely" => Ok(Self::Likely),
            "unknown" => Ok(Self::Unknown),
            "unlikely" => Ok(Self::Unlikely),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCertainty {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confirmed => "confirmed",
            Self::Likely => "likely",
            Self::Unknown => "unknown",
            Self::Unlikely => "unlikely",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceCertainty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceCertainty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCertainty {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCertainty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceCertainty> for Coding {
    fn from(code: AllergyIntoleranceCertainty) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/reaction-event-certainty".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceCertainty> for CodeableConcept {
    fn from(code: AllergyIntoleranceCertainty) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceClinicalStatus](http://hl7.org/fhir/ValueSet/allergy-clinical-status)**. The clinical status of the allergy or intolerance.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceClinicalStatus {
    /** **active**

Active. An active record of a risk of a reaction to the identified substance. */
    Active,
    /** **inactive**

Inactive. An inactivated record of a risk of a reaction to the identified substance. */
    Inactive,
    /** **resolved**

Resolved. A reaction to the identified substance has been clinically reassessed by testing or re-exposure and considered to be resolved. */
    Resolved,
}
impl ::core::str::FromStr for AllergyIntoleranceClinicalStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "resolved" => Ok(Self::Resolved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceClinicalStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Resolved => "resolved",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceClinicalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceClinicalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceClinicalStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceClinicalStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceClinicalStatus> for Coding {
    fn from(code: AllergyIntoleranceClinicalStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergy-clinical-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceClinicalStatus> for CodeableConcept {
    fn from(code: AllergyIntoleranceClinicalStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceCriticality](http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality)**. Estimate of the potential clinical harm, or seriousness, of a reaction to an identified substance.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceCriticality {
    /** **high**

High Risk. Worst case result of a future exposure is assessed to be life-threatening or having high potential for organ system failure. */
    High,
    /** **low**

Low Risk. Worst case result of a future exposure is not assessed to be life-threatening or having high potential for organ system failure. */
    Low,
    /** **unable-to-assess**

Unable to Assess Risk. Unable to assess the worst case result of a future exposure. */
    UnableToAssess,
}
impl ::core::str::FromStr for AllergyIntoleranceCriticality {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "unable-to-assess" => Ok(Self::UnableToAssess),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCriticality {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::UnableToAssess => "unable-to-assess",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceCriticality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceCriticality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCriticality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCriticality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceCriticality> for Coding {
    fn from(code: AllergyIntoleranceCriticality) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceCriticality> for CodeableConcept {
    fn from(code: AllergyIntoleranceCriticality) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceSeverity](http://hl7.org/fhir/ValueSet/reaction-event-severity)**. Clinical assessment of the severity of a reaction event as a whole, potentially considering multiple different manifestations.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceSeverity {
    /** **mild**

Mild. Causes mild physiological effects. */
    Mild,
    /** **moderate**

Moderate. Causes moderate physiological effects. */
    Moderate,
    /** **severe**

Severe. Causes severe physiological effects. */
    Severe,
}
impl ::core::str::FromStr for AllergyIntoleranceSeverity {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mild" => Ok(Self::Mild),
            "moderate" => Ok(Self::Moderate),
            "severe" => Ok(Self::Severe),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mild => "mild",
            Self::Moderate => "moderate",
            Self::Severe => "severe",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceSeverity> for Coding {
    fn from(code: AllergyIntoleranceSeverity) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/reaction-event-severity".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceSeverity> for CodeableConcept {
    fn from(code: AllergyIntoleranceSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceSubstanceExposureRisk](http://hl7.org/fhir/ValueSet/allerg-intol-substance-exp-risk)**. The risk of an adverse reaction (allergy or intolerance) for this patient upon exposure to the substance (including pharmaceutical products).\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceSubstanceExposureRisk {
    /** **known-reaction-risk**

Known Reaction Risk. Known risk of allergy or intolerance reaction upon exposure to the specified substance. */
    KnownReactionRisk,
    /** **no-known-reaction-risk**

No Known Reaction Risk. No known risk of allergy or intolerance reaction upon exposure to the specified substance. */
    NoKnownReactionRisk,
}
impl ::core::str::FromStr for AllergyIntoleranceSubstanceExposureRisk {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "known-reaction-risk" => Ok(Self::KnownReactionRisk),
            "no-known-reaction-risk" => Ok(Self::NoKnownReactionRisk),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceSubstanceExposureRisk {
    fn as_ref(&self) -> &str {
        match self {
            Self::KnownReactionRisk => "known-reaction-risk",
            Self::NoKnownReactionRisk => "no-known-reaction-risk",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceSubstanceExposureRisk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceSubstanceExposureRisk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceSubstanceExposureRisk {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceSubstanceExposureRisk {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceSubstanceExposureRisk> for Coding {
    fn from(code: AllergyIntoleranceSubstanceExposureRisk) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allerg-intol-substance-exp-risk".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceSubstanceExposureRisk> for CodeableConcept {
    fn from(code: AllergyIntoleranceSubstanceExposureRisk) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceType](http://hl7.org/fhir/ValueSet/allergy-intolerance-type)**. Identification of the underlying physiological mechanism for a Reaction Risk.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceType {
    /** **allergy**

Allergy. A propensity for hypersensitivity reaction(s) to a substance.  These reactions are most typically type I hypersensitivity, plus other "allergy-like" reactions, including pseudoallergy. */
    Allergy,
    /** **intolerance**

Intolerance. A propensity for adverse reactions to a substance that is not judged to be allergic or "allergy-like".  These reactions are typically (but not necessarily) non-immune.  They are to some degree idiosyncratic and/or individually specific (i.e. are not a reaction that is expected to occur with most or all patients given similar circumstances). */
    Intolerance,
}
impl ::core::str::FromStr for AllergyIntoleranceType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "allergy" => Ok(Self::Allergy),
            "intolerance" => Ok(Self::Intolerance),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Allergy => "allergy",
            Self::Intolerance => "intolerance",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceType> for Coding {
    fn from(code: AllergyIntoleranceType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergy-intolerance-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceType> for CodeableConcept {
    fn from(code: AllergyIntoleranceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceVerificationStatus](http://hl7.org/fhir/ValueSet/allergy-verification-status)**. Assertion about certainty associated with a propensity, or potential risk, of a reaction to the identified substance.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceVerificationStatus {
    /** **confirmed**

Confirmed. A high level of certainty about the propensity for a reaction to the identified substance, which may include clinical evidence by testing or rechallenge. */
    Confirmed,
    /** **entered-in-error**

Entered In Error. The statement was entered in error and is not valid. */
    EnteredInError,
    /** **refuted**

Refuted. A propensity for a reaction to the identified substance has been disproven with a high level of clinical certainty, which may include testing or rechallenge, and is refuted. */
    Refuted,
    /** **unconfirmed**

Unconfirmed. A low level of certainty about the propensity for a reaction to the identified substance. */
    Unconfirmed,
}
impl ::core::str::FromStr for AllergyIntoleranceVerificationStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(Self::Confirmed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "refuted" => Ok(Self::Refuted),
            "unconfirmed" => Ok(Self::Unconfirmed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceVerificationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confirmed => "confirmed",
            Self::EnteredInError => "entered-in-error",
            Self::Refuted => "refuted",
            Self::Unconfirmed => "unconfirmed",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceVerificationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceVerificationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceVerificationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceVerificationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceVerificationStatus> for Coding {
    fn from(code: AllergyIntoleranceVerificationStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergy-verification-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceVerificationStatus> for CodeableConcept {
    fn from(code: AllergyIntoleranceVerificationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AnimalSpecies](http://hl7.org/fhir/ValueSet/animal-species)**. This example value set defines a set of codes that can be used to indicate species of animal patients.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AnimalSpecies {
    /** **canislf**

Dog. Canis lupus familiaris */
    Canislf,
    /** **ovisa**

Sheep. Ovis aries */
    Ovisa,
    /** **serinuscd**

Domestic Canary. Serinus canaria domestica */
    Serinuscd,
}
impl ::core::str::FromStr for AnimalSpecies {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "canislf" => Ok(Self::Canislf),
            "ovisa" => Ok(Self::Ovisa),
            "serinuscd" => Ok(Self::Serinuscd),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AnimalSpecies {
    fn as_ref(&self) -> &str {
        match self {
            Self::Canislf => "canislf",
            Self::Ovisa => "ovisa",
            Self::Serinuscd => "serinuscd",
        }
    }
}
impl ::std::fmt::Debug for AnimalSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AnimalSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AnimalSpecies {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AnimalSpecies {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AnimalSpecies> for Coding {
    fn from(code: AnimalSpecies) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/animal-species".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AnimalSpecies> for CodeableConcept {
    fn from(code: AnimalSpecies) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AppointmentStatus](http://hl7.org/fhir/ValueSet/appointmentstatus)**. The free/busy status of an appointment.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AppointmentStatus {
    /** **arrived**

Arrived. Some of the patients have arrived. */
    Arrived,
    /** **booked**

Booked. All participant(s) have been considered and the appointment is confirmed to go ahead at the date/times specified. */
    Booked,
    /** **cancelled**

Cancelled. The appointment has been cancelled. */
    Cancelled,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **fulfilled**

Fulfilled. This appointment has completed and may have resulted in an encounter. */
    Fulfilled,
    /** **noshow**

No Show. Some or all of the participant(s) have not/did not appear for the appointment (usually the patient). */
    Noshow,
    /** **pending**

Pending. Some or all of the participant(s) have not finalized their acceptance of the appointment request. */
    Pending,
    /** **proposed**

Proposed. None of the participant(s) have finalized their acceptance of the appointment request, and the start/end time may not be set yet. */
    Proposed,
}
impl ::core::str::FromStr for AppointmentStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "arrived" => Ok(Self::Arrived),
            "booked" => Ok(Self::Booked),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "fulfilled" => Ok(Self::Fulfilled),
            "noshow" => Ok(Self::Noshow),
            "pending" => Ok(Self::Pending),
            "proposed" => Ok(Self::Proposed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AppointmentStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Arrived => "arrived",
            Self::Booked => "booked",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Fulfilled => "fulfilled",
            Self::Noshow => "noshow",
            Self::Pending => "pending",
            Self::Proposed => "proposed",
        }
    }
}
impl ::std::fmt::Debug for AppointmentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AppointmentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AppointmentStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AppointmentStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AppointmentStatus> for Coding {
    fn from(code: AppointmentStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/appointmentstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AppointmentStatus> for CodeableConcept {
    fn from(code: AppointmentStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AssertionDirectionType](http://hl7.org/fhir/ValueSet/assert-direction-codes)**. The type of direction to use for assertion.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AssertionDirectionType {
    /** **request**

request. The assertion is evaluated on the request. */
    Request,
    /** **response**

response. The assertion is evaluated on the response. This is the default value. */
    Response,
}
impl ::core::str::FromStr for AssertionDirectionType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "request" => Ok(Self::Request),
            "response" => Ok(Self::Response),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionDirectionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Request => "request",
            Self::Response => "response",
        }
    }
}
impl ::std::fmt::Debug for AssertionDirectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AssertionDirectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AssertionDirectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionDirectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionDirectionType> for Coding {
    fn from(code: AssertionDirectionType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/assert-direction-codes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AssertionDirectionType> for CodeableConcept {
    fn from(code: AssertionDirectionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AssertionOperatorType](http://hl7.org/fhir/ValueSet/assert-operator-codes)**. The type of operator to use for assertion.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AssertionOperatorType {
    /** **contains**

contains. Compare value string contains a known value. */
    Contains,
    /** **empty**

empty. Compare value is empty. */
    Empty,
    /** **equals**

equals. Default value. Equals comparison. */
    Equals,
    /** **eval**

evaluate. Evaluate the fluentpath expression as a boolean condition. */
    Eval,
    /** **greaterThan**

greaterThan. Compare value to be greater than a known value. */
    GreaterThan,
    /** **in**

in. Compare value within a known set of values. */
    In,
    /** **lessThan**

lessThan. Compare value to be less than a known value. */
    LessThan,
    /** **notContains**

notContains. Compare value string does not contain a known value. */
    NotContains,
    /** **notEmpty**

notEmpty. Compare value is not empty. */
    NotEmpty,
    /** **notEquals**

notEquals. Not equals comparison. */
    NotEquals,
    /** **notIn**

notIn. Compare value not within a known set of values. */
    NotIn,
}
impl ::core::str::FromStr for AssertionOperatorType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contains" => Ok(Self::Contains),
            "empty" => Ok(Self::Empty),
            "equals" => Ok(Self::Equals),
            "eval" => Ok(Self::Eval),
            "greaterThan" => Ok(Self::GreaterThan),
            "in" => Ok(Self::In),
            "lessThan" => Ok(Self::LessThan),
            "notContains" => Ok(Self::NotContains),
            "notEmpty" => Ok(Self::NotEmpty),
            "notEquals" => Ok(Self::NotEquals),
            "notIn" => Ok(Self::NotIn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionOperatorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contains => "contains",
            Self::Empty => "empty",
            Self::Equals => "equals",
            Self::Eval => "eval",
            Self::GreaterThan => "greaterThan",
            Self::In => "in",
            Self::LessThan => "lessThan",
            Self::NotContains => "notContains",
            Self::NotEmpty => "notEmpty",
            Self::NotEquals => "notEquals",
            Self::NotIn => "notIn",
        }
    }
}
impl ::std::fmt::Debug for AssertionOperatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AssertionOperatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AssertionOperatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionOperatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionOperatorType> for Coding {
    fn from(code: AssertionOperatorType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/assert-operator-codes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AssertionOperatorType> for CodeableConcept {
    fn from(code: AssertionOperatorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AssertionResponseTypes](http://hl7.org/fhir/ValueSet/assert-response-code-types)**. The type of response code to use for assertion.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AssertionResponseTypes {
    /** **bad**

bad. Response code is 400. */
    Bad,
    /** **conflict**

conflict. Response code is 409. */
    Conflict,
    /** **created**

created. Response code is 201. */
    Created,
    /** **forbidden**

forbidden. Response code is 403. */
    Forbidden,
    /** **gone**

gone. Response code is 410. */
    Gone,
    /** **methodNotAllowed**

methodNotAllowed. Response code is 405. */
    MethodNotAllowed,
    /** **noContent**

noContent. Response code is 204. */
    NoContent,
    /** **notFound**

notFound. Response code is 404. */
    NotFound,
    /** **notModified**

notModified. Response code is 304. */
    NotModified,
    /** **okay**

okay. Response code is 200. */
    Okay,
    /** **preconditionFailed**

preconditionFailed. Response code is 412. */
    PreconditionFailed,
    /** **unprocessable**

unprocessable. Response code is 422. */
    Unprocessable,
}
impl ::core::str::FromStr for AssertionResponseTypes {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bad" => Ok(Self::Bad),
            "conflict" => Ok(Self::Conflict),
            "created" => Ok(Self::Created),
            "forbidden" => Ok(Self::Forbidden),
            "gone" => Ok(Self::Gone),
            "methodNotAllowed" => Ok(Self::MethodNotAllowed),
            "noContent" => Ok(Self::NoContent),
            "notFound" => Ok(Self::NotFound),
            "notModified" => Ok(Self::NotModified),
            "okay" => Ok(Self::Okay),
            "preconditionFailed" => Ok(Self::PreconditionFailed),
            "unprocessable" => Ok(Self::Unprocessable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionResponseTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bad => "bad",
            Self::Conflict => "conflict",
            Self::Created => "created",
            Self::Forbidden => "forbidden",
            Self::Gone => "gone",
            Self::MethodNotAllowed => "methodNotAllowed",
            Self::NoContent => "noContent",
            Self::NotFound => "notFound",
            Self::NotModified => "notModified",
            Self::Okay => "okay",
            Self::PreconditionFailed => "preconditionFailed",
            Self::Unprocessable => "unprocessable",
        }
    }
}
impl ::std::fmt::Debug for AssertionResponseTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AssertionResponseTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AssertionResponseTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionResponseTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionResponseTypes> for Coding {
    fn from(code: AssertionResponseTypes) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/assert-response-code-types".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AssertionResponseTypes> for CodeableConcept {
    fn from(code: AssertionResponseTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventAction](http://hl7.org/fhir/ValueSet/audit-event-action)**. Indicator for type of action performed during the event that generated the event\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AuditEventAction {
    /** **C**

Create. Create a new database object, such as placing an order. */
    C,
    /** **D**

Delete. Delete items, such as a doctor master file record. */
    D,
    /** **E**

Execute. Perform a system or application function such as log-on, program execution or use of an object's method, or perform a query/search operation. */
    E,
    /** **R**

Read/View/Print. Display or print data, such as a doctor census. */
    R,
    /** **U**

Update. Update data, such as revise patient information. */
    U,
}
impl ::core::str::FromStr for AuditEventAction {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "C" => Ok(Self::C),
            "D" => Ok(Self::D),
            "E" => Ok(Self::E),
            "R" => Ok(Self::R),
            "U" => Ok(Self::U),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventAction {
    fn as_ref(&self) -> &str {
        match self {
            Self::C => "C",
            Self::D => "D",
            Self::E => "E",
            Self::R => "R",
            Self::U => "U",
        }
    }
}
impl ::std::fmt::Debug for AuditEventAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventAction> for Coding {
    fn from(code: AuditEventAction) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/audit-event-action".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventAction> for CodeableConcept {
    fn from(code: AuditEventAction) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventAgentNetworkType](http://hl7.org/fhir/ValueSet/network-type)**. The type of network access point of this agent in the audit event\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AuditEventAgentNetworkType {
    /** **1**

Machine Name. The machine name, including DNS name. */
    N1,
    /** **2**

IP Address. The assigned Internet Protocol (IP) address. */
    N2,
    /** **3**

Telephone Number. The assigned telephone number. */
    N3,
    /** **4**

Email address. The assigned email address. */
    N4,
    /** **5**

URI. URI (User directory, HTTP-PUT, ftp, etc.). */
    N5,
}
impl ::core::str::FromStr for AuditEventAgentNetworkType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "2" => Ok(Self::N2),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventAgentNetworkType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N2 => "2",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::N5 => "5",
        }
    }
}
impl ::std::fmt::Debug for AuditEventAgentNetworkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventAgentNetworkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventAgentNetworkType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventAgentNetworkType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventAgentNetworkType> for Coding {
    fn from(code: AuditEventAgentNetworkType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/network-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventAgentNetworkType> for CodeableConcept {
    fn from(code: AuditEventAgentNetworkType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventEntityRole](http://hl7.org/fhir/ValueSet/object-role)**. Code representing the role the entity played in the audit event\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AuditEventEntityRole {
    /** **1**

Patient. This object is the patient that is the subject of care related to this event.  It is identifiable by patient ID or equivalent.  The patient may be either human or animal. */
    N1,
    /** **10**

Guarantor. Insurance company, or any other organization who accepts responsibility for paying for the healthcare event. */
    N10,
    /** **11**

Security User Entity. A person or active system object involved in the event with a security role. */
    N11,
    /** **12**

Security User Group. A person or system object involved in the event with the authority to modify security roles of other objects. */
    N12,
    /** **13**

Security Resource. A passive object, such as a role table, that is relevant to the event. */
    N13,
    /** **14**

Security Granularity Definition. (deprecated)  Relevant to certain RBAC security methodologies. */
    N14,
    /** **15**

Practitioner. Any person or organization responsible for providing care.  This encompasses all forms of care, licensed or otherwise, and all sorts of teams and care groups. Note the distinction between practitioner and the doctor that actually provided the care to the patient. */
    N15,
    /** **16**

Data Destination. The source or destination for data transfer, when it does not match some other role. */
    N16,
    /** **17**

Data Repository. A source or destination for data transfer that acts as an archive, database, or similar role. */
    N17,
    /** **18**

Schedule. An object that holds schedule information.  This could be an appointment book, availability information, etc. */
    N18,
    /** **19**

Customer. An organization or person that is the recipient of services.  This could be an organization that is buying services for a patient, or a person that is buying services for an animal. */
    N19,
    /** **2**

Location. This is a location identified as related to the event.  This is usually the location where the event took place.  Note that for shipping, the usual events are arrival at a location or departure from a location. */
    N2,
    /** **20**

Job. An order, task, work item, procedure step, or other description of work to be performed; e.g. a particular instance of an MPPS. */
    N20,
    /** **21**

Job Stream. A list of jobs or a system that provides lists of jobs; e.g. an MWL SCP. */
    N21,
    /** **22**

Table. (Deprecated) */
    N22,
    /** **23**

Routing Criteria. An object that specifies or controls the routing or delivery of items.  For example, a distribution list is the routing criteria for mail.  The items delivered may be documents, jobs, or other objects. */
    N23,
    /** **24**

Query. The contents of a query.  This is used to capture the contents of any kind of query.  For security surveillance purposes knowing the queries being made is very important. */
    N24,
    /** **3**

Report. This object is any kind of persistent document created as a result of the event.  This could be a paper report, film, electronic report, DICOM Study, etc.  Issues related to medical records life cycle management are conveyed elsewhere. */
    N3,
    /** **4**

Domain Resource. A logical object related to a health record event.  This is any healthcare  specific resource (object) not restricted to FHIR defined Resources. */
    N4,
    /** **5**

Master file. This is any configurable file used to control creation of documents.  Examples include the objects maintained by the HL7 Master File transactions, Value Sets, etc. */
    N5,
    /** **6**

User. A human participant not otherwise identified by some other category. */
    N6,
    /** **7**

List. (deprecated) */
    N7,
    /** **8**

Doctor. Typically a licensed person who is providing or performing care related to the event, generally a physician.   The key distinction between doctor and practitioner is with regards to their role, not the licensing.  The doctor is the human who actually performed the work.  The practitioner is the human or organization that is responsible for the work. */
    N8,
    /** **9**

Subscriber. A person or system that is being notified as part of the event.  This is relevant in situations where automated systems provide notifications to other parties when an event took place. */
    N9,
}
impl ::core::str::FromStr for AuditEventEntityRole {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "10" => Ok(Self::N10),
            "11" => Ok(Self::N11),
            "12" => Ok(Self::N12),
            "13" => Ok(Self::N13),
            "14" => Ok(Self::N14),
            "15" => Ok(Self::N15),
            "16" => Ok(Self::N16),
            "17" => Ok(Self::N17),
            "18" => Ok(Self::N18),
            "19" => Ok(Self::N19),
            "2" => Ok(Self::N2),
            "20" => Ok(Self::N20),
            "21" => Ok(Self::N21),
            "22" => Ok(Self::N22),
            "23" => Ok(Self::N23),
            "24" => Ok(Self::N24),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            "6" => Ok(Self::N6),
            "7" => Ok(Self::N7),
            "8" => Ok(Self::N8),
            "9" => Ok(Self::N9),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventEntityRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N10 => "10",
            Self::N11 => "11",
            Self::N12 => "12",
            Self::N13 => "13",
            Self::N14 => "14",
            Self::N15 => "15",
            Self::N16 => "16",
            Self::N17 => "17",
            Self::N18 => "18",
            Self::N19 => "19",
            Self::N2 => "2",
            Self::N20 => "20",
            Self::N21 => "21",
            Self::N22 => "22",
            Self::N23 => "23",
            Self::N24 => "24",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::N5 => "5",
            Self::N6 => "6",
            Self::N7 => "7",
            Self::N8 => "8",
            Self::N9 => "9",
        }
    }
}
impl ::std::fmt::Debug for AuditEventEntityRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventEntityRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventEntityRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventEntityRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventEntityRole> for Coding {
    fn from(code: AuditEventEntityRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/object-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventEntityRole> for CodeableConcept {
    fn from(code: AuditEventEntityRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventEntityType](http://hl7.org/fhir/ValueSet/audit-entity-type)**. Code for the entity type involved in the audit event.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AuditEventEntityType {
    /** **1**

Person. Person */
    N1,
    /** **2**

System Object. System Object */
    N2,
    /** **3**

Organization. Organization */
    N3,
    /** **4**

Other. Other */
    N4,
}
impl ::core::str::FromStr for AuditEventEntityType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "2" => Ok(Self::N2),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventEntityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N2 => "2",
            Self::N3 => "3",
            Self::N4 => "4",
        }
    }
}
impl ::std::fmt::Debug for AuditEventEntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventEntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventEntityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventEntityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventEntityType> for Coding {
    fn from(code: AuditEventEntityType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/audit-entity-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventEntityType> for CodeableConcept {
    fn from(code: AuditEventEntityType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventOutcome](http://hl7.org/fhir/ValueSet/audit-event-outcome)**. Indicates whether the event succeeded or failed\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AuditEventOutcome {
    /** **0**

Success. The operation completed successfully (whether with warnings or not). */
    N0,
    /** **12**

Major failure. An error of such magnitude occurred that the system is no longer available for use (i.e. the system died). */
    N12,
    /** **4**

Minor failure. The action was not successful due to some kind of catered for error (often equivalent to an HTTP 400 response). */
    N4,
    /** **8**

Serious failure. The action was not successful due to some kind of unexpected error (often equivalent to an HTTP 500 response). */
    N8,
}
impl ::core::str::FromStr for AuditEventOutcome {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0" => Ok(Self::N0),
            "12" => Ok(Self::N12),
            "4" => Ok(Self::N4),
            "8" => Ok(Self::N8),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0 => "0",
            Self::N12 => "12",
            Self::N4 => "4",
            Self::N8 => "8",
        }
    }
}
impl ::std::fmt::Debug for AuditEventOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventOutcome> for Coding {
    fn from(code: AuditEventOutcome) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/audit-event-outcome".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventOutcome> for CodeableConcept {
    fn from(code: AuditEventOutcome) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BindingStrength](http://hl7.org/fhir/ValueSet/binding-strength)**. Indication of the degree of conformance expectations associated with a binding.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum BindingStrength {
    /** **example**

Example. Instances are not expected or even encouraged to draw from the specified value set.  The value set merely provides examples of the types of concepts intended to be included. */
    Example,
    /** **extensible**

Extensible. To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated.  If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead. */
    Extensible,
    /** **preferred**

Preferred. Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. */
    Preferred,
    /** **required**

Required. To be conformant, the concept in this element SHALL be from the specified value set */
    Required,
}
impl ::core::str::FromStr for BindingStrength {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "example" => Ok(Self::Example),
            "extensible" => Ok(Self::Extensible),
            "preferred" => Ok(Self::Preferred),
            "required" => Ok(Self::Required),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BindingStrength {
    fn as_ref(&self) -> &str {
        match self {
            Self::Example => "example",
            Self::Extensible => "extensible",
            Self::Preferred => "preferred",
            Self::Required => "required",
        }
    }
}
impl ::std::fmt::Debug for BindingStrength {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BindingStrength {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BindingStrength {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BindingStrength {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BindingStrength> for Coding {
    fn from(code: BindingStrength) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/binding-strength".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BindingStrength> for CodeableConcept {
    fn from(code: BindingStrength) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BundleType](http://hl7.org/fhir/ValueSet/bundle-type)**. Indicates the purpose of a bundle - how it was intended to be used.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum BundleType {
    /** **batch**

Batch. The bundle is a transaction - intended to be processed by a server as a group of actions. */
    Batch,
    /** **batch-response**

Batch Response. The bundle is a batch response. Note that as a batch, some responses may indicate failure and others success. */
    BatchResponse,
    /** **collection**

Collection. The bundle is a set of resources collected into a single package for ease of distribution. */
    Collection,
    /** **document**

Document. The bundle is a document. The first resource is a Composition. */
    Document,
    /** **history**

History List. The bundle is a list of resources from a history interaction on a server. */
    History,
    /** **message**

Message. The bundle is a message. The first resource is a MessageHeader. */
    Message,
    /** **searchset**

Search Results. The bundle is a list of resources returned as a result of a search/query interaction, operation, or message. */
    Searchset,
    /** **transaction**

Transaction. The bundle is a transaction - intended to be processed by a server as an atomic commit. */
    Transaction,
    /** **transaction-response**

Transaction Response. The bundle is a transaction response. Because the response is a transaction response, the transaction has succeeded, and all responses are error free. */
    TransactionResponse,
}
impl ::core::str::FromStr for BundleType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "batch" => Ok(Self::Batch),
            "batch-response" => Ok(Self::BatchResponse),
            "collection" => Ok(Self::Collection),
            "document" => Ok(Self::Document),
            "history" => Ok(Self::History),
            "message" => Ok(Self::Message),
            "searchset" => Ok(Self::Searchset),
            "transaction" => Ok(Self::Transaction),
            "transaction-response" => Ok(Self::TransactionResponse),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BundleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Batch => "batch",
            Self::BatchResponse => "batch-response",
            Self::Collection => "collection",
            Self::Document => "document",
            Self::History => "history",
            Self::Message => "message",
            Self::Searchset => "searchset",
            Self::Transaction => "transaction",
            Self::TransactionResponse => "transaction-response",
        }
    }
}
impl ::std::fmt::Debug for BundleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BundleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BundleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BundleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BundleType> for Coding {
    fn from(code: BundleType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/bundle-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BundleType> for CodeableConcept {
    fn from(code: BundleType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CapabilityStatementKind](http://hl7.org/fhir/ValueSet/capability-statement-kind)**. How a capability statement is intended to be used.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CapabilityStatementKind {
    /** **capability**

Capability. The CapabilityStatement instance represents the capabilities of a system or piece of software, independent of a particular installation. */
    Capability,
    /** **instance**

Instance. The CapabilityStatement instance represents the present capabilities of a specific system instance.  This is the kind returned by OPTIONS for a FHIR server end-point. */
    Instance,
    /** **requirements**

Requirements. The CapabilityStatement instance represents a set of requirements for other systems to meet; e.g. as part of an implementation guide or 'request for proposal'. */
    Requirements,
}
impl ::core::str::FromStr for CapabilityStatementKind {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "capability" => Ok(Self::Capability),
            "instance" => Ok(Self::Instance),
            "requirements" => Ok(Self::Requirements),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CapabilityStatementKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Capability => "capability",
            Self::Instance => "instance",
            Self::Requirements => "requirements",
        }
    }
}
impl ::std::fmt::Debug for CapabilityStatementKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CapabilityStatementKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CapabilityStatementKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CapabilityStatementKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CapabilityStatementKind> for Coding {
    fn from(code: CapabilityStatementKind) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/capability-statement-kind".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CapabilityStatementKind> for CodeableConcept {
    fn from(code: CapabilityStatementKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CarePlanActivityCategory](http://hl7.org/fhir/ValueSet/care-plan-activity-category)**. High-level categorization of the type of activity in a care plan.\n\nFHIR version: 1.0.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CarePlanActivityCategory {
    /** **diet**

Diet. Plan for the patient to consume food of a specified nature */
    Diet,
    /** **drug**

Drug. Plan for the patient to consume/receive a drug, vaccine or other product */
    Drug,
    /** **encounter**

Encounter. Plan to meet or communicate with the patient (in-patient, out-patient, phone call, etc.) */
    Encounter,
    /** **observation**

Observation. Plan to capture information about a patient (vitals, labs, diagnostic images, etc.) */
    Observation,
    /** **other**

Other. Some other form of action */
    Other,
    /** **procedure**

Procedure. Plan to modify the patient in some way (surgery, physiotherapy, education, counseling, etc.) */
    Procedure,
    /** **supply**

Supply. Plan to provide something to the patient (medication, medical supply, etc.) */
    Supply,
}
impl ::core::str::FromStr for CarePlanActivityCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "diet" => Ok(Self::Diet),
            "drug" => Ok(Self::Drug),
            "encounter" => Ok(Self::Encounter),
            "observation" => Ok(Self::Observation),
            "other" => Ok(Self::Other),
            "procedure" => Ok(Self::Procedure),
            "supply" => Ok(Self::Supply),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CarePlanActivityCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Diet => "diet",
            Self::Drug => "drug",
            Self::Encounter => "encounter",
            Self::Observation => "observation",
            Self::Other => "other",
            Self::Procedure => "procedure",
            Self::Supply => "supply",
        }
    }
}
impl ::std::fmt::Debug for CarePlanActivityCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CarePlanActivityCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CarePlanActivityCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CarePlanActivityCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CarePlanActivityCategory> for Coding {
    fn from(code: CarePlanActivityCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/care-plan-activity-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CarePlanActivityCategory> for CodeableConcept {
    fn from(code: CarePlanActivityCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CarePlanActivityStatus](http://hl7.org/fhir/ValueSet/care-plan-activity-status)**. Indicates where the activity is at in its overall life cycle.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CarePlanActivityStatus {
    /** **cancelled**

Cancelled. The activities have been ended prior to completion (perhaps even before they were started). */
    Cancelled,
    /** **completed**

Completed. The activities have been completed (more or less) as planned. */
    Completed,
    /** **in-progress**

In Progress. Activity has been started but is not yet complete. */
    InProgress,
    /** **not-started**

Not Started. Activity is planned but no action has yet been taken. */
    NotStarted,
    /** **on-hold**

On Hold. Activity was started but has temporarily ceased with an expectation of resumption at a future time. */
    OnHold,
    /** **scheduled**

Scheduled. Appointment or other booking has occurred but activity has not yet begun. */
    Scheduled,
    /** **unknown**

Unknown. The authoring system doesn't know the current state of the activity. */
    Unknown,
}
impl ::core::str::FromStr for CarePlanActivityStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "in-progress" => Ok(Self::InProgress),
            "not-started" => Ok(Self::NotStarted),
            "on-hold" => Ok(Self::OnHold),
            "scheduled" => Ok(Self::Scheduled),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CarePlanActivityStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::InProgress => "in-progress",
            Self::NotStarted => "not-started",
            Self::OnHold => "on-hold",
            Self::Scheduled => "scheduled",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for CarePlanActivityStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CarePlanActivityStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CarePlanActivityStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CarePlanActivityStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CarePlanActivityStatus> for Coding {
    fn from(code: CarePlanActivityStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/care-plan-activity-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CarePlanActivityStatus> for CodeableConcept {
    fn from(code: CarePlanActivityStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CarePlanIntent](http://hl7.org/fhir/ValueSet/care-plan-intent)**. Codes indicating the degree of authority/intentionality associated with a care plan\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CarePlanIntent {
    /** **option**

Option. The care plan represents a component or option for a RequestGroup that establishes timing, conditionality and/or other constraints among a set of requests.

Refer to [[[RequestGroup]]] for additional information on how this status is used */
    Option,
    /** **order**

Order. The care plan represents a request/demand and authorization for action */
    Order,
    /** **plan**

Plan. The care plan represents an intention to ensure something occurs without providing an authorization for others to act */
    Plan,
    /** **proposal**

Proposal. The care plan is a suggestion made by someone/something that doesn't have an intention to ensure it occurs and without providing an authorization to act */
    Proposal,
}
impl ::core::str::FromStr for CarePlanIntent {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "option" => Ok(Self::Option),
            "order" => Ok(Self::Order),
            "plan" => Ok(Self::Plan),
            "proposal" => Ok(Self::Proposal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CarePlanIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Option => "option",
            Self::Order => "order",
            Self::Plan => "plan",
            Self::Proposal => "proposal",
        }
    }
}
impl ::std::fmt::Debug for CarePlanIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CarePlanIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CarePlanIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CarePlanIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CarePlanIntent> for Coding {
    fn from(code: CarePlanIntent) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/care-plan-intent".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CarePlanIntent> for CodeableConcept {
    fn from(code: CarePlanIntent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CarePlanStatus](http://hl7.org/fhir/ValueSet/care-plan-status)**. Indicates whether the plan is currently being acted upon, represents future intentions or is now a historical record.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CarePlanStatus {
    /** **active**

Active. The plan is intended to be followed and used as part of patient care. */
    Active,
    /** **cancelled**

Cancelled. The plan has been terminated prior to reaching completion (though it may have been replaced by a new plan). */
    Cancelled,
    /** **completed**

Completed. The plan is no longer in use and is not expected to be followed or used in patient care. */
    Completed,
    /** **draft**

Pending. The plan is in development or awaiting use but is not yet intended to be acted upon. */
    Draft,
    /** **entered-in-error**

Entered In Error. The plan was entered in error and voided. */
    EnteredInError,
    /** **suspended**

Suspended. The plan has been temporarily stopped but is expected to resume in the future. */
    Suspended,
    /** **unknown**

Unknown. The authoring system doesn't know the current state of the care plan. */
    Unknown,
}
impl ::core::str::FromStr for CarePlanStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "suspended" => Ok(Self::Suspended),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CarePlanStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Suspended => "suspended",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for CarePlanStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CarePlanStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CarePlanStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CarePlanStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CarePlanStatus> for Coding {
    fn from(code: CarePlanStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/care-plan-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CarePlanStatus> for CodeableConcept {
    fn from(code: CarePlanStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CareTeamCategory](http://hl7.org/fhir/ValueSet/care-team-category)**. Indicates the type of care team.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CareTeamCategory {
    /** **clinical-research**

Clinical Research. This type of team is responsible for establishing, conducting, coordinating and monitoring the outcomes of clinical trials. The team focuses on research, clinical care and education. */
    ClinicalResearch,
    /** **condition**

Condition. This type of team focuses on one specific condition. The condition is determined by the context of use.  For example, a disease management team focused on one condition (e.g. diabetes). */
    Condition,
    /** **encounter**

Encounter. This type of team focuses on one specific encounter. The encounter is determined by the context of use.  For example, during an inpatient encounter, the nutrition support care team */
    Encounter,
    /** **episode**

Episode. This type of team focuses on one specific episode of care with a defined time period or self-limiting process (e.g. 10 visits). The episode of care is determined by the context of use.  For example, a maternity care team over 9 months. */
    Episode,
    /** **event**

Event. This type of team focuses on one specific type of incident, which is non-patient specific. The incident is determined by the context of use.  For example, code team (code red, code blue, medical emergency treatment) or the PICC line team. */
    Event,
    /** **longitudinal**

Longitudinal Care Coordination. This type of team focuses on overall care coordination managing one or more conditions across the continuum of care ensuring there are smooth transitions of care. The members of the team are determined or selected by an individual or organization. When determined by an organization, the team may be assigned or based on the person's enrollment in a particular program. For example, disease management team or patient centered medical home team. */
    Longitudinal,
}
impl ::core::str::FromStr for CareTeamCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "clinical-research" => Ok(Self::ClinicalResearch),
            "condition" => Ok(Self::Condition),
            "encounter" => Ok(Self::Encounter),
            "episode" => Ok(Self::Episode),
            "event" => Ok(Self::Event),
            "longitudinal" => Ok(Self::Longitudinal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CareTeamCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::ClinicalResearch => "clinical-research",
            Self::Condition => "condition",
            Self::Encounter => "encounter",
            Self::Episode => "episode",
            Self::Event => "event",
            Self::Longitudinal => "longitudinal",
        }
    }
}
impl ::std::fmt::Debug for CareTeamCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CareTeamCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CareTeamCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CareTeamCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CareTeamCategory> for Coding {
    fn from(code: CareTeamCategory) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/care-team-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CareTeamCategory> for CodeableConcept {
    fn from(code: CareTeamCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CareTeamStatus](http://hl7.org/fhir/ValueSet/care-team-status)**. Indicates the status of the care team.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CareTeamStatus {
    /** **active**

Active. The care team is currently participating in the coordination and delivery of care. */
    Active,
    /** **entered-in-error**

Entered In Error. The care team should have never existed. */
    EnteredInError,
    /** **inactive**

Inactive. The care team was, but is no longer, participating in the coordination and delivery of care. */
    Inactive,
    /** **proposed**

Proposed. The care team has been drafted and proposed, but not yet participating in the coordination and delivery of care. */
    Proposed,
    /** **suspended**

Suspended. The care team is temporarily on hold or suspended and not participating in the coordination and delivery of care. */
    Suspended,
}
impl ::core::str::FromStr for CareTeamStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "proposed" => Ok(Self::Proposed),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CareTeamStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Proposed => "proposed",
            Self::Suspended => "suspended",
        }
    }
}
impl ::std::fmt::Debug for CareTeamStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CareTeamStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CareTeamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CareTeamStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CareTeamStatus> for Coding {
    fn from(code: CareTeamStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/care-team-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CareTeamStatus> for CodeableConcept {
    fn from(code: CareTeamStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ChargeItemCode](http://hl7.org/fhir/ValueSet/chargeitem-billingcodes)**. Example set of codes that can be used for billing purposes\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ChargeItemCode {
    /** **1100**

Unvorhergesehene Inanspruchnahme. From German EBM billing system:
Unvorhergesehene Inanspruchnahme des Vertragsarztes durch einen Patienten;zwischen 19:00 und 22:00 Uhr;an Samstagen, Sonntagen und gesetzlichen Feiertagen, am 24.12. und 31.12. zwischen 07:00 und 19:00 Uhr */
    N1100,
    /** **1210**

Notfallpauschale. From German EBM billing system:
Notfallpauschale im organisierten Not(-fall)dienst und für nicht an der vertragsärztlichen Versorgung teilnehmende Ärzte, Institute und Krankenhäuser bei Inanspruchnahme;zwischen 07:00 und 19:00 Uhr */
    N1210,
    /** **1320**

Grundpauschale. From German EBM billing system:
Grundpauschale für Ärzte, Institute und Krankenhäuser, die zur Erbringung von Leistungen innerhalb mindestens eines der Fachgebiete Anästhesiologie, Frauenheilkunde und Geburtshilfe, Haut- und Geschlechtskrankheiten, Mund-, Kiefer- und Gesichtschirurgie und Humangenetik ermächtigt sind */
    N1320,
}
impl ::core::str::FromStr for ChargeItemCode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1100" => Ok(Self::N1100),
            "1210" => Ok(Self::N1210),
            "1320" => Ok(Self::N1320),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ChargeItemCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1100 => "1100",
            Self::N1210 => "1210",
            Self::N1320 => "1320",
        }
    }
}
impl ::std::fmt::Debug for ChargeItemCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ChargeItemCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ChargeItemCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ChargeItemCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ChargeItemCode> for Coding {
    fn from(code: ChargeItemCode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/chargeitem-billingcodes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ChargeItemCode> for CodeableConcept {
    fn from(code: ChargeItemCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ChargeItemStatus](http://hl7.org/fhir/ValueSet/chargeitem-status)**. Codes identifying the stage lifecycle stage of a ChargeItem\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ChargeItemStatus {
    /** **aborted**

Aborted. The processing of the charge was aborted */
    Aborted,
    /** **billable**

Billable. The charge item is ready for billing */
    Billable,
    /** **billed**

Billed. The charge item has been billed (e.g. a billing engine has generated financial transactions by applying the associated ruled for the charge item to the context of the Encounter, and placed them into Claims/Invoices */
    Billed,
    /** **entered-in-error**

Entered in Error. The charge item has been entered in error and should not be processed for billing */
    EnteredInError,
    /** **not-billable**

Not billable. The charge item has been determined to be not billable (e.g. due to rules associated with the billing code) */
    NotBillable,
    /** **planned**

Planned. The charge item has been entered, but the charged service is not  yet complete, so it shall not be billed yet but might be used in the context of pre-authorization */
    Planned,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this charge item  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for ChargeItemStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aborted" => Ok(Self::Aborted),
            "billable" => Ok(Self::Billable),
            "billed" => Ok(Self::Billed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "not-billable" => Ok(Self::NotBillable),
            "planned" => Ok(Self::Planned),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ChargeItemStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aborted => "aborted",
            Self::Billable => "billable",
            Self::Billed => "billed",
            Self::EnteredInError => "entered-in-error",
            Self::NotBillable => "not-billable",
            Self::Planned => "planned",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for ChargeItemStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ChargeItemStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ChargeItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ChargeItemStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ChargeItemStatus> for Coding {
    fn from(code: ChargeItemStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/chargeitem-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ChargeItemStatus> for CodeableConcept {
    fn from(code: ChargeItemStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ChoiceListOrientation](http://hl7.org/fhir/ValueSet/choice-list-orientation)**. Direction in which lists of question options should be displayed\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ChoiceListOrientation {
    /** **horizontal**

Horizontal. List choices along the horizontal axis */
    Horizontal,
    /** **vertical**

Vertical. List choices down the vertical axis */
    Vertical,
}
impl ::core::str::FromStr for ChoiceListOrientation {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ChoiceListOrientation {
    fn as_ref(&self) -> &str {
        match self {
            Self::Horizontal => "horizontal",
            Self::Vertical => "vertical",
        }
    }
}
impl ::std::fmt::Debug for ChoiceListOrientation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ChoiceListOrientation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ChoiceListOrientation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ChoiceListOrientation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ChoiceListOrientation> for Coding {
    fn from(code: ChoiceListOrientation) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/choice-list-orientation".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ChoiceListOrientation> for CodeableConcept {
    fn from(code: ChoiceListOrientation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ClaimPayeeResourceType](http://hl7.org/fhir/ValueSet/ex-payee-resource-type)**. The type of Claim payee Resource\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ClaimPayeeResourceType {
    /** **organization**

Organization. Organization resource */
    Organization,
    /** **patient**

Patient. Patient resource */
    Patient,
    /** **practitioner**

Practitioner. Practitioner resource */
    Practitioner,
    /** **relatedperson**

RelatedPerson. RelatedPerson resource */
    Relatedperson,
}
impl ::core::str::FromStr for ClaimPayeeResourceType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "organization" => Ok(Self::Organization),
            "patient" => Ok(Self::Patient),
            "practitioner" => Ok(Self::Practitioner),
            "relatedperson" => Ok(Self::Relatedperson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClaimPayeeResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Organization => "organization",
            Self::Patient => "patient",
            Self::Practitioner => "practitioner",
            Self::Relatedperson => "relatedperson",
        }
    }
}
impl ::std::fmt::Debug for ClaimPayeeResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ClaimPayeeResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ClaimPayeeResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimPayeeResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClaimPayeeResourceType> for Coding {
    fn from(code: ClaimPayeeResourceType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/ex-payee-resource-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ClaimPayeeResourceType> for CodeableConcept {
    fn from(code: ClaimPayeeResourceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ClassificationOrContext](http://hl7.org/fhir/ValueSet/classification-or-context)**. Identifies whether a useContext represents a context or classification for the element\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ClassificationOrContext {
    /** **classification**

Classification. Indicates the useContext is a classification - e.g. Administrative, financial, etc. */
    Classification,
    /** **context**

Context. Indicates the useContext is a context - a domain of use - e.g. Particular country, organization or system */
    Context,
}
impl ::core::str::FromStr for ClassificationOrContext {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "classification" => Ok(Self::Classification),
            "context" => Ok(Self::Context),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClassificationOrContext {
    fn as_ref(&self) -> &str {
        match self {
            Self::Classification => "classification",
            Self::Context => "context",
        }
    }
}
impl ::std::fmt::Debug for ClassificationOrContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ClassificationOrContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ClassificationOrContext {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClassificationOrContext {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClassificationOrContext> for Coding {
    fn from(code: ClassificationOrContext) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/classification-or-context".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ClassificationOrContext> for CodeableConcept {
    fn from(code: ClassificationOrContext) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ClinicalImpressionStatus](http://hl7.org/fhir/ValueSet/clinical-impression-status)**. The workflow state of a clinical impression.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ClinicalImpressionStatus {
    /** **completed**

Completed. The assessment is done and the results are final. */
    Completed,
    /** **draft**

In progress. The assessment is still on-going and results are not yet final. */
    Draft,
    /** **entered-in-error**

Entered in Error. This assessment was never actually done and the record is erroneous (e.g. Wrong patient). */
    EnteredInError,
}
impl ::core::str::FromStr for ClinicalImpressionStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClinicalImpressionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
        }
    }
}
impl ::std::fmt::Debug for ClinicalImpressionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ClinicalImpressionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ClinicalImpressionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClinicalImpressionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClinicalImpressionStatus> for Coding {
    fn from(code: ClinicalImpressionStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/clinical-impression-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ClinicalImpressionStatus> for CodeableConcept {
    fn from(code: ClinicalImpressionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CodeSystemContentMode](http://hl7.org/fhir/ValueSet/codesystem-content-mode)**. How much of the content of the code system - the concepts and codes it defines - are represented in a code system resource\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CodeSystemContentMode {
    /** **complete**

Complete. All the concepts defined by the code system are included in the code system resource */
    Complete,
    /** **example**

Example. A few representative concepts are included in the code system resource */
    Example,
    /** **fragment**

Fragment. A subset of the code system concepts are included in the code system resource */
    Fragment,
    /** **not-present**

Not Present. None of the concepts defined by the code system are included in the code system resource */
    NotPresent,
}
impl ::core::str::FromStr for CodeSystemContentMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "example" => Ok(Self::Example),
            "fragment" => Ok(Self::Fragment),
            "not-present" => Ok(Self::NotPresent),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSystemContentMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Example => "example",
            Self::Fragment => "fragment",
            Self::NotPresent => "not-present",
        }
    }
}
impl ::std::fmt::Debug for CodeSystemContentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CodeSystemContentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CodeSystemContentMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSystemContentMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CodeSystemContentMode> for Coding {
    fn from(code: CodeSystemContentMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/codesystem-content-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CodeSystemContentMode> for CodeableConcept {
    fn from(code: CodeSystemContentMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CodeSystemHierarchyMeaning](http://hl7.org/fhir/ValueSet/codesystem-hierarchy-meaning)**. The meaning of the hierarchy of concepts in a code system\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CodeSystemHierarchyMeaning {
    /** **classified-with**

Classified With. Child concepts in the hierarchy may have only one parent, and there is a presumption that the code system is a "closed world" meaning all things must be in the hierarchy. This results in concepts such as "not otherwise classified." */
    ClassifiedWith,
    /** **grouped-by**

Grouped By. No particular relationship between the concepts can be assumed, except what can be determined by inspection of the definitions of the elements (possible reasons to use this: importing from a source where this is not defined, or where various parts of the hierarchy have different meanings) */
    GroupedBy,
    /** **is-a**

Is-A. A hierarchy where the child concepts have an IS-A relationship with the parents - that is, all the properties of the parent are also true for its child concepts */
    IsA,
    /** **part-of**

Part Of. Child elements list the individual parts of a composite whole (e.g. body site) */
    PartOf,
}
impl ::core::str::FromStr for CodeSystemHierarchyMeaning {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "classified-with" => Ok(Self::ClassifiedWith),
            "grouped-by" => Ok(Self::GroupedBy),
            "is-a" => Ok(Self::IsA),
            "part-of" => Ok(Self::PartOf),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSystemHierarchyMeaning {
    fn as_ref(&self) -> &str {
        match self {
            Self::ClassifiedWith => "classified-with",
            Self::GroupedBy => "grouped-by",
            Self::IsA => "is-a",
            Self::PartOf => "part-of",
        }
    }
}
impl ::std::fmt::Debug for CodeSystemHierarchyMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CodeSystemHierarchyMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CodeSystemHierarchyMeaning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSystemHierarchyMeaning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CodeSystemHierarchyMeaning> for Coding {
    fn from(code: CodeSystemHierarchyMeaning) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/codesystem-hierarchy-meaning".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CodeSystemHierarchyMeaning> for CodeableConcept {
    fn from(code: CodeSystemHierarchyMeaning) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CommunicationCategory](http://hl7.org/fhir/ValueSet/communication-category)**. Codes for general categories of communications such as alerts, instruction, etc.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CommunicationCategory {
    /** **alert**

Alert. The communication conveys an alert. */
    Alert,
    /** **instruction**

Instruction. The communication conveys instruction. */
    Instruction,
    /** **notification**

Notification. The communication conveys a notification. */
    Notification,
    /** **reminder**

Reminder. The communication conveys a reminder. */
    Reminder,
}
impl ::core::str::FromStr for CommunicationCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alert" => Ok(Self::Alert),
            "instruction" => Ok(Self::Instruction),
            "notification" => Ok(Self::Notification),
            "reminder" => Ok(Self::Reminder),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommunicationCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alert => "alert",
            Self::Instruction => "instruction",
            Self::Notification => "notification",
            Self::Reminder => "reminder",
        }
    }
}
impl ::std::fmt::Debug for CommunicationCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CommunicationCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CommunicationCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommunicationCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CommunicationCategory> for Coding {
    fn from(code: CommunicationCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/communication-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CommunicationCategory> for CodeableConcept {
    fn from(code: CommunicationCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CommunicationNotDoneReason](http://hl7.org/fhir/ValueSet/communication-not-done-reason)**. Codes for the reason why a communication was not done.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CommunicationNotDoneReason {
    /** **family-objection**

Family Objection. The communication was not done due to a family objection. */
    FamilyObjection,
    /** **invalid-phone-number**

Invalid Phone Number. The communication was not done due to an invalid phone number. */
    InvalidPhoneNumber,
    /** **patient-objection**

Patient Objection. The communication was not done due to a patient objection. */
    PatientObjection,
    /** **recipient-unavailable**

Recipient Unavailable. The communication was not done due to the recipient being unavailable. */
    RecipientUnavailable,
    /** **system-error**

System Error. The communication was not done due to a system error. */
    SystemError,
    /** **unknown**

Unknown. The communication was not done due to an unknown reason. */
    Unknown,
}
impl ::core::str::FromStr for CommunicationNotDoneReason {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "family-objection" => Ok(Self::FamilyObjection),
            "invalid-phone-number" => Ok(Self::InvalidPhoneNumber),
            "patient-objection" => Ok(Self::PatientObjection),
            "recipient-unavailable" => Ok(Self::RecipientUnavailable),
            "system-error" => Ok(Self::SystemError),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommunicationNotDoneReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::FamilyObjection => "family-objection",
            Self::InvalidPhoneNumber => "invalid-phone-number",
            Self::PatientObjection => "patient-objection",
            Self::RecipientUnavailable => "recipient-unavailable",
            Self::SystemError => "system-error",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for CommunicationNotDoneReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CommunicationNotDoneReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CommunicationNotDoneReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommunicationNotDoneReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CommunicationNotDoneReason> for Coding {
    fn from(code: CommunicationNotDoneReason) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/communication-not-done-reason".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CommunicationNotDoneReason> for CodeableConcept {
    fn from(code: CommunicationNotDoneReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CompartmentType](http://hl7.org/fhir/ValueSet/compartment-type)**. Which compartment a compartment definition describes\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CompartmentType {
    /** **Device**

Device. The compartment definition is for the device compartment */
    Device,
    /** **Encounter**

Encounter. The compartment definition is for the encounter compartment */
    Encounter,
    /** **Patient**

Patient. The compartment definition is for the patient compartment */
    Patient,
    /** **Practitioner**

Practitioner. The compartment definition is for the practitioner compartment */
    Practitioner,
    /** **RelatedPerson**

RelatedPerson. The compartment definition is for the related-person compartment */
    RelatedPerson,
}
impl ::core::str::FromStr for CompartmentType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Device" => Ok(Self::Device),
            "Encounter" => Ok(Self::Encounter),
            "Patient" => Ok(Self::Patient),
            "Practitioner" => Ok(Self::Practitioner),
            "RelatedPerson" => Ok(Self::RelatedPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompartmentType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "Device",
            Self::Encounter => "Encounter",
            Self::Patient => "Patient",
            Self::Practitioner => "Practitioner",
            Self::RelatedPerson => "RelatedPerson",
        }
    }
}
impl ::std::fmt::Debug for CompartmentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CompartmentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CompartmentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompartmentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompartmentType> for Coding {
    fn from(code: CompartmentType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/compartment-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CompartmentType> for CodeableConcept {
    fn from(code: CompartmentType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CompositeMeasureScoring](http://hl7.org/fhir/ValueSet/composite-measure-scoring)**. The composite scoring method of the measure\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CompositeMeasureScoring {
    /** **all-or-nothing**

All-or-nothing. All-or-nothing scoring includes an individual in the numerator of the composite measure if they are in the numerators of all of the component measures in which they are in the denominator */
    AllOrNothing,
    /** **linear**

Linear. Linear scoring gives an individual a score based on the number of numerators in which they appear */
    Linear,
    /** **opportunity**

Opportunity. Opportunity scoring combines the scores from component measures by combining the numerators and denominators for each component */
    Opportunity,
    /** **weighted**

Weighted. Weighted scoring gives an individual a score based on a weighted factor for each component numerator in which they appear */
    Weighted,
}
impl ::core::str::FromStr for CompositeMeasureScoring {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all-or-nothing" => Ok(Self::AllOrNothing),
            "linear" => Ok(Self::Linear),
            "opportunity" => Ok(Self::Opportunity),
            "weighted" => Ok(Self::Weighted),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositeMeasureScoring {
    fn as_ref(&self) -> &str {
        match self {
            Self::AllOrNothing => "all-or-nothing",
            Self::Linear => "linear",
            Self::Opportunity => "opportunity",
            Self::Weighted => "weighted",
        }
    }
}
impl ::std::fmt::Debug for CompositeMeasureScoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CompositeMeasureScoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CompositeMeasureScoring {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositeMeasureScoring {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompositeMeasureScoring> for Coding {
    fn from(code: CompositeMeasureScoring) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/composite-measure-scoring".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CompositeMeasureScoring> for CodeableConcept {
    fn from(code: CompositeMeasureScoring) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CompositionAttestationMode](http://hl7.org/fhir/ValueSet/composition-attestation-mode)**. The way in which a person authenticated a composition.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CompositionAttestationMode {
    /** **legal**

Legal. The person authenticated the content and accepted legal responsibility for its content. */
    Legal,
    /** **official**

Official. The organization authenticated the content as consistent with their policies and procedures. */
    Official,
    /** **personal**

Personal. The person authenticated the content in their personal capacity. */
    Personal,
    /** **professional**

Professional. The person authenticated the content in their professional capacity. */
    Professional,
}
impl ::core::str::FromStr for CompositionAttestationMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "legal" => Ok(Self::Legal),
            "official" => Ok(Self::Official),
            "personal" => Ok(Self::Personal),
            "professional" => Ok(Self::Professional),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositionAttestationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Legal => "legal",
            Self::Official => "official",
            Self::Personal => "personal",
            Self::Professional => "professional",
        }
    }
}
impl ::std::fmt::Debug for CompositionAttestationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CompositionAttestationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CompositionAttestationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositionAttestationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompositionAttestationMode> for Coding {
    fn from(code: CompositionAttestationMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/composition-attestation-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CompositionAttestationMode> for CodeableConcept {
    fn from(code: CompositionAttestationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CompositionStatus](http://hl7.org/fhir/ValueSet/composition-status)**. The workflow/clinical status of the composition.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CompositionStatus {
    /** **amended**

Amended. The composition content or the referenced resources have been modified (edited or added to) subsequent to being released as "final" and the composition is complete and verified by an authorized person. */
    Amended,
    /** **entered-in-error**

Entered in Error. The composition or document was originally created/issued in error, and this is an amendment that marks that the entire series should not be considered as valid. */
    EnteredInError,
    /** **final**

Final. This version of the composition is complete and verified by an appropriate person and no further work is planned. Any subsequent updates would be on a new version of the composition. */
    Final,
    /** **preliminary**

Preliminary. This is a preliminary composition or document (also known as initial or interim). The content may be incomplete or unverified. */
    Preliminary,
}
impl ::core::str::FromStr for CompositionStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "preliminary" => Ok(Self::Preliminary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Preliminary => "preliminary",
        }
    }
}
impl ::std::fmt::Debug for CompositionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CompositionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CompositionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompositionStatus> for Coding {
    fn from(code: CompositionStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/composition-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CompositionStatus> for CodeableConcept {
    fn from(code: CompositionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConceptMapEquivalence](http://hl7.org/fhir/ValueSet/concept-map-equivalence)**. The degree of equivalence between concepts.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConceptMapEquivalence {
    /** **disjoint**

Disjoint. This is an explicit assertion that there is no mapping between the source and target concept. */
    Disjoint,
    /** **equal**

Equal. The definitions of the concepts are exactly the same (i.e. only grammatical differences) and structural implications of meaning are identical or irrelevant (i.e. intentionally identical). */
    Equal,
    /** **equivalent**

Equivalent. The definitions of the concepts mean the same thing (including when structural implications of meaning are considered) (i.e. extensionally identical). */
    Equivalent,
    /** **inexact**

Inexact. The target mapping overlaps with the source concept, but both source and target cover additional meaning, or the definitions are imprecise and it is uncertain whether they have the same boundaries to their meaning. The sense in which the mapping is narrower SHALL be described in the comments in this case, and applications should be careful when attempting to use these mappings operationally. */
    Inexact,
    /** **narrower**

Narrower. The target mapping is narrower in meaning than the source concept. The sense in which the mapping is narrower SHALL be described in the comments in this case, and applications should be careful when attempting to use these mappings operationally. */
    Narrower,
    /** **relatedto**

Related To. The concepts are related to each other, and have at least some overlap in meaning, but the exact relationship is not known */
    Relatedto,
    /** **specializes**

Specializes. The target mapping specializes the meaning of the source concept (e.g. the target is-a source). */
    Specializes,
    /** **subsumes**

Subsumes. The target mapping subsumes the meaning of the source concept (e.g. the source is-a target). */
    Subsumes,
    /** **unmatched**

Unmatched. There is no match for this concept in the destination concept system. */
    Unmatched,
    /** **wider**

Wider. The target mapping is wider in meaning than the source concept. */
    Wider,
}
impl ::core::str::FromStr for ConceptMapEquivalence {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "disjoint" => Ok(Self::Disjoint),
            "equal" => Ok(Self::Equal),
            "equivalent" => Ok(Self::Equivalent),
            "inexact" => Ok(Self::Inexact),
            "narrower" => Ok(Self::Narrower),
            "relatedto" => Ok(Self::Relatedto),
            "specializes" => Ok(Self::Specializes),
            "subsumes" => Ok(Self::Subsumes),
            "unmatched" => Ok(Self::Unmatched),
            "wider" => Ok(Self::Wider),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapEquivalence {
    fn as_ref(&self) -> &str {
        match self {
            Self::Disjoint => "disjoint",
            Self::Equal => "equal",
            Self::Equivalent => "equivalent",
            Self::Inexact => "inexact",
            Self::Narrower => "narrower",
            Self::Relatedto => "relatedto",
            Self::Specializes => "specializes",
            Self::Subsumes => "subsumes",
            Self::Unmatched => "unmatched",
            Self::Wider => "wider",
        }
    }
}
impl ::std::fmt::Debug for ConceptMapEquivalence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConceptMapEquivalence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConceptMapEquivalence {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapEquivalence {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptMapEquivalence> for Coding {
    fn from(code: ConceptMapEquivalence) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/concept-map-equivalence".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConceptMapEquivalence> for CodeableConcept {
    fn from(code: ConceptMapEquivalence) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConceptMapGroupUnmappedMode](http://hl7.org/fhir/ValueSet/conceptmap-unmapped-mode)**. Defines which action to take if there is no match in the group.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConceptMapGroupUnmappedMode {
    /** **fixed**

Fixed Code. Use the code explicitly provided in the group.unmapped */
    Fixed,
    /** **other-map**

Other Map. Use the map identified by the canonical URL in URL */
    OtherMap,
    /** **provided**

Provided Code. Use the code as provided in the $translate request */
    Provided,
}
impl ::core::str::FromStr for ConceptMapGroupUnmappedMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fixed" => Ok(Self::Fixed),
            "other-map" => Ok(Self::OtherMap),
            "provided" => Ok(Self::Provided),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapGroupUnmappedMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fixed => "fixed",
            Self::OtherMap => "other-map",
            Self::Provided => "provided",
        }
    }
}
impl ::std::fmt::Debug for ConceptMapGroupUnmappedMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConceptMapGroupUnmappedMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConceptMapGroupUnmappedMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapGroupUnmappedMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptMapGroupUnmappedMode> for Coding {
    fn from(code: ConceptMapGroupUnmappedMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/conceptmap-unmapped-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConceptMapGroupUnmappedMode> for CodeableConcept {
    fn from(code: ConceptMapGroupUnmappedMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConditionState](http://hl7.org/fhir/ValueSet/condition-state)**. Enumeration indicating whether the condition is currently active, inactive, or has been resolved.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConditionState {
    /** **active**

Active. The condition is active. */
    Active,
    /** **inactive**

Inactive. The condition is inactive, but not resolved. */
    Inactive,
    /** **resolved**

Resolved. The condition is resolved. */
    Resolved,
}
impl ::core::str::FromStr for ConditionState {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "resolved" => Ok(Self::Resolved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Resolved => "resolved",
        }
    }
}
impl ::std::fmt::Debug for ConditionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConditionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConditionState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionState> for Coding {
    fn from(code: ConditionState) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/condition-state".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConditionState> for CodeableConcept {
    fn from(code: ConditionState) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConditionVerificationStatus](http://hl7.org/fhir/ValueSet/condition-ver-status)**. The verification status to support or decline the clinical status of the condition or diagnosis.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConditionVerificationStatus {
    /** **confirmed**

Confirmed. There is sufficient diagnostic and/or clinical evidence to treat this as a confirmed condition. */
    Confirmed,
    /** **differential**

Differential. One of a set of potential (and typically mutually exclusive) diagnoses asserted to further guide the diagnostic process and preliminary treatment. */
    Differential,
    /** **entered-in-error**

Entered In Error. The statement was entered in error and is not valid. */
    EnteredInError,
    /** **provisional**

Provisional. This is a tentative diagnosis - still a candidate that is under consideration. */
    Provisional,
    /** **refuted**

Refuted. This condition has been ruled out by diagnostic and clinical evidence. */
    Refuted,
    /** **unknown**

Unknown. The condition status is unknown.  Note that "unknown" is a value of last resort and every attempt should be made to provide a meaningful value other than "unknown". */
    Unknown,
}
impl ::core::str::FromStr for ConditionVerificationStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(Self::Confirmed),
            "differential" => Ok(Self::Differential),
            "entered-in-error" => Ok(Self::EnteredInError),
            "provisional" => Ok(Self::Provisional),
            "refuted" => Ok(Self::Refuted),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionVerificationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confirmed => "confirmed",
            Self::Differential => "differential",
            Self::EnteredInError => "entered-in-error",
            Self::Provisional => "provisional",
            Self::Refuted => "refuted",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for ConditionVerificationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConditionVerificationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConditionVerificationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionVerificationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionVerificationStatus> for Coding {
    fn from(code: ConditionVerificationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/condition-ver-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConditionVerificationStatus> for CodeableConcept {
    fn from(code: ConditionVerificationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConditionalDeleteStatus](http://hl7.org/fhir/ValueSet/conditional-delete-status)**. A code that indicates how the server supports conditional delete.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConditionalDeleteStatus {
    /** **multiple**

Multiple Deletes Supported. Conditional deletes are supported, and multiple resources can be deleted in a single interaction. */
    Multiple,
    /** **not-supported**

Not Supported. No support for conditional deletes. */
    NotSupported,
    /** **single**

Single Deletes Supported. Conditional deletes are supported, but only single resources at a time. */
    Single,
}
impl ::core::str::FromStr for ConditionalDeleteStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "multiple" => Ok(Self::Multiple),
            "not-supported" => Ok(Self::NotSupported),
            "single" => Ok(Self::Single),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionalDeleteStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Multiple => "multiple",
            Self::NotSupported => "not-supported",
            Self::Single => "single",
        }
    }
}
impl ::std::fmt::Debug for ConditionalDeleteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConditionalDeleteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConditionalDeleteStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionalDeleteStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionalDeleteStatus> for Coding {
    fn from(code: ConditionalDeleteStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/conditional-delete-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConditionalDeleteStatus> for CodeableConcept {
    fn from(code: ConditionalDeleteStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConditionalReadStatus](http://hl7.org/fhir/ValueSet/conditional-read-status)**. A code that indicates how the server supports conditional read.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConditionalReadStatus {
    /** **full-support**

Full Support. Conditional reads are supported, with both If-Modified-Since and If-None-Match HTTP Headers. */
    FullSupport,
    /** **modified-since**

If-Modified-Since. Conditional reads are supported, but only with the If-Modified-Since HTTP Header. */
    ModifiedSince,
    /** **not-match**

If-None-Match. Conditional reads are supported, but only with the If-None-Match HTTP Header. */
    NotMatch,
    /** **not-supported**

Not Supported. No support for conditional deletes. */
    NotSupported,
}
impl ::core::str::FromStr for ConditionalReadStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "full-support" => Ok(Self::FullSupport),
            "modified-since" => Ok(Self::ModifiedSince),
            "not-match" => Ok(Self::NotMatch),
            "not-supported" => Ok(Self::NotSupported),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionalReadStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::FullSupport => "full-support",
            Self::ModifiedSince => "modified-since",
            Self::NotMatch => "not-match",
            Self::NotSupported => "not-supported",
        }
    }
}
impl ::std::fmt::Debug for ConditionalReadStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConditionalReadStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConditionalReadStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionalReadStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionalReadStatus> for Coding {
    fn from(code: ConditionalReadStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/conditional-read-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConditionalReadStatus> for CodeableConcept {
    fn from(code: ConditionalReadStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConformanceExpectation](http://hl7.org/fhir/ValueSet/conformance-expectation)**. Indicates the degree of adherence to a specified behavior or capability expected for a system to be deemed conformant with a specification.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConformanceExpectation {
    /** **MAY**

MAY. Support for the specified capability is not necessary to be considered conformant, and the requirement should be considered strictly optional. */
    May,
    /** **SHALL**

SHALL. Support for the specified capability is required to be considered conformant. */
    Shall,
    /** **SHOULD**

SHOULD. Support for the specified capability is strongly encouraged, and failure to support it should only occur after careful consideration. */
    Should,
    /** **SHOULD-NOT**

SHOULD-NOT. Support for the specified capability is strongly discouraged and should occur only after careful consideration. */
    ShouldNot,
}
impl ::core::str::FromStr for ConformanceExpectation {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "MAY" => Ok(Self::May),
            "SHALL" => Ok(Self::Shall),
            "SHOULD" => Ok(Self::Should),
            "SHOULD-NOT" => Ok(Self::ShouldNot),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConformanceExpectation {
    fn as_ref(&self) -> &str {
        match self {
            Self::May => "MAY",
            Self::Shall => "SHALL",
            Self::Should => "SHOULD",
            Self::ShouldNot => "SHOULD-NOT",
        }
    }
}
impl ::std::fmt::Debug for ConformanceExpectation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConformanceExpectation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConformanceExpectation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConformanceExpectation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConformanceExpectation> for Coding {
    fn from(code: ConformanceExpectation) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/conformance-expectation".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConformanceExpectation> for CodeableConcept {
    fn from(code: ConformanceExpectation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConsentDataMeaning](http://hl7.org/fhir/ValueSet/consent-data-meaning)**. How a resource reference is interpreted when testing consent restrictions\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConsentDataMeaning {
    /** **authoredby**

AuthoredBy. The consent applies to instances of resources that are authored by */
    Authoredby,
    /** **dependents**

Dependents. The consent applies directly to the instance of the resource and instances that refer to it */
    Dependents,
    /** **instance**

Instance. The consent applies directly to the instance of the resource */
    Instance,
    /** **related**

Related. The consent applies directly to the instance of the resource and instances it refers to */
    Related,
}
impl ::core::str::FromStr for ConsentDataMeaning {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "authoredby" => Ok(Self::Authoredby),
            "dependents" => Ok(Self::Dependents),
            "instance" => Ok(Self::Instance),
            "related" => Ok(Self::Related),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentDataMeaning {
    fn as_ref(&self) -> &str {
        match self {
            Self::Authoredby => "authoredby",
            Self::Dependents => "dependents",
            Self::Instance => "instance",
            Self::Related => "related",
        }
    }
}
impl ::std::fmt::Debug for ConsentDataMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConsentDataMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConsentDataMeaning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentDataMeaning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentDataMeaning> for Coding {
    fn from(code: ConsentDataMeaning) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/consent-data-meaning".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConsentDataMeaning> for CodeableConcept {
    fn from(code: ConsentDataMeaning) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConsentExceptType](http://hl7.org/fhir/ValueSet/consent-except-type)**. How an exception statement is applied, such as adding additional consent or removing consent\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConsentExceptType {
    /** **deny**

Opt Out. Consent is denied for actions meeting these rules */
    Deny,
    /** **permit**

Opt In. Consent is provided for actions meeting these rules */
    Permit,
}
impl ::core::str::FromStr for ConsentExceptType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deny" => Ok(Self::Deny),
            "permit" => Ok(Self::Permit),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentExceptType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deny => "deny",
            Self::Permit => "permit",
        }
    }
}
impl ::std::fmt::Debug for ConsentExceptType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConsentExceptType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConsentExceptType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentExceptType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentExceptType> for Coding {
    fn from(code: ConsentExceptType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/consent-except-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConsentExceptType> for CodeableConcept {
    fn from(code: ConsentExceptType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConsentState](http://hl7.org/fhir/ValueSet/consent-state-codes)**. Indicates the state of the consent\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConsentState {
    /** **active**

Active. The consent is to be followed and enforced. */
    Active,
    /** **draft**

Pending. The consent is in development or awaiting use but is not yet intended to be acted upon. */
    Draft,
    /** **entered-in-error**

Entered in Error. The consent was created wrongly (e.g. wrong patient) and should be ignored */
    EnteredInError,
    /** **inactive**

Inactive. The consent is terminated or replaced. */
    Inactive,
    /** **proposed**

Proposed. The consent has been proposed but not yet agreed to by all parties. The negotiation stage. */
    Proposed,
    /** **rejected**

Rejected. The consent has been rejected by one or more of the parties. */
    Rejected,
}
impl ::core::str::FromStr for ConsentState {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "proposed" => Ok(Self::Proposed),
            "rejected" => Ok(Self::Rejected),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Proposed => "proposed",
            Self::Rejected => "rejected",
        }
    }
}
impl ::std::fmt::Debug for ConsentState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConsentState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConsentState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentState> for Coding {
    fn from(code: ConsentState) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/consent-state-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConsentState> for CodeableConcept {
    fn from(code: ConsentState) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConstraintSeverity](http://hl7.org/fhir/ValueSet/constraint-severity)**. SHALL applications comply with this constraint?\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConstraintSeverity {
    /** **error**

Error. If the constraint is violated, the resource is not conformant. */
    Error,
    /** **warning**

Warning. If the constraint is violated, the resource is conformant, but it is not necessarily following best practice. */
    Warning,
}
impl ::core::str::FromStr for ConstraintSeverity {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConstraintSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Debug for ConstraintSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConstraintSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConstraintSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConstraintSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConstraintSeverity> for Coding {
    fn from(code: ConstraintSeverity) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/constraint-severity".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConstraintSeverity> for CodeableConcept {
    fn from(code: ConstraintSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContactEntityType](http://hl7.org/fhir/ValueSet/contactentity-type)**. This example value set defines a set of codes that can be used to indicate the purpose for which you would contact a contact party.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContactEntityType {
    /** **ADMIN**

Administrative. Contact details for administrative enquiries. */
    Admin,
    /** **BILL**

Billing. Contact details for information regarding to billing/general finance enquiries. */
    Bill,
    /** **HR**

Human Resource. Contact details for issues related to Human Resources, such as staff matters, OH&S etc. */
    Hr,
    /** **PATINF**

Patient. Generic information contact for patients. */
    Patinf,
    /** **PAYOR**

Payor. Contact details for dealing with issues related to insurance claims/adjudication/payment. */
    Payor,
    /** **PRESS**

Press. Dedicated contact point for matters relating to press enquiries. */
    Press,
}
impl ::core::str::FromStr for ContactEntityType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ADMIN" => Ok(Self::Admin),
            "BILL" => Ok(Self::Bill),
            "HR" => Ok(Self::Hr),
            "PATINF" => Ok(Self::Patinf),
            "PAYOR" => Ok(Self::Payor),
            "PRESS" => Ok(Self::Press),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContactEntityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Admin => "ADMIN",
            Self::Bill => "BILL",
            Self::Hr => "HR",
            Self::Patinf => "PATINF",
            Self::Payor => "PAYOR",
            Self::Press => "PRESS",
        }
    }
}
impl ::std::fmt::Debug for ContactEntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContactEntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContactEntityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactEntityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContactEntityType> for Coding {
    fn from(code: ContactEntityType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/contactentity-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContactEntityType> for CodeableConcept {
    fn from(code: ContactEntityType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContactPointSystem](http://hl7.org/fhir/ValueSet/contact-point-system)**. Telecommunications form for contact point\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContactPointSystem {
    /** **email**

Email. The value is an email address. */
    Email,
    /** **fax**

Fax. The value is a fax machine. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required. */
    Fax,
    /** **other**

Other. A contact that is not a phone, fax, page or email address and is not expressible as a URL.  E.g. Internal mail address.  This SHOULD NOT be used for contacts that are expressible as a URL (e.g. Skype, Twitter, Facebook, etc.)  Extensions may be used to distinguish "other" contact types. */
    Other,
    /** **pager**

Pager. The value is a pager number. These may be local pager numbers that are only usable on a particular pager system. */
    Pager,
    /** **phone**

Phone. The value is a telephone number used for voice calls. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required. */
    Phone,
    /** **sms**

SMS. A contact that can be used for sending an sms message (e.g. mobide phones, some landlines) */
    Sms,
    /** **url**

URL. A contact that is not a phone, fax, pager or email address and is expressed as a URL.  This is intended for various personal contacts including blogs, Skype, Twitter, Facebook, etc. Do not use for email addresses. */
    Url,
}
impl ::core::str::FromStr for ContactPointSystem {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "email" => Ok(Self::Email),
            "fax" => Ok(Self::Fax),
            "other" => Ok(Self::Other),
            "pager" => Ok(Self::Pager),
            "phone" => Ok(Self::Phone),
            "sms" => Ok(Self::Sms),
            "url" => Ok(Self::Url),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContactPointSystem {
    fn as_ref(&self) -> &str {
        match self {
            Self::Email => "email",
            Self::Fax => "fax",
            Self::Other => "other",
            Self::Pager => "pager",
            Self::Phone => "phone",
            Self::Sms => "sms",
            Self::Url => "url",
        }
    }
}
impl ::std::fmt::Debug for ContactPointSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContactPointSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContactPointSystem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactPointSystem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContactPointSystem> for Coding {
    fn from(code: ContactPointSystem) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/contact-point-system".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContactPointSystem> for CodeableConcept {
    fn from(code: ContactPointSystem) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContactPointUse](http://hl7.org/fhir/ValueSet/contact-point-use)**. Use of contact point\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContactPointUse {
    /** **home**

Home. A communication contact point at a home; attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available. */
    Home,
    /** **mobile**

Mobile. A telecommunication device that moves and stays with its owner. May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business. */
    Mobile,
    /** **old**

Old. This contact point is no longer in use (or was never correct, but retained for records). */
    Old,
    /** **temp**

Temp. A temporary contact point. The period can provide more detailed information. */
    Temp,
    /** **work**

Work. An office contact point. First choice for business related contacts during business hours. */
    Work,
}
impl ::core::str::FromStr for ContactPointUse {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "home" => Ok(Self::Home),
            "mobile" => Ok(Self::Mobile),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "work" => Ok(Self::Work),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContactPointUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Home => "home",
            Self::Mobile => "mobile",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Work => "work",
        }
    }
}
impl ::std::fmt::Debug for ContactPointUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContactPointUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContactPointUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactPointUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContactPointUse> for Coding {
    fn from(code: ContactPointUse) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/contact-point-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContactPointUse> for CodeableConcept {
    fn from(code: ContactPointUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContentType](http://hl7.org/fhir/ValueSet/content-type)**. The content or mime type.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContentType {
    /** **json**

json. JSON content-type corresponding to the application/fhir+json mime-type. */
    Json,
    /** **none**

none. Prevent the use of the corresponding http header. */
    None,
    /** **ttl**

ttl. RDF content-type corresponding to the text/turtle mime-type. */
    Ttl,
    /** **xml**

xml. XML content-type corresponding to the application/fhir+xml mime-type. */
    Xml,
}
impl ::core::str::FromStr for ContentType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "json" => Ok(Self::Json),
            "none" => Ok(Self::None),
            "ttl" => Ok(Self::Ttl),
            "xml" => Ok(Self::Xml),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContentType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Json => "json",
            Self::None => "none",
            Self::Ttl => "ttl",
            Self::Xml => "xml",
        }
    }
}
impl ::std::fmt::Debug for ContentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContentType> for Coding {
    fn from(code: ContentType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/content-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContentType> for CodeableConcept {
    fn from(code: ContentType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContributorType](http://hl7.org/fhir/ValueSet/contributor-type)**. The type of contributor\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContributorType {
    /** **author**

Author. An author of the content of the module */
    Author,
    /** **editor**

Editor. An editor of the content of the module */
    Editor,
    /** **endorser**

Endorser. An endorser of the content of the module */
    Endorser,
    /** **reviewer**

Reviewer. A reviewer of the content of the module */
    Reviewer,
}
impl ::core::str::FromStr for ContributorType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "author" => Ok(Self::Author),
            "editor" => Ok(Self::Editor),
            "endorser" => Ok(Self::Endorser),
            "reviewer" => Ok(Self::Reviewer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Author => "author",
            Self::Editor => "editor",
            Self::Endorser => "endorser",
            Self::Reviewer => "reviewer",
        }
    }
}
impl ::std::fmt::Debug for ContributorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContributorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContributorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorType> for Coding {
    fn from(code: ContributorType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/contributor-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContributorType> for CodeableConcept {
    fn from(code: ContributorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CopyNumberEvent](http://hl7.org/fhir/ValueSet/copy-number-event)**. Copy Number Event\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CopyNumberEvent {
    /** **amp**

amplificaiton. amplificaiton */
    Amp,
    /** **del**

deletion. deletion */
    Del,
    /** **lof**

loss of function. loss of function */
    Lof,
}
impl ::core::str::FromStr for CopyNumberEvent {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amp" => Ok(Self::Amp),
            "del" => Ok(Self::Del),
            "lof" => Ok(Self::Lof),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CopyNumberEvent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amp => "amp",
            Self::Del => "del",
            Self::Lof => "lof",
        }
    }
}
impl ::std::fmt::Debug for CopyNumberEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CopyNumberEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CopyNumberEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CopyNumberEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CopyNumberEvent> for Coding {
    fn from(code: CopyNumberEvent) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/copy-number-event".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CopyNumberEvent> for CodeableConcept {
    fn from(code: CopyNumberEvent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DataAbsentReason](http://hl7.org/fhir/ValueSet/data-absent-reason)**. Used to specify why the normally expected content of the data element is missing.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DataAbsentReason {
    /** **NaN**

Not a Number. NaN, standing for not a number, is a numeric data type value representing an undefined or unrepresentable value. */
    NaN,
    /** **asked**

Asked. The source human does not know the value. */
    Asked,
    /** **astext**

As Text. The content of the data is represented in the resource narrative. */
    Astext,
    /** **error**

Error. Some system or workflow process error means that the information is not available. */
    Error,
    /** **masked**

Masked. The information is not available due to security, privacy or related reasons. */
    Masked,
    /** **not-asked**

Not Asked. The workflow didn't lead to this value being known. */
    NotAsked,
    /** **not-performed**

Not Performed. The value is not available because the observation procedure (test, etc.) was not performed. */
    NotPerformed,
    /** **temp**

Temp. There is reason to expect (from the workflow) that the value may become known. */
    Temp,
    /** **unknown**

Unknown. The value is not known. */
    Unknown,
    /** **unsupported**

Unsupported. The source system wasn't capable of supporting this element. */
    Unsupported,
}
impl ::core::str::FromStr for DataAbsentReason {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "NaN" => Ok(Self::NaN),
            "asked" => Ok(Self::Asked),
            "astext" => Ok(Self::Astext),
            "error" => Ok(Self::Error),
            "masked" => Ok(Self::Masked),
            "not-asked" => Ok(Self::NotAsked),
            "not-performed" => Ok(Self::NotPerformed),
            "temp" => Ok(Self::Temp),
            "unknown" => Ok(Self::Unknown),
            "unsupported" => Ok(Self::Unsupported),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DataAbsentReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::NaN => "NaN",
            Self::Asked => "asked",
            Self::Astext => "astext",
            Self::Error => "error",
            Self::Masked => "masked",
            Self::NotAsked => "not-asked",
            Self::NotPerformed => "not-performed",
            Self::Temp => "temp",
            Self::Unknown => "unknown",
            Self::Unsupported => "unsupported",
        }
    }
}
impl ::std::fmt::Debug for DataAbsentReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DataAbsentReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DataAbsentReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DataAbsentReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DataAbsentReason> for Coding {
    fn from(code: DataAbsentReason) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/data-absent-reason".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DataAbsentReason> for CodeableConcept {
    fn from(code: DataAbsentReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DataElementStringency](http://hl7.org/fhir/ValueSet/dataelement-stringency)**. Indicates the degree of precision of the data element definition.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DataElementStringency {
    /** **comparable**

Comparable. The data element is sufficiently well-constrained that multiple pieces of data captured according to the constraints of the data element will be comparable (though in some cases, a degree of automated conversion/normalization may be required). */
    Comparable,
    /** **convertable**

Convertable. The data element allows multiple units of measure that are convertable between each other (e.g. inches and centimeters) and/or allows data to be captured in multiple value sets for which a known mapping exists allowing conversion of meaning. */
    Convertable,
    /** **equivalent**

Equivalent. The data element allows multiple units of measure having equivalent meaning; e.g. "cc" (cubic centimeter) and "mL" (milliliter). */
    Equivalent,
    /** **flexible**

Flexible. The data element is unconstrained in units, choice of data types and/or choice of vocabulary such that automated comparison of data captured using the data element is not possible. */
    Flexible,
    /** **fully-specified**

Fully Specified. The data element is fully specified down to a single value set, single unit of measure, single data type, etc.  Multiple pieces of data associated with this data element are fully comparable. */
    FullySpecified,
    /** **scaleable**

Scaleable. A convertable data element where unit conversions are different only by a power of 10; e.g. g, mg, kg. */
    Scaleable,
}
impl ::core::str::FromStr for DataElementStringency {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "comparable" => Ok(Self::Comparable),
            "convertable" => Ok(Self::Convertable),
            "equivalent" => Ok(Self::Equivalent),
            "flexible" => Ok(Self::Flexible),
            "fully-specified" => Ok(Self::FullySpecified),
            "scaleable" => Ok(Self::Scaleable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DataElementStringency {
    fn as_ref(&self) -> &str {
        match self {
            Self::Comparable => "comparable",
            Self::Convertable => "convertable",
            Self::Equivalent => "equivalent",
            Self::Flexible => "flexible",
            Self::FullySpecified => "fully-specified",
            Self::Scaleable => "scaleable",
        }
    }
}
impl ::std::fmt::Debug for DataElementStringency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DataElementStringency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DataElementStringency {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DataElementStringency {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DataElementStringency> for Coding {
    fn from(code: DataElementStringency) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/dataelement-stringency".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DataElementStringency> for CodeableConcept {
    fn from(code: DataElementStringency) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DataType](http://hl7.org/fhir/ValueSet/data-types)**. The type of an element - one of the FHIR data types.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DataType {
    /** **Address**

Address. An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world. */
    Address,
    /** **Age**

Age. A duration of time during which an organism (or a process) has existed. */
    Age,
    /** **Annotation**

Annotation. A  text note which also  contains information about who made the statement and when. */
    Annotation,
    /** **Attachment**

Attachment. For referring to data content defined in other formats. */
    Attachment,
    /** **BackboneElement**

BackboneElement. Base definition for all elements that are defined inside a resource - but not those in a data type. */
    BackboneElement,
    /** **CodeableConcept**

CodeableConcept. A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text. */
    CodeableConcept,
    /** **Coding**

Coding. A reference to a code defined by a terminology system. */
    Coding,
    /** **ContactDetail**

ContactDetail. Specifies contact information for a person or organization. */
    ContactDetail,
    /** **ContactPoint**

ContactPoint. Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc. */
    ContactPoint,
    /** **Contributor**

Contributor. A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers. */
    Contributor,
    /** **Count**

Count. A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies. */
    Count,
    /** **DataRequirement**

DataRequirement. Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data. */
    DataRequirement,
    /** **Distance**

Distance. A length - a value with a unit that is a physical distance. */
    Distance,
    /** **Dosage**

Dosage. Indicates how the medication is/was taken or should be taken by the patient. */
    Dosage,
    /** **Duration**

Duration. A length of time. */
    Duration,
    /** **Element**

Element. Base definition for all elements in a resource. */
    Element,
    /** **ElementDefinition**

ElementDefinition. Captures constraints on each element within the resource, profile, or extension. */
    ElementDefinition,
    /** **Extension**

Extension. Optional Extension Element - found in all resources. */
    Extension,
    /** **HumanName**

HumanName. A human's name with the ability to identify parts and usage. */
    HumanName,
    /** **Identifier**

Identifier. A technical identifier - identifies some entity uniquely and unambiguously. */
    Identifier,
    /** **Meta**

Meta. The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content may not always be associated with version changes to the resource. */
    Meta,
    /** **Money**

Money. An amount of economic utility in some recognized currency. */
    Money,
    /** **Narrative**

Narrative. A human-readable formatted text, including images. */
    Narrative,
    /** **ParameterDefinition**

ParameterDefinition. The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse. */
    ParameterDefinition,
    /** **Period**

Period. A time period defined by a start and end date and optionally time. */
    Period,
    /** **Quantity**

Quantity. A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies. */
    Quantity,
    /** **Range**

Range. A set of ordered Quantities defined by a low and high limit. */
    Range,
    /** **Ratio**

Ratio. A relationship of two Quantity values - expressed as a numerator and a denominator. */
    Ratio,
    /** **Reference**

Reference. A reference from one resource to another. */
    Reference,
    /** **RelatedArtifact**

RelatedArtifact. Related artifacts such as additional documentation, justification, or bibliographic references. */
    RelatedArtifact,
    /** **SampledData**

SampledData. A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data. */
    SampledData,
    /** **Signature**

Signature. A digital signature along with supporting context. The signature may be electronic/cryptographic in nature, or a graphical image representing a hand-written signature, or a signature process. Different signature approaches have different utilities. */
    Signature,
    /** **SimpleQuantity**

SimpleQuantity. */
    SimpleQuantity,
    /** **Timing**

Timing. Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out. */
    Timing,
    /** **TriggerDefinition**

TriggerDefinition. A description of a triggering event. */
    TriggerDefinition,
    /** **UsageContext**

UsageContext. Specifies clinical/business/etc metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care). */
    UsageContext,
    /** **base64Binary**

base64Binary. A stream of bytes */
    Base64Binary,
    /** **boolean**

boolean. Value of "true" or "false" */
    Boolean,
    /** **code**

code. A string which has at least one character and no leading or trailing whitespace and where there is no whitespace other than single spaces in the contents */
    Code,
    /** **date**

date. A date or partial date (e.g. just year or year + month). There is no time zone. The format is a union of the schema types gYear, gYearMonth and date.  Dates SHALL be valid dates. */
    Date,
    /** **dateTime**

dateTime. A date, date-time or partial date (e.g. just year or year + month).  If hours and minutes are specified, a time zone SHALL be populated. The format is a union of the schema types gYear, gYearMonth, date and dateTime. Seconds must be provided due to schema type constraints but may be zero-filled and may be ignored.                 Dates SHALL be valid dates. */
    DateTime,
    /** **decimal**

decimal. A rational number with implicit precision */
    Decimal,
    /** **id**

id. Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these constraints.)  Ids are case-insensitive. */
    Id,
    /** **instant**

instant. An instant in time - known at least to the second */
    Instant,
    /** **integer**

integer. A whole number */
    Integer,
    /** **markdown**

markdown. A string that may contain markdown syntax for optional processing by a mark down presentation engine */
    Markdown,
    /** **oid**

oid. An OID represented as a URI */
    Oid,
    /** **positiveInt**

positiveInt. An integer with a value that is positive (e.g. >0) */
    PositiveInt,
    /** **string**

string. A sequence of Unicode characters */
    String,
    /** **time**

time. A time during the day, with no date specified */
    Time,
    /** **unsignedInt**

unsignedInt. An integer with a value that is not negative (e.g. >= 0) */
    UnsignedInt,
    /** **uri**

uri. String of characters used to identify a name or a resource */
    Uri,
    /** **uuid**

uuid. A UUID, represented as a URI */
    Uuid,
    /** **xhtml**

XHTML. XHTML format, as defined by W3C, but restricted usage (mainly, no active content) */
    Xhtml,
}
impl ::core::str::FromStr for DataType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Address" => Ok(Self::Address),
            "Age" => Ok(Self::Age),
            "Annotation" => Ok(Self::Annotation),
            "Attachment" => Ok(Self::Attachment),
            "BackboneElement" => Ok(Self::BackboneElement),
            "CodeableConcept" => Ok(Self::CodeableConcept),
            "Coding" => Ok(Self::Coding),
            "ContactDetail" => Ok(Self::ContactDetail),
            "ContactPoint" => Ok(Self::ContactPoint),
            "Contributor" => Ok(Self::Contributor),
            "Count" => Ok(Self::Count),
            "DataRequirement" => Ok(Self::DataRequirement),
            "Distance" => Ok(Self::Distance),
            "Dosage" => Ok(Self::Dosage),
            "Duration" => Ok(Self::Duration),
            "Element" => Ok(Self::Element),
            "ElementDefinition" => Ok(Self::ElementDefinition),
            "Extension" => Ok(Self::Extension),
            "HumanName" => Ok(Self::HumanName),
            "Identifier" => Ok(Self::Identifier),
            "Meta" => Ok(Self::Meta),
            "Money" => Ok(Self::Money),
            "Narrative" => Ok(Self::Narrative),
            "ParameterDefinition" => Ok(Self::ParameterDefinition),
            "Period" => Ok(Self::Period),
            "Quantity" => Ok(Self::Quantity),
            "Range" => Ok(Self::Range),
            "Ratio" => Ok(Self::Ratio),
            "Reference" => Ok(Self::Reference),
            "RelatedArtifact" => Ok(Self::RelatedArtifact),
            "SampledData" => Ok(Self::SampledData),
            "Signature" => Ok(Self::Signature),
            "SimpleQuantity" => Ok(Self::SimpleQuantity),
            "Timing" => Ok(Self::Timing),
            "TriggerDefinition" => Ok(Self::TriggerDefinition),
            "UsageContext" => Ok(Self::UsageContext),
            "base64Binary" => Ok(Self::Base64Binary),
            "boolean" => Ok(Self::Boolean),
            "code" => Ok(Self::Code),
            "date" => Ok(Self::Date),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "id" => Ok(Self::Id),
            "instant" => Ok(Self::Instant),
            "integer" => Ok(Self::Integer),
            "markdown" => Ok(Self::Markdown),
            "oid" => Ok(Self::Oid),
            "positiveInt" => Ok(Self::PositiveInt),
            "string" => Ok(Self::String),
            "time" => Ok(Self::Time),
            "unsignedInt" => Ok(Self::UnsignedInt),
            "uri" => Ok(Self::Uri),
            "uuid" => Ok(Self::Uuid),
            "xhtml" => Ok(Self::Xhtml),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DataType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Address => "Address",
            Self::Age => "Age",
            Self::Annotation => "Annotation",
            Self::Attachment => "Attachment",
            Self::BackboneElement => "BackboneElement",
            Self::CodeableConcept => "CodeableConcept",
            Self::Coding => "Coding",
            Self::ContactDetail => "ContactDetail",
            Self::ContactPoint => "ContactPoint",
            Self::Contributor => "Contributor",
            Self::Count => "Count",
            Self::DataRequirement => "DataRequirement",
            Self::Distance => "Distance",
            Self::Dosage => "Dosage",
            Self::Duration => "Duration",
            Self::Element => "Element",
            Self::ElementDefinition => "ElementDefinition",
            Self::Extension => "Extension",
            Self::HumanName => "HumanName",
            Self::Identifier => "Identifier",
            Self::Meta => "Meta",
            Self::Money => "Money",
            Self::Narrative => "Narrative",
            Self::ParameterDefinition => "ParameterDefinition",
            Self::Period => "Period",
            Self::Quantity => "Quantity",
            Self::Range => "Range",
            Self::Ratio => "Ratio",
            Self::Reference => "Reference",
            Self::RelatedArtifact => "RelatedArtifact",
            Self::SampledData => "SampledData",
            Self::Signature => "Signature",
            Self::SimpleQuantity => "SimpleQuantity",
            Self::Timing => "Timing",
            Self::TriggerDefinition => "TriggerDefinition",
            Self::UsageContext => "UsageContext",
            Self::Base64Binary => "base64Binary",
            Self::Boolean => "boolean",
            Self::Code => "code",
            Self::Date => "date",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Id => "id",
            Self::Instant => "instant",
            Self::Integer => "integer",
            Self::Markdown => "markdown",
            Self::Oid => "oid",
            Self::PositiveInt => "positiveInt",
            Self::String => "string",
            Self::Time => "time",
            Self::UnsignedInt => "unsignedInt",
            Self::Uri => "uri",
            Self::Uuid => "uuid",
            Self::Xhtml => "xhtml",
        }
    }
}
impl ::std::fmt::Debug for DataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DataType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DataType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DataType> for Coding {
    fn from(code: DataType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/data-types".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DataType> for CodeableConcept {
    fn from(code: DataType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DaysOfWeek](http://hl7.org/fhir/ValueSet/days-of-week)**. The days of the week.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DaysOfWeek {
    /** **fri**

Friday. Friday */
    Fri,
    /** **mon**

Monday. Monday */
    Mon,
    /** **sat**

Saturday. Saturday */
    Sat,
    /** **sun**

Sunday. Sunday */
    Sun,
    /** **thu**

Thursday. Thursday */
    Thu,
    /** **tue**

Tuesday. Tuesday */
    Tue,
    /** **wed**

Wednesday. Wednesday */
    Wed,
}
impl ::core::str::FromStr for DaysOfWeek {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fri" => Ok(Self::Fri),
            "mon" => Ok(Self::Mon),
            "sat" => Ok(Self::Sat),
            "sun" => Ok(Self::Sun),
            "thu" => Ok(Self::Thu),
            "tue" => Ok(Self::Tue),
            "wed" => Ok(Self::Wed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DaysOfWeek {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fri => "fri",
            Self::Mon => "mon",
            Self::Sat => "sat",
            Self::Sun => "sun",
            Self::Thu => "thu",
            Self::Tue => "tue",
            Self::Wed => "wed",
        }
    }
}
impl ::std::fmt::Debug for DaysOfWeek {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DaysOfWeek {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DaysOfWeek {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DaysOfWeek {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DaysOfWeek> for Coding {
    fn from(code: DaysOfWeek) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/days-of-week".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DaysOfWeek> for CodeableConcept {
    fn from(code: DaysOfWeek) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DefinitionStatus](http://hl7.org/fhir/ValueSet/definition-status)**. Codes identifying the lifecycle stage of a definition\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DefinitionStatus {
    /** **active**

Active. The definition is considered ready for use */
    Active,
    /** **draft**

Draft. The definition is in the design stage and is not yet considered to be "ready for use" */
    Draft,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this request.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
    /** **withdrawn**

Withdrawn. The definition should no longer be used */
    Withdrawn,
}
impl ::core::str::FromStr for DefinitionStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "unknown" => Ok(Self::Unknown),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::Unknown => "unknown",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Debug for DefinitionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DefinitionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DefinitionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DefinitionStatus> for Coding {
    fn from(code: DefinitionStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/definition-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DefinitionStatus> for CodeableConcept {
    fn from(code: DefinitionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DefinitionTopic](http://hl7.org/fhir/ValueSet/definition-topic)**. High-level categorization of the definition, used for searching, sorting, and filtering\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DefinitionTopic {
    /** **assessment**

Assessment. The definition is related to assessment of the patient */
    Assessment,
    /** **education**

Education. The definition is related to education of the patient */
    Education,
    /** **treatment**

Treatment. The definition is related to treatment of the patient */
    Treatment,
}
impl ::core::str::FromStr for DefinitionTopic {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assessment" => Ok(Self::Assessment),
            "education" => Ok(Self::Education),
            "treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionTopic {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assessment => "assessment",
            Self::Education => "education",
            Self::Treatment => "treatment",
        }
    }
}
impl ::std::fmt::Debug for DefinitionTopic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DefinitionTopic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DefinitionTopic {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionTopic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DefinitionTopic> for Coding {
    fn from(code: DefinitionTopic) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/definition-topic".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DefinitionTopic> for CodeableConcept {
    fn from(code: DefinitionTopic) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DetectedIssueSeverity](http://hl7.org/fhir/ValueSet/detectedissue-severity)**. Indicates the potential degree of impact of the identified issue on the patient.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DetectedIssueSeverity {
    /** **high**

High. Indicates the issue may be life-threatening or has the potential to cause permanent injury. */
    High,
    /** **low**

Low. Indicates the issue may result in some adverse consequences but is unlikely to substantially affect the situation of the subject. */
    Low,
    /** **moderate**

Moderate. Indicates the issue may result in noticeable adverse consequences but is unlikely to be life-threatening or cause permanent injury. */
    Moderate,
}
impl ::core::str::FromStr for DetectedIssueSeverity {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DetectedIssueSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
        }
    }
}
impl ::std::fmt::Debug for DetectedIssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DetectedIssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DetectedIssueSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DetectedIssueSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DetectedIssueSeverity> for Coding {
    fn from(code: DetectedIssueSeverity) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/detectedissue-severity".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DetectedIssueSeverity> for CodeableConcept {
    fn from(code: DetectedIssueSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceComponentOperationalStatus](http://hl7.org/fhir/ValueSet/operational-status)**. Codes representing the current status of the device - on, off, suspended, etc.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceComponentOperationalStatus {
    /** **entered-in-error**

Entered In Error. The device was entered in error. */
    EnteredInError,
    /** **hw-discon**

Hardware Disconnectd. The device hardware is disconnected. */
    HwDiscon,
    /** **not-ready**

Not Ready. The device is not ready. */
    NotReady,
    /** **off**

Off. The device is off. */
    Off,
    /** **on**

On. The device is fully operational. */
    On,
    /** **standby**

Standby. The device is ready but not actively operating. */
    Standby,
    /** **transduc-discon**

Transducer Diconnected. The device transducer is diconnected. */
    TransducDiscon,
}
impl ::core::str::FromStr for DeviceComponentOperationalStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "entered-in-error" => Ok(Self::EnteredInError),
            "hw-discon" => Ok(Self::HwDiscon),
            "not-ready" => Ok(Self::NotReady),
            "off" => Ok(Self::Off),
            "on" => Ok(Self::On),
            "standby" => Ok(Self::Standby),
            "transduc-discon" => Ok(Self::TransducDiscon),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceComponentOperationalStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::EnteredInError => "entered-in-error",
            Self::HwDiscon => "hw-discon",
            Self::NotReady => "not-ready",
            Self::Off => "off",
            Self::On => "on",
            Self::Standby => "standby",
            Self::TransducDiscon => "transduc-discon",
        }
    }
}
impl ::std::fmt::Debug for DeviceComponentOperationalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceComponentOperationalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceComponentOperationalStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceComponentOperationalStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceComponentOperationalStatus> for Coding {
    fn from(code: DeviceComponentOperationalStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/operational-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceComponentOperationalStatus> for CodeableConcept {
    fn from(code: DeviceComponentOperationalStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceComponentParameterGroup](http://hl7.org/fhir/ValueSet/parameter-group)**. Codes identifying groupings of parameters; e.g. Cardiovascular.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceComponentParameterGroup {
    /** **blood-chemistry**

Blood Chemistry Parameter Group. Blood Chemistry Parameter Group - MDC_PGRP_BLOOD_CHEM */
    BloodChemistry,
    /** **drug-delivery**

Drug Delivery Parameter Group. Drug Delivery Parameter Group - MDC_PGRP_DRUG */
    DrugDelivery,
    /** **ecg**

ECG Parameter Group. ECG Parameter Group - MDC_PGRP_ECG */
    Ecg,
    /** **fluid-chemistry**

Fluid Chemistry Parameter Group. Fluid Chemistry Parameter Group - MDC_PGRP_FLUID */
    FluidChemistry,
    /** **haemodynamic**

Haemodynamic Parameter Group. Haemodynamic Parameter Group - MDC_PGRP_HEMO */
    Haemodynamic,
    /** **miscellaneous**

Miscellaneous Parameter Group. Miscellaneous Parameter Group - MDC_PGRP_MISC */
    Miscellaneous,
    /** **neurological**

Neurological Parameter Group. Neurological Parameter Group - MDC_PGRP_NEURO */
    Neurological,
    /** **respiratory**

Respiratory Parameter Group. Respiratory Parameter Group - MDC_PGRP_RESP */
    Respiratory,
    /** **ventilation**

Ventilation Parameter Group. Ventilation Parameter Group - MDC_PGRP_VENT */
    Ventilation,
}
impl ::core::str::FromStr for DeviceComponentParameterGroup {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "blood-chemistry" => Ok(Self::BloodChemistry),
            "drug-delivery" => Ok(Self::DrugDelivery),
            "ecg" => Ok(Self::Ecg),
            "fluid-chemistry" => Ok(Self::FluidChemistry),
            "haemodynamic" => Ok(Self::Haemodynamic),
            "miscellaneous" => Ok(Self::Miscellaneous),
            "neurological" => Ok(Self::Neurological),
            "respiratory" => Ok(Self::Respiratory),
            "ventilation" => Ok(Self::Ventilation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceComponentParameterGroup {
    fn as_ref(&self) -> &str {
        match self {
            Self::BloodChemistry => "blood-chemistry",
            Self::DrugDelivery => "drug-delivery",
            Self::Ecg => "ecg",
            Self::FluidChemistry => "fluid-chemistry",
            Self::Haemodynamic => "haemodynamic",
            Self::Miscellaneous => "miscellaneous",
            Self::Neurological => "neurological",
            Self::Respiratory => "respiratory",
            Self::Ventilation => "ventilation",
        }
    }
}
impl ::std::fmt::Debug for DeviceComponentParameterGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceComponentParameterGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceComponentParameterGroup {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceComponentParameterGroup {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceComponentParameterGroup> for Coding {
    fn from(code: DeviceComponentParameterGroup) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/parameter-group".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceComponentParameterGroup> for CodeableConcept {
    fn from(code: DeviceComponentParameterGroup) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricCalibrationState](http://hl7.org/fhir/ValueSet/metric-calibration-state)**. Describes the state of a metric calibration.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricCalibrationState {
    /** **calibrated**

Calibrated. The metric has been calibrated. */
    Calibrated,
    /** **calibration-required**

Calibration Required. The metric needs to be calibrated. */
    CalibrationRequired,
    /** **not-calibrated**

Not Calibrated. The metric has not been calibrated. */
    NotCalibrated,
    /** **unspecified**

Unspecified. The state of calibration of this metric is unspecified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCalibrationState {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calibrated" => Ok(Self::Calibrated),
            "calibration-required" => Ok(Self::CalibrationRequired),
            "not-calibrated" => Ok(Self::NotCalibrated),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCalibrationState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calibrated => "calibrated",
            Self::CalibrationRequired => "calibration-required",
            Self::NotCalibrated => "not-calibrated",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricCalibrationState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricCalibrationState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCalibrationState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCalibrationState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricCalibrationState> for Coding {
    fn from(code: DeviceMetricCalibrationState) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/metric-calibration-state".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricCalibrationState> for CodeableConcept {
    fn from(code: DeviceMetricCalibrationState) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricCalibrationType](http://hl7.org/fhir/ValueSet/metric-calibration-type)**. Describes the type of a metric calibration.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricCalibrationType {
    /** **gain**

Gain. Gain metric calibration method */
    Gain,
    /** **offset**

Offset. Offset metric calibration method */
    Offset,
    /** **two-point**

Two Point. Two-point metric calibration method */
    TwoPoint,
    /** **unspecified**

Unspecified. Metric calibration method has not been identified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCalibrationType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "gain" => Ok(Self::Gain),
            "offset" => Ok(Self::Offset),
            "two-point" => Ok(Self::TwoPoint),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCalibrationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Gain => "gain",
            Self::Offset => "offset",
            Self::TwoPoint => "two-point",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricCalibrationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricCalibrationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCalibrationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCalibrationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricCalibrationType> for Coding {
    fn from(code: DeviceMetricCalibrationType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/metric-calibration-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricCalibrationType> for CodeableConcept {
    fn from(code: DeviceMetricCalibrationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricCategory](http://hl7.org/fhir/ValueSet/metric-category)**. Describes the category of the metric.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricCategory {
    /** **calculation**

Calculation. DeviceObservations generated for this DeviceMetric are calculated. */
    Calculation,
    /** **measurement**

Measurement. DeviceObservations generated for this DeviceMetric are measured. */
    Measurement,
    /** **setting**

Setting. DeviceObservations generated for this DeviceMetric is a setting that will influence the behavior of the Device. */
    Setting,
    /** **unspecified**

Unspecified. The category of this DeviceMetric is unspecified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calculation" => Ok(Self::Calculation),
            "measurement" => Ok(Self::Measurement),
            "setting" => Ok(Self::Setting),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calculation => "calculation",
            Self::Measurement => "measurement",
            Self::Setting => "setting",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricCategory> for Coding {
    fn from(code: DeviceMetricCategory) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/metric-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricCategory> for CodeableConcept {
    fn from(code: DeviceMetricCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricColor](http://hl7.org/fhir/ValueSet/metric-color)**. Describes the typical color of representation.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricColor {
    /** **black**

Color Black. Color for representation - black. */
    Black,
    /** **blue**

Color Blue. Color for representation - blue. */
    Blue,
    /** **cyan**

Color Cyan. Color for representation - cyan. */
    Cyan,
    /** **green**

Color Green. Color for representation - green. */
    Green,
    /** **magenta**

Color Magenta. Color for representation - magenta. */
    Magenta,
    /** **red**

Color Red. Color for representation - red. */
    Red,
    /** **white**

Color White. Color for representation - white. */
    White,
    /** **yellow**

Color Yellow. Color for representation - yellow. */
    Yellow,
}
impl ::core::str::FromStr for DeviceMetricColor {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "black" => Ok(Self::Black),
            "blue" => Ok(Self::Blue),
            "cyan" => Ok(Self::Cyan),
            "green" => Ok(Self::Green),
            "magenta" => Ok(Self::Magenta),
            "red" => Ok(Self::Red),
            "white" => Ok(Self::White),
            "yellow" => Ok(Self::Yellow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricColor {
    fn as_ref(&self) -> &str {
        match self {
            Self::Black => "black",
            Self::Blue => "blue",
            Self::Cyan => "cyan",
            Self::Green => "green",
            Self::Magenta => "magenta",
            Self::Red => "red",
            Self::White => "white",
            Self::Yellow => "yellow",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricColor {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricColor {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricColor> for Coding {
    fn from(code: DeviceMetricColor) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/metric-color".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricColor> for CodeableConcept {
    fn from(code: DeviceMetricColor) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricOperationalStatus](http://hl7.org/fhir/ValueSet/metric-operational-status)**. Describes the operational status of the DeviceMetric.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricOperationalStatus {
    /** **entered-in-error**

Entered In Error. The DeviceMetric was entered in error. */
    EnteredInError,
    /** **off**

Off. The DeviceMetric is not operating. */
    Off,
    /** **on**

On. The DeviceMetric is operating and will generate DeviceObservations. */
    On,
    /** **standby**

Standby. The DeviceMetric is operating, but will not generate any DeviceObservations. */
    Standby,
}
impl ::core::str::FromStr for DeviceMetricOperationalStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "entered-in-error" => Ok(Self::EnteredInError),
            "off" => Ok(Self::Off),
            "on" => Ok(Self::On),
            "standby" => Ok(Self::Standby),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricOperationalStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::EnteredInError => "entered-in-error",
            Self::Off => "off",
            Self::On => "on",
            Self::Standby => "standby",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricOperationalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricOperationalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricOperationalStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricOperationalStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricOperationalStatus> for Coding {
    fn from(code: DeviceMetricOperationalStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/metric-operational-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricOperationalStatus> for CodeableConcept {
    fn from(code: DeviceMetricOperationalStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceSpecificationSpecType](http://hl7.org/fhir/ValueSet/specification-type)**. Codes for device specification types such as serial number, part number, hardware revision, software revision, etc.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceSpecificationSpecType {
    /** **firmware-revision**

Firmware Revision. Firmware Revision - MDC_ID_PROD_SPEC_FW */
    FirmwareRevision,
    /** **gmdn**

GMDN. GMDN - MDC_ID_PROD_SPEC_GMDN */
    Gmdn,
    /** **hardware-revision**

Hardware Revision. Hardware Revision - MDC_ID_PROD_SPEC_HW */
    HardwareRevision,
    /** **part-number**

Part Number. Part Number - MDC_ID_PROD_SPEC_PART */
    PartNumber,
    /** **protocol-revision**

Protocol Revision. Protocol Revision - MDC_ID_PROD_SPEC_PROTOCOL */
    ProtocolRevision,
    /** **serial-number**

Serial Number. Serial Number - MDC_ID_PROD_SPEC_SERIAL */
    SerialNumber,
    /** **software-revision**

Software Revision. Software Revision - MDC_ID_PROD_SPEC_SW */
    SoftwareRevision,
    /** **unspecified**

Unspecified Production Specification. Unspecified Production Specification - MDC_ID_PROD_SPEC_UNSPECIFIED */
    Unspecified,
}
impl ::core::str::FromStr for DeviceSpecificationSpecType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "firmware-revision" => Ok(Self::FirmwareRevision),
            "gmdn" => Ok(Self::Gmdn),
            "hardware-revision" => Ok(Self::HardwareRevision),
            "part-number" => Ok(Self::PartNumber),
            "protocol-revision" => Ok(Self::ProtocolRevision),
            "serial-number" => Ok(Self::SerialNumber),
            "software-revision" => Ok(Self::SoftwareRevision),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceSpecificationSpecType {
    fn as_ref(&self) -> &str {
        match self {
            Self::FirmwareRevision => "firmware-revision",
            Self::Gmdn => "gmdn",
            Self::HardwareRevision => "hardware-revision",
            Self::PartNumber => "part-number",
            Self::ProtocolRevision => "protocol-revision",
            Self::SerialNumber => "serial-number",
            Self::SoftwareRevision => "software-revision",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Debug for DeviceSpecificationSpecType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceSpecificationSpecType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceSpecificationSpecType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceSpecificationSpecType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceSpecificationSpecType> for Coding {
    fn from(code: DeviceSpecificationSpecType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/specification-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceSpecificationSpecType> for CodeableConcept {
    fn from(code: DeviceSpecificationSpecType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceUseStatementStatus](http://hl7.org/fhir/ValueSet/device-statement-status)**. A coded concept indicating the current status of a the Device Usage\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceUseStatementStatus {
    /** **active**

Active. The device is still being used. */
    Active,
    /** **completed**

Completed. The device is no longer being used. */
    Completed,
    /** **entered-in-error**

Entered in Error. The statement was recorded incorrectly. */
    EnteredInError,
    /** **intended**

Intended. The device may be used at some time in the future. */
    Intended,
    /** **on-hold**

On Hold. Actions implied by the statement have been temporarily halted, but are expected to continue later. May also be called "suspended". */
    OnHold,
    /** **stopped**

Stopped. Actions implied by the statement have been permanently halted, before all of them occurred. */
    Stopped,
}
impl ::core::str::FromStr for DeviceUseStatementStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "intended" => Ok(Self::Intended),
            "on-hold" => Ok(Self::OnHold),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceUseStatementStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::Intended => "intended",
            Self::OnHold => "on-hold",
            Self::Stopped => "stopped",
        }
    }
}
impl ::std::fmt::Debug for DeviceUseStatementStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceUseStatementStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceUseStatementStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceUseStatementStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceUseStatementStatus> for Coding {
    fn from(code: DeviceUseStatementStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/device-statement-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceUseStatementStatus> for CodeableConcept {
    fn from(code: DeviceUseStatementStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DiagnosisRole](http://hl7.org/fhir/ValueSet/diagnosis-role)**. This value set defines a set of codes that can be used to express the role of a diagnosis on the Encounter or EpisodeOfCare record.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DiagnosisRole {
    /** **AD**

Admission diagnosis. */
    Ad,
    /** **CC**

Chief complaint. */
    Cc,
    /** **CM**

Comorbidity diagnosis. */
    Cm,
    /** **DD**

Discharge diagnosis. */
    Dd,
    /** **billing**

Billing. */
    Billing,
    /** **post-op**

post-op diagnosis. */
    PostOp,
    /** **pre-op**

pre-op diagnosis. */
    PreOp,
}
impl ::core::str::FromStr for DiagnosisRole {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AD" => Ok(Self::Ad),
            "CC" => Ok(Self::Cc),
            "CM" => Ok(Self::Cm),
            "DD" => Ok(Self::Dd),
            "billing" => Ok(Self::Billing),
            "post-op" => Ok(Self::PostOp),
            "pre-op" => Ok(Self::PreOp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiagnosisRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ad => "AD",
            Self::Cc => "CC",
            Self::Cm => "CM",
            Self::Dd => "DD",
            Self::Billing => "billing",
            Self::PostOp => "post-op",
            Self::PreOp => "pre-op",
        }
    }
}
impl ::std::fmt::Debug for DiagnosisRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DiagnosisRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DiagnosisRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiagnosisRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DiagnosisRole> for Coding {
    fn from(code: DiagnosisRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/diagnosis-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DiagnosisRole> for CodeableConcept {
    fn from(code: DiagnosisRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DiagnosticReportStatus](http://hl7.org/fhir/ValueSet/diagnostic-report-status)**. The status of the diagnostic report as a whole.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DiagnosticReportStatus {
    /** **amended**

Amended. Subsequent to being final, the report has been modified.  This includes any change in the results, diagnosis, narrative text, or other content of a report that has been issued. */
    Amended,
    /** **appended**

Appended. Subsequent to being final, the report has been modified by adding new content. The existing content is unchanged. */
    Appended,
    /** **cancelled**

Cancelled. The report is unavailable because the measurement was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **corrected**

Corrected. Subsequent to being final, the report has been modified  to correct an error in the report or referenced results. */
    Corrected,
    /** **entered-in-error**

Entered in Error. The report has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".) */
    EnteredInError,
    /** **final**

Final. The report is complete and verified by an authorized person. */
    Final,
    /** **partial**

Partial. This is a partial (e.g. initial, interim or preliminary) report: data in the report may be incomplete or unverified. */
    Partial,
    /** **preliminary**

Preliminary. Verified early results are available, but not all  results are final. */
    Preliminary,
    /** **registered**

Registered. The existence of the report is registered, but there is nothing yet available. */
    Registered,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for DiagnosticReportStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "corrected" => Ok(Self::Corrected),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "partial" => Ok(Self::Partial),
            "preliminary" => Ok(Self::Preliminary),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiagnosticReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Corrected => "corrected",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Partial => "partial",
            Self::Preliminary => "preliminary",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for DiagnosticReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DiagnosticReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DiagnosticReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiagnosticReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DiagnosticReportStatus> for Coding {
    fn from(code: DiagnosticReportStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/diagnostic-report-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DiagnosticReportStatus> for CodeableConcept {
    fn from(code: DiagnosticReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[Diet](http://hl7.org/fhir/ValueSet/encounter-diet)**. This value set defines a set of codes that can be used to indicate dietary preferences or restrictions a patient may have.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum Diet {
    /** **dairy-free**

Dairy Free. Excludes dairy products. */
    DairyFree,
    /** **gluten-free**

Gluten Free. Excludes ingredients containing gluten. */
    GlutenFree,
    /** **halal**

Halal. Foods that conform to Islamic law. */
    Halal,
    /** **kosher**

Kosher. Foods that conform to Jewish dietary law. */
    Kosher,
    /** **nut-free**

Nut Free. Excludes ingredients containing nuts. */
    NutFree,
    /** **vegan**

Vegan. Food without meat, poultry, seafood, eggs, dairy products and other animal-derived substances. */
    Vegan,
    /** **vegetarian**

Vegetarian. Food without meat, poultry or seafood. */
    Vegetarian,
}
impl ::core::str::FromStr for Diet {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "dairy-free" => Ok(Self::DairyFree),
            "gluten-free" => Ok(Self::GlutenFree),
            "halal" => Ok(Self::Halal),
            "kosher" => Ok(Self::Kosher),
            "nut-free" => Ok(Self::NutFree),
            "vegan" => Ok(Self::Vegan),
            "vegetarian" => Ok(Self::Vegetarian),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Diet {
    fn as_ref(&self) -> &str {
        match self {
            Self::DairyFree => "dairy-free",
            Self::GlutenFree => "gluten-free",
            Self::Halal => "halal",
            Self::Kosher => "kosher",
            Self::NutFree => "nut-free",
            Self::Vegan => "vegan",
            Self::Vegetarian => "vegetarian",
        }
    }
}
impl ::std::fmt::Debug for Diet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for Diet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for Diet {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Diet {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<Diet> for Coding {
    fn from(code: Diet) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/encounter-diet".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<Diet> for CodeableConcept {
    fn from(code: Diet) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DigitalMediaType](http://hl7.org/fhir/ValueSet/digital-media-type)**. Whether the media is a photo, video, or audio\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DigitalMediaType {
    /** **audio**

Audio. The media consists of a sound recording */
    Audio,
    /** **photo**

Photo. The media consists of one or more unmoving images, including photographs, computer-generated graphs and charts, and scanned documents */
    Photo,
    /** **video**

Video. The media consists of a series of frames that capture a moving image */
    Video,
}
impl ::core::str::FromStr for DigitalMediaType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "audio" => Ok(Self::Audio),
            "photo" => Ok(Self::Photo),
            "video" => Ok(Self::Video),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DigitalMediaType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Audio => "audio",
            Self::Photo => "photo",
            Self::Video => "video",
        }
    }
}
impl ::std::fmt::Debug for DigitalMediaType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DigitalMediaType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DigitalMediaType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DigitalMediaType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DigitalMediaType> for Coding {
    fn from(code: DigitalMediaType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/digital-media-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DigitalMediaType> for CodeableConcept {
    fn from(code: DigitalMediaType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DischargeDisposition](http://hl7.org/fhir/ValueSet/encounter-discharge-disposition)**. This value set defines a set of codes that can be used to where the patient left the hospital.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DischargeDisposition {
    /** **aadvice**

Left against advice. The patient self discharged against medical advice. */
    Aadvice,
    /** **exp**

Expired. The patient has deceased during this encounter. */
    Exp,
    /** **home**

Home. The patient was dicharged and has indicated that they are going to return home afterwards. */
    Home,
    /** **hosp**

Hospice. The patient has been discharged into palliative care. */
    Hosp,
    /** **long**

Long-term care. The patient has been discharged into long-term care where is likely to be monitored through an ongoing episode-of-care. */
    Long,
    /** **oth**

Other. The discharge disposition has not otherwise defined. */
    Oth,
    /** **other-hcf**

Other healthcare facility. The patient was transferred to another healthcare facility. */
    OtherHcf,
    /** **psy**

Psychiatric hospital. The patient has been transferred to a psychiatric facility. */
    Psy,
    /** **rehab**

Rehabilitation. The patient was discharged and is to receive post acute care rehabilitation services. */
    Rehab,
    /** **snf**

Skilled nursing facility. The patient has been discharged to a skilled nursing facility for the patient to receive additional care. */
    Snf,
}
impl ::core::str::FromStr for DischargeDisposition {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aadvice" => Ok(Self::Aadvice),
            "exp" => Ok(Self::Exp),
            "home" => Ok(Self::Home),
            "hosp" => Ok(Self::Hosp),
            "long" => Ok(Self::Long),
            "oth" => Ok(Self::Oth),
            "other-hcf" => Ok(Self::OtherHcf),
            "psy" => Ok(Self::Psy),
            "rehab" => Ok(Self::Rehab),
            "snf" => Ok(Self::Snf),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DischargeDisposition {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aadvice => "aadvice",
            Self::Exp => "exp",
            Self::Home => "home",
            Self::Hosp => "hosp",
            Self::Long => "long",
            Self::Oth => "oth",
            Self::OtherHcf => "other-hcf",
            Self::Psy => "psy",
            Self::Rehab => "rehab",
            Self::Snf => "snf",
        }
    }
}
impl ::std::fmt::Debug for DischargeDisposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DischargeDisposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DischargeDisposition {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DischargeDisposition {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DischargeDisposition> for Coding {
    fn from(code: DischargeDisposition) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/encounter-discharge-disposition".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DischargeDisposition> for CodeableConcept {
    fn from(code: DischargeDisposition) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DiscriminatorType](http://hl7.org/fhir/ValueSet/discriminator-type)**. How an element value is interpreted when discrimination is evaluated\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DiscriminatorType {
    /** **exists**

Exists. The slices are differentiated by the presence or absence of the nominated element */
    Exists,
    /** **pattern**

Pattern. The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x] */
    Pattern,
    /** **profile**

Profile. The slices are differentiated by conformance of the nominated element to a specifed profile */
    Profile,
    /** **type**

Type. The slices are differentiated by type of the nominated element to a specifed profile */
    Type,
    /** **value**

Value. The slices have different values in the nominated element */
    Value,
}
impl ::core::str::FromStr for DiscriminatorType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exists" => Ok(Self::Exists),
            "pattern" => Ok(Self::Pattern),
            "profile" => Ok(Self::Profile),
            "type" => Ok(Self::Type),
            "value" => Ok(Self::Value),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiscriminatorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exists => "exists",
            Self::Pattern => "pattern",
            Self::Profile => "profile",
            Self::Type => "type",
            Self::Value => "value",
        }
    }
}
impl ::std::fmt::Debug for DiscriminatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DiscriminatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DiscriminatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiscriminatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DiscriminatorType> for Coding {
    fn from(code: DiscriminatorType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/discriminator-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DiscriminatorType> for CodeableConcept {
    fn from(code: DiscriminatorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DocumentMode](http://hl7.org/fhir/ValueSet/document-mode)**. Whether the application produces or consumes documents.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DocumentMode {
    /** **consumer**

Consumer. The application consumes documents of the specified type. */
    Consumer,
    /** **producer**

Producer. The application produces documents of the specified type. */
    Producer,
}
impl ::core::str::FromStr for DocumentMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "consumer" => Ok(Self::Consumer),
            "producer" => Ok(Self::Producer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consumer => "consumer",
            Self::Producer => "producer",
        }
    }
}
impl ::std::fmt::Debug for DocumentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DocumentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DocumentMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DocumentMode> for Coding {
    fn from(code: DocumentMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/document-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DocumentMode> for CodeableConcept {
    fn from(code: DocumentMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DocumentReferenceStatus](http://hl7.org/fhir/ValueSet/document-reference-status)**. The status of the document reference.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DocumentReferenceStatus {
    /** **current**

Current. This is the current reference for this document. */
    Current,
    /** **entered-in-error**

Entered in Error. This reference was created in error. */
    EnteredInError,
    /** **superseded**

Superseded. This reference has been superseded by another reference. */
    Superseded,
}
impl ::core::str::FromStr for DocumentReferenceStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "current" => Ok(Self::Current),
            "entered-in-error" => Ok(Self::EnteredInError),
            "superseded" => Ok(Self::Superseded),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentReferenceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Current => "current",
            Self::EnteredInError => "entered-in-error",
            Self::Superseded => "superseded",
        }
    }
}
impl ::std::fmt::Debug for DocumentReferenceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DocumentReferenceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DocumentReferenceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentReferenceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DocumentReferenceStatus> for Coding {
    fn from(code: DocumentReferenceStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/document-reference-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DocumentReferenceStatus> for CodeableConcept {
    fn from(code: DocumentReferenceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DocumentRelationshipType](http://hl7.org/fhir/ValueSet/document-relationship-type)**. The type of relationship between documents.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DocumentRelationshipType {
    /** **appends**

Appends. This document adds additional information to the target document. */
    Appends,
    /** **replaces**

Replaces. This document logically replaces or supersedes the target document. */
    Replaces,
    /** **signs**

Signs. This document is a signature of the target document. */
    Signs,
    /** **transforms**

Transforms. This document was generated by transforming the target document (e.g. format or language conversion). */
    Transforms,
}
impl ::core::str::FromStr for DocumentRelationshipType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "appends" => Ok(Self::Appends),
            "replaces" => Ok(Self::Replaces),
            "signs" => Ok(Self::Signs),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Appends => "appends",
            Self::Replaces => "replaces",
            Self::Signs => "signs",
            Self::Transforms => "transforms",
        }
    }
}
impl ::std::fmt::Debug for DocumentRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DocumentRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DocumentRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DocumentRelationshipType> for Coding {
    fn from(code: DocumentRelationshipType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/document-relationship-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DocumentRelationshipType> for CodeableConcept {
    fn from(code: DocumentRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EncounterLocationStatus](http://hl7.org/fhir/ValueSet/encounter-location-status)**. The status of the location.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EncounterLocationStatus {
    /** **active**

Active. The patient is currently at this location, or was between the period specified.

A system may update these records when the patient leaves the location to either reserved, or completed */
    Active,
    /** **completed**

Completed. The patient was at this location during the period specified.

Not to be used when the patient is currently at the location */
    Completed,
    /** **planned**

Planned. The patient is planned to be moved to this location at some point in the future. */
    Planned,
    /** **reserved**

Reserved. This location is held empty for this patient. */
    Reserved,
}
impl ::core::str::FromStr for EncounterLocationStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "planned" => Ok(Self::Planned),
            "reserved" => Ok(Self::Reserved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterLocationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::Planned => "planned",
            Self::Reserved => "reserved",
        }
    }
}
impl ::std::fmt::Debug for EncounterLocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EncounterLocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EncounterLocationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterLocationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterLocationStatus> for Coding {
    fn from(code: EncounterLocationStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/encounter-location-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EncounterLocationStatus> for CodeableConcept {
    fn from(code: EncounterLocationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EncounterStatus](http://hl7.org/fhir/ValueSet/encounter-status)**. Current state of the encounter\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EncounterStatus {
    /** **arrived**

Arrived. The Patient is present for the encounter, however is not currently meeting with a practitioner. */
    Arrived,
    /** **cancelled**

Cancelled. The Encounter has ended before it has begun. */
    Cancelled,
    /** **entered-in-error**

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **finished**

Finished. The Encounter has ended. */
    Finished,
    /** **in-progress**

In Progress. The Encounter has begun and the patient is present / the practitioner and the patient are meeting. */
    InProgress,
    /** **onleave**

On Leave. The Encounter has begun, but the patient is temporarily on leave. */
    Onleave,
    /** **planned**

Planned. The Encounter has not yet started. */
    Planned,
    /** **triaged**

Triaged. The patient has been assessed for the priority of their treatment based on the severity of their condition. */
    Triaged,
    /** **unknown**

Unknown. The encounter status is unknown. Note that "unknown" is a value of last resort and every attempt should be made to provide a meaningful value other than "unknown". */
    Unknown,
}
impl ::core::str::FromStr for EncounterStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "arrived" => Ok(Self::Arrived),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "finished" => Ok(Self::Finished),
            "in-progress" => Ok(Self::InProgress),
            "onleave" => Ok(Self::Onleave),
            "planned" => Ok(Self::Planned),
            "triaged" => Ok(Self::Triaged),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Arrived => "arrived",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Finished => "finished",
            Self::InProgress => "in-progress",
            Self::Onleave => "onleave",
            Self::Planned => "planned",
            Self::Triaged => "triaged",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for EncounterStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EncounterStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EncounterStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterStatus> for Coding {
    fn from(code: EncounterStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/encounter-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EncounterStatus> for CodeableConcept {
    fn from(code: EncounterStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EncounterType](http://hl7.org/fhir/ValueSet/encounter-type)**. This example value set defines a set of codes that can be used to indicate the type of encounter: a specific code indicating type of service provided.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EncounterType {
    /** **ADMS**

Annual diabetes mellitus screening. */
    Adms,
    /** **BD/BM-clin**

Bone drilling/bone marrow punction in clinic. */
    BdBmClin,
    /** **CCS60**

Infant colon screening - 60 minutes. */
    Ccs60,
    /** **OKI**

Outpatient Kenacort injection. */
    Oki,
}
impl ::core::str::FromStr for EncounterType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ADMS" => Ok(Self::Adms),
            "BD/BM-clin" => Ok(Self::BdBmClin),
            "CCS60" => Ok(Self::Ccs60),
            "OKI" => Ok(Self::Oki),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adms => "ADMS",
            Self::BdBmClin => "BD/BM-clin",
            Self::Ccs60 => "CCS60",
            Self::Oki => "OKI",
        }
    }
}
impl ::std::fmt::Debug for EncounterType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EncounterType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EncounterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterType> for Coding {
    fn from(code: EncounterType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/encounter-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EncounterType> for CodeableConcept {
    fn from(code: EncounterType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EndpointStatus](http://hl7.org/fhir/ValueSet/endpoint-status)**. The status of the endpoint\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EndpointStatus {
    /** **active**

Active. This endpoint is expected to be active and can be used */
    Active,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **error**

Error. This endpoint has exceeded connectivity thresholds and is considered in an error state and should no longer be attempted to connect to until corrective action is taken */
    Error,
    /** **off**

Off. This endpoint is no longer to be used */
    Off,
    /** **suspended**

Suspended. This endpoint is temporarily unavailable */
    Suspended,
    /** **test**

Test. This endpoint is not intended for production usage. */
    Test,
}
impl ::core::str::FromStr for EndpointStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "error" => Ok(Self::Error),
            "off" => Ok(Self::Off),
            "suspended" => Ok(Self::Suspended),
            "test" => Ok(Self::Test),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EndpointStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Error => "error",
            Self::Off => "off",
            Self::Suspended => "suspended",
            Self::Test => "test",
        }
    }
}
impl ::std::fmt::Debug for EndpointStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EndpointStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EndpointStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EndpointStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EndpointStatus> for Coding {
    fn from(code: EndpointStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/endpoint-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EndpointStatus> for CodeableConcept {
    fn from(code: EndpointStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EpisodeOfCareStatus](http://hl7.org/fhir/ValueSet/episode-of-care-status)**. The status of the episode of care.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EpisodeOfCareStatus {
    /** **active**

Active. This episode of care is current. */
    Active,
    /** **cancelled**

Cancelled. The episode of care was cancelled, or withdrawn from service, often selected during the planned stage as the patient may have gone elsewhere, or the circumstances have changed and the organization is unable to provide the care. It indicates that services terminated outside the planned/expected workflow. */
    Cancelled,
    /** **entered-in-error**

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **finished**

Finished. This episode of care is finished and the organization is not expecting to be providing further care to the patient. Can also be known as "closed", "completed" or other similar terms. */
    Finished,
    /** **onhold**

On Hold. This episode of care is on hold, the organization has limited responsibility for the patient (such as while on respite). */
    Onhold,
    /** **planned**

Planned. This episode of care is planned to start at the date specified in the period.start. During this status, an organization may perform assessments to determine if the patient is eligible to receive services, or be organizing to make resources available to provide care services. */
    Planned,
    /** **waitlist**

Waitlist. This episode has been placed on a waitlist, pending the episode being made active (or cancelled). */
    Waitlist,
}
impl ::core::str::FromStr for EpisodeOfCareStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "finished" => Ok(Self::Finished),
            "onhold" => Ok(Self::Onhold),
            "planned" => Ok(Self::Planned),
            "waitlist" => Ok(Self::Waitlist),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EpisodeOfCareStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Finished => "finished",
            Self::Onhold => "onhold",
            Self::Planned => "planned",
            Self::Waitlist => "waitlist",
        }
    }
}
impl ::std::fmt::Debug for EpisodeOfCareStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EpisodeOfCareStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EpisodeOfCareStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EpisodeOfCareStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EpisodeOfCareStatus> for Coding {
    fn from(code: EpisodeOfCareStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/episode-of-care-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EpisodeOfCareStatus> for CodeableConcept {
    fn from(code: EpisodeOfCareStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EpisodeOfCareType](http://hl7.org/fhir/ValueSet/episodeofcare-type)**. This example value set defines a set of codes that can be used to express the usage type of an EpisodeOfCare record.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EpisodeOfCareType {
    /** **cacp**

Community-based aged care. */
    Cacp,
    /** **da**

Drug and alcohol rehabilitation. */
    Da,
    /** **diab**

Post co-ordinated diabetes program. */
    Diab,
    /** **hacc**

Home and Community Care. */
    Hacc,
    /** **pac**

Post Acute Care. */
    Pac,
}
impl ::core::str::FromStr for EpisodeOfCareType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cacp" => Ok(Self::Cacp),
            "da" => Ok(Self::Da),
            "diab" => Ok(Self::Diab),
            "hacc" => Ok(Self::Hacc),
            "pac" => Ok(Self::Pac),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EpisodeOfCareType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cacp => "cacp",
            Self::Da => "da",
            Self::Diab => "diab",
            Self::Hacc => "hacc",
            Self::Pac => "pac",
        }
    }
}
impl ::std::fmt::Debug for EpisodeOfCareType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EpisodeOfCareType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EpisodeOfCareType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EpisodeOfCareType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EpisodeOfCareType> for Coding {
    fn from(code: EpisodeOfCareType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/episodeofcare-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EpisodeOfCareType> for CodeableConcept {
    fn from(code: EpisodeOfCareType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EventCapabilityMode](http://hl7.org/fhir/ValueSet/event-capability-mode)**. The mode of a message capability statement.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EventCapabilityMode {
    /** **receiver**

Receiver. The application receives requests and sends responses. */
    Receiver,
    /** **sender**

Sender. The application sends requests and receives responses. */
    Sender,
}
impl ::core::str::FromStr for EventCapabilityMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "receiver" => Ok(Self::Receiver),
            "sender" => Ok(Self::Sender),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventCapabilityMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Receiver => "receiver",
            Self::Sender => "sender",
        }
    }
}
impl ::std::fmt::Debug for EventCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EventCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EventCapabilityMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventCapabilityMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventCapabilityMode> for Coding {
    fn from(code: EventCapabilityMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/event-capability-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EventCapabilityMode> for CodeableConcept {
    fn from(code: EventCapabilityMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EventStatus](http://hl7.org/fhir/ValueSet/event-status)**. Codes identifying the stage lifecycle stage of a event\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EventStatus {
    /** **aborted**

Aborted. The event was  prior to the full completion of the intended actions */
    Aborted,
    /** **completed**

Completed. The event has now concluded */
    Completed,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".) */
    EnteredInError,
    /** **in-progress**

In Progress. The event is currently occurring */
    InProgress,
    /** **preparation**

Preparation. The core event has not started yet, but some staging activities have begun (e.g. surgical suite preparation).  Preparation stages may be tracked for billing purposes. */
    Preparation,
    /** **suspended**

Suspended. The event has been temporarily stopped but is expected to resume in the future */
    Suspended,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this request.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for EventStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aborted" => Ok(Self::Aborted),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "preparation" => Ok(Self::Preparation),
            "suspended" => Ok(Self::Suspended),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aborted => "aborted",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Preparation => "preparation",
            Self::Suspended => "suspended",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for EventStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EventStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EventStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventStatus> for Coding {
    fn from(code: EventStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/event-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EventStatus> for CodeableConcept {
    fn from(code: EventStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EventTiming](http://hl7.org/fhir/ValueSet/event-timing)**. Real world event relating to the schedule.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EventTiming {
    /** **AFT**

Afternoon. event occurs during the afternoon */
    Aft,
    /** **EVE**

Evening. event occurs during the evening */
    Eve,
    /** **MORN**

Morning. event occurs during the morning */
    Morn,
    /** **NIGHT**

Night. event occurs during the night */
    Night,
    /** **PHS**

After Sleep. event occurs [offset] after subject goes to sleep */
    Phs,
}
impl ::core::str::FromStr for EventTiming {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AFT" => Ok(Self::Aft),
            "EVE" => Ok(Self::Eve),
            "MORN" => Ok(Self::Morn),
            "NIGHT" => Ok(Self::Night),
            "PHS" => Ok(Self::Phs),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventTiming {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aft => "AFT",
            Self::Eve => "EVE",
            Self::Morn => "MORN",
            Self::Night => "NIGHT",
            Self::Phs => "PHS",
        }
    }
}
impl ::std::fmt::Debug for EventTiming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EventTiming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EventTiming {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventTiming {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventTiming> for Coding {
    fn from(code: EventTiming) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/event-timing".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EventTiming> for CodeableConcept {
    fn from(code: EventTiming) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExplanationOfBenefitStatus](http://hl7.org/fhir/ValueSet/explanationofbenefit-status)**. A code specifying the state of the resource instance.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ExplanationOfBenefitStatus {
    /** **active**

Active. The resource instance is currently in-force. */
    Active,
    /** **cancelled**

Cancelled. The resource instance is withdrawn, rescinded or reversed. */
    Cancelled,
    /** **draft**

Draft. A new resource instance the contents of which is not complete. */
    Draft,
    /** **entered-in-error**

Entered In Error. The resource instance was entered in error. */
    EnteredInError,
}
impl ::core::str::FromStr for ExplanationOfBenefitStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExplanationOfBenefitStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
        }
    }
}
impl ::std::fmt::Debug for ExplanationOfBenefitStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExplanationOfBenefitStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExplanationOfBenefitStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExplanationOfBenefitStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExplanationOfBenefitStatus> for Coding {
    fn from(code: ExplanationOfBenefitStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/explanationofbenefit-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExplanationOfBenefitStatus> for CodeableConcept {
    fn from(code: ExplanationOfBenefitStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExtensionContext](http://hl7.org/fhir/ValueSet/extension-context)**. How an extension context is interpreted.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ExtensionContext {
    /** **datatype**

Datatype. The context is all nodes matching a particular data type element path (root or repeating element) or all elements referencing a particular primitive data type (expressed as the datatype name). */
    Datatype,
    /** **extension**

Extension. The context is a particular extension from a particular profile, a uri that identifies the extension definition. */
    Extension,
    /** **resource**

Resource. The context is all elements matching a particular resource element path. */
    Resource,
}
impl ::core::str::FromStr for ExtensionContext {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "datatype" => Ok(Self::Datatype),
            "extension" => Ok(Self::Extension),
            "resource" => Ok(Self::Resource),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExtensionContext {
    fn as_ref(&self) -> &str {
        match self {
            Self::Datatype => "datatype",
            Self::Extension => "extension",
            Self::Resource => "resource",
        }
    }
}
impl ::std::fmt::Debug for ExtensionContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExtensionContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExtensionContext {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExtensionContext {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExtensionContext> for Coding {
    fn from(code: ExtensionContext) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/extension-context".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExtensionContext> for CodeableConcept {
    fn from(code: ExtensionContext) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExtraActivityType](http://hl7.org/fhir/extra-activity-type)**. This value set includes coded concepts not well covered in any of the included valuesets.\n\nFHIR version: 1.1.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExtraActivityType {
    /** **aggregate**

aggregate. Activity resulting in a structured collection of preexisting content that does not necessarily result in an integral object with semantic context making it more than the sum of component parts, from which components could be disaggregated without loss of semantic context, e.g., the assembly of multiple stand-alone documents. */
    Aggregate,
    /** **compose**

compose. Activity resulting in the structured compilation of new and preexisting content for the purposes of forming an integral object with  semantic context making it more than the sum of component parts, which would be lost if decomposed. For example, the composition of a document that includes in whole or part other documents along with new content that result in a new document that has unique semantic meaning. */
    Compose,
    /** **label**

label. The means used to associate a set of security attributes with a specific information object as part of the data structure for that object. [ISO-10181-3 Access Control] */
    Label,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExtraActivityType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aggregate" => Ok(Self::Aggregate),
            "compose" => Ok(Self::Compose),
            "label" => Ok(Self::Label),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExtraActivityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aggregate => "aggregate",
            Self::Compose => "compose",
            Self::Label => "label",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExtraActivityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExtraActivityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExtraActivityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExtraActivityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExtraActivityType> for Coding {
    fn from(code: ExtraActivityType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/extra-activity-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExtraActivityType> for CodeableConcept {
    fn from(code: ExtraActivityType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FHIRDeviceStatus](http://hl7.org/fhir/ValueSet/device-status)**. The availability status of the device.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FHIRDeviceStatus {
    /** **active**

Active. The Device is available for use.  Note: This means for *implanted devices*  the device is implanted in the patient. */
    Active,
    /** **entered-in-error**

Entered in Error. The Device was entered in error and voided. */
    EnteredInError,
    /** **inactive**

Inactive. The Device is no longer available for use (e.g. lost, expired, damaged).  Note: This means for *implanted devices*  the device has been removed from the patient. */
    Inactive,
    /** **unknown**

Unknown. The status of the device has not been determined. */
    Unknown,
}
impl ::core::str::FromStr for FHIRDeviceStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FHIRDeviceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for FHIRDeviceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FHIRDeviceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FHIRDeviceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FHIRDeviceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FHIRDeviceStatus> for Coding {
    fn from(code: FHIRDeviceStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/device-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FHIRDeviceStatus> for CodeableConcept {
    fn from(code: FHIRDeviceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FHIRSubstanceStatus](http://hl7.org/fhir/ValueSet/substance-status)**. A code to indicate if the substance is actively used\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FHIRSubstanceStatus {
    /** **active**

Active. The substance is considered for use or reference */
    Active,
    /** **entered-in-error**

Entered in Error. The substance was entered in error */
    EnteredInError,
    /** **inactive**

Inactive. The substance is considered for reference, but not for use */
    Inactive,
}
impl ::core::str::FromStr for FHIRSubstanceStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FHIRSubstanceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Debug for FHIRSubstanceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FHIRSubstanceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FHIRSubstanceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FHIRSubstanceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FHIRSubstanceStatus> for Coding {
    fn from(code: FHIRSubstanceStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/substance-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FHIRSubstanceStatus> for CodeableConcept {
    fn from(code: FHIRSubstanceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FamilyHistoryNotDoneReason](http://hl7.org/fhir/ValueSet/history-not-done-reason)**. Codes describing the reason why a family member history was not done.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FamilyHistoryNotDoneReason {
    /** **deferred**

Deferred. Patient does not have the information now, but can provide the information at a later date. */
    Deferred,
    /** **subject-unknown**

Subject Unknown. Patient does not know the subject, e.g. the biological parent of an adopted patient. */
    SubjectUnknown,
    /** **unable-to-obtain**

Unable To Obtain. Information cannot be obtained; e.g. unconscious patient */
    UnableToObtain,
    /** **withheld**

Information Withheld. The patient withheld or refused to share the information. */
    Withheld,
}
impl ::core::str::FromStr for FamilyHistoryNotDoneReason {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deferred" => Ok(Self::Deferred),
            "subject-unknown" => Ok(Self::SubjectUnknown),
            "unable-to-obtain" => Ok(Self::UnableToObtain),
            "withheld" => Ok(Self::Withheld),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FamilyHistoryNotDoneReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deferred => "deferred",
            Self::SubjectUnknown => "subject-unknown",
            Self::UnableToObtain => "unable-to-obtain",
            Self::Withheld => "withheld",
        }
    }
}
impl ::std::fmt::Debug for FamilyHistoryNotDoneReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FamilyHistoryNotDoneReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FamilyHistoryNotDoneReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FamilyHistoryNotDoneReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FamilyHistoryNotDoneReason> for Coding {
    fn from(code: FamilyHistoryNotDoneReason) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/history-not-done-reason".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FamilyHistoryNotDoneReason> for CodeableConcept {
    fn from(code: FamilyHistoryNotDoneReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FamilyHistoryStatus](http://hl7.org/fhir/ValueSet/history-status)**. A code that identifies the status of the family history record.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FamilyHistoryStatus {
    /** **completed**

Completed. All available related health information is captured as of the date (and possibly time) when the family member history was taken. */
    Completed,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **health-unknown**

Health unknown. Health information for this individual is unavailable/unknown. */
    HealthUnknown,
    /** **partial**

Partial. Some health information is known and captured, but not complete - see notes for details. */
    Partial,
}
impl ::core::str::FromStr for FamilyHistoryStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "health-unknown" => Ok(Self::HealthUnknown),
            "partial" => Ok(Self::Partial),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FamilyHistoryStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::HealthUnknown => "health-unknown",
            Self::Partial => "partial",
        }
    }
}
impl ::std::fmt::Debug for FamilyHistoryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FamilyHistoryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FamilyHistoryStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FamilyHistoryStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FamilyHistoryStatus> for Coding {
    fn from(code: FamilyHistoryStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/history-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FamilyHistoryStatus> for CodeableConcept {
    fn from(code: FamilyHistoryStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FilterOperator](http://hl7.org/fhir/ValueSet/filter-operator)**. The kind of operation to perform as a part of a property based filter.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FilterOperator {
    /** **=**

Equals. The specified property of the code equals the provided value. */
    Equal,
    /** **descendent-of**

Descendent Of (by subsumption). Includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, excluding the provided concept itself (i.e. include child codes) */
    DescendentOf,
    /** **exists**

Exists. The specified property of the code has at least one value (if the specified value is true; if the specified value is false, then matches when the specified property of the code has no values) */
    Exists,
    /** **generalizes**

Generalizes (by Subsumption). Includes all concept ids that have a transitive is-a relationship from the concept Id provided as the value, including the provided concept itself (e.g. include parent codes) */
    Generalizes,
    /** **in**

In Set. The specified property of the code is in the set of codes or concepts specified in the provided value (comma separated list). */
    In,
    /** **is-a**

Is A (by subsumption). Includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, including the provided concept itself (i.e. include child codes) */
    IsA,
    /** **is-not-a**

Not (Is A) (by subsumption). The specified property of the code does not have an is-a relationship with the provided value. */
    IsNotA,
    /** **not-in**

Not in Set. The specified property of the code is not in the set of codes or concepts specified in the provided value (comma separated list). */
    NotIn,
    /** **regex**

Regular Expression. The specified property of the code  matches the regex specified in the provided value. */
    Regex,
}
impl ::core::str::FromStr for FilterOperator {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "=" => Ok(Self::Equal),
            "descendent-of" => Ok(Self::DescendentOf),
            "exists" => Ok(Self::Exists),
            "generalizes" => Ok(Self::Generalizes),
            "in" => Ok(Self::In),
            "is-a" => Ok(Self::IsA),
            "is-not-a" => Ok(Self::IsNotA),
            "not-in" => Ok(Self::NotIn),
            "regex" => Ok(Self::Regex),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FilterOperator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equal => "=",
            Self::DescendentOf => "descendent-of",
            Self::Exists => "exists",
            Self::Generalizes => "generalizes",
            Self::In => "in",
            Self::IsA => "is-a",
            Self::IsNotA => "is-not-a",
            Self::NotIn => "not-in",
            Self::Regex => "regex",
        }
    }
}
impl ::std::fmt::Debug for FilterOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FilterOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FilterOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FilterOperator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FilterOperator> for Coding {
    fn from(code: FilterOperator) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/filter-operator".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FilterOperator> for CodeableConcept {
    fn from(code: FilterOperator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FlagStatus](http://hl7.org/fhir/ValueSet/flag-status)**. Indicates whether this flag is active and needs to be displayed to a user, or whether it is no longer needed or entered in error.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FlagStatus {
    /** **active**

Active. A current flag that should be displayed to a user. A system may use the category to determine which roles should view the flag. */
    Active,
    /** **entered-in-error**

Entered in Error. The flag was added in error, and should no longer be displayed. */
    EnteredInError,
    /** **inactive**

Inactive. The flag does not need to be displayed any more. */
    Inactive,
}
impl ::core::str::FromStr for FlagStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FlagStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Debug for FlagStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FlagStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FlagStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FlagStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FlagStatus> for Coding {
    fn from(code: FlagStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/flag-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FlagStatus> for CodeableConcept {
    fn from(code: FlagStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GenderStatus](http://hl7.org/fhir/ValueSet/animal-genderstatus)**. This example value set defines a set of codes that can be used to indicate the current state of the animal's reproductive organs.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GenderStatus {
    /** **intact**

Intact. The animal's reproductive organs are intact. */
    Intact,
    /** **neutered**

Neutered. The animal has been sterilized, castrated or otherwise made infertile. */
    Neutered,
    /** **unknown**

Unknown. Unable to determine whether the animal has been neutered. */
    Unknown,
}
impl ::core::str::FromStr for GenderStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "intact" => Ok(Self::Intact),
            "neutered" => Ok(Self::Neutered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GenderStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Intact => "intact",
            Self::Neutered => "neutered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for GenderStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GenderStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GenderStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenderStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GenderStatus> for Coding {
    fn from(code: GenderStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/animal-genderstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GenderStatus> for CodeableConcept {
    fn from(code: GenderStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalAcceptanceStatus](http://hl7.org/fhir/ValueSet/goal-acceptance-status)**. Codes indicating whether the goal has been accepted by a stakeholder\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GoalAcceptanceStatus {
    /** **agree**

Agree. Stakeholder supports pursuit of the goal */
    Agree,
    /** **disagree**

Disagree. Stakeholder is not in support of the pursuit of the goal */
    Disagree,
    /** **pending**

Pending. Stakeholder has not yet made a decision on whether they support the goal */
    Pending,
}
impl ::core::str::FromStr for GoalAcceptanceStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "agree" => Ok(Self::Agree),
            "disagree" => Ok(Self::Disagree),
            "pending" => Ok(Self::Pending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalAcceptanceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Agree => "agree",
            Self::Disagree => "disagree",
            Self::Pending => "pending",
        }
    }
}
impl ::std::fmt::Debug for GoalAcceptanceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalAcceptanceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalAcceptanceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalAcceptanceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalAcceptanceStatus> for Coding {
    fn from(code: GoalAcceptanceStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/goal-acceptance-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalAcceptanceStatus> for CodeableConcept {
    fn from(code: GoalAcceptanceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalCategory](http://hl7.org/fhir/ValueSet/goal-category)**. Example codes for grouping goals for filtering or presentation.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GoalCategory {
    /** **behavioral**

Behavioral. Goals related to the manner in which the subject acts. */
    Behavioral,
    /** **dietary**

Dietary. Goals related to the consumption of food and/or beverages. */
    Dietary,
    /** **nursing**

Nursing. Goals related to the practice of nursing or established by nurses. */
    Nursing,
    /** **physiotherapy**

Physiotherapy. Goals related to the mobility and motor capability of the subject. */
    Physiotherapy,
    /** **safety**

Safety. Goals related to the personal protection of the subject. */
    Safety,
}
impl ::core::str::FromStr for GoalCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "behavioral" => Ok(Self::Behavioral),
            "dietary" => Ok(Self::Dietary),
            "nursing" => Ok(Self::Nursing),
            "physiotherapy" => Ok(Self::Physiotherapy),
            "safety" => Ok(Self::Safety),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Behavioral => "behavioral",
            Self::Dietary => "dietary",
            Self::Nursing => "nursing",
            Self::Physiotherapy => "physiotherapy",
            Self::Safety => "safety",
        }
    }
}
impl ::std::fmt::Debug for GoalCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalCategory> for Coding {
    fn from(code: GoalCategory) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/goal-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalCategory> for CodeableConcept {
    fn from(code: GoalCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalPriority](http://hl7.org/fhir/ValueSet/goal-priority)**. Indicates the level of importance associated with reaching or sustaining a goal.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GoalPriority {
    /** **high-priority**

High Priority. Indicates that the goal is of considerable importance and should be a primary focus of care delivery. */
    HighPriority,
    /** **low-priority**

Low Priority. The goal is desirable but is not sufficiently important to devote significant resources to.  Achievement of the goal may be sought when incidental to achieving other goals. */
    LowPriority,
    /** **medium-priority**

Medium Priority. Indicates that the goal has a reasonable degree of importance and that concrete action should be taken towards the goal.  Attainment is not as critical as high-priority goals. */
    MediumPriority,
}
impl ::core::str::FromStr for GoalPriority {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high-priority" => Ok(Self::HighPriority),
            "low-priority" => Ok(Self::LowPriority),
            "medium-priority" => Ok(Self::MediumPriority),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalPriority {
    fn as_ref(&self) -> &str {
        match self {
            Self::HighPriority => "high-priority",
            Self::LowPriority => "low-priority",
            Self::MediumPriority => "medium-priority",
        }
    }
}
impl ::std::fmt::Debug for GoalPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalPriority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalPriority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalPriority> for Coding {
    fn from(code: GoalPriority) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/goal-priority".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalPriority> for CodeableConcept {
    fn from(code: GoalPriority) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalRelationshipType](http://hl7.org/fhir/ValueSet/goal-relationship-type)**. Types of relationships between two goals\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GoalRelationshipType {
    /** **milestone**

Milestone. Indicates that the target goal is considered to be a "piece" of attaining this goal. */
    Milestone,
    /** **other**

Other. Indicates that the relationship is not covered by one of the pre-defined codes.  (An extension may convey more information about the meaning of the relationship.) */
    Other,
    /** **predecessor**

Predecessor. Indicates that the target goal is one which must be met before striving for the current goal */
    Predecessor,
    /** **replacement**

Replacement. Indicates that this goal has been replaced by the target goal */
    Replacement,
    /** **successor**

Successor. Indicates that the target goal is a desired objective once the current goal is met */
    Successor,
}
impl ::core::str::FromStr for GoalRelationshipType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "milestone" => Ok(Self::Milestone),
            "other" => Ok(Self::Other),
            "predecessor" => Ok(Self::Predecessor),
            "replacement" => Ok(Self::Replacement),
            "successor" => Ok(Self::Successor),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Milestone => "milestone",
            Self::Other => "other",
            Self::Predecessor => "predecessor",
            Self::Replacement => "replacement",
            Self::Successor => "successor",
        }
    }
}
impl ::std::fmt::Debug for GoalRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalRelationshipType> for Coding {
    fn from(code: GoalRelationshipType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/goal-relationship-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalRelationshipType> for CodeableConcept {
    fn from(code: GoalRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalStatus](http://hl7.org/fhir/ValueSet/goal-status)**. Indicates whether the goal has been met and is still being targeted\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GoalStatus {
    /** **accepted**

Accepted. A proposed goal was accepted or acknowledged */
    Accepted,
    /** **achieved**

Achieved. The goal has been met and no further action is needed */
    Achieved,
    /** **ahead-of-target**

Ahead of Target. The goal is ahead of the planned timelines */
    AheadOfTarget,
    /** **behind-target**

Behind Target. The goal is behind the planned timelines */
    BehindTarget,
    /** **cancelled**

Cancelled. The previously accepted goal is no longer being sought */
    Cancelled,
    /** **entered-in-error**

Entered In Error. The goal was entered in error and voided. */
    EnteredInError,
    /** **in-progress**

In Progress. The goal is being sought but has not yet been reached.  (Also applies if goal was reached in the past but there has been regression and goal is being sought again) */
    InProgress,
    /** **on-hold**

On Hold. The goal remains a long term objective but is no longer being actively pursued for a temporary period of time. */
    OnHold,
    /** **on-target**

On Target. The goal is on schedule for the planned timelines */
    OnTarget,
    /** **planned**

Planned. A goal is planned for this patient */
    Planned,
    /** **proposed**

Proposed. A goal is proposed for this patient */
    Proposed,
    /** **rejected**

Rejected. A proposed goal was rejected */
    Rejected,
    /** **sustaining**

Sustaining. The goal has been met, but ongoing activity is needed to sustain the goal objective */
    Sustaining,
}
impl ::core::str::FromStr for GoalStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "achieved" => Ok(Self::Achieved),
            "ahead-of-target" => Ok(Self::AheadOfTarget),
            "behind-target" => Ok(Self::BehindTarget),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "on-target" => Ok(Self::OnTarget),
            "planned" => Ok(Self::Planned),
            "proposed" => Ok(Self::Proposed),
            "rejected" => Ok(Self::Rejected),
            "sustaining" => Ok(Self::Sustaining),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Achieved => "achieved",
            Self::AheadOfTarget => "ahead-of-target",
            Self::BehindTarget => "behind-target",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::OnTarget => "on-target",
            Self::Planned => "planned",
            Self::Proposed => "proposed",
            Self::Rejected => "rejected",
            Self::Sustaining => "sustaining",
        }
    }
}
impl ::std::fmt::Debug for GoalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalStatus> for Coding {
    fn from(code: GoalStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/goal-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalStatus> for CodeableConcept {
    fn from(code: GoalStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalStatusReason](http://hl7.org/fhir/ValueSet/goal-status-reason)**. Example codes indicating the reason for a current status.  Note that these are in no way complete and may not even be appropriate for some uses.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GoalStatusReason {
    /** **financial-barrier**

Financial Reason. Goal can not be reached due to financial barrier or reason. */
    FinancialBarrier,
    /** **lack-of-social-support**

Lack Of Social Support. Goal can not be reached due to a lack of social support. */
    LackOfSocialSupport,
    /** **lack-of-transportation**

Lack Of Transportation. Goal can not be reached due to a lack of transportation. */
    LackOfTransportation,
    /** **life-event**

Life Event. Goal suspended or ended because of a significant life event (marital change, bereavement, etc.). */
    LifeEvent,
    /** **patient-request**

Patient Request. Patient wishes the goal to be set aside, at least temporarily. */
    PatientRequest,
    /** **permanent-not-attainable**

Goal Not Attainable Permanently. Goal can not be reached permanently. */
    PermanentNotAttainable,
    /** **replaced**

Replaced. Goal has been superseded by a new goal. */
    Replaced,
    /** **surgery**

Surgery. Goal suspended or ended because of a surgical procedure. */
    Surgery,
    /** **temp-not-attainable**

Goal Not Attainable Temporarily. Goal can not be reached temporarily. */
    TempNotAttainable,
}
impl ::core::str::FromStr for GoalStatusReason {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "financial-barrier" => Ok(Self::FinancialBarrier),
            "lack-of-social-support" => Ok(Self::LackOfSocialSupport),
            "lack-of-transportation" => Ok(Self::LackOfTransportation),
            "life-event" => Ok(Self::LifeEvent),
            "patient-request" => Ok(Self::PatientRequest),
            "permanent-not-attainable" => Ok(Self::PermanentNotAttainable),
            "replaced" => Ok(Self::Replaced),
            "surgery" => Ok(Self::Surgery),
            "temp-not-attainable" => Ok(Self::TempNotAttainable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalStatusReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::FinancialBarrier => "financial-barrier",
            Self::LackOfSocialSupport => "lack-of-social-support",
            Self::LackOfTransportation => "lack-of-transportation",
            Self::LifeEvent => "life-event",
            Self::PatientRequest => "patient-request",
            Self::PermanentNotAttainable => "permanent-not-attainable",
            Self::Replaced => "replaced",
            Self::Surgery => "surgery",
            Self::TempNotAttainable => "temp-not-attainable",
        }
    }
}
impl ::std::fmt::Debug for GoalStatusReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalStatusReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalStatusReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalStatusReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalStatusReason> for Coding {
    fn from(code: GoalStatusReason) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/goal-status-reason".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalStatusReason> for CodeableConcept {
    fn from(code: GoalStatusReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GraphCompartmentRule](http://hl7.org/fhir/ValueSet/graph-compartment-rule)**. How a compartment must be linked\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GraphCompartmentRule {
    /** **custom**

Custom. The compartment rule is defined in the accompanying FHIRPath expression */
    Custom,
    /** **different**

Different. The compartment must be different */
    Different,
    /** **identical**

Identical. The compartment must be identical (the same literal reference) */
    Identical,
    /** **matching**

Matching. The compartment must be the same - the record must be about the same patient, but the reference may be different */
    Matching,
}
impl ::core::str::FromStr for GraphCompartmentRule {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "custom" => Ok(Self::Custom),
            "different" => Ok(Self::Different),
            "identical" => Ok(Self::Identical),
            "matching" => Ok(Self::Matching),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GraphCompartmentRule {
    fn as_ref(&self) -> &str {
        match self {
            Self::Custom => "custom",
            Self::Different => "different",
            Self::Identical => "identical",
            Self::Matching => "matching",
        }
    }
}
impl ::std::fmt::Debug for GraphCompartmentRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GraphCompartmentRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GraphCompartmentRule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GraphCompartmentRule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GraphCompartmentRule> for Coding {
    fn from(code: GraphCompartmentRule) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/graph-compartment-rule".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GraphCompartmentRule> for CodeableConcept {
    fn from(code: GraphCompartmentRule) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GroupType](http://hl7.org/fhir/ValueSet/group-type)**. Types of resources that are part of group\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GroupType {
    /** **animal**

Animal. Group contains "animal" Patient resources */
    Animal,
    /** **device**

Device. Group contains Device resources */
    Device,
    /** **medication**

Medication. Group contains Medication resources */
    Medication,
    /** **person**

Person. Group contains "person" Patient resources */
    Person,
    /** **practitioner**

Practitioner. Group contains healthcare practitioner resources */
    Practitioner,
    /** **substance**

Substance. Group contains Substance resources */
    Substance,
}
impl ::core::str::FromStr for GroupType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "animal" => Ok(Self::Animal),
            "device" => Ok(Self::Device),
            "medication" => Ok(Self::Medication),
            "person" => Ok(Self::Person),
            "practitioner" => Ok(Self::Practitioner),
            "substance" => Ok(Self::Substance),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GroupType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "animal",
            Self::Device => "device",
            Self::Medication => "medication",
            Self::Person => "person",
            Self::Practitioner => "practitioner",
            Self::Substance => "substance",
        }
    }
}
impl ::std::fmt::Debug for GroupType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GroupType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GroupType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GroupType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GroupType> for Coding {
    fn from(code: GroupType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/group-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GroupType> for CodeableConcept {
    fn from(code: GroupType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GuidanceResponseStatus](http://hl7.org/fhir/ValueSet/guidance-response-status)**. The status of a guidance response\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GuidanceResponseStatus {
    /** **data-requested**

Data Requested. The request was processed successfully, but more data may result in a more complete evaluation */
    DataRequested,
    /** **data-required**

Data Required. The request was processed, but more data is required to complete the evaluation */
    DataRequired,
    /** **entered-in-error**

Entered In Error. The response was entered in error */
    EnteredInError,
    /** **failure**

Failure. The request was not processed successfully */
    Failure,
    /** **in-progress**

In Progress. The request is currently being processed */
    InProgress,
    /** **success**

Success. The request was processed successfully */
    Success,
}
impl ::core::str::FromStr for GuidanceResponseStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-requested" => Ok(Self::DataRequested),
            "data-required" => Ok(Self::DataRequired),
            "entered-in-error" => Ok(Self::EnteredInError),
            "failure" => Ok(Self::Failure),
            "in-progress" => Ok(Self::InProgress),
            "success" => Ok(Self::Success),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuidanceResponseStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataRequested => "data-requested",
            Self::DataRequired => "data-required",
            Self::EnteredInError => "entered-in-error",
            Self::Failure => "failure",
            Self::InProgress => "in-progress",
            Self::Success => "success",
        }
    }
}
impl ::std::fmt::Debug for GuidanceResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GuidanceResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GuidanceResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuidanceResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuidanceResponseStatus> for Coding {
    fn from(code: GuidanceResponseStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/guidance-response-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GuidanceResponseStatus> for CodeableConcept {
    fn from(code: GuidanceResponseStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GuideDependencyType](http://hl7.org/fhir/ValueSet/guide-dependency-type)**. How a dependency is represented when the guide is published.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GuideDependencyType {
    /** **inclusion**

Inclusion. The guide is embedded in this guide when published. */
    Inclusion,
    /** **reference**

Reference. The guide is referred to by URL. */
    Reference,
}
impl ::core::str::FromStr for GuideDependencyType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "inclusion" => Ok(Self::Inclusion),
            "reference" => Ok(Self::Reference),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuideDependencyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Inclusion => "inclusion",
            Self::Reference => "reference",
        }
    }
}
impl ::std::fmt::Debug for GuideDependencyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GuideDependencyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GuideDependencyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuideDependencyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuideDependencyType> for Coding {
    fn from(code: GuideDependencyType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/guide-dependency-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GuideDependencyType> for CodeableConcept {
    fn from(code: GuideDependencyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GuidePageKind](http://hl7.org/fhir/ValueSet/guide-page-kind)**. The kind of an included page.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GuidePageKind {
    /** **dictionary**

Dictionary. This is a page that creates the listed resources as a dictionary. */
    Dictionary,
    /** **directory**

Directory. This is a page that lists the resources of a given type, and also creates pages for all the listed types as other pages in the section. */
    Directory,
    /** **example**

Example. This is a page that represents a human readable rendering of an example. */
    Example,
    /** **include**

Include. This is a page showing where an included guide is injected. */
    Include,
    /** **list**

List. This is a page that represents a list of resources of one or more types. */
    List,
    /** **page**

Page. This is a page of content that is included in the implementation guide. It has no particular function. */
    Page,
    /** **resource**

Resource. This is a page that represents a presented resource. This is typically used for generated conformance resource presentations. */
    Resource,
    /** **toc**

Table Of Contents. This is a generated page that contains the table of contents. */
    Toc,
}
impl ::core::str::FromStr for GuidePageKind {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "dictionary" => Ok(Self::Dictionary),
            "directory" => Ok(Self::Directory),
            "example" => Ok(Self::Example),
            "include" => Ok(Self::Include),
            "list" => Ok(Self::List),
            "page" => Ok(Self::Page),
            "resource" => Ok(Self::Resource),
            "toc" => Ok(Self::Toc),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuidePageKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Dictionary => "dictionary",
            Self::Directory => "directory",
            Self::Example => "example",
            Self::Include => "include",
            Self::List => "list",
            Self::Page => "page",
            Self::Resource => "resource",
            Self::Toc => "toc",
        }
    }
}
impl ::std::fmt::Debug for GuidePageKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GuidePageKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GuidePageKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuidePageKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuidePageKind> for Coding {
    fn from(code: GuidePageKind) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/guide-page-kind".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GuidePageKind> for CodeableConcept {
    fn from(code: GuidePageKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[HL7Workgroup](http://hl7.org/fhir/ValueSet/hl7-work-group)**. An HL7 administrative unit that owns artifacts in the FHIR specification\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum HL7Workgroup {
    /** **aid**

Application Implementation and Design. Application Implementation and Design (http://www.hl7.org/Special/committees/java/index.cfm) */
    Aid,
    /** **cbcc**

Community Based Collaborative Care. Community Based Collaborative Care (http://www.hl7.org/Special/committees/cbcc/index.cfm) */
    Cbcc,
    /** **cds**

Clinical Decision Support. Clinical Decision Support (http://www.hl7.org/Special/committees/dss/index.cfm) */
    Cds,
    /** **cg**

Clinical Genomics. Clinical Genomics (http://www.hl7.org/Special/committees/clingenomics/index.cfm) */
    Cg,
    /** **cqi**

Clinical Quality Information. Clinical Quality Information (http://www.hl7.org/Special/committees/cqi/index.cfm) */
    Cqi,
    /** **dev**

Health Care Devices. Health Care Devices (http://www.hl7.org/Special/committees/healthcaredevices/index.cfm) */
    Dev,
    /** **ehr**

Electronic Health Records. Electronic Health Records (http://www.hl7.org/special/committees/ehr/index.cfm) */
    Ehr,
    /** **fhir**

FHIR Infrastructure. FHIR Infrastructure (http://www.hl7.org/Special/committees/fiwg/index.cfm) */
    Fhir,
    /** **fm**

Financial Management. Financial Management (http://www.hl7.org/Special/committees/fm/index.cfm) */
    Fm,
    /** **hsi**

Health Standards Integration. Health Standards Integration (http://www.hl7.org/Special/committees/hsi/index.cfm) */
    Hsi,
    /** **ii**

Imaging Integration. Imaging Integration (http://www.hl7.org/Special/committees/imagemgt/index.cfm) */
    Ii,
    /** **inm**

Infrastructure And Messaging. Infrastructure And Messaging (http://www.hl7.org/special/committees/inm/index.cfm) */
    Inm,
    /** **its**

Implementable Technology Specifications. Implementable Technology Specifications (http://www.hl7.org/special/committees/xml/index.cfm) */
    Its,
    /** **oo**

Orders and Observations. Orders and Observations (http://www.hl7.org/Special/committees/orders/index.cfm) */
    Oo,
    /** **pa**

Patient Administration. Patient Administration (http://www.hl7.org/Special/committees/pafm/index.cfm) */
    Pa,
    /** **pc**

Patient Care. Patient Care (http://www.hl7.org/Special/committees/patientcare/index.cfm) */
    Pc,
    /** **pher**

Public Health and Emergency Response. Public Health and Emergency Response (http://www.hl7.org/Special/committees/pher/index.cfm) */
    Pher,
    /** **phx**

Pharmacy. Pharmacy (http://www.hl7.org/Special/committees/medication/index.cfm) */
    Phx,
    /** **rcrim**

Regulated Clinical Research Information Management. Regulated Clinical Research Information Management (http://www.hl7.org/Special/committees/rcrim/index.cfm) */
    Rcrim,
    /** **sd**

Structured Documents. Structured Documents (http://www.hl7.org/Special/committees/structure/index.cfm) */
    Sd,
    /** **sec**

Security. Security (http://www.hl7.org/Special/committees/secure/index.cfm) */
    Sec,
    /** **us**

US Realm Taskforce. US Realm Taskforce (http://wiki.hl7.org/index.php?title=US_Realm_Task_Force) */
    Us,
    /** **vocab**

Vocabulary. Vocabulary (http://www.hl7.org/Special/committees/Vocab/index.cfm) */
    Vocab,
}
impl ::core::str::FromStr for HL7Workgroup {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aid" => Ok(Self::Aid),
            "cbcc" => Ok(Self::Cbcc),
            "cds" => Ok(Self::Cds),
            "cg" => Ok(Self::Cg),
            "cqi" => Ok(Self::Cqi),
            "dev" => Ok(Self::Dev),
            "ehr" => Ok(Self::Ehr),
            "fhir" => Ok(Self::Fhir),
            "fm" => Ok(Self::Fm),
            "hsi" => Ok(Self::Hsi),
            "ii" => Ok(Self::Ii),
            "inm" => Ok(Self::Inm),
            "its" => Ok(Self::Its),
            "oo" => Ok(Self::Oo),
            "pa" => Ok(Self::Pa),
            "pc" => Ok(Self::Pc),
            "pher" => Ok(Self::Pher),
            "phx" => Ok(Self::Phx),
            "rcrim" => Ok(Self::Rcrim),
            "sd" => Ok(Self::Sd),
            "sec" => Ok(Self::Sec),
            "us" => Ok(Self::Us),
            "vocab" => Ok(Self::Vocab),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for HL7Workgroup {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aid => "aid",
            Self::Cbcc => "cbcc",
            Self::Cds => "cds",
            Self::Cg => "cg",
            Self::Cqi => "cqi",
            Self::Dev => "dev",
            Self::Ehr => "ehr",
            Self::Fhir => "fhir",
            Self::Fm => "fm",
            Self::Hsi => "hsi",
            Self::Ii => "ii",
            Self::Inm => "inm",
            Self::Its => "its",
            Self::Oo => "oo",
            Self::Pa => "pa",
            Self::Pc => "pc",
            Self::Pher => "pher",
            Self::Phx => "phx",
            Self::Rcrim => "rcrim",
            Self::Sd => "sd",
            Self::Sec => "sec",
            Self::Us => "us",
            Self::Vocab => "vocab",
        }
    }
}
impl ::std::fmt::Debug for HL7Workgroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for HL7Workgroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for HL7Workgroup {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for HL7Workgroup {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<HL7Workgroup> for Coding {
    fn from(code: HL7Workgroup) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/hl7-work-group".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<HL7Workgroup> for CodeableConcept {
    fn from(code: HL7Workgroup) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[HTTPVerb](http://hl7.org/fhir/ValueSet/http-verb)**. HTTP verbs (in the HTTP command line).\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum HTTPVerb {
    /** **DELETE**

DELETE. HTTP DELETE */
    Delete,
    /** **GET**

GET. HTTP GET */
    Get,
    /** **POST**

POST. HTTP POST */
    Post,
    /** **PUT**

PUT. HTTP PUT */
    Put,
}
impl ::core::str::FromStr for HTTPVerb {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "DELETE" => Ok(Self::Delete),
            "GET" => Ok(Self::Get),
            "POST" => Ok(Self::Post),
            "PUT" => Ok(Self::Put),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for HTTPVerb {
    fn as_ref(&self) -> &str {
        match self {
            Self::Delete => "DELETE",
            Self::Get => "GET",
            Self::Post => "POST",
            Self::Put => "PUT",
        }
    }
}
impl ::std::fmt::Debug for HTTPVerb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for HTTPVerb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for HTTPVerb {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for HTTPVerb {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<HTTPVerb> for Coding {
    fn from(code: HTTPVerb) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/http-verb".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<HTTPVerb> for CodeableConcept {
    fn from(code: HTTPVerb) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[HumanNameAssemblyOrder](http://hl7.org/fhir/ValueSet/name-assembly-order)**. A code that represents the preferred display order of the components of a human name\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum HumanNameAssemblyOrder {
    /** **NL1**

Own Name. */
    Nl1,
    /** **NL2**

Partner Name. */
    Nl2,
    /** **NL3**

Partner Name followed by Maiden Name. */
    Nl3,
    /** **NL4**

Own Name followed by Partner Name. */
    Nl4,
}
impl ::core::str::FromStr for HumanNameAssemblyOrder {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "NL1" => Ok(Self::Nl1),
            "NL2" => Ok(Self::Nl2),
            "NL3" => Ok(Self::Nl3),
            "NL4" => Ok(Self::Nl4),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for HumanNameAssemblyOrder {
    fn as_ref(&self) -> &str {
        match self {
            Self::Nl1 => "NL1",
            Self::Nl2 => "NL2",
            Self::Nl3 => "NL3",
            Self::Nl4 => "NL4",
        }
    }
}
impl ::std::fmt::Debug for HumanNameAssemblyOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for HumanNameAssemblyOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for HumanNameAssemblyOrder {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for HumanNameAssemblyOrder {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<HumanNameAssemblyOrder> for Coding {
    fn from(code: HumanNameAssemblyOrder) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/name-assembly-order".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<HumanNameAssemblyOrder> for CodeableConcept {
    fn from(code: HumanNameAssemblyOrder) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IdentifierUse](http://hl7.org/fhir/ValueSet/identifier-use)**. Identifies the purpose for this identifier, if known .\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IdentifierUse {
    /** **official**

Official. The identifier considered to be most trusted for the identification of this item. */
    Official,
    /** **secondary**

Secondary. An identifier that was assigned in secondary use - it serves to identify the object in a relative context, but cannot be consistently assigned to the same object again in a different context. */
    Secondary,
    /** **temp**

Temp. A temporary identifier. */
    Temp,
    /** **usual**

Usual. The identifier recommended for display and use in real-world interactions. */
    Usual,
}
impl ::core::str::FromStr for IdentifierUse {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "official" => Ok(Self::Official),
            "secondary" => Ok(Self::Secondary),
            "temp" => Ok(Self::Temp),
            "usual" => Ok(Self::Usual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IdentifierUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Official => "official",
            Self::Secondary => "secondary",
            Self::Temp => "temp",
            Self::Usual => "usual",
        }
    }
}
impl ::std::fmt::Debug for IdentifierUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IdentifierUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IdentifierUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IdentifierUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IdentifierUse> for Coding {
    fn from(code: IdentifierUse) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/identifier-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IdentifierUse> for CodeableConcept {
    fn from(code: IdentifierUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IdentityAssuranceLevel](http://hl7.org/fhir/ValueSet/identity-assuranceLevel)**. The level of confidence that this link represents the same actual person, based on NIST Authentication Levels.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IdentityAssuranceLevel {
    /** **level1**

Level 1. Little or no confidence in the asserted identity's accuracy. */
    Level1,
    /** **level2**

Level 2. Some confidence in the asserted identity's accuracy. */
    Level2,
    /** **level3**

Level 3. High confidence in the asserted identity's accuracy. */
    Level3,
    /** **level4**

Level 4. Very high confidence in the asserted identity's accuracy. */
    Level4,
}
impl ::core::str::FromStr for IdentityAssuranceLevel {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "level1" => Ok(Self::Level1),
            "level2" => Ok(Self::Level2),
            "level3" => Ok(Self::Level3),
            "level4" => Ok(Self::Level4),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IdentityAssuranceLevel {
    fn as_ref(&self) -> &str {
        match self {
            Self::Level1 => "level1",
            Self::Level2 => "level2",
            Self::Level3 => "level3",
            Self::Level4 => "level4",
        }
    }
}
impl ::std::fmt::Debug for IdentityAssuranceLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IdentityAssuranceLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IdentityAssuranceLevel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IdentityAssuranceLevel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IdentityAssuranceLevel> for Coding {
    fn from(code: IdentityAssuranceLevel) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/identity-assuranceLevel".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IdentityAssuranceLevel> for CodeableConcept {
    fn from(code: IdentityAssuranceLevel) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IssueSeverity](http://hl7.org/fhir/ValueSet/issue-severity)**. How the issue affects the success of the action.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IssueSeverity {
    /** **error**

Error. The issue is sufficiently important to cause the action to fail. */
    Error,
    /** **fatal**

Fatal. The issue caused the action to fail, and no further checking could be performed. */
    Fatal,
    /** **information**

Information. The issue has no relation to the degree of success of the action. */
    Information,
    /** **warning**

Warning. The issue is not important enough to cause the action to fail, but may cause it to be performed suboptimally or in a way that is not as desired. */
    Warning,
}
impl ::core::str::FromStr for IssueSeverity {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "fatal" => Ok(Self::Fatal),
            "information" => Ok(Self::Information),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IssueSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Fatal => "fatal",
            Self::Information => "information",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Debug for IssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IssueSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IssueSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IssueSeverity> for Coding {
    fn from(code: IssueSeverity) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/issue-severity".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IssueSeverity> for CodeableConcept {
    fn from(code: IssueSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IssueType](http://hl7.org/fhir/ValueSet/issue-type)**. A code that describes the type of issue.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IssueType {
    /** **business-rule**

Business Rule Violation. The content/operation failed to pass some business rule, and so could not proceed. */
    BusinessRule,
    /** **code-invalid**

Invalid Code. The code or system could not be understood, or it was not valid in the context of a particular ValueSet.code. */
    CodeInvalid,
    /** **conflict**

Edit Version Conflict. Content could not be accepted because of an edit conflict (i.e. version aware updates) (In a pure RESTful environment, this would be an HTTP 404 error, but this code may be used where the conflict is discovered further into the application architecture.) */
    Conflict,
    /** **duplicate**

Duplicate. An attempt was made to create a duplicate record. */
    Duplicate,
    /** **exception**

Exception. An unexpected internal error has occurred. */
    Exception,
    /** **expired**

Session Expired. User session expired; a login may be required. */
    Expired,
    /** **extension**

Unacceptable Extension. An extension was found that was not acceptable, could not be resolved, or a modifierExtension was not recognized. */
    Extension,
    /** **forbidden**

Forbidden. The user does not have the rights to perform this action. */
    Forbidden,
    /** **incomplete**

Incomplete Results. Not all data sources typically accessed could be reached, or responded in time, so the returned information may not be complete. */
    Incomplete,
    /** **informational**

Informational Note. A message unrelated to the processing success of the completed operation (examples of the latter include things like reminders of password expiry, system maintenance times, etc.). */
    Informational,
    /** **invalid**

Invalid Content. Content invalid against the specification or a profile. */
    Invalid,
    /** **invariant**

Validation rule failed. A content validation rule failed - e.g. a schematron rule. */
    Invariant,
    /** **lock-error**

Lock Error. A resource/record locking failure (usually in an underlying database). */
    LockError,
    /** **login**

Login Required. The client needs to initiate an authentication process. */
    Login,
    /** **no-store**

No Store Available. The persistent store is unavailable; e.g. the database is down for maintenance or similar action. */
    NoStore,
    /** **not-found**

Not Found. The reference provided was not found. In a pure RESTful environment, this would be an HTTP 404 error, but this code may be used where the content is not found further into the application architecture. */
    NotFound,
    /** **not-supported**

Content not supported. The resource or profile is not supported. */
    NotSupported,
    /** **processing**

Processing Failure. Processing issues. These are expected to be final e.g. there is no point resubmitting the same content unchanged. */
    Processing,
    /** **required**

Required element missing. A required element is missing. */
    Required,
    /** **security**

Security Problem. An authentication/authorization/permissions issue of some kind. */
    Security,
    /** **structure**

Structural Issue. A structural issue in the content such as wrong namespace, or unable to parse the content completely, or invalid json syntax. */
    Structure,
    /** **suppressed**

Information  Suppressed. Some information was not or may not have been returned due to business rules, consent or privacy rules, or access permission constraints.  This information may be accessible through alternate processes. */
    Suppressed,
    /** **throttled**

Throttled. The system is not prepared to handle this request due to load management. */
    Throttled,
    /** **timeout**

Timeout. An internal timeout has occurred. */
    Timeout,
    /** **too-costly**

Operation Too Costly. The operation was stopped to protect server resources; e.g. a request for a value set expansion on all of SNOMED CT. */
    TooCostly,
    /** **too-long**

Content Too Long. Provided content is too long (typically, this is a denial of service protection type of error). */
    TooLong,
    /** **transient**

Transient Issue. Transient processing issues. The system receiving the error may be able to resubmit the same content once an underlying issue is resolved. */
    Transient,
    /** **unknown**

Unknown User. The user or system was not able to be authenticated (either there is no process, or the proferred token is unacceptable). */
    Unknown,
    /** **value**

Element value invalid. An element value is invalid. */
    Value,
}
impl ::core::str::FromStr for IssueType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "business-rule" => Ok(Self::BusinessRule),
            "code-invalid" => Ok(Self::CodeInvalid),
            "conflict" => Ok(Self::Conflict),
            "duplicate" => Ok(Self::Duplicate),
            "exception" => Ok(Self::Exception),
            "expired" => Ok(Self::Expired),
            "extension" => Ok(Self::Extension),
            "forbidden" => Ok(Self::Forbidden),
            "incomplete" => Ok(Self::Incomplete),
            "informational" => Ok(Self::Informational),
            "invalid" => Ok(Self::Invalid),
            "invariant" => Ok(Self::Invariant),
            "lock-error" => Ok(Self::LockError),
            "login" => Ok(Self::Login),
            "no-store" => Ok(Self::NoStore),
            "not-found" => Ok(Self::NotFound),
            "not-supported" => Ok(Self::NotSupported),
            "processing" => Ok(Self::Processing),
            "required" => Ok(Self::Required),
            "security" => Ok(Self::Security),
            "structure" => Ok(Self::Structure),
            "suppressed" => Ok(Self::Suppressed),
            "throttled" => Ok(Self::Throttled),
            "timeout" => Ok(Self::Timeout),
            "too-costly" => Ok(Self::TooCostly),
            "too-long" => Ok(Self::TooLong),
            "transient" => Ok(Self::Transient),
            "unknown" => Ok(Self::Unknown),
            "value" => Ok(Self::Value),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IssueType {
    fn as_ref(&self) -> &str {
        match self {
            Self::BusinessRule => "business-rule",
            Self::CodeInvalid => "code-invalid",
            Self::Conflict => "conflict",
            Self::Duplicate => "duplicate",
            Self::Exception => "exception",
            Self::Expired => "expired",
            Self::Extension => "extension",
            Self::Forbidden => "forbidden",
            Self::Incomplete => "incomplete",
            Self::Informational => "informational",
            Self::Invalid => "invalid",
            Self::Invariant => "invariant",
            Self::LockError => "lock-error",
            Self::Login => "login",
            Self::NoStore => "no-store",
            Self::NotFound => "not-found",
            Self::NotSupported => "not-supported",
            Self::Processing => "processing",
            Self::Required => "required",
            Self::Security => "security",
            Self::Structure => "structure",
            Self::Suppressed => "suppressed",
            Self::Throttled => "throttled",
            Self::Timeout => "timeout",
            Self::TooCostly => "too-costly",
            Self::TooLong => "too-long",
            Self::Transient => "transient",
            Self::Unknown => "unknown",
            Self::Value => "value",
        }
    }
}
impl ::std::fmt::Debug for IssueType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IssueType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IssueType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IssueType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IssueType> for Coding {
    fn from(code: IssueType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/issue-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IssueType> for CodeableConcept {
    fn from(code: IssueType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LibraryType](http://hl7.org/fhir/ValueSet/library-type)**. The type of knowledge asset this library contains\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LibraryType {
    /** **asset-collection**

Asset Collection. The resource is a collection of knowledge assets */
    AssetCollection,
    /** **logic-library**

Logic Library. The resource is a shareable library of formalized knowledge */
    LogicLibrary,
    /** **model-definition**

Model Definition. The resource is a definition of an information model */
    ModelDefinition,
    /** **module-definition**

Module Definition. The resource defines the dependencies, parameters, and data requirements for a particular module or evaluation context */
    ModuleDefinition,
}
impl ::core::str::FromStr for LibraryType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "asset-collection" => Ok(Self::AssetCollection),
            "logic-library" => Ok(Self::LogicLibrary),
            "model-definition" => Ok(Self::ModelDefinition),
            "module-definition" => Ok(Self::ModuleDefinition),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LibraryType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AssetCollection => "asset-collection",
            Self::LogicLibrary => "logic-library",
            Self::ModelDefinition => "model-definition",
            Self::ModuleDefinition => "module-definition",
        }
    }
}
impl ::std::fmt::Debug for LibraryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LibraryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LibraryType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LibraryType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LibraryType> for Coding {
    fn from(code: LibraryType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/library-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LibraryType> for CodeableConcept {
    fn from(code: LibraryType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LinkType](http://hl7.org/fhir/ValueSet/link-type)**. The type of link between this patient resource and another patient resource.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LinkType {
    /** **refer**

Refer. The patient resource containing this link is in use and valid but not considered the main source of information about a patient. The link points forward to another patient resource that should be consulted to retrieve additional patient information. */
    Refer,
    /** **replaced-by**

Replaced-by. The patient resource containing this link must no longer be used. The link points forward to another patient resource that must be used in lieu of the patient resource that contains this link. */
    ReplacedBy,
    /** **replaces**

Replaces. The patient resource containing this link is the current active patient record. The link points back to an inactive patient resource that has been merged into this resource, and should be consulted to retrieve additional referenced information. */
    Replaces,
    /** **seealso**

See also. The patient resource containing this link is in use and valid, but points to another patient resource that is known to contain data about the same person. Data in this resource might overlap or contradict information found in the other patient resource. This link does not indicate any relative importance of the resources concerned, and both should be regarded as equally valid. */
    Seealso,
}
impl ::core::str::FromStr for LinkType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "refer" => Ok(Self::Refer),
            "replaced-by" => Ok(Self::ReplacedBy),
            "replaces" => Ok(Self::Replaces),
            "seealso" => Ok(Self::Seealso),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LinkType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Refer => "refer",
            Self::ReplacedBy => "replaced-by",
            Self::Replaces => "replaces",
            Self::Seealso => "seealso",
        }
    }
}
impl ::std::fmt::Debug for LinkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LinkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LinkType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LinkType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LinkType> for Coding {
    fn from(code: LinkType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/link-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LinkType> for CodeableConcept {
    fn from(code: LinkType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LinkageType](http://hl7.org/fhir/ValueSet/linkage-type)**. Used to distinguish different roles a resource can play within a set of linked resources\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LinkageType {
    /** **alternate**

Alternate record. The record represents the alternative view of the underlying event/condition/etc.  The record may still be actively maintained, even though it is not considered to be the source of truth. */
    Alternate,
    /** **historical**

Historical/obsolete record. The record represents an obsolete record of the underlyng event/condition/etc.  It is not expected to be actively maintained. */
    Historical,
    /** **source**

Source of truth. The record represents the "source of truth" (from the perspective of this Linkage resource) for the underlying event/condition/etc. */
    Source,
}
impl ::core::str::FromStr for LinkageType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alternate" => Ok(Self::Alternate),
            "historical" => Ok(Self::Historical),
            "source" => Ok(Self::Source),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LinkageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alternate => "alternate",
            Self::Historical => "historical",
            Self::Source => "source",
        }
    }
}
impl ::std::fmt::Debug for LinkageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LinkageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LinkageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LinkageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LinkageType> for Coding {
    fn from(code: LinkageType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/linkage-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LinkageType> for CodeableConcept {
    fn from(code: LinkageType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ListMode](http://hl7.org/fhir/ValueSet/list-mode)**. The processing mode that applies to this list\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ListMode {
    /** **changes**

Change List. A list that indicates where changes have been made or recommended */
    Changes,
    /** **snapshot**

Snapshot List. This list was prepared as a snapshot. It should not be assumed to be current */
    Snapshot,
    /** **working**

Working List. This list is the master list, maintained in an ongoing fashion with regular updates as the real world list it is tracking changes */
    Working,
}
impl ::core::str::FromStr for ListMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "changes" => Ok(Self::Changes),
            "snapshot" => Ok(Self::Snapshot),
            "working" => Ok(Self::Working),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Changes => "changes",
            Self::Snapshot => "snapshot",
            Self::Working => "working",
        }
    }
}
impl ::std::fmt::Debug for ListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ListMode> for Coding {
    fn from(code: ListMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/list-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ListMode> for CodeableConcept {
    fn from(code: ListMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ListStatus](http://hl7.org/fhir/ValueSet/list-status)**. The current state of the list\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ListStatus {
    /** **current**

Current. The list is considered to be an active part of the patient's record. */
    Current,
    /** **entered-in-error**

Entered In Error. The list was never accurate.  It is retained for medico-legal purposes only. */
    EnteredInError,
    /** **retired**

Retired. The list is "old" and should no longer be considered accurate or relevant. */
    Retired,
}
impl ::core::str::FromStr for ListStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "current" => Ok(Self::Current),
            "entered-in-error" => Ok(Self::EnteredInError),
            "retired" => Ok(Self::Retired),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ListStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Current => "current",
            Self::EnteredInError => "entered-in-error",
            Self::Retired => "retired",
        }
    }
}
impl ::std::fmt::Debug for ListStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ListStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ListStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ListStatus> for Coding {
    fn from(code: ListStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/list-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ListStatus> for CodeableConcept {
    fn from(code: ListStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LocationMode](http://hl7.org/fhir/ValueSet/location-mode)**. Indicates whether a resource instance represents a specific location or a class of locations.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LocationMode {
    /** **instance**

Instance. The Location resource represents a specific instance of a location (e.g. Operating Theatre 1A). */
    Instance,
    /** **kind**

Kind. The Location represents a class of locations (e.g. Any Operating Theatre) although this class of locations could be constrained within a specific boundary (such as organization, or parent location, address etc.). */
    Kind,
}
impl ::core::str::FromStr for LocationMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "instance" => Ok(Self::Instance),
            "kind" => Ok(Self::Kind),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Instance => "instance",
            Self::Kind => "kind",
        }
    }
}
impl ::std::fmt::Debug for LocationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LocationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LocationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LocationMode> for Coding {
    fn from(code: LocationMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/location-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LocationMode> for CodeableConcept {
    fn from(code: LocationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LocationStatus](http://hl7.org/fhir/ValueSet/location-status)**. Indicates whether the location is still in use.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LocationStatus {
    /** **active**

Active. The location is operational. */
    Active,
    /** **inactive**

Inactive. The location is no longer used. */
    Inactive,
    /** **suspended**

Suspended. The location is temporarily closed. */
    Suspended,
}
impl ::core::str::FromStr for LocationStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Suspended => "suspended",
        }
    }
}
impl ::std::fmt::Debug for LocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LocationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LocationStatus> for Coding {
    fn from(code: LocationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/location-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LocationStatus> for CodeableConcept {
    fn from(code: LocationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LocationType](http://hl7.org/fhir/ValueSet/location-physical-type)**. This example value set defines a set of codes that can be used to indicate the physical form of the Location.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LocationType {
    /** **area**

Area. A defined physical boundary of something, such as a flood risk zone, region, postcode */
    Area,
    /** **bd**

Bed. A space that is allocated for sleeping/laying on. This is not the physical bed/trolley that may be moved about, but the space it may occupy. */
    Bd,
    /** **bu**

Building. Any Building or structure. This may contain rooms, corridors, wings, etc. It may not have walls, or a roof, but is considered a defined/allocated space. */
    Bu,
    /** **ca**

Cabinet. A container that can store goods, equipment, medications or other items. */
    Ca,
    /** **co**

Corridor. Any corridor within a Building, that may connect rooms. */
    Co,
    /** **ho**

House. A residential dwelling. Usually used to reference a location that a person/patient may reside. */
    Ho,
    /** **jdn**

Jurisdiction. A wide scope that covers a conceptual domain, such as a Nation (Country wide community or Federal Government - e.g. Ministry of Health),  Province or State (community or Government), Business (throughout the enterprise), Nation with a business scope of an agency (e.g. CDC, FDA etc.) or a Business segment (UK Pharmacy), not just an physical boundry */
    Jdn,
    /** **lvl**

Level. A Level in a multi-level Building/Structure. */
    Lvl,
    /** **rd**

Road. A defined path to travel between 2 points that has a known name. */
    Rd,
    /** **ro**

Room. A space that is allocated as a room, it may have walls/roof etc., but does not require these. */
    Ro,
    /** **si**

Site. A collection of buildings or other locations such as a site or a campus. */
    Si,
    /** **ve**

Vehicle. A means of transportation. */
    Ve,
    /** **wa**

Ward. A Ward is a section of a medical facility that may contain rooms and other types of location. */
    Wa,
    /** **wi**

Wing. A Wing within a Building, this often contains levels, rooms and corridors. */
    Wi,
}
impl ::core::str::FromStr for LocationType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "area" => Ok(Self::Area),
            "bd" => Ok(Self::Bd),
            "bu" => Ok(Self::Bu),
            "ca" => Ok(Self::Ca),
            "co" => Ok(Self::Co),
            "ho" => Ok(Self::Ho),
            "jdn" => Ok(Self::Jdn),
            "lvl" => Ok(Self::Lvl),
            "rd" => Ok(Self::Rd),
            "ro" => Ok(Self::Ro),
            "si" => Ok(Self::Si),
            "ve" => Ok(Self::Ve),
            "wa" => Ok(Self::Wa),
            "wi" => Ok(Self::Wi),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Area => "area",
            Self::Bd => "bd",
            Self::Bu => "bu",
            Self::Ca => "ca",
            Self::Co => "co",
            Self::Ho => "ho",
            Self::Jdn => "jdn",
            Self::Lvl => "lvl",
            Self::Rd => "rd",
            Self::Ro => "ro",
            Self::Si => "si",
            Self::Ve => "ve",
            Self::Wa => "wa",
            Self::Wi => "wi",
        }
    }
}
impl ::std::fmt::Debug for LocationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LocationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LocationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LocationType> for Coding {
    fn from(code: LocationType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/location-physical-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LocationType> for CodeableConcept {
    fn from(code: LocationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MatchGrade](http://hl7.org/fhir/ValueSet/match-grade)**. A Master Patient Index (MPI) assessment of whether a candidate patient record is a match or not.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MatchGrade {
    /** **certain**

Certain Match. This record meets the matching criteria to be automatically considered as a full match. */
    Certain,
    /** **certainly-not**

Certainly Not a Match. This record is known not to be a match. Note that usually non-matching records are not returned, but in some cases records previously or likely considered as a match may specifically be negated by the matching engine */
    CertainlyNot,
    /** **possible**

Possible Match. This record may be a matching one. Additional review (e.g. by a human) SHOULD be performed before using this as a match. */
    Possible,
    /** **probable**

Probable Match. This record is a close match, but not a certain match. Additional review (e.g. by a human) may be required before using this as a match. */
    Probable,
}
impl ::core::str::FromStr for MatchGrade {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "certain" => Ok(Self::Certain),
            "certainly-not" => Ok(Self::CertainlyNot),
            "possible" => Ok(Self::Possible),
            "probable" => Ok(Self::Probable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MatchGrade {
    fn as_ref(&self) -> &str {
        match self {
            Self::Certain => "certain",
            Self::CertainlyNot => "certainly-not",
            Self::Possible => "possible",
            Self::Probable => "probable",
        }
    }
}
impl ::std::fmt::Debug for MatchGrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MatchGrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MatchGrade {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MatchGrade {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MatchGrade> for Coding {
    fn from(code: MatchGrade) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/match-grade".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MatchGrade> for CodeableConcept {
    fn from(code: MatchGrade) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MaxOccurs](http://hl7.org/fhir/ValueSet/question-max-occurs)**. Flags an element as having unlimited repetitions\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MaxOccurs {
    /** *****

Repeating. Element can repeat an unlimited number of times */
    Repeating,
}
impl ::core::str::FromStr for MaxOccurs {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "*" => Ok(Self::Repeating),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MaxOccurs {
    fn as_ref(&self) -> &str {
        match self {
            Self::Repeating => "*",
        }
    }
}
impl ::std::fmt::Debug for MaxOccurs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MaxOccurs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MaxOccurs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MaxOccurs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MaxOccurs> for Coding {
    fn from(code: MaxOccurs) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/question-max-occurs".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MaxOccurs> for CodeableConcept {
    fn from(code: MaxOccurs) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasmntPrinciple](http://hl7.org/fhir/ValueSet/measurement-principle)**. Different measurement principle supported by the device.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasmntPrinciple {
    /** **acoustical**

MSP Acoustical. Measurement is done using the acoustical principle. */
    Acoustical,
    /** **biological**

MSP Biological. Measurement is done using the biological principle. */
    Biological,
    /** **chemical**

MSP Chemical. Measurement is done using the chemical principle. */
    Chemical,
    /** **electrical**

MSP Electrical. Measurement is done using the electrical principle. */
    Electrical,
    /** **impedance**

MSP Impedance. Measurement is done using the impedance principle. */
    Impedance,
    /** **manual**

MSP Manual. Measurement is done using the manual principle. */
    Manual,
    /** **mechanical**

MSP Mechanical. Measurement is done using the mechanical principle. */
    Mechanical,
    /** **nuclear**

MSP Nuclear. Measurement is done using the nuclear principle. */
    Nuclear,
    /** **optical**

MSP Optical. Measurement is done using the optical principle. */
    Optical,
    /** **other**

MSP Other. Measurement principle isn't in the list. */
    Other,
    /** **thermal**

MSP Thermal. Measurement is done using the thermal principle. */
    Thermal,
}
impl ::core::str::FromStr for MeasmntPrinciple {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acoustical" => Ok(Self::Acoustical),
            "biological" => Ok(Self::Biological),
            "chemical" => Ok(Self::Chemical),
            "electrical" => Ok(Self::Electrical),
            "impedance" => Ok(Self::Impedance),
            "manual" => Ok(Self::Manual),
            "mechanical" => Ok(Self::Mechanical),
            "nuclear" => Ok(Self::Nuclear),
            "optical" => Ok(Self::Optical),
            "other" => Ok(Self::Other),
            "thermal" => Ok(Self::Thermal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasmntPrinciple {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acoustical => "acoustical",
            Self::Biological => "biological",
            Self::Chemical => "chemical",
            Self::Electrical => "electrical",
            Self::Impedance => "impedance",
            Self::Manual => "manual",
            Self::Mechanical => "mechanical",
            Self::Nuclear => "nuclear",
            Self::Optical => "optical",
            Self::Other => "other",
            Self::Thermal => "thermal",
        }
    }
}
impl ::std::fmt::Debug for MeasmntPrinciple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasmntPrinciple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasmntPrinciple {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasmntPrinciple {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasmntPrinciple> for Coding {
    fn from(code: MeasmntPrinciple) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/measurement-principle".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasmntPrinciple> for CodeableConcept {
    fn from(code: MeasmntPrinciple) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureDataUsage](http://hl7.org/fhir/ValueSet/measure-data-usage)**. The intended usage for supplemental data elements in the measure\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureDataUsage {
    /** **risk-adjustment-factor**

Risk Adjustment Factor. The data is intended to be used to calculate and apply a risk adjustment model for the measure */
    RiskAdjustmentFactor,
    /** **supplemental-data**

Supplemental Data. The data is intended to be provided as additional information alongside the measure results */
    SupplementalData,
}
impl ::core::str::FromStr for MeasureDataUsage {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "risk-adjustment-factor" => Ok(Self::RiskAdjustmentFactor),
            "supplemental-data" => Ok(Self::SupplementalData),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureDataUsage {
    fn as_ref(&self) -> &str {
        match self {
            Self::RiskAdjustmentFactor => "risk-adjustment-factor",
            Self::SupplementalData => "supplemental-data",
        }
    }
}
impl ::std::fmt::Debug for MeasureDataUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureDataUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureDataUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureDataUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureDataUsage> for Coding {
    fn from(code: MeasureDataUsage) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-data-usage".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureDataUsage> for CodeableConcept {
    fn from(code: MeasureDataUsage) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasurePopulationType](http://hl7.org/fhir/ValueSet/measure-population)**. The type of population\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasurePopulationType {
    /** **denominator**

Denominator. The lower portion of a fraction used to calculate a rate, proportion, or ratio. The denominator can be the same as the initial population, or a subset of the initial population to further constrain the population for the purpose of the measure */
    Denominator,
    /** **denominator-exception**

Denominator Exception. Denominator exceptions are conditions that should remove a patient or event from the denominator of a measure only if the numerator criteria are not met. Denominator exception allows for adjustment of the calculated score for those providers with higher risk populations. Denominator exception criteria are only used in proportion measures */
    DenominatorException,
    /** **denominator-exclusion**

Denominator Exclusion. Denominator exclusion criteria define patients or events that should be removed from the denominator before determining if numerator criteria are met. Denominator exclusions are used in proportion and ratio measures to help narrow the denominator. For example, patients with bilateral lower extremity amputations would be listed as a denominator exclusion for a measure requiring foot exams */
    DenominatorExclusion,
    /** **initial-population**

Initial Population. The initial population refers to all patients or events to be evaluated by a quality measure involving patients who share a common set of specified characterstics. All patients or events counted (for example, as numerator, as denominator) are drawn from the initial population */
    InitialPopulation,
    /** **measure-observation**

Measure Observation. Defines the individual observation to be performed for each patient or event in the measure population. Measure observations for each case in the population are aggregated to determine the overall measure score for the population */
    MeasureObservation,
    /** **measure-population**

Measure Population. Measure population criteria define the patients or events for which the individual observation for the measure should be taken. Measure populations are used for continuous variable measures rather than numerator and denominator criteria */
    MeasurePopulation,
    /** **measure-population-exclusion**

Measure Population Exclusion. Measure population criteria define the patients or events that should be removed from the measure population before determining the outcome of one or more continuous variables defined for the measure observation. Measure population exclusion criteria are used within continuous variable measures to help narrow the measure population */
    MeasurePopulationExclusion,
    /** **numerator**

Numerator. The upper portion of a fraction used to calculate a rate, proportion, or ratio. Also called the measure focus, it is the target process, condition, event, or outcome. Numerator criteria are the processes or outcomes expected for each patient, or event defined in the denominator. A numerator statement describes the clinical action that satisfies the conditions of the measure */
    Numerator,
    /** **numerator-exclusion**

Numerator Exclusion. Numerator exclusion criteria define patients or events to be removed from the numerator. Numerator exclusions are used in proportion and ratio measures to help narrow the numerator (for inverted measures) */
    NumeratorExclusion,
}
impl ::core::str::FromStr for MeasurePopulationType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "denominator" => Ok(Self::Denominator),
            "denominator-exception" => Ok(Self::DenominatorException),
            "denominator-exclusion" => Ok(Self::DenominatorExclusion),
            "initial-population" => Ok(Self::InitialPopulation),
            "measure-observation" => Ok(Self::MeasureObservation),
            "measure-population" => Ok(Self::MeasurePopulation),
            "measure-population-exclusion" => Ok(Self::MeasurePopulationExclusion),
            "numerator" => Ok(Self::Numerator),
            "numerator-exclusion" => Ok(Self::NumeratorExclusion),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasurePopulationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Denominator => "denominator",
            Self::DenominatorException => "denominator-exception",
            Self::DenominatorExclusion => "denominator-exclusion",
            Self::InitialPopulation => "initial-population",
            Self::MeasureObservation => "measure-observation",
            Self::MeasurePopulation => "measure-population",
            Self::MeasurePopulationExclusion => "measure-population-exclusion",
            Self::Numerator => "numerator",
            Self::NumeratorExclusion => "numerator-exclusion",
        }
    }
}
impl ::std::fmt::Debug for MeasurePopulationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasurePopulationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasurePopulationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasurePopulationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasurePopulationType> for Coding {
    fn from(code: MeasurePopulationType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-population".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasurePopulationType> for CodeableConcept {
    fn from(code: MeasurePopulationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureReportStatus](http://hl7.org/fhir/ValueSet/measure-report-status)**. The status of the measure report\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureReportStatus {
    /** **complete**

Complete. The report is complete and ready for use */
    Complete,
    /** **error**

Error. An error occurred attempting to generate the report */
    Error,
    /** **pending**

Pending. The report is currently being generated */
    Pending,
}
impl ::core::str::FromStr for MeasureReportStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "error" => Ok(Self::Error),
            "pending" => Ok(Self::Pending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Error => "error",
            Self::Pending => "pending",
        }
    }
}
impl ::std::fmt::Debug for MeasureReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureReportStatus> for Coding {
    fn from(code: MeasureReportStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/measure-report-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureReportStatus> for CodeableConcept {
    fn from(code: MeasureReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureReportType](http://hl7.org/fhir/ValueSet/measure-report-type)**. The type of the measure report\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureReportType {
    /** **individual**

Individual. An individual report that provides information on the performance for a given measure with respect to a single patient */
    Individual,
    /** **patient-list**

Patient List. A patient list report that includes a listing of patients that satisfied each population criteria in the measure */
    PatientList,
    /** **summary**

Summary. A summary report that returns the number of patients in each population criteria for the measure */
    Summary,
}
impl ::core::str::FromStr for MeasureReportType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "individual" => Ok(Self::Individual),
            "patient-list" => Ok(Self::PatientList),
            "summary" => Ok(Self::Summary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Individual => "individual",
            Self::PatientList => "patient-list",
            Self::Summary => "summary",
        }
    }
}
impl ::std::fmt::Debug for MeasureReportType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureReportType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureReportType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureReportType> for Coding {
    fn from(code: MeasureReportType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-report-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureReportType> for CodeableConcept {
    fn from(code: MeasureReportType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureScoring](http://hl7.org/fhir/ValueSet/measure-scoring)**. The scoring type of the measure\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureScoring {
    /** **cohort**

Cohort. The measure is a cohort definition */
    Cohort,
    /** **continuous-variable**

Continuous Variable. The score is defined by a calculation of some quantity */
    ContinuousVariable,
    /** **proportion**

Proportion. The measure score is defined using a proportion */
    Proportion,
    /** **ratio**

Ratio. The measure score is defined using a ratio */
    Ratio,
}
impl ::core::str::FromStr for MeasureScoring {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cohort" => Ok(Self::Cohort),
            "continuous-variable" => Ok(Self::ContinuousVariable),
            "proportion" => Ok(Self::Proportion),
            "ratio" => Ok(Self::Ratio),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureScoring {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cohort => "cohort",
            Self::ContinuousVariable => "continuous-variable",
            Self::Proportion => "proportion",
            Self::Ratio => "ratio",
        }
    }
}
impl ::std::fmt::Debug for MeasureScoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureScoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureScoring {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureScoring {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureScoring> for Coding {
    fn from(code: MeasureScoring) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-scoring".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureScoring> for CodeableConcept {
    fn from(code: MeasureScoring) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureType](http://hl7.org/fhir/ValueSet/measure-type)**. The type of measure (includes codes from 2.16.840.1.113883.1.11.20368)\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureType {
    /** **composite**

Composite. A measure that combines multiple component measures in to a single quality measure */
    Composite,
    /** **outcome**

Outcome. A measure that indicates the result of the performance (or non-performance) of a function or process */
    Outcome,
    /** **patient-reported-outcome**

Patient Reported Outcome. A measure that focuses on patient-reported information such as patient engagement or patient experience measures */
    PatientReportedOutcome,
    /** **process**

Process. A measure which focuses on a process which leads to a certain outcome, meaning that a scientific basis exists for believing that the process, when executed well, will increase the probability of achieving a desired outcome */
    Process,
    /** **structure**

Structure. A measure that focuses on a health care provider's capacity, systems, and processes to provide high-quality care */
    Structure,
}
impl ::core::str::FromStr for MeasureType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "composite" => Ok(Self::Composite),
            "outcome" => Ok(Self::Outcome),
            "patient-reported-outcome" => Ok(Self::PatientReportedOutcome),
            "process" => Ok(Self::Process),
            "structure" => Ok(Self::Structure),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Composite => "composite",
            Self::Outcome => "outcome",
            Self::PatientReportedOutcome => "patient-reported-outcome",
            Self::Process => "process",
            Self::Structure => "structure",
        }
    }
}
impl ::std::fmt::Debug for MeasureType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureType> for Coding {
    fn from(code: MeasureType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureType> for CodeableConcept {
    fn from(code: MeasureType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationAdministrationCategory](http://hl7.org/fhir/ValueSet/medication-admin-category)**. A coded concept describing where the medication administered is expected to occur\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationAdministrationCategory {
    /** **community**

Community. Includes administrations by the patient in their home (this would include long term care or nursing homes, hospices, etc) */
    Community,
    /** **inpatient**

Inpatient. Includes administrations in an inpatient or acute care setting */
    Inpatient,
    /** **outpatient**

Outpatient. Includes administrations in an outpatient setting (for example, Emergency Department, Outpatient Clinic, Outpatient Surgery, Doctor's office) */
    Outpatient,
}
impl ::core::str::FromStr for MedicationAdministrationCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "community" => Ok(Self::Community),
            "inpatient" => Ok(Self::Inpatient),
            "outpatient" => Ok(Self::Outpatient),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationAdministrationCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Community => "community",
            Self::Inpatient => "inpatient",
            Self::Outpatient => "outpatient",
        }
    }
}
impl ::std::fmt::Debug for MedicationAdministrationCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationAdministrationCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationAdministrationCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationAdministrationCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationAdministrationCategory> for Coding {
    fn from(code: MedicationAdministrationCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-admin-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationAdministrationCategory> for CodeableConcept {
    fn from(code: MedicationAdministrationCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationAdministrationStatus](http://hl7.org/fhir/ValueSet/medication-admin-status)**. A set of codes indicating the current status of a MedicationAdministration.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationAdministrationStatus {
    /** **completed**

Completed. All actions that are implied by the administration have occurred. */
    Completed,
    /** **entered-in-error**

Entered in Error. The administration was entered in error and therefore nullified. */
    EnteredInError,
    /** **in-progress**

In Progress. The administration has started but has not yet completed. */
    InProgress,
    /** **on-hold**

On Hold. Actions implied by the administration have been temporarily halted, but are expected to continue later. May also be called "suspended". */
    OnHold,
    /** **stopped**

Stopped. Actions implied by the administration have been permanently halted, before all of them occurred. */
    Stopped,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for MedicationAdministrationStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationAdministrationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for MedicationAdministrationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationAdministrationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationAdministrationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationAdministrationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationAdministrationStatus> for Coding {
    fn from(code: MedicationAdministrationStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-admin-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationAdministrationStatus> for CodeableConcept {
    fn from(code: MedicationAdministrationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationContainer](http://hl7.org/fhir/ValueSet/medication-package-form)**. A coded concept defining the kind of container a medication package is packaged in\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationContainer {
    /** **ampoule**

Ampoule. A sealed glass capsule containing a liquid */
    Ampoule,
    /** **bottle**

Bottle. A container, typically made of glass or plastic and with a narrow neck, used for storing liquids. */
    Bottle,
    /** **box**

Box. A container with a flat base and sides, typically square or rectangular and having a lid. */
    Box,
    /** **cartridge**

Cartridge. A device of various configuration and composition used with a syringe for the application of anesthetic or other materials to a patient. */
    Cartridge,
    /** **container**

Container. A package intended to store pharmaceuticals. */
    Container,
    /** **tube**

Tube. A long, hollow cylinder of metal, plastic, glass, etc., for holding medications, typically creams or ointments */
    Tube,
    /** **unitdose**

Unit Dose Blister. A dose of medicine prepared in an individual package for convenience, safety or monitoring. */
    Unitdose,
    /** **vial**

Vial. A small container, typically cylindrical and made of glass, used especially for holding liquid medications. */
    Vial,
}
impl ::core::str::FromStr for MedicationContainer {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ampoule" => Ok(Self::Ampoule),
            "bottle" => Ok(Self::Bottle),
            "box" => Ok(Self::Box),
            "cartridge" => Ok(Self::Cartridge),
            "container" => Ok(Self::Container),
            "tube" => Ok(Self::Tube),
            "unitdose" => Ok(Self::Unitdose),
            "vial" => Ok(Self::Vial),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationContainer {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ampoule => "ampoule",
            Self::Bottle => "bottle",
            Self::Box => "box",
            Self::Cartridge => "cartridge",
            Self::Container => "container",
            Self::Tube => "tube",
            Self::Unitdose => "unitdose",
            Self::Vial => "vial",
        }
    }
}
impl ::std::fmt::Debug for MedicationContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationContainer {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationContainer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationContainer> for Coding {
    fn from(code: MedicationContainer) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-package-form".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationContainer> for CodeableConcept {
    fn from(code: MedicationContainer) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationDispenseCategory](http://hl7.org/fhir/ValueSet/medication-dispense-category)**. A code describing where the dispensed medication is expected to be consumed or administered\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationDispenseCategory {
    /** **community**

Community. Includes dispenses for medications to be administered or consumed by the patient in their home (this would include long term care or nursing homes, hospices, etc) */
    Community,
    /** **inpatient**

Inpatient. Includes dispenses for medications to be administered or consumed in an inpatient or acute care setting */
    Inpatient,
    /** **outpatient**

Outpatient. Includes dispenses for medications to be administered or consumed in an outpatient setting (for example, Emergency Department, Outpatient Clinic, Outpatient Surgery, Doctor's office) */
    Outpatient,
}
impl ::core::str::FromStr for MedicationDispenseCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "community" => Ok(Self::Community),
            "inpatient" => Ok(Self::Inpatient),
            "outpatient" => Ok(Self::Outpatient),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationDispenseCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Community => "community",
            Self::Inpatient => "inpatient",
            Self::Outpatient => "outpatient",
        }
    }
}
impl ::std::fmt::Debug for MedicationDispenseCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationDispenseCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationDispenseCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationDispenseCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationDispenseCategory> for Coding {
    fn from(code: MedicationDispenseCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-dispense-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationDispenseCategory> for CodeableConcept {
    fn from(code: MedicationDispenseCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationDispenseStatus](http://hl7.org/fhir/ValueSet/medication-dispense-status)**. A coded concept specifying the state of the dispense event.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationDispenseStatus {
    /** **completed**

Completed. All actions that are implied by the dispense have occurred. */
    Completed,
    /** **entered-in-error**

Entered in-Error. The dispense was entered in error and therefore nullified. */
    EnteredInError,
    /** **in-progress**

In Progress. The dispense has started but has not yet completed. */
    InProgress,
    /** **on-hold**

On Hold. Actions implied by the administration have been temporarily halted, but are expected to continue later. May also be called "suspended" */
    OnHold,
    /** **preparation**

Preparation. The core event has not started yet, but some staging activities have begun (e.g. initial compounding or packaging of medication). Preparation stages may be tracked for billing purposes. */
    Preparation,
    /** **stopped**

Stopped. Actions implied by the dispense have been permanently halted, before all of them occurred. */
    Stopped,
}
impl ::core::str::FromStr for MedicationDispenseStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "preparation" => Ok(Self::Preparation),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationDispenseStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::Preparation => "preparation",
            Self::Stopped => "stopped",
        }
    }
}
impl ::std::fmt::Debug for MedicationDispenseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationDispenseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationDispenseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationDispenseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationDispenseStatus> for Coding {
    fn from(code: MedicationDispenseStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-dispense-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationDispenseStatus> for CodeableConcept {
    fn from(code: MedicationDispenseStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationRequestCategory](http://hl7.org/fhir/ValueSet/medication-request-category)**. A coded concept identifying where the medication ordered is expected to be consumed or administered\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationRequestCategory {
    /** **community**

Community. Includes orders for medications to be administered or consumed by the patient in their home (this would include long term care or nursing homes, hospices, etc) */
    Community,
    /** **inpatient**

Inpatient. Includes orders for medications to be administered or consumed in an inpatient or acute care setting */
    Inpatient,
    /** **outpatient**

Outpatient. Includes orders for medications to be administered or consumed in an outpatient setting (for example, Emergency Department, Outpatient Clinic, Outpatient Surgery, Doctor's office) */
    Outpatient,
}
impl ::core::str::FromStr for MedicationRequestCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "community" => Ok(Self::Community),
            "inpatient" => Ok(Self::Inpatient),
            "outpatient" => Ok(Self::Outpatient),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationRequestCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Community => "community",
            Self::Inpatient => "inpatient",
            Self::Outpatient => "outpatient",
        }
    }
}
impl ::std::fmt::Debug for MedicationRequestCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationRequestCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationRequestCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationRequestCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationRequestCategory> for Coding {
    fn from(code: MedicationRequestCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-request-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationRequestCategory> for CodeableConcept {
    fn from(code: MedicationRequestCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationRequestIntent](http://hl7.org/fhir/ValueSet/medication-request-intent)**. The kind of medication order\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationRequestIntent {
    /** **instance-order**

Instance Order. The request represents an instance for the particular order, for example a medication administration record. */
    InstanceOrder,
    /** **order**

Order. The request represents a request/demand and authorization for action */
    Order,
    /** **plan**

Plan. The request represents an intension to ensure something occurs without providing an authorization for others to act */
    Plan,
    /** **proposal**

Proposal. The request is a suggestion made by someone/something that doesn't have an intention to ensure it occurs and without providing an authorization to act */
    Proposal,
}
impl ::core::str::FromStr for MedicationRequestIntent {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "instance-order" => Ok(Self::InstanceOrder),
            "order" => Ok(Self::Order),
            "plan" => Ok(Self::Plan),
            "proposal" => Ok(Self::Proposal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationRequestIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::InstanceOrder => "instance-order",
            Self::Order => "order",
            Self::Plan => "plan",
            Self::Proposal => "proposal",
        }
    }
}
impl ::std::fmt::Debug for MedicationRequestIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationRequestIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationRequestIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationRequestIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationRequestIntent> for Coding {
    fn from(code: MedicationRequestIntent) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-request-intent".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationRequestIntent> for CodeableConcept {
    fn from(code: MedicationRequestIntent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationRequestPriority](http://hl7.org/fhir/ValueSet/medication-request-priority)**. Identifies the level of importance to be assigned to actioning the request\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationRequestPriority {
    /** **asap**

ASAP. The order should be acted on as soon as possible. */
    Asap,
    /** **routine**

Routine. The order has a normal priority . */
    Routine,
    /** **stat**

Stat. The order is time-critical. */
    Stat,
    /** **urgent**

Urgent. The order should be urgently. */
    Urgent,
}
impl ::core::str::FromStr for MedicationRequestPriority {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "asap" => Ok(Self::Asap),
            "routine" => Ok(Self::Routine),
            "stat" => Ok(Self::Stat),
            "urgent" => Ok(Self::Urgent),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationRequestPriority {
    fn as_ref(&self) -> &str {
        match self {
            Self::Asap => "asap",
            Self::Routine => "routine",
            Self::Stat => "stat",
            Self::Urgent => "urgent",
        }
    }
}
impl ::std::fmt::Debug for MedicationRequestPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationRequestPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationRequestPriority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationRequestPriority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationRequestPriority> for Coding {
    fn from(code: MedicationRequestPriority) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-request-priority".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationRequestPriority> for CodeableConcept {
    fn from(code: MedicationRequestPriority) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationRequestStatus](http://hl7.org/fhir/ValueSet/medication-request-status)**. A coded concept specifying the state of the prescribing event. Describes the lifecycle of the prescription\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationRequestStatus {
    /** **active**

Active. The prescription is 'actionable', but not all actions that are implied by it have occurred yet. */
    Active,
    /** **cancelled**

Cancelled. The prescription has been withdrawn. */
    Cancelled,
    /** **completed**

Completed. All actions that are implied by the prescription have occurred. */
    Completed,
    /** **draft**

Draft. The prescription is not yet 'actionable', i.e. it is a work in progress, requires sign-off or verification, and needs to be run through decision support process. */
    Draft,
    /** **entered-in-error**

Entered In Error. The prescription was entered in error. */
    EnteredInError,
    /** **on-hold**

On Hold. Actions implied by the prescription are to be temporarily halted, but are expected to continue later.  May also be called "suspended". */
    OnHold,
    /** **stopped**

Stopped. Actions implied by the prescription are to be permanently halted, before all of them occurred. */
    Stopped,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this request */
    Unknown,
}
impl ::core::str::FromStr for MedicationRequestStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "on-hold" => Ok(Self::OnHold),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationRequestStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::OnHold => "on-hold",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for MedicationRequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationRequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationRequestStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationRequestStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationRequestStatus> for Coding {
    fn from(code: MedicationRequestStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-request-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationRequestStatus> for CodeableConcept {
    fn from(code: MedicationRequestStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationStatementCategory](http://hl7.org/fhir/ValueSet/medication-statement-category)**. A coded concept identifying where the medication included in the medicationstatement is expected to be consumed or administered\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationStatementCategory {
    /** **community**

Community. Includes orders for medications to be administered or consumed by the patient in their home (this would include long term care or nursing homes, hospices, etc) */
    Community,
    /** **inpatient**

Inpatient. Includes orders for medications to be administered or consumed in an inpatient or acute care setting */
    Inpatient,
    /** **outpatient**

Outpatient. Includes orders for medications to be administered or consumed in an outpatient setting (for example, Emergency Department, Outpatient Clinic, Outpatient Surgery, Doctor's office) */
    Outpatient,
    /** **patientspecified**

Patient Specified. Includes statements about medication use, including over the counter medication, provided by the patient, agent or another provider */
    Patientspecified,
}
impl ::core::str::FromStr for MedicationStatementCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "community" => Ok(Self::Community),
            "inpatient" => Ok(Self::Inpatient),
            "outpatient" => Ok(Self::Outpatient),
            "patientspecified" => Ok(Self::Patientspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationStatementCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Community => "community",
            Self::Inpatient => "inpatient",
            Self::Outpatient => "outpatient",
            Self::Patientspecified => "patientspecified",
        }
    }
}
impl ::std::fmt::Debug for MedicationStatementCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationStatementCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationStatementCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationStatementCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationStatementCategory> for Coding {
    fn from(code: MedicationStatementCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-statement-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationStatementCategory> for CodeableConcept {
    fn from(code: MedicationStatementCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationStatementStatus](http://hl7.org/fhir/ValueSet/medication-statement-status)**. A coded concept indicating the current status of a MedicationStatement.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationStatementStatus {
    /** **active**

Active. The medication is still being taken. */
    Active,
    /** **completed**

Completed. The medication is no longer being taken. */
    Completed,
    /** **entered-in-error**

Entered in Error. The statement was recorded incorrectly. */
    EnteredInError,
    /** **intended**

Intended. The medication may be taken at some time in the future. */
    Intended,
    /** **on-hold**

On Hold. Actions implied by the statement have been temporarily halted, but are expected to continue later. May also be called "suspended". */
    OnHold,
    /** **stopped**

Stopped. Actions implied by the statement have been permanently halted, before all of them occurred. */
    Stopped,
}
impl ::core::str::FromStr for MedicationStatementStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "intended" => Ok(Self::Intended),
            "on-hold" => Ok(Self::OnHold),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationStatementStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::Intended => "intended",
            Self::OnHold => "on-hold",
            Self::Stopped => "stopped",
        }
    }
}
impl ::std::fmt::Debug for MedicationStatementStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationStatementStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationStatementStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationStatementStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationStatementStatus> for Coding {
    fn from(code: MedicationStatementStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-statement-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationStatementStatus> for CodeableConcept {
    fn from(code: MedicationStatementStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationStatementTaken](http://hl7.org/fhir/ValueSet/medication-statement-taken)**. A coded concept identifying level of certainty if patient has taken or has not taken the medication\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationStatementTaken {
    /** **n**

No. Negative assertion that patient has not taken medication */
    N,
    /** **na**

Not Applicable. Patient reporting does not apply */
    Na,
    /** **unk**

Unknown. Unknown assertion if patient has taken medication */
    Unk,
    /** **y**

Yes. Positive assertion that patient has taken medication */
    Y,
}
impl ::core::str::FromStr for MedicationStatementTaken {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "n" => Ok(Self::N),
            "na" => Ok(Self::Na),
            "unk" => Ok(Self::Unk),
            "y" => Ok(Self::Y),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationStatementTaken {
    fn as_ref(&self) -> &str {
        match self {
            Self::N => "n",
            Self::Na => "na",
            Self::Unk => "unk",
            Self::Y => "y",
        }
    }
}
impl ::std::fmt::Debug for MedicationStatementTaken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationStatementTaken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationStatementTaken {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationStatementTaken {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationStatementTaken> for Coding {
    fn from(code: MedicationStatementTaken) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medication-statement-taken".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationStatementTaken> for CodeableConcept {
    fn from(code: MedicationStatementTaken) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicationStatus](http://hl7.org/fhir/ValueSet/medication-status)**. A coded concept defining if the medication is in active use\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicationStatus {
    /** **active**

Active. The medication is available for use */
    Active,
    /** **entered-in-error**

Entered in Error. The medication was entered in error */
    EnteredInError,
    /** **inactive**

Inactive. The medication is not available for use */
    Inactive,
}
impl ::core::str::FromStr for MedicationStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Debug for MedicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationStatus> for Coding {
    fn from(code: MedicationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/medication-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicationStatus> for CodeableConcept {
    fn from(code: MedicationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MessageEvent](http://hl7.org/fhir/ValueSet/message-events)**. One of the message events defined as part of FHIR.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MessageEvent {
    /** **CodeSystem-expand**

CodeSystem-expand. The definition of a code system is used to create a simple collection of codes suitable for use for data entry or validation. An expanded code system will be returned, or an error message. */
    CodeSystemExpand,
    /** **MedicationAdministration-Complete**

MedicationAdministration-Complete. Change the status of a Medication Administration to show that it is complete. */
    MedicationAdministrationComplete,
    /** **MedicationAdministration-Nullification**

MedicationAdministration-Nullification. Someone wishes to record that the record of administration of a medication is in error and should be ignored. */
    MedicationAdministrationNullification,
    /** **MedicationAdministration-Recording**

MedicationAdministration-Recording. Indicates that a medication has been recorded against the patient's record. */
    MedicationAdministrationRecording,
    /** **MedicationAdministration-Update**

MedicationAdministration-Update. Update a Medication Administration record. */
    MedicationAdministrationUpdate,
    /** **admin-notify**

admin-notify. Notification of a change to an administrative resource (either create or update). Note that there is no delete, though some administrative resources have status or period elements for this use. */
    AdminNotify,
    /** **communication-request**

communication-request. Notification to convey information. */
    CommunicationRequest,
    /** **diagnosticreport-provide**

diagnosticreport-provide. Provide a diagnostic report, or update a previously provided diagnostic report. */
    DiagnosticreportProvide,
    /** **observation-provide**

observation-provide. Provide a simple observation or update a previously provided simple observation. */
    ObservationProvide,
    /** **patient-link**

patient-link. Notification that two patient records actually identify the same patient. */
    PatientLink,
    /** **patient-unlink**

patient-unlink. Notification that previous advice that two patient records concern the same patient is now considered incorrect. */
    PatientUnlink,
    /** **valueset-expand**

valueset-expand. The definition of a value set is used to create a simple collection of codes suitable for use for data entry or validation. An expanded value set will be returned, or an error message. */
    ValuesetExpand,
}
impl ::core::str::FromStr for MessageEvent {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CodeSystem-expand" => Ok(Self::CodeSystemExpand),
            "MedicationAdministration-Complete" => {
                Ok(Self::MedicationAdministrationComplete)
            }
            "MedicationAdministration-Nullification" => {
                Ok(Self::MedicationAdministrationNullification)
            }
            "MedicationAdministration-Recording" => {
                Ok(Self::MedicationAdministrationRecording)
            }
            "MedicationAdministration-Update" => Ok(Self::MedicationAdministrationUpdate),
            "admin-notify" => Ok(Self::AdminNotify),
            "communication-request" => Ok(Self::CommunicationRequest),
            "diagnosticreport-provide" => Ok(Self::DiagnosticreportProvide),
            "observation-provide" => Ok(Self::ObservationProvide),
            "patient-link" => Ok(Self::PatientLink),
            "patient-unlink" => Ok(Self::PatientUnlink),
            "valueset-expand" => Ok(Self::ValuesetExpand),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageEvent {
    fn as_ref(&self) -> &str {
        match self {
            Self::CodeSystemExpand => "CodeSystem-expand",
            Self::MedicationAdministrationComplete => "MedicationAdministration-Complete",
            Self::MedicationAdministrationNullification => {
                "MedicationAdministration-Nullification"
            }
            Self::MedicationAdministrationRecording => {
                "MedicationAdministration-Recording"
            }
            Self::MedicationAdministrationUpdate => "MedicationAdministration-Update",
            Self::AdminNotify => "admin-notify",
            Self::CommunicationRequest => "communication-request",
            Self::DiagnosticreportProvide => "diagnosticreport-provide",
            Self::ObservationProvide => "observation-provide",
            Self::PatientLink => "patient-link",
            Self::PatientUnlink => "patient-unlink",
            Self::ValuesetExpand => "valueset-expand",
        }
    }
}
impl ::std::fmt::Debug for MessageEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MessageEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MessageEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageEvent> for Coding {
    fn from(code: MessageEvent) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/message-events".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MessageEvent> for CodeableConcept {
    fn from(code: MessageEvent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MessageSignificanceCategory](http://hl7.org/fhir/ValueSet/message-significance-category)**. The impact of the content of a message.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MessageSignificanceCategory {
    /** **Consequence**

Consequence. The message represents/requests a change that should not be processed more than once; e.g., making a booking for an appointment. */
    Consequence,
    /** **Currency**

Currency. The message represents a response to query for current information. Retrospective processing is wrong and/or wasteful. */
    Currency,
    /** **Notification**

Notification. The content is not necessarily intended to be current, and it can be reprocessed, though there may be version issues created by processing old notifications. */
    Notification,
}
impl ::core::str::FromStr for MessageSignificanceCategory {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Consequence" => Ok(Self::Consequence),
            "Currency" => Ok(Self::Currency),
            "Notification" => Ok(Self::Notification),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageSignificanceCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consequence => "Consequence",
            Self::Currency => "Currency",
            Self::Notification => "Notification",
        }
    }
}
impl ::std::fmt::Debug for MessageSignificanceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MessageSignificanceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MessageSignificanceCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageSignificanceCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageSignificanceCategory> for Coding {
    fn from(code: MessageSignificanceCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/message-significance-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MessageSignificanceCategory> for CodeableConcept {
    fn from(code: MessageSignificanceCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MessageTransport](http://hl7.org/fhir/ValueSet/message-transport)**. The protocol used for message transport.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MessageTransport {
    /** **ftp**

FTP. The application sends or receives messages using File Transfer Protocol. */
    Ftp,
    /** **http**

HTTP. The application sends or receives messages using HTTP POST (may be over http: or https:). */
    Http,
    /** **mllp**

MLLP. The application sends or receives messages using HL7's Minimal Lower Level Protocol. */
    Mllp,
}
impl ::core::str::FromStr for MessageTransport {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ftp" => Ok(Self::Ftp),
            "http" => Ok(Self::Http),
            "mllp" => Ok(Self::Mllp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageTransport {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ftp => "ftp",
            Self::Http => "http",
            Self::Mllp => "mllp",
        }
    }
}
impl ::std::fmt::Debug for MessageTransport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MessageTransport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MessageTransport {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageTransport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageTransport> for Coding {
    fn from(code: MessageTransport) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/message-transport".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MessageTransport> for CodeableConcept {
    fn from(code: MessageTransport) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NameUse](http://hl7.org/fhir/ValueSet/name-use)**. The use of a human name\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NameUse {
    /** **anonymous**

Anonymous. Anonymous assigned name, alias, or pseudonym (used to protect a person's identity for privacy reasons) */
    Anonymous,
    /** **maiden**

Name changed for Marriage. A name used prior to changing name because of marriage. This name use is for use by applications that collect and store names that were used prior to a marriage. Marriage naming customs vary greatly around the world, and are constantly changing. This term is not gender specific. The use of this term does not imply any particular history for a person's name */
    Maiden,
    /** **nickname**

Nickname. A name that is used to address the person in an informal manner, but is not part of their formal or usual name */
    Nickname,
    /** **official**

Official. The formal name as registered in an official (government) registry, but which name might not be commonly used. May be called "legal name". */
    Official,
    /** **old**

Old. This name is no longer in use (or was never correct, but retained for records) */
    Old,
    /** **temp**

Temp. A temporary name. Name.period can provide more detailed information. This may also be used for temporary names assigned at birth or in emergency situations. */
    Temp,
    /** **usual**

Usual. Known as/conventional/the one you normally use */
    Usual,
}
impl ::core::str::FromStr for NameUse {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "anonymous" => Ok(Self::Anonymous),
            "maiden" => Ok(Self::Maiden),
            "nickname" => Ok(Self::Nickname),
            "official" => Ok(Self::Official),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "usual" => Ok(Self::Usual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NameUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Anonymous => "anonymous",
            Self::Maiden => "maiden",
            Self::Nickname => "nickname",
            Self::Official => "official",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Usual => "usual",
        }
    }
}
impl ::std::fmt::Debug for NameUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NameUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NameUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NameUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NameUse> for Coding {
    fn from(code: NameUse) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/name-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NameUse> for CodeableConcept {
    fn from(code: NameUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NamingSystemIdentifierType](http://hl7.org/fhir/ValueSet/namingsystem-identifier-type)**. Identifies the style of unique identifier used to identify a namespace.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NamingSystemIdentifierType {
    /** **oid**

OID. An ISO object identifier; e.g. 1.2.3.4.5. */
    Oid,
    /** **other**

Other. Some other type of unique identifier; e.g. HL7-assigned reserved string such as LN for LOINC. */
    Other,
    /** **uri**

URI. A uniform resource identifier (ideally a URL - uniform resource locator); e.g. http://unitsofmeasure.org. */
    Uri,
    /** **uuid**

UUID. A universally unique identifier of the form a5afddf4-e880-459b-876e-e4591b0acc11. */
    Uuid,
}
impl ::core::str::FromStr for NamingSystemIdentifierType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "oid" => Ok(Self::Oid),
            "other" => Ok(Self::Other),
            "uri" => Ok(Self::Uri),
            "uuid" => Ok(Self::Uuid),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NamingSystemIdentifierType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Oid => "oid",
            Self::Other => "other",
            Self::Uri => "uri",
            Self::Uuid => "uuid",
        }
    }
}
impl ::std::fmt::Debug for NamingSystemIdentifierType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NamingSystemIdentifierType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NamingSystemIdentifierType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NamingSystemIdentifierType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NamingSystemIdentifierType> for Coding {
    fn from(code: NamingSystemIdentifierType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/namingsystem-identifier-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NamingSystemIdentifierType> for CodeableConcept {
    fn from(code: NamingSystemIdentifierType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NamingSystemType](http://hl7.org/fhir/ValueSet/namingsystem-type)**. Identifies the purpose of the naming system.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NamingSystemType {
    /** **codesystem**

Code System. The naming system is used to define concepts and symbols to represent those concepts; e.g. UCUM, LOINC, NDC code, local lab codes, etc. */
    Codesystem,
    /** **identifier**

Identifier. The naming system is used to manage identifiers (e.g. license numbers, order numbers, etc.). */
    Identifier,
    /** **root**

Root. The naming system is used as the root for other identifiers and naming systems. */
    Root,
}
impl ::core::str::FromStr for NamingSystemType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "codesystem" => Ok(Self::Codesystem),
            "identifier" => Ok(Self::Identifier),
            "root" => Ok(Self::Root),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NamingSystemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Codesystem => "codesystem",
            Self::Identifier => "identifier",
            Self::Root => "root",
        }
    }
}
impl ::std::fmt::Debug for NamingSystemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NamingSystemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NamingSystemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NamingSystemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NamingSystemType> for Coding {
    fn from(code: NamingSystemType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/namingsystem-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NamingSystemType> for CodeableConcept {
    fn from(code: NamingSystemType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NarrativeStatus](http://hl7.org/fhir/ValueSet/narrative-status)**. The status of a resource narrative\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NarrativeStatus {
    /** **additional**

Additional. The contents of the narrative may contain additional information not found in the structured data. Note that there is no computable way to determine what the extra information is, other than by human inspection */
    Additional,
    /** **empty**

Empty. The contents of the narrative are some equivalent of "No human-readable text provided in this case" */
    Empty,
    /** **extensions**

Extensions. The contents of the narrative are entirely generated from the structured data in the content and some of the content is generated from extensions */
    Extensions,
    /** **generated**

Generated. The contents of the narrative are entirely generated from the structured data in the content. */
    Generated,
}
impl ::core::str::FromStr for NarrativeStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "additional" => Ok(Self::Additional),
            "empty" => Ok(Self::Empty),
            "extensions" => Ok(Self::Extensions),
            "generated" => Ok(Self::Generated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NarrativeStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Additional => "additional",
            Self::Empty => "empty",
            Self::Extensions => "extensions",
            Self::Generated => "generated",
        }
    }
}
impl ::std::fmt::Debug for NarrativeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NarrativeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NarrativeStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NarrativeStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NarrativeStatus> for Coding {
    fn from(code: NarrativeStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/narrative-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NarrativeStatus> for CodeableConcept {
    fn from(code: NarrativeStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NoteType](http://hl7.org/fhir/ValueSet/note-type)**. The presentation types of notes.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NoteType {
    /** **display**

Display. Display the note. */
    Display,
    /** **print**

Print (Form). Print the note on the form. */
    Print,
    /** **printoper**

Print (Operator). Print the note for the operator. */
    Printoper,
}
impl ::core::str::FromStr for NoteType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "display" => Ok(Self::Display),
            "print" => Ok(Self::Print),
            "printoper" => Ok(Self::Printoper),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NoteType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Display => "display",
            Self::Print => "print",
            Self::Printoper => "printoper",
        }
    }
}
impl ::std::fmt::Debug for NoteType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NoteType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NoteType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NoteType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NoteType> for Coding {
    fn from(code: NoteType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/note-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NoteType> for CodeableConcept {
    fn from(code: NoteType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NutritionOrderStatus](http://hl7.org/fhir/ValueSet/nutrition-request-status)**. Codes specifying the state of the request. Describes the lifecycle of the nutrition order.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NutritionOrderStatus {
    /** **active**

Active. The request is 'actionable', but not all actions that are implied by it have occurred yet. */
    Active,
    /** **cancelled**

Cancelled. The request has been withdrawn and is no longer actionable. */
    Cancelled,
    /** **completed**

Completed. All actions that are implied by the order have occurred and no continuation is planned (this will rarely be made explicit). */
    Completed,
    /** **draft**

Draft. The request is in preliminary form prior to being sent. */
    Draft,
    /** **entered-in-error**

Entered in Error. The request was entered in error and voided. */
    EnteredInError,
    /** **on-hold**

On-Hold. Actions implied by the request have been temporarily halted, but are expected to continue later. May also be called "suspended". */
    OnHold,
    /** **planned**

Planned. The request has been planned. */
    Planned,
    /** **proposed**

Proposed. The request has been proposed. */
    Proposed,
    /** **requested**

Requested. The request has been placed. */
    Requested,
}
impl ::core::str::FromStr for NutritionOrderStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "on-hold" => Ok(Self::OnHold),
            "planned" => Ok(Self::Planned),
            "proposed" => Ok(Self::Proposed),
            "requested" => Ok(Self::Requested),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NutritionOrderStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::OnHold => "on-hold",
            Self::Planned => "planned",
            Self::Proposed => "proposed",
            Self::Requested => "requested",
        }
    }
}
impl ::std::fmt::Debug for NutritionOrderStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NutritionOrderStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NutritionOrderStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NutritionOrderStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NutritionOrderStatus> for Coding {
    fn from(code: NutritionOrderStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/nutrition-request-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NutritionOrderStatus> for CodeableConcept {
    fn from(code: NutritionOrderStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ObservationRelationshipType](http://hl7.org/fhir/ValueSet/observation-relationshiptypes)**. Codes specifying how two observations are related.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ObservationRelationshipType {
    /** **derived-from**

Derived From. The target resource (Observation or QuestionnaireResponse) is part of the information from which this observation value is derived. (e.g. calculated anion gap, Apgar score)  NOTE:  "derived-from" is the only logical choice when referencing QuestionnaireResponse. */
    DerivedFrom,
    /** **has-member**

Has Member. This observation is a group observation (e.g. a battery, a panel of tests, a set of vital sign measurements) that includes the target as a member of the group. */
    HasMember,
    /** **interfered-by**

Interfered By. The value of the target observation interferes (degrades quality, or prevents valid observation) with the semantics of the source observation (e.g. a hemolysis measure target from a plasma potassium measure, which has no value). */
    InterferedBy,
    /** **qualified-by**

Qualified By. The value of the target observation qualifies (refines) the semantics of the source observation (e.g. a lipemia measure target from a plasma measure). */
    QualifiedBy,
    /** **replaces**

Replaces. This observation replaces a previous observation (i.e. a revised value). The target observation is now obsolete. */
    Replaces,
    /** **sequel-to**

Sequel To. This observation follows the target observation (e.g. timed tests such as Glucose Tolerance Test). */
    SequelTo,
}
impl ::core::str::FromStr for ObservationRelationshipType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "derived-from" => Ok(Self::DerivedFrom),
            "has-member" => Ok(Self::HasMember),
            "interfered-by" => Ok(Self::InterferedBy),
            "qualified-by" => Ok(Self::QualifiedBy),
            "replaces" => Ok(Self::Replaces),
            "sequel-to" => Ok(Self::SequelTo),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DerivedFrom => "derived-from",
            Self::HasMember => "has-member",
            Self::InterferedBy => "interfered-by",
            Self::QualifiedBy => "qualified-by",
            Self::Replaces => "replaces",
            Self::SequelTo => "sequel-to",
        }
    }
}
impl ::std::fmt::Debug for ObservationRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ObservationRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ObservationRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationRelationshipType> for Coding {
    fn from(code: ObservationRelationshipType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/observation-relationshiptypes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ObservationRelationshipType> for CodeableConcept {
    fn from(code: ObservationRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ObservationStatus](http://hl7.org/fhir/ValueSet/observation-status)**. Codes providing the status of an observation.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ObservationStatus {
    /** **amended**

Amended. Subsequent to being Final, the observation has been modified subsequent.  This includes updates/new information and corrections. */
    Amended,
    /** **cancelled**

Cancelled. The observation is unavailable because the measurement was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **corrected**

Corrected. Subsequent to being Final, the observation has been modified to correct an error in the test result. */
    Corrected,
    /** **entered-in-error**

Entered in Error. The observation has been withdrawn following previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".) */
    EnteredInError,
    /** **final**

Final. The observation is complete. */
    Final,
    /** **preliminary**

Preliminary. This is an initial or interim observation: data may be incomplete or unverified. */
    Preliminary,
    /** **registered**

Registered. The existence of the observation is registered, but there is no result yet available. */
    Registered,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for ObservationStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "cancelled" => Ok(Self::Cancelled),
            "corrected" => Ok(Self::Corrected),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "preliminary" => Ok(Self::Preliminary),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Cancelled => "cancelled",
            Self::Corrected => "corrected",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Preliminary => "preliminary",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for ObservationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ObservationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ObservationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationStatus> for Coding {
    fn from(code: ObservationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/observation-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ObservationStatus> for CodeableConcept {
    fn from(code: ObservationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[OperationKind](http://hl7.org/fhir/ValueSet/operation-kind)**. Whether an operation is a normal operation or a query.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum OperationKind {
    /** **operation**

Operation. This operation is invoked as an operation. */
    Operation,
    /** **query**

Query. This operation is a named query, invoked using the search mechanism. */
    Query,
}
impl ::core::str::FromStr for OperationKind {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "operation" => Ok(Self::Operation),
            "query" => Ok(Self::Query),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OperationKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Operation => "operation",
            Self::Query => "query",
        }
    }
}
impl ::std::fmt::Debug for OperationKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for OperationKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for OperationKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OperationKind> for Coding {
    fn from(code: OperationKind) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/operation-kind".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<OperationKind> for CodeableConcept {
    fn from(code: OperationKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[OperationParameterUse](http://hl7.org/fhir/ValueSet/operation-parameter-use)**. Whether an operation parameter is an input or an output parameter.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum OperationParameterUse {
    /** **in**

In. This is an input parameter. */
    In,
    /** **out**

Out. This is an output parameter. */
    Out,
}
impl ::core::str::FromStr for OperationParameterUse {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OperationParameterUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::In => "in",
            Self::Out => "out",
        }
    }
}
impl ::std::fmt::Debug for OperationParameterUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for OperationParameterUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for OperationParameterUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationParameterUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OperationParameterUse> for Coding {
    fn from(code: OperationParameterUse) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/operation-parameter-use".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<OperationParameterUse> for CodeableConcept {
    fn from(code: OperationParameterUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[OrganizationType](http://hl7.org/fhir/ValueSet/organization-type)**. This example value set defines a set of codes that can be used to indicate a type of organization.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum OrganizationType {
    /** **bus**

Non-Healthcare Business or Corporation. An organization that is a registered business or corporation but not identified by other types. */
    Bus,
    /** **cg**

Community Group. An un-incorporated community group. */
    Cg,
    /** **crs**

Clinical Research Sponsor. An organization that is identified as a Pharmaceutical/Clinical Research Sponsor. */
    Crs,
    /** **dept**

Hospital Department. A department or ward within a hospital (Generally is not applicable to top level organizations) */
    Dept,
    /** **edu**

Educational Institute. An educational institution that provides education or research facilities. */
    Edu,
    /** **govt**

Government. A political body, often used when including organization records for government bodies such as a Federal Government, State or Local Government. */
    Govt,
    /** **ins**

Insurance Company. A company that provides insurance to its subscribers that may include healthcare related policies. */
    Ins,
    /** **other**

Other. Other type of organization not already specified. */
    Other,
    /** **prov**

Healthcare Provider. An organization that provides healthcare services. */
    Prov,
    /** **reli**

Religious Institution. An organization that is identified as a part of a religious institution. */
    Reli,
    /** **team**

Organizational team. An organizational team is usually a grouping of practitioners that perform a specific function within an organization (which could be a top level organization, or a department). */
    Team,
}
impl ::core::str::FromStr for OrganizationType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bus" => Ok(Self::Bus),
            "cg" => Ok(Self::Cg),
            "crs" => Ok(Self::Crs),
            "dept" => Ok(Self::Dept),
            "edu" => Ok(Self::Edu),
            "govt" => Ok(Self::Govt),
            "ins" => Ok(Self::Ins),
            "other" => Ok(Self::Other),
            "prov" => Ok(Self::Prov),
            "reli" => Ok(Self::Reli),
            "team" => Ok(Self::Team),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OrganizationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bus => "bus",
            Self::Cg => "cg",
            Self::Crs => "crs",
            Self::Dept => "dept",
            Self::Edu => "edu",
            Self::Govt => "govt",
            Self::Ins => "ins",
            Self::Other => "other",
            Self::Prov => "prov",
            Self::Reli => "reli",
            Self::Team => "team",
        }
    }
}
impl ::std::fmt::Debug for OrganizationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for OrganizationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for OrganizationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OrganizationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OrganizationType> for Coding {
    fn from(code: OrganizationType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/organization-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<OrganizationType> for CodeableConcept {
    fn from(code: OrganizationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ParticipantRequired](http://hl7.org/fhir/ValueSet/participantrequired)**. Is the Participant required to attend the appointment.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ParticipantRequired {
    /** **information-only**

Information Only. The participant is excluded from the appointment, and may not be informed of the appointment taking place. (Appointment is about them, not for them - such as 2 doctors discussing results about a patient's test). */
    InformationOnly,
    /** **optional**

Optional. The participant may optionally attend the appointment. */
    Optional,
    /** **required**

Required. The participant is required to attend the appointment. */
    Required,
}
impl ::core::str::FromStr for ParticipantRequired {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "information-only" => Ok(Self::InformationOnly),
            "optional" => Ok(Self::Optional),
            "required" => Ok(Self::Required),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ParticipantRequired {
    fn as_ref(&self) -> &str {
        match self {
            Self::InformationOnly => "information-only",
            Self::Optional => "optional",
            Self::Required => "required",
        }
    }
}
impl ::std::fmt::Debug for ParticipantRequired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ParticipantRequired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ParticipantRequired {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipantRequired {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ParticipantRequired> for Coding {
    fn from(code: ParticipantRequired) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/participantrequired".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ParticipantRequired> for CodeableConcept {
    fn from(code: ParticipantRequired) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ParticipantType](http://hl7.org/fhir/ValueSet/encounter-participant-type)**. This value set defines a set of codes that can be used to indicate how an individual participates in an encounter.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ParticipantType {
    /** **emergency**

Emergency. A person to be contacted in case of an emergency during the encounter. */
    Emergency,
    /** **translator**

Translator. A translator who is facilitating communication with the patient during the encounter. */
    Translator,
}
impl ::core::str::FromStr for ParticipantType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "emergency" => Ok(Self::Emergency),
            "translator" => Ok(Self::Translator),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Emergency => "emergency",
            Self::Translator => "translator",
        }
    }
}
impl ::std::fmt::Debug for ParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ParticipantType> for Coding {
    fn from(code: ParticipantType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/encounter-participant-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ParticipantType> for CodeableConcept {
    fn from(code: ParticipantType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ParticipationStatus](http://hl7.org/fhir/ValueSet/participationstatus)**. The Participation status of an appointment.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ParticipationStatus {
    /** **accepted**

Accepted. The participant has accepted the appointment. */
    Accepted,
    /** **declined**

Declined. The participant has declined the appointment and will not participate in the appointment. */
    Declined,
    /** **needs-action**

Needs Action. The participant needs to indicate if they accept the appointment by changing this status to one of the other statuses. */
    NeedsAction,
    /** **tentative**

Tentative. The participant has  tentatively accepted the appointment. This could be automatically created by a system and requires further processing before it can be accepted. There is no commitment that attendance will occur. */
    Tentative,
}
impl ::core::str::FromStr for ParticipationStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "declined" => Ok(Self::Declined),
            "needs-action" => Ok(Self::NeedsAction),
            "tentative" => Ok(Self::Tentative),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ParticipationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Declined => "declined",
            Self::NeedsAction => "needs-action",
            Self::Tentative => "tentative",
        }
    }
}
impl ::std::fmt::Debug for ParticipationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ParticipationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ParticipationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ParticipationStatus> for Coding {
    fn from(code: ParticipationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/participationstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ParticipationStatus> for CodeableConcept {
    fn from(code: ParticipationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PayeeResourceType](http://hl7.org/fhir/ValueSet/resource-type-link)**. The type of payee Resource\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PayeeResourceType {
    /** **organization**

Organization. Organization resource */
    Organization,
    /** **patient**

Patient. Patient resource */
    Patient,
    /** **practitioner**

Practitioner. Practitioner resource */
    Practitioner,
    /** **relatedperson**

RelatedPerson. RelatedPerson resource */
    Relatedperson,
}
impl ::core::str::FromStr for PayeeResourceType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "organization" => Ok(Self::Organization),
            "patient" => Ok(Self::Patient),
            "practitioner" => Ok(Self::Practitioner),
            "relatedperson" => Ok(Self::Relatedperson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PayeeResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Organization => "organization",
            Self::Patient => "patient",
            Self::Practitioner => "practitioner",
            Self::Relatedperson => "relatedperson",
        }
    }
}
impl ::std::fmt::Debug for PayeeResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PayeeResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PayeeResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PayeeResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PayeeResourceType> for Coding {
    fn from(code: PayeeResourceType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/resource-type-link".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PayeeResourceType> for CodeableConcept {
    fn from(code: PayeeResourceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PlanDefinitionType](http://hl7.org/fhir/ValueSet/plan-definition-type)**. The type of PlanDefinition\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PlanDefinitionType {
    /** **eca-rule**

ECA Rule. A decision support rule of the form [on Event] if Condition then Action. It is intended to be a shareable, computable definition of actions that should be taken whenever some condition is met in response to a particular event or events */
    EcaRule,
    /** **order-set**

Order Set. A pre-defined and approved group of orders related to a particular clinical condition (e.g. hypertension treatment and monitoring) or stage of care (e.g. hospital admission to Coronary Care Unit). An order set is used as a checklist for the clinician when managing a patient with a specific condition. It is a structured collection of orders relevant to that condition and presented to the clinician in a computerized provider order entry (CPOE) system */
    OrderSet,
    /** **protocol**

Protocol. A set of activities that can be performed that have relationships in terms of order, pre-conditions, etc. */
    Protocol,
}
impl ::core::str::FromStr for PlanDefinitionType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "eca-rule" => Ok(Self::EcaRule),
            "order-set" => Ok(Self::OrderSet),
            "protocol" => Ok(Self::Protocol),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PlanDefinitionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::EcaRule => "eca-rule",
            Self::OrderSet => "order-set",
            Self::Protocol => "protocol",
        }
    }
}
impl ::std::fmt::Debug for PlanDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PlanDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PlanDefinitionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PlanDefinitionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PlanDefinitionType> for Coding {
    fn from(code: PlanDefinitionType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/plan-definition-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PlanDefinitionType> for CodeableConcept {
    fn from(code: PlanDefinitionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PractitionerRole](http://hl7.org/fhir/ValueSet/practitioner-role)**. This example value set defines a set of codes that can be used to indicate the role of a Practitioner.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PractitionerRole {
    /** **doctor**

Doctor. A qualified/registered medical practitioner */
    Doctor,
    /** **ict**

ICT professional. Someone who is qualified in Information and Communication Technologies */
    Ict,
    /** **nurse**

Nurse. A practitoner with nursing experience that may be qualified/registered */
    Nurse,
    /** **pharmacist**

Pharmacist. A qualified/registered/licensed pharmacist */
    Pharmacist,
    /** **researcher**

Researcher. A practitioner that may perform research */
    Researcher,
    /** **teacher**

Teacher/educator. Someone who is able to provide educational services */
    Teacher,
}
impl ::core::str::FromStr for PractitionerRole {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "doctor" => Ok(Self::Doctor),
            "ict" => Ok(Self::Ict),
            "nurse" => Ok(Self::Nurse),
            "pharmacist" => Ok(Self::Pharmacist),
            "researcher" => Ok(Self::Researcher),
            "teacher" => Ok(Self::Teacher),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PractitionerRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Doctor => "doctor",
            Self::Ict => "ict",
            Self::Nurse => "nurse",
            Self::Pharmacist => "pharmacist",
            Self::Researcher => "researcher",
            Self::Teacher => "teacher",
        }
    }
}
impl ::std::fmt::Debug for PractitionerRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PractitionerRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PractitionerRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PractitionerRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PractitionerRole> for Coding {
    fn from(code: PractitionerRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/practitioner-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PractitionerRole> for CodeableConcept {
    fn from(code: PractitionerRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PractitionerSpecialty](http://hl7.org/fhir/ValueSet/practitioner-specialty)**. This example value set defines a set of codes that can be used to indicate the specialty of a Practitioner.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PractitionerSpecialty {
    /** **cardio**

Cardiologist. */
    Cardio,
    /** **dent**

Dentist. */
    Dent,
    /** **dietary**

Dietary consultant. */
    Dietary,
    /** **midw**

Midwife. */
    Midw,
    /** **sysarch**

Systems architect. */
    Sysarch,
}
impl ::core::str::FromStr for PractitionerSpecialty {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cardio" => Ok(Self::Cardio),
            "dent" => Ok(Self::Dent),
            "dietary" => Ok(Self::Dietary),
            "midw" => Ok(Self::Midw),
            "sysarch" => Ok(Self::Sysarch),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PractitionerSpecialty {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cardio => "cardio",
            Self::Dent => "dent",
            Self::Dietary => "dietary",
            Self::Midw => "midw",
            Self::Sysarch => "sysarch",
        }
    }
}
impl ::std::fmt::Debug for PractitionerSpecialty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PractitionerSpecialty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PractitionerSpecialty {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PractitionerSpecialty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PractitionerSpecialty> for Coding {
    fn from(code: PractitionerSpecialty) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/practitioner-specialty".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PractitionerSpecialty> for CodeableConcept {
    fn from(code: PractitionerSpecialty) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PropertyRepresentation](http://hl7.org/fhir/ValueSet/property-representation)**. How a property is represented when serialized.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PropertyRepresentation {
    /** **cdaText**

CDA Text Format. Use CDA narrative instead of XHTML */
    CdaText,
    /** **typeAttr**

Type Attribute. The type of this element is indicated using xsi:type */
    TypeAttr,
    /** **xhtml**

XHTML. The property is represented using XHTML */
    Xhtml,
    /** **xmlAttr**

XML Attribute. In XML, this property is represented as an attribute not an element. */
    XmlAttr,
    /** **xmlText**

XML Text. This element is represented using the XML text attribute (primitives only) */
    XmlText,
}
impl ::core::str::FromStr for PropertyRepresentation {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cdaText" => Ok(Self::CdaText),
            "typeAttr" => Ok(Self::TypeAttr),
            "xhtml" => Ok(Self::Xhtml),
            "xmlAttr" => Ok(Self::XmlAttr),
            "xmlText" => Ok(Self::XmlText),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PropertyRepresentation {
    fn as_ref(&self) -> &str {
        match self {
            Self::CdaText => "cdaText",
            Self::TypeAttr => "typeAttr",
            Self::Xhtml => "xhtml",
            Self::XmlAttr => "xmlAttr",
            Self::XmlText => "xmlText",
        }
    }
}
impl ::std::fmt::Debug for PropertyRepresentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PropertyRepresentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PropertyRepresentation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PropertyRepresentation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PropertyRepresentation> for Coding {
    fn from(code: PropertyRepresentation) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/property-representation".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PropertyRepresentation> for CodeableConcept {
    fn from(code: PropertyRepresentation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PropertyType](http://hl7.org/fhir/ValueSet/concept-property-type)**. The type of a property value\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PropertyType {
    /** **Coding**

Coding (external reference). The property  value is a code defined in an external code system. This may be used for translations, but is not the intent */
    Coding,
    /** **boolean**

boolean. The property value is a boolean true | false */
    Boolean,
    /** **code**

code (internal reference). The property value is a code that identifies a concept defined in the code system */
    Code,
    /** **dateTime**

dateTime. The property is a date or a date + time */
    DateTime,
    /** **integer**

integer. The property value is a string (often used to assign ranking values to concepts for supporting score assessments) */
    Integer,
    /** **string**

string. The property value is a string */
    String,
}
impl ::core::str::FromStr for PropertyType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Coding" => Ok(Self::Coding),
            "boolean" => Ok(Self::Boolean),
            "code" => Ok(Self::Code),
            "dateTime" => Ok(Self::DateTime),
            "integer" => Ok(Self::Integer),
            "string" => Ok(Self::String),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PropertyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Coding => "Coding",
            Self::Boolean => "boolean",
            Self::Code => "code",
            Self::DateTime => "dateTime",
            Self::Integer => "integer",
            Self::String => "string",
        }
    }
}
impl ::std::fmt::Debug for PropertyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PropertyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PropertyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PropertyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PropertyType> for Coding {
    fn from(code: PropertyType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/concept-property-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PropertyType> for CodeableConcept {
    fn from(code: PropertyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProvenanceEntityRole](http://hl7.org/fhir/ValueSet/provenance-entity-role)**. How an entity was used in an activity.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProvenanceEntityRole {
    /** **derivation**

Derivation. A transformation of an entity into another, an update of an entity resulting in a new one, or the construction of a new entity based on a preexisting entity. */
    Derivation,
    /** **quotation**

Quotation. The repeat of (some or all of) an entity, such as text or image, by someone who may or may not be its original author. */
    Quotation,
    /** **removal**

Removal. A derivation for which the entity is removed from accessibility usually through the use of the Delete operation. */
    Removal,
    /** **revision**

Revision. A derivation for which the resulting entity is a revised version of some original. */
    Revision,
    /** **source**

Source. A primary source for a topic refers to something produced by some agent with direct experience and knowledge about the topic, at the time of the topic's study, without benefit from hindsight. */
    Source,
}
impl ::core::str::FromStr for ProvenanceEntityRole {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "derivation" => Ok(Self::Derivation),
            "quotation" => Ok(Self::Quotation),
            "removal" => Ok(Self::Removal),
            "revision" => Ok(Self::Revision),
            "source" => Ok(Self::Source),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProvenanceEntityRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Derivation => "derivation",
            Self::Quotation => "quotation",
            Self::Removal => "removal",
            Self::Revision => "revision",
            Self::Source => "source",
        }
    }
}
impl ::std::fmt::Debug for ProvenanceEntityRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProvenanceEntityRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProvenanceEntityRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProvenanceEntityRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProvenanceEntityRole> for Coding {
    fn from(code: ProvenanceEntityRole) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/provenance-entity-role".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProvenanceEntityRole> for CodeableConcept {
    fn from(code: ProvenanceEntityRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PublicationStatus](http://hl7.org/fhir/ValueSet/publication-status)**. The lifecycle status of a Value Set or Concept Map.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PublicationStatus {
    /** **active**

Active. This resource is ready for normal use. */
    Active,
    /** **draft**

Draft. This resource is still under development and is not yet considered to be ready for normal use. */
    Draft,
    /** **retired**

Retired. This resource has been withdrawn or superseded and should no longer be used. */
    Retired,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this resource.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for PublicationStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "retired" => Ok(Self::Retired),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PublicationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::Retired => "retired",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for PublicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PublicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PublicationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PublicationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PublicationStatus> for Coding {
    fn from(code: PublicationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/publication-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PublicationStatus> for CodeableConcept {
    fn from(code: PublicationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QualityOfEvidenceRating](http://hl7.org/fhir/ValueSet/cqif-evidence-quality)**. A rating system that describes the quality of evidence such as the GRADE, DynaMed, or Oxford CEBM systems\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QualityOfEvidenceRating {
    /** **high**

High quality. High quality evidence */
    High,
    /** **low**

Low quality. Low quality evidence */
    Low,
    /** **moderate**

Moderate quality. Moderate quality evidence */
    Moderate,
    /** **very-low**

Very low quality. Very low quality evidence */
    VeryLow,
}
impl ::core::str::FromStr for QualityOfEvidenceRating {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            "very-low" => Ok(Self::VeryLow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QualityOfEvidenceRating {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
            Self::VeryLow => "very-low",
        }
    }
}
impl ::std::fmt::Debug for QualityOfEvidenceRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QualityOfEvidenceRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QualityOfEvidenceRating {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QualityOfEvidenceRating {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QualityOfEvidenceRating> for Coding {
    fn from(code: QualityOfEvidenceRating) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/cqif-evidence-quality".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QualityOfEvidenceRating> for CodeableConcept {
    fn from(code: QualityOfEvidenceRating) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuantityComparator](http://hl7.org/fhir/ValueSet/quantity-comparator)**. How the Quantity should be understood and represented.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuantityComparator {
    /** **<**

Less than. The actual value is less than the given value. */
    Less,
    /** **<=**

Less or Equal to. The actual value is less than or equal to the given value. */
    LessOrEqual,
    /** **>**

Greater than. The actual value is greater than the given value. */
    Greater,
    /** **>=**

Greater or Equal to. The actual value is greater than or equal to the given value. */
    GreaterOrEqual,
}
impl ::core::str::FromStr for QuantityComparator {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "<" => Ok(Self::Less),
            "<=" => Ok(Self::LessOrEqual),
            ">" => Ok(Self::Greater),
            ">=" => Ok(Self::GreaterOrEqual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuantityComparator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Less => "<",
            Self::LessOrEqual => "<=",
            Self::Greater => ">",
            Self::GreaterOrEqual => ">=",
        }
    }
}
impl ::std::fmt::Debug for QuantityComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuantityComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuantityComparator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuantityComparator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuantityComparator> for Coding {
    fn from(code: QuantityComparator) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/quantity-comparator".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuantityComparator> for CodeableConcept {
    fn from(code: QuantityComparator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuestionnaireItemType](http://hl7.org/fhir/ValueSet/item-type)**. Distinguishes groups from questions and display text and indicates data type for questions\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuestionnaireItemType {
    /** **attachment**

Attachment. Question with binary content such as a image, PDF, etc. as an answer (valueAttachment) */
    Attachment,
    /** **boolean**

Boolean. Question with a yes/no answer (valueBoolean) */
    Boolean,
    /** **choice**

Choice. Question with a Coding drawn from a list of options (specified in either the option property, or via the valueset referenced in the options property) as an answer (valueCoding) */
    Choice,
    /** **date**

Date. Question with a date answer (valueDate) */
    Date,
    /** **dateTime**

Date Time. Question with a date and time answer (valueDateTime) */
    DateTime,
    /** **decimal**

Decimal. Question with is a real number answer (valueDecimal) */
    Decimal,
    /** **display**

Display. Text for display that will not capture an answer or have child items. */
    Display,
    /** **group**

Group. An item with no direct answer but should have at least one child item. */
    Group,
    /** **integer**

Integer. Question with an integer answer (valueInteger) */
    Integer,
    /** **open-choice**

Open Choice. Answer is a Coding drawn from a list of options (as with the choice type) or a free-text entry in a string (valueCoding or valueString) */
    OpenChoice,
    /** **quantity**

Quantity. Question with a combination of a numeric value and unit, potentially with a comparator (<, >, etc.) as an answer. (valueQuantity)
There is an extension 'http://hl7.org/fhir/StructureDefinition/questionnaire-unit' that can be used to define what unit whould be captured (or the a unit that has a ucum conversion from the provided unit) */
    Quantity,
    /** **question**

Question. An item that defines a specific answer to be captured, and may have child items.
(the answer provided in the QuestionnaireResponse should be of the defined datatype) */
    Question,
    /** **reference**

Reference. Question with a reference to another resource (practitioner, organization, etc.) as an answer (valueReference) */
    Reference,
    /** **string**

String. Question with a short (few words to short sentence) free-text entry answer (valueString) */
    String,
    /** **text**

Text. Question with a long (potentially multi-paragraph) free-text entry answer (valueString) */
    Text,
    /** **time**

Time. Question with a time (hour:minute:second) answer independent of date. (valueTime) */
    Time,
    /** **url**

Url. Question with a URL (website, FTP site, etc.) answer (valueUri) */
    Url,
}
impl ::core::str::FromStr for QuestionnaireItemType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "attachment" => Ok(Self::Attachment),
            "boolean" => Ok(Self::Boolean),
            "choice" => Ok(Self::Choice),
            "date" => Ok(Self::Date),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "display" => Ok(Self::Display),
            "group" => Ok(Self::Group),
            "integer" => Ok(Self::Integer),
            "open-choice" => Ok(Self::OpenChoice),
            "quantity" => Ok(Self::Quantity),
            "question" => Ok(Self::Question),
            "reference" => Ok(Self::Reference),
            "string" => Ok(Self::String),
            "text" => Ok(Self::Text),
            "time" => Ok(Self::Time),
            "url" => Ok(Self::Url),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attachment => "attachment",
            Self::Boolean => "boolean",
            Self::Choice => "choice",
            Self::Date => "date",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Display => "display",
            Self::Group => "group",
            Self::Integer => "integer",
            Self::OpenChoice => "open-choice",
            Self::Quantity => "quantity",
            Self::Question => "question",
            Self::Reference => "reference",
            Self::String => "string",
            Self::Text => "text",
            Self::Time => "time",
            Self::Url => "url",
        }
    }
}
impl ::std::fmt::Debug for QuestionnaireItemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuestionnaireItemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireItemType> for Coding {
    fn from(code: QuestionnaireItemType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/item-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuestionnaireItemType> for CodeableConcept {
    fn from(code: QuestionnaireItemType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuestionnaireItemUsageMode](http://hl7.org/fhir/ValueSet/questionnaire-usage-mode)**. Identifies the modes of usage of a questionnaire that should enable a particular questionnaire item\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuestionnaireItemUsageMode {
    /** **capture**

Capture Only. Render the item only when capturing data */
    Capture,
    /** **capture-display**

Capture & Display. Render the item regardless of usage mode */
    CaptureDisplay,
    /** **capture-display-non-empty**

Capture or, if answered, Display. Render the item when capturing data or when displaying a completed form and the item has been answered (or has child items that have been answered) */
    CaptureDisplayNonEmpty,
    /** **display**

Display Only. Render the item only when displaying a completed form */
    Display,
    /** **display-non-empty**

Display when Answered. Render the item only when displaying a completed form and the item has been answered (or has child items that have been answered) */
    DisplayNonEmpty,
}
impl ::core::str::FromStr for QuestionnaireItemUsageMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "capture" => Ok(Self::Capture),
            "capture-display" => Ok(Self::CaptureDisplay),
            "capture-display-non-empty" => Ok(Self::CaptureDisplayNonEmpty),
            "display" => Ok(Self::Display),
            "display-non-empty" => Ok(Self::DisplayNonEmpty),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemUsageMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Capture => "capture",
            Self::CaptureDisplay => "capture-display",
            Self::CaptureDisplayNonEmpty => "capture-display-non-empty",
            Self::Display => "display",
            Self::DisplayNonEmpty => "display-non-empty",
        }
    }
}
impl ::std::fmt::Debug for QuestionnaireItemUsageMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuestionnaireItemUsageMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemUsageMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemUsageMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireItemUsageMode> for Coding {
    fn from(code: QuestionnaireItemUsageMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/questionnaire-usage-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuestionnaireItemUsageMode> for CodeableConcept {
    fn from(code: QuestionnaireItemUsageMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuestionnaireResponseStatus](http://hl7.org/fhir/ValueSet/questionnaire-answers-status)**. Lifecycle status of the questionnaire response.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuestionnaireResponseStatus {
    /** **amended**

Amended. This QuestionnaireResponse has been filled out with answers, then marked as complete, yet changes or additions have been made to it afterwards. */
    Amended,
    /** **completed**

Completed. This QuestionnaireResponse has been filled out with answers, and the current content is regarded as definitive. */
    Completed,
    /** **entered-in-error**

Entered in Error. This QuestionnaireResponse was entered in error and voided. */
    EnteredInError,
    /** **in-progress**

In Progress. This QuestionnaireResponse has been partially filled out with answers, but changes or additions are still expected to be made to it. */
    InProgress,
    /** **stopped**

Stopped. This QuestionnaireResponse has been partially filled out with answers, but has been abandoned. It is unknown whether changes or additions are expected to be made to it. */
    Stopped,
}
impl ::core::str::FromStr for QuestionnaireResponseStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireResponseStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Stopped => "stopped",
        }
    }
}
impl ::std::fmt::Debug for QuestionnaireResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuestionnaireResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuestionnaireResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireResponseStatus> for Coding {
    fn from(code: QuestionnaireResponseStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/questionnaire-answers-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuestionnaireResponseStatus> for CodeableConcept {
    fn from(code: QuestionnaireResponseStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReferenceHandlingPolicy](http://hl7.org/fhir/ValueSet/reference-handling-policy)**. A set of flags that defines how references are supported.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ReferenceHandlingPolicy {
    /** **enforced**

Reference Integrity Enforced. The server enforces that references have integrity - e.g. it ensures that references can always be resolved. This is typically the case for clinical record systems, but often not the case for middleware/proxy systems */
    Enforced,
    /** **literal**

Literal References. The server supports and populates Literal references where they are known (this code does not guarantee that all references are literal; see 'enforced') */
    Literal,
    /** **local**

Local References Only. The server does not support references that point to other servers */
    Local,
    /** **logical**

Logical References. The server allows logical references */
    Logical,
    /** **resolves**

Resolves References. The server will attempt to resolve logical references to literal references (if resolution fails, the server may still accept resources; see logical) */
    Resolves,
}
impl ::core::str::FromStr for ReferenceHandlingPolicy {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "enforced" => Ok(Self::Enforced),
            "literal" => Ok(Self::Literal),
            "local" => Ok(Self::Local),
            "logical" => Ok(Self::Logical),
            "resolves" => Ok(Self::Resolves),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferenceHandlingPolicy {
    fn as_ref(&self) -> &str {
        match self {
            Self::Enforced => "enforced",
            Self::Literal => "literal",
            Self::Local => "local",
            Self::Logical => "logical",
            Self::Resolves => "resolves",
        }
    }
}
impl ::std::fmt::Debug for ReferenceHandlingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReferenceHandlingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReferenceHandlingPolicy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferenceHandlingPolicy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReferenceHandlingPolicy> for Coding {
    fn from(code: ReferenceHandlingPolicy) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/reference-handling-policy".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReferenceHandlingPolicy> for CodeableConcept {
    fn from(code: ReferenceHandlingPolicy) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReferenceVersionRules](http://hl7.org/fhir/ValueSet/reference-version-rules)**. Whether a reference needs to be version specific or version independent, or whether either can be used\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ReferenceVersionRules {
    /** **either**

Either Specific or independent. The reference may be either version independent or version specific */
    Either,
    /** **independent**

Version independent. The reference must be version independent */
    Independent,
    /** **specific**

Version Specific. The reference must be version specific */
    Specific,
}
impl ::core::str::FromStr for ReferenceVersionRules {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "either" => Ok(Self::Either),
            "independent" => Ok(Self::Independent),
            "specific" => Ok(Self::Specific),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferenceVersionRules {
    fn as_ref(&self) -> &str {
        match self {
            Self::Either => "either",
            Self::Independent => "independent",
            Self::Specific => "specific",
        }
    }
}
impl ::std::fmt::Debug for ReferenceVersionRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReferenceVersionRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReferenceVersionRules {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferenceVersionRules {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReferenceVersionRules> for Coding {
    fn from(code: ReferenceVersionRules) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/reference-version-rules".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReferenceVersionRules> for CodeableConcept {
    fn from(code: ReferenceVersionRules) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReferralMethod](http://hl7.org/fhir/ValueSet/service-referral-method)**. The methods of referral can be used when referring to a specific HealthCareService resource.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ReferralMethod {
    /** **elec**

Secure Messaging. Referrals may be accepted via a secure messaging system. To determine the types of secure messaging systems supported, refer to the identifiers collection. Callers will need to understand the specific identifier system used to know that they are able to transmit messages. */
    Elec,
    /** **fax**

Fax. Referrals may be accepted by fax. */
    Fax,
    /** **mail**

Mail. Referrals may be accepted via regular postage (or hand delivered). */
    Mail,
    /** **phone**

Phone. Referrals may be accepted over the phone from a practitioner. */
    Phone,
    /** **semail**

Secure Email. Referrals may be accepted via a secure email. To send please encrypt with the services public key. */
    Semail,
}
impl ::core::str::FromStr for ReferralMethod {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "elec" => Ok(Self::Elec),
            "fax" => Ok(Self::Fax),
            "mail" => Ok(Self::Mail),
            "phone" => Ok(Self::Phone),
            "semail" => Ok(Self::Semail),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferralMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Elec => "elec",
            Self::Fax => "fax",
            Self::Mail => "mail",
            Self::Phone => "phone",
            Self::Semail => "semail",
        }
    }
}
impl ::std::fmt::Debug for ReferralMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReferralMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReferralMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferralMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReferralMethod> for Coding {
    fn from(code: ReferralMethod) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/service-referral-method".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReferralMethod> for CodeableConcept {
    fn from(code: ReferralMethod) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RelatedArtifactType](http://hl7.org/fhir/ValueSet/related-artifact-type)**. The type of relationship to the related artifact\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RelatedArtifactType {
    /** **citation**

Citation. Bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource */
    Citation,
    /** **composed-of**

Composed Of. The knowledge resource is composed of the given related artifact */
    ComposedOf,
    /** **depends-on**

Depends On. The knowledge resource depends on the given related artifact */
    DependsOn,
    /** **derived-from**

Derived From. The knowledge resource is derived from the related artifact. This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but is modified to capture either a different set of overall requirements, or a more specific set of requirements such as those involved in a particular institution or clinical setting */
    DerivedFrom,
    /** **documentation**

Documentation. Additional documentation for the knowledge resource. This would include additional instructions on usage as well as additional information on clinical context or appropriateness */
    Documentation,
    /** **justification**

Justification. A summary of the justification for the knowledge resource including supporting evidence, relevant guidelines, or other clinically important information. This information is intended to provide a way to make the justification for the knowledge resource available to the consumer of interventions or results produced by the knowledge resource */
    Justification,
    /** **predecessor**

Predecessor. The previous version of the knowledge resource */
    Predecessor,
    /** **successor**

Successor. The next version of the knowledge resource */
    Successor,
}
impl ::core::str::FromStr for RelatedArtifactType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "citation" => Ok(Self::Citation),
            "composed-of" => Ok(Self::ComposedOf),
            "depends-on" => Ok(Self::DependsOn),
            "derived-from" => Ok(Self::DerivedFrom),
            "documentation" => Ok(Self::Documentation),
            "justification" => Ok(Self::Justification),
            "predecessor" => Ok(Self::Predecessor),
            "successor" => Ok(Self::Successor),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RelatedArtifactType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Citation => "citation",
            Self::ComposedOf => "composed-of",
            Self::DependsOn => "depends-on",
            Self::DerivedFrom => "derived-from",
            Self::Documentation => "documentation",
            Self::Justification => "justification",
            Self::Predecessor => "predecessor",
            Self::Successor => "successor",
        }
    }
}
impl ::std::fmt::Debug for RelatedArtifactType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RelatedArtifactType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RelatedArtifactType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RelatedArtifactType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RelatedArtifactType> for Coding {
    fn from(code: RelatedArtifactType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/related-artifact-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RelatedArtifactType> for CodeableConcept {
    fn from(code: RelatedArtifactType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RequestIntent](http://hl7.org/fhir/ValueSet/request-intent)**. Codes indicating the degree of authority/intentionality associated with a request\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RequestIntent {
    /** **filler-order**

Filler Order. The request represents the view of an authorization instantiated by a fulfilling system representing the details of the fulfiller's intention to act upon a submitted order */
    FillerOrder,
    /** **instance-order**

Instance Order. An order created in fulfillment of a broader order that represents the authorization for a single activity occurrence.  E.g. The administration of a single dose of a drug. */
    InstanceOrder,
    /** **option**

Option. The request represents a component or option for a RequestGroup that establishes timing, conditionality and/or other constraints among a set of requests.

Refer to [[[RequestGroup]]] for additional information on how this status is used */
    Option,
    /** **order**

Order. The request represents a request/demand and authorization for action */
    Order,
    /** **original-order**

Original Order. The request represents an original authorization for action */
    OriginalOrder,
    /** **plan**

Plan. The request represents an intension to ensure something occurs without providing an authorization for others to act */
    Plan,
    /** **proposal**

Proposal. The request is a suggestion made by someone/something that doesn't have an intention to ensure it occurs and without providing an authorization to act */
    Proposal,
    /** **reflex-order**

Reflex Order. The request represents an automatically generated supplemental authorization for action based on a parent authorization together with initial results of the action taken against that parent authorization */
    ReflexOrder,
}
impl ::core::str::FromStr for RequestIntent {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "filler-order" => Ok(Self::FillerOrder),
            "instance-order" => Ok(Self::InstanceOrder),
            "option" => Ok(Self::Option),
            "order" => Ok(Self::Order),
            "original-order" => Ok(Self::OriginalOrder),
            "plan" => Ok(Self::Plan),
            "proposal" => Ok(Self::Proposal),
            "reflex-order" => Ok(Self::ReflexOrder),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::FillerOrder => "filler-order",
            Self::InstanceOrder => "instance-order",
            Self::Option => "option",
            Self::Order => "order",
            Self::OriginalOrder => "original-order",
            Self::Plan => "plan",
            Self::Proposal => "proposal",
            Self::ReflexOrder => "reflex-order",
        }
    }
}
impl ::std::fmt::Debug for RequestIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RequestIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RequestIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestIntent> for Coding {
    fn from(code: RequestIntent) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/request-intent".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RequestIntent> for CodeableConcept {
    fn from(code: RequestIntent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RequestPriority](http://hl7.org/fhir/ValueSet/request-priority)**. Identifies the level of importance to be assigned to actioning the request\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RequestPriority {
    /** **asap**

ASAP. The request should be actioned as soon as possible - higher priority than urgent */
    Asap,
    /** **routine**

Routine. The request has normal priority */
    Routine,
    /** **stat**

STAT. The request should be actioned immediately - highest possible priority.  E.g. an emergency */
    Stat,
    /** **urgent**

Urgent. The request should be actioned promptly - higher priority than routine */
    Urgent,
}
impl ::core::str::FromStr for RequestPriority {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "asap" => Ok(Self::Asap),
            "routine" => Ok(Self::Routine),
            "stat" => Ok(Self::Stat),
            "urgent" => Ok(Self::Urgent),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestPriority {
    fn as_ref(&self) -> &str {
        match self {
            Self::Asap => "asap",
            Self::Routine => "routine",
            Self::Stat => "stat",
            Self::Urgent => "urgent",
        }
    }
}
impl ::std::fmt::Debug for RequestPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RequestPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RequestPriority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestPriority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestPriority> for Coding {
    fn from(code: RequestPriority) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/request-priority".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RequestPriority> for CodeableConcept {
    fn from(code: RequestPriority) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RequestStatus](http://hl7.org/fhir/ValueSet/request-status)**. Codes identifying the stage lifecycle stage of a request\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RequestStatus {
    /** **active**

Active. The request is ready to be acted upon */
    Active,
    /** **cancelled**

Cancelled. The authorization/request to act has been terminated prior to the full completion of the intended actions.  No further activity should occur. */
    Cancelled,
    /** **completed**

Completed. Activity against the request has been sufficiently completed to the satisfaction of the requester */
    Completed,
    /** **draft**

Draft. The request has been created but is not yet complete or ready for action */
    Draft,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".) */
    EnteredInError,
    /** **suspended**

Suspended. The authorization/request to act has been temporarily withdrawn but is expected to resume in the future */
    Suspended,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this request.  Note: This concept is not to be used for "other" . One of the listed statuses is presumed to apply,  but the system creating the request doesn't know. */
    Unknown,
}
impl ::core::str::FromStr for RequestStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "suspended" => Ok(Self::Suspended),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Suspended => "suspended",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for RequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RequestStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestStatus> for Coding {
    fn from(code: RequestStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/request-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RequestStatus> for CodeableConcept {
    fn from(code: RequestStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResearchStudyStatus](http://hl7.org/fhir/ValueSet/research-study-status)**. Codes that convey the current status of the research study\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResearchStudyStatus {
    /** **completed**

Completed. The information sought by the study has been gathered and compiled and no further work is being performed */
    Completed,
    /** **draft**

Draft. The study is undergoing design but the process of selecting study subjects and capturing data has not yet begun. */
    Draft,
    /** **entered-in-error**

Entered in error. This study never actually existed.  The record is retained for tracking purposes in the event decisions may have been made based on this erroneous information. */
    EnteredInError,
    /** **in-progress**

In-progress. The study is currently being executed */
    InProgress,
    /** **stopped**

Stopped. The study was terminated prior to the final determination of results */
    Stopped,
    /** **suspended**

Suspended. Execution of the study has been temporarily paused */
    Suspended,
}
impl ::core::str::FromStr for ResearchStudyStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "stopped" => Ok(Self::Stopped),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Stopped => "stopped",
            Self::Suspended => "suspended",
        }
    }
}
impl ::std::fmt::Debug for ResearchStudyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResearchStudyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResearchStudyStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyStatus> for Coding {
    fn from(code: ResearchStudyStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/research-study-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResearchStudyStatus> for CodeableConcept {
    fn from(code: ResearchStudyStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResearchSubjectStatus](http://hl7.org/fhir/ValueSet/research-subject-status)**. Indicates the progression of a study subject through a study\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResearchSubjectStatus {
    /** **active**

Active. The subject is currently being monitored and/or subject to treatment as part of the study */
    Active,
    /** **candidate**

Candidate. The subject has been identified as a potential participant in the study but has not yet agreed to participate */
    Candidate,
    /** **completed**

Completed. All intended monitoring/treatment of the subject has been completed and their engagement with the study is now ended */
    Completed,
    /** **enrolled**

Enrolled. The subject has agreed to participate in the study but has not yet begun performing any action within the study */
    Enrolled,
    /** **suspended**

Suspended. The subject has temporarily discontinued monitoring/treatment as part of the study */
    Suspended,
    /** **withdrawn**

Withdrawn. The subject has permanently ended participation in the study prior to completion of the intended monitoring/treatment */
    Withdrawn,
}
impl ::core::str::FromStr for ResearchSubjectStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "candidate" => Ok(Self::Candidate),
            "completed" => Ok(Self::Completed),
            "enrolled" => Ok(Self::Enrolled),
            "suspended" => Ok(Self::Suspended),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchSubjectStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Candidate => "candidate",
            Self::Completed => "completed",
            Self::Enrolled => "enrolled",
            Self::Suspended => "suspended",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Debug for ResearchSubjectStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResearchSubjectStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResearchSubjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchSubjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchSubjectStatus> for Coding {
    fn from(code: ResearchSubjectStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/research-subject-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResearchSubjectStatus> for CodeableConcept {
    fn from(code: ResearchSubjectStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResourceType](http://hl7.org/fhir/ValueSet/resource-types)**. One of the resource types defined as part of FHIR.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResourceType {
    /** **Account**

Account. A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc. */
    Account,
    /** **ActivityDefinition**

ActivityDefinition. This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context. */
    ActivityDefinition,
    /** **AdverseEvent**

AdverseEvent. Actual or  potential/avoided event causing unintended physical injury resulting from or contributed to by medical care, a research study or other healthcare setting factors that requires additional monitoring, treatment, or hospitalization, or that results in death. */
    AdverseEvent,
    /** **AllergyIntolerance**

AllergyIntolerance. Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance. */
    AllergyIntolerance,
    /** **Appointment**

Appointment. A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s). */
    Appointment,
    /** **AppointmentResponse**

AppointmentResponse. A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection. */
    AppointmentResponse,
    /** **AuditEvent**

AuditEvent. A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage. */
    AuditEvent,
    /** **Basic**

Basic. Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don't map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification. */
    Basic,
    /** **Binary**

Binary. A binary resource can contain any content, whether text, image, pdf, zip archive, etc. */
    Binary,
    /** **BodySite**

BodySite. Record details about the anatomical location of a specimen or body part.  This resource may be used when a coded concept does not provide the necessary detail needed for the use case. */
    BodySite,
    /** **Bundle**

Bundle. A container for a collection of resources. */
    Bundle,
    /** **CapabilityStatement**

CapabilityStatement. A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation. */
    CapabilityStatement,
    /** **CarePlan**

CarePlan. Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions. */
    CarePlan,
    /** **CareTeam**

CareTeam. The Care Team includes all the people and organizations who plan to participate in the coordination and delivery of care for a patient. */
    CareTeam,
    /** **ChargeItem**

ChargeItem. The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation. */
    ChargeItem,
    /** **Claim**

Claim. A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery. */
    Claim,
    /** **ClaimResponse**

ClaimResponse. This resource provides the adjudication details from the processing of a Claim resource. */
    ClaimResponse,
    /** **ClinicalImpression**

ClinicalImpression. A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score. */
    ClinicalImpression,
    /** **CodeSystem**

CodeSystem. A code system resource specifies a set of codes drawn from one or more code systems. */
    CodeSystem,
    /** **Communication**

Communication. An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency was notified about a reportable condition. */
    Communication,
    /** **CommunicationRequest**

CommunicationRequest. A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition. */
    CommunicationRequest,
    /** **CompartmentDefinition**

CompartmentDefinition. A compartment definition that defines how resources are accessed on a server. */
    CompartmentDefinition,
    /** **Composition**

Composition. A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. While a Composition defines the structure, it does not actually contain the content: rather the full content of a document is contained in a Bundle, of which the Composition is the first resource contained. */
    Composition,
    /** **ConceptMap**

ConceptMap. A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models. */
    ConceptMap,
    /** **Condition**

Condition. A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern. */
    Condition,
    /** **Consent**

Consent. A record of a healthcare consumer’s policy choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time. */
    Consent,
    /** **Contract**

Contract. A formal agreement between parties regarding the conduct of business, exchange of information or other matters. */
    Contract,
    /** **Coverage**

Coverage. Financial instrument which may be used to reimburse or pay for health care products and services. */
    Coverage,
    /** **DataElement**

DataElement. The formal description of a single piece of information that can be gathered and reported. */
    DataElement,
    /** **DetectedIssue**

DetectedIssue. Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc. */
    DetectedIssue,
    /** **Device**

Device. This resource identifies an instance or a type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.  Medical devices include durable (reusable) medical equipment, implantable devices, as well as disposable equipment used for diagnostic, treatment, and research for healthcare and public health.  Non-medical devices may include items such as a machine, cellphone, computer, application, etc. */
    Device,
    /** **DeviceComponent**

DeviceComponent. The characteristics, operational status and capabilities of a medical-related component of a medical device. */
    DeviceComponent,
    /** **DeviceMetric**

DeviceMetric. Describes a measurement, calculation or setting capability of a medical device. */
    DeviceMetric,
    /** **DeviceRequest**

DeviceRequest. Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker. */
    DeviceRequest,
    /** **DeviceUseStatement**

DeviceUseStatement. A record of a device being used by a patient where the record is the result of a report from the patient or another clinician. */
    DeviceUseStatement,
    /** **DiagnosticReport**

DiagnosticReport. The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports. */
    DiagnosticReport,
    /** **DocumentManifest**

DocumentManifest. A collection of documents compiled for a purpose together with metadata that applies to the collection. */
    DocumentManifest,
    /** **DocumentReference**

DocumentReference. A reference to a document. */
    DocumentReference,
    /** **DomainResource**

DomainResource. A resource that includes narrative, extensions, and contained resources. */
    DomainResource,
    /** **EligibilityRequest**

EligibilityRequest. The EligibilityRequest provides patient and insurance coverage information to an insurer for them to respond, in the form of an EligibilityResponse, with information regarding whether the stated coverage is valid and in-force and optionally to provide the insurance details of the policy. */
    EligibilityRequest,
    /** **EligibilityResponse**

EligibilityResponse. This resource provides eligibility and plan details from the processing of an Eligibility resource. */
    EligibilityResponse,
    /** **Encounter**

Encounter. An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient. */
    Encounter,
    /** **Endpoint**

Endpoint. The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information. */
    Endpoint,
    /** **EnrollmentRequest**

EnrollmentRequest. This resource provides the insurance enrollment details to the insurer regarding a specified coverage. */
    EnrollmentRequest,
    /** **EnrollmentResponse**

EnrollmentResponse. This resource provides enrollment and plan details from the processing of an Enrollment resource. */
    EnrollmentResponse,
    /** **EpisodeOfCare**

EpisodeOfCare. An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time. */
    EpisodeOfCare,
    /** **ExpansionProfile**

ExpansionProfile. Resource to define constraints on the Expansion of a FHIR ValueSet. */
    ExpansionProfile,
    /** **ExplanationOfBenefit**

ExplanationOfBenefit. This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided. */
    ExplanationOfBenefit,
    /** **FamilyMemberHistory**

FamilyMemberHistory. Significant health events and conditions for a person related to the patient relevant in the context of care for the patient. */
    FamilyMemberHistory,
    /** **Flag**

Flag. Prospective warnings of potential issues when providing care to the patient. */
    Flag,
    /** **Goal**

Goal. Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc. */
    Goal,
    /** **GraphDefinition**

GraphDefinition. A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set. */
    GraphDefinition,
    /** **Group**

Group. Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization. */
    Group,
    /** **GuidanceResponse**

GuidanceResponse. A guidance response is the formal response to a guidance request, including any output parameters returned by the evaluation, as well as the description of any proposed actions to be taken. */
    GuidanceResponse,
    /** **HealthcareService**

HealthcareService. The details of a healthcare service available at a location. */
    HealthcareService,
    /** **ImagingManifest**

ImagingManifest. A text description of the DICOM SOP instances selected in the ImagingManifest; or the reason for, or significance of, the selection. */
    ImagingManifest,
    /** **ImagingStudy**

ImagingStudy. Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities. */
    ImagingStudy,
    /** **Immunization**

Immunization. Describes the event of a patient being administered a vaccination or a record of a vaccination as reported by a patient, a clinician or another party and may include vaccine reaction information and what vaccination protocol was followed. */
    Immunization,
    /** **ImmunizationRecommendation**

ImmunizationRecommendation. A patient's point-in-time immunization and recommendation (i.e. forecasting a patient's immunization eligibility according to a published schedule) with optional supporting justification. */
    ImmunizationRecommendation,
    /** **ImplementationGuide**

ImplementationGuide. A set of rules of how FHIR is used to solve a particular problem. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts. */
    ImplementationGuide,
    /** **Library**

Library. The Library resource is a general-purpose container for knowledge asset definitions. It can be used to describe and expose existing knowledge assets such as logic libraries and information model descriptions, as well as to describe a collection of knowledge assets. */
    Library,
    /** **Linkage**

Linkage. Identifies two or more records (resource instances) that are referring to the same real-world "occurrence". */
    Linkage,
    /** **List**

List. A set of information summarized from a list of other resources. */
    List,
    /** **Location**

Location. Details and position information for a physical place where services are provided  and resources and participants may be stored, found, contained or accommodated. */
    Location,
    /** **Measure**

Measure. The Measure resource provides the definition of a quality measure. */
    Measure,
    /** **MeasureReport**

MeasureReport. The MeasureReport resource contains the results of evaluating a measure. */
    MeasureReport,
    /** **Media**

Media. A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference. */
    Media,
    /** **Medication**

Medication. This resource is primarily used for the identification and definition of a medication. It covers the ingredients and the packaging for a medication. */
    Medication,
    /** **MedicationAdministration**

MedicationAdministration. Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner. */
    MedicationAdministration,
    /** **MedicationDispense**

MedicationDispense. Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order. */
    MedicationDispense,
    /** **MedicationRequest**

MedicationRequest. An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns. */
    MedicationRequest,
    /** **MedicationStatement**

MedicationStatement. A record of a medication that is being consumed by a patient.   A MedicationStatement may indicate that the patient may be taking the medication now, or has taken the medication in the past or will be taking the medication in the future.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay.   The medication information may come from sources such as the patient's memory, from a prescription bottle,  or from a list of medications the patient, clinician or other party maintains

The primary difference between a medication statement and a medication administration is that the medication administration has complete administration information and is based on actual administration information from the person who administered the medication.  A medication statement is often, if not always, less specific.  There is no required date/time when the medication was administered, in fact we only know that a source has reported the patient is taking this medication, where details such as time, quantity, or rate or even medication product may be incomplete or missing or less precise.  As stated earlier, the medication statement information may come from the patient's memory, from a prescription bottle or from a list of medications the patient, clinician or other party maintains.  Medication administration is more formal and is not missing detailed information. */
    MedicationStatement,
    /** **MessageDefinition**

MessageDefinition. Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted. */
    MessageDefinition,
    /** **MessageHeader**

MessageHeader. The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle. */
    MessageHeader,
    /** **NamingSystem**

NamingSystem. A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types. */
    NamingSystem,
    /** **NutritionOrder**

NutritionOrder. A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident. */
    NutritionOrder,
    /** **Observation**

Observation. Measurements and simple assertions made about a patient, device or other subject. */
    Observation,
    /** **OperationDefinition**

OperationDefinition. A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction). */
    OperationDefinition,
    /** **OperationOutcome**

OperationOutcome. A collection of error, warning or information messages that result from a system action. */
    OperationOutcome,
    /** **Organization**

Organization. A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, etc. */
    Organization,
    /** **Parameters**

Parameters. This special resource type is used to represent an operation request and response (operations.html). It has no other use, and there is no RESTful endpoint associated with it. */
    Parameters,
    /** **Patient**

Patient. Demographics and other administrative information about an individual or animal receiving care or other health-related services. */
    Patient,
    /** **PaymentNotice**

PaymentNotice. This resource provides the status of the payment for goods and services rendered, and the request and response resource references. */
    PaymentNotice,
    /** **PaymentReconciliation**

PaymentReconciliation. This resource provides payment details and claim references supporting a bulk payment. */
    PaymentReconciliation,
    /** **Person**

Person. Demographics and administrative information about a person independent of a specific health-related context. */
    Person,
    /** **PlanDefinition**

PlanDefinition. This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols. */
    PlanDefinition,
    /** **Practitioner**

Practitioner. A person who is directly or indirectly involved in the provisioning of healthcare. */
    Practitioner,
    /** **PractitionerRole**

PractitionerRole. A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time. */
    PractitionerRole,
    /** **Procedure**

Procedure. An action that is or was performed on a patient. This can be a physical intervention like an operation, or less invasive like counseling or hypnotherapy. */
    Procedure,
    /** **ProcedureRequest**

ProcedureRequest. A record of a request for diagnostic investigations, treatments, or operations to be performed. */
    ProcedureRequest,
    /** **ProcessRequest**

ProcessRequest. This resource provides the target, request and response, and action details for an action to be performed by the target on or about existing resources. */
    ProcessRequest,
    /** **ProcessResponse**

ProcessResponse. This resource provides processing status, errors and notes from the processing of a resource. */
    ProcessResponse,
    /** **Provenance**

Provenance. Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies. */
    Provenance,
    /** **Questionnaire**

Questionnaire. A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection. */
    Questionnaire,
    /** **QuestionnaireResponse**

QuestionnaireResponse. A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to. */
    QuestionnaireResponse,
    /** **ReferralRequest**

ReferralRequest. Used to record and send details about a request for referral service or transfer of a patient to the care of another provider or provider organization. */
    ReferralRequest,
    /** **RelatedPerson**

RelatedPerson. Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process. */
    RelatedPerson,
    /** **RequestGroup**

RequestGroup. A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one". */
    RequestGroup,
    /** **ResearchStudy**

ResearchStudy. A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects. */
    ResearchStudy,
    /** **ResearchSubject**

ResearchSubject. A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects. */
    ResearchSubject,
    /** **Resource**

Resource. This is the base resource type for everything. */
    Resource,
    /** **RiskAssessment**

RiskAssessment. An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome. */
    RiskAssessment,
    /** **Schedule**

Schedule. A container for slots of time that may be available for booking appointments. */
    Schedule,
    /** **SearchParameter**

SearchParameter. A search parameter that defines a named search item that can be used to search/filter on a resource. */
    SearchParameter,
    /** **Sequence**

Sequence. Raw data describing a biological sequence. */
    Sequence,
    /** **ServiceDefinition**

ServiceDefinition. The ServiceDefinition describes a unit of decision support functionality that is made available as a service, such as immunization modules or drug-drug interaction checking. */
    ServiceDefinition,
    /** **Slot**

Slot. A slot of time on a schedule that may be available for booking appointments. */
    Slot,
    /** **Specimen**

Specimen. A sample to be used for analysis. */
    Specimen,
    /** **StructureDefinition**

StructureDefinition. A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types. */
    StructureDefinition,
    /** **StructureMap**

StructureMap. A Map of relationships between 2 structures that can be used to transform data. */
    StructureMap,
    /** **Subscription**

Subscription. The subscription resource is used to define a push based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system is able to take an appropriate action. */
    Subscription,
    /** **Substance**

Substance. A homogeneous material with a definite composition. */
    Substance,
    /** **SupplyDelivery**

SupplyDelivery. Record of delivery of what is supplied. */
    SupplyDelivery,
    /** **SupplyRequest**

SupplyRequest. A record of a request for a medication, substance or device used in the healthcare setting. */
    SupplyRequest,
    /** **Task**

Task. A task to be performed. */
    Task,
    /** **TestReport**

TestReport. A summary of information based on the results of executing a TestScript. */
    TestReport,
    /** **TestScript**

TestScript. A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification. */
    TestScript,
    /** **ValueSet**

ValueSet. A value set specifies a set of codes drawn from one or more code systems. */
    ValueSet,
    /** **VisionPrescription**

VisionPrescription. An authorization for the supply of glasses and/or contact lenses to a patient. */
    VisionPrescription,
}
impl ::core::str::FromStr for ResourceType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Account" => Ok(Self::Account),
            "ActivityDefinition" => Ok(Self::ActivityDefinition),
            "AdverseEvent" => Ok(Self::AdverseEvent),
            "AllergyIntolerance" => Ok(Self::AllergyIntolerance),
            "Appointment" => Ok(Self::Appointment),
            "AppointmentResponse" => Ok(Self::AppointmentResponse),
            "AuditEvent" => Ok(Self::AuditEvent),
            "Basic" => Ok(Self::Basic),
            "Binary" => Ok(Self::Binary),
            "BodySite" => Ok(Self::BodySite),
            "Bundle" => Ok(Self::Bundle),
            "CapabilityStatement" => Ok(Self::CapabilityStatement),
            "CarePlan" => Ok(Self::CarePlan),
            "CareTeam" => Ok(Self::CareTeam),
            "ChargeItem" => Ok(Self::ChargeItem),
            "Claim" => Ok(Self::Claim),
            "ClaimResponse" => Ok(Self::ClaimResponse),
            "ClinicalImpression" => Ok(Self::ClinicalImpression),
            "CodeSystem" => Ok(Self::CodeSystem),
            "Communication" => Ok(Self::Communication),
            "CommunicationRequest" => Ok(Self::CommunicationRequest),
            "CompartmentDefinition" => Ok(Self::CompartmentDefinition),
            "Composition" => Ok(Self::Composition),
            "ConceptMap" => Ok(Self::ConceptMap),
            "Condition" => Ok(Self::Condition),
            "Consent" => Ok(Self::Consent),
            "Contract" => Ok(Self::Contract),
            "Coverage" => Ok(Self::Coverage),
            "DataElement" => Ok(Self::DataElement),
            "DetectedIssue" => Ok(Self::DetectedIssue),
            "Device" => Ok(Self::Device),
            "DeviceComponent" => Ok(Self::DeviceComponent),
            "DeviceMetric" => Ok(Self::DeviceMetric),
            "DeviceRequest" => Ok(Self::DeviceRequest),
            "DeviceUseStatement" => Ok(Self::DeviceUseStatement),
            "DiagnosticReport" => Ok(Self::DiagnosticReport),
            "DocumentManifest" => Ok(Self::DocumentManifest),
            "DocumentReference" => Ok(Self::DocumentReference),
            "DomainResource" => Ok(Self::DomainResource),
            "EligibilityRequest" => Ok(Self::EligibilityRequest),
            "EligibilityResponse" => Ok(Self::EligibilityResponse),
            "Encounter" => Ok(Self::Encounter),
            "Endpoint" => Ok(Self::Endpoint),
            "EnrollmentRequest" => Ok(Self::EnrollmentRequest),
            "EnrollmentResponse" => Ok(Self::EnrollmentResponse),
            "EpisodeOfCare" => Ok(Self::EpisodeOfCare),
            "ExpansionProfile" => Ok(Self::ExpansionProfile),
            "ExplanationOfBenefit" => Ok(Self::ExplanationOfBenefit),
            "FamilyMemberHistory" => Ok(Self::FamilyMemberHistory),
            "Flag" => Ok(Self::Flag),
            "Goal" => Ok(Self::Goal),
            "GraphDefinition" => Ok(Self::GraphDefinition),
            "Group" => Ok(Self::Group),
            "GuidanceResponse" => Ok(Self::GuidanceResponse),
            "HealthcareService" => Ok(Self::HealthcareService),
            "ImagingManifest" => Ok(Self::ImagingManifest),
            "ImagingStudy" => Ok(Self::ImagingStudy),
            "Immunization" => Ok(Self::Immunization),
            "ImmunizationRecommendation" => Ok(Self::ImmunizationRecommendation),
            "ImplementationGuide" => Ok(Self::ImplementationGuide),
            "Library" => Ok(Self::Library),
            "Linkage" => Ok(Self::Linkage),
            "List" => Ok(Self::List),
            "Location" => Ok(Self::Location),
            "Measure" => Ok(Self::Measure),
            "MeasureReport" => Ok(Self::MeasureReport),
            "Media" => Ok(Self::Media),
            "Medication" => Ok(Self::Medication),
            "MedicationAdministration" => Ok(Self::MedicationAdministration),
            "MedicationDispense" => Ok(Self::MedicationDispense),
            "MedicationRequest" => Ok(Self::MedicationRequest),
            "MedicationStatement" => Ok(Self::MedicationStatement),
            "MessageDefinition" => Ok(Self::MessageDefinition),
            "MessageHeader" => Ok(Self::MessageHeader),
            "NamingSystem" => Ok(Self::NamingSystem),
            "NutritionOrder" => Ok(Self::NutritionOrder),
            "Observation" => Ok(Self::Observation),
            "OperationDefinition" => Ok(Self::OperationDefinition),
            "OperationOutcome" => Ok(Self::OperationOutcome),
            "Organization" => Ok(Self::Organization),
            "Parameters" => Ok(Self::Parameters),
            "Patient" => Ok(Self::Patient),
            "PaymentNotice" => Ok(Self::PaymentNotice),
            "PaymentReconciliation" => Ok(Self::PaymentReconciliation),
            "Person" => Ok(Self::Person),
            "PlanDefinition" => Ok(Self::PlanDefinition),
            "Practitioner" => Ok(Self::Practitioner),
            "PractitionerRole" => Ok(Self::PractitionerRole),
            "Procedure" => Ok(Self::Procedure),
            "ProcedureRequest" => Ok(Self::ProcedureRequest),
            "ProcessRequest" => Ok(Self::ProcessRequest),
            "ProcessResponse" => Ok(Self::ProcessResponse),
            "Provenance" => Ok(Self::Provenance),
            "Questionnaire" => Ok(Self::Questionnaire),
            "QuestionnaireResponse" => Ok(Self::QuestionnaireResponse),
            "ReferralRequest" => Ok(Self::ReferralRequest),
            "RelatedPerson" => Ok(Self::RelatedPerson),
            "RequestGroup" => Ok(Self::RequestGroup),
            "ResearchStudy" => Ok(Self::ResearchStudy),
            "ResearchSubject" => Ok(Self::ResearchSubject),
            "Resource" => Ok(Self::Resource),
            "RiskAssessment" => Ok(Self::RiskAssessment),
            "Schedule" => Ok(Self::Schedule),
            "SearchParameter" => Ok(Self::SearchParameter),
            "Sequence" => Ok(Self::Sequence),
            "ServiceDefinition" => Ok(Self::ServiceDefinition),
            "Slot" => Ok(Self::Slot),
            "Specimen" => Ok(Self::Specimen),
            "StructureDefinition" => Ok(Self::StructureDefinition),
            "StructureMap" => Ok(Self::StructureMap),
            "Subscription" => Ok(Self::Subscription),
            "Substance" => Ok(Self::Substance),
            "SupplyDelivery" => Ok(Self::SupplyDelivery),
            "SupplyRequest" => Ok(Self::SupplyRequest),
            "Task" => Ok(Self::Task),
            "TestReport" => Ok(Self::TestReport),
            "TestScript" => Ok(Self::TestScript),
            "ValueSet" => Ok(Self::ValueSet),
            "VisionPrescription" => Ok(Self::VisionPrescription),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Account => "Account",
            Self::ActivityDefinition => "ActivityDefinition",
            Self::AdverseEvent => "AdverseEvent",
            Self::AllergyIntolerance => "AllergyIntolerance",
            Self::Appointment => "Appointment",
            Self::AppointmentResponse => "AppointmentResponse",
            Self::AuditEvent => "AuditEvent",
            Self::Basic => "Basic",
            Self::Binary => "Binary",
            Self::BodySite => "BodySite",
            Self::Bundle => "Bundle",
            Self::CapabilityStatement => "CapabilityStatement",
            Self::CarePlan => "CarePlan",
            Self::CareTeam => "CareTeam",
            Self::ChargeItem => "ChargeItem",
            Self::Claim => "Claim",
            Self::ClaimResponse => "ClaimResponse",
            Self::ClinicalImpression => "ClinicalImpression",
            Self::CodeSystem => "CodeSystem",
            Self::Communication => "Communication",
            Self::CommunicationRequest => "CommunicationRequest",
            Self::CompartmentDefinition => "CompartmentDefinition",
            Self::Composition => "Composition",
            Self::ConceptMap => "ConceptMap",
            Self::Condition => "Condition",
            Self::Consent => "Consent",
            Self::Contract => "Contract",
            Self::Coverage => "Coverage",
            Self::DataElement => "DataElement",
            Self::DetectedIssue => "DetectedIssue",
            Self::Device => "Device",
            Self::DeviceComponent => "DeviceComponent",
            Self::DeviceMetric => "DeviceMetric",
            Self::DeviceRequest => "DeviceRequest",
            Self::DeviceUseStatement => "DeviceUseStatement",
            Self::DiagnosticReport => "DiagnosticReport",
            Self::DocumentManifest => "DocumentManifest",
            Self::DocumentReference => "DocumentReference",
            Self::DomainResource => "DomainResource",
            Self::EligibilityRequest => "EligibilityRequest",
            Self::EligibilityResponse => "EligibilityResponse",
            Self::Encounter => "Encounter",
            Self::Endpoint => "Endpoint",
            Self::EnrollmentRequest => "EnrollmentRequest",
            Self::EnrollmentResponse => "EnrollmentResponse",
            Self::EpisodeOfCare => "EpisodeOfCare",
            Self::ExpansionProfile => "ExpansionProfile",
            Self::ExplanationOfBenefit => "ExplanationOfBenefit",
            Self::FamilyMemberHistory => "FamilyMemberHistory",
            Self::Flag => "Flag",
            Self::Goal => "Goal",
            Self::GraphDefinition => "GraphDefinition",
            Self::Group => "Group",
            Self::GuidanceResponse => "GuidanceResponse",
            Self::HealthcareService => "HealthcareService",
            Self::ImagingManifest => "ImagingManifest",
            Self::ImagingStudy => "ImagingStudy",
            Self::Immunization => "Immunization",
            Self::ImmunizationRecommendation => "ImmunizationRecommendation",
            Self::ImplementationGuide => "ImplementationGuide",
            Self::Library => "Library",
            Self::Linkage => "Linkage",
            Self::List => "List",
            Self::Location => "Location",
            Self::Measure => "Measure",
            Self::MeasureReport => "MeasureReport",
            Self::Media => "Media",
            Self::Medication => "Medication",
            Self::MedicationAdministration => "MedicationAdministration",
            Self::MedicationDispense => "MedicationDispense",
            Self::MedicationRequest => "MedicationRequest",
            Self::MedicationStatement => "MedicationStatement",
            Self::MessageDefinition => "MessageDefinition",
            Self::MessageHeader => "MessageHeader",
            Self::NamingSystem => "NamingSystem",
            Self::NutritionOrder => "NutritionOrder",
            Self::Observation => "Observation",
            Self::OperationDefinition => "OperationDefinition",
            Self::OperationOutcome => "OperationOutcome",
            Self::Organization => "Organization",
            Self::Parameters => "Parameters",
            Self::Patient => "Patient",
            Self::PaymentNotice => "PaymentNotice",
            Self::PaymentReconciliation => "PaymentReconciliation",
            Self::Person => "Person",
            Self::PlanDefinition => "PlanDefinition",
            Self::Practitioner => "Practitioner",
            Self::PractitionerRole => "PractitionerRole",
            Self::Procedure => "Procedure",
            Self::ProcedureRequest => "ProcedureRequest",
            Self::ProcessRequest => "ProcessRequest",
            Self::ProcessResponse => "ProcessResponse",
            Self::Provenance => "Provenance",
            Self::Questionnaire => "Questionnaire",
            Self::QuestionnaireResponse => "QuestionnaireResponse",
            Self::ReferralRequest => "ReferralRequest",
            Self::RelatedPerson => "RelatedPerson",
            Self::RequestGroup => "RequestGroup",
            Self::ResearchStudy => "ResearchStudy",
            Self::ResearchSubject => "ResearchSubject",
            Self::Resource => "Resource",
            Self::RiskAssessment => "RiskAssessment",
            Self::Schedule => "Schedule",
            Self::SearchParameter => "SearchParameter",
            Self::Sequence => "Sequence",
            Self::ServiceDefinition => "ServiceDefinition",
            Self::Slot => "Slot",
            Self::Specimen => "Specimen",
            Self::StructureDefinition => "StructureDefinition",
            Self::StructureMap => "StructureMap",
            Self::Subscription => "Subscription",
            Self::Substance => "Substance",
            Self::SupplyDelivery => "SupplyDelivery",
            Self::SupplyRequest => "SupplyRequest",
            Self::Task => "Task",
            Self::TestReport => "TestReport",
            Self::TestScript => "TestScript",
            Self::ValueSet => "ValueSet",
            Self::VisionPrescription => "VisionPrescription",
        }
    }
}
impl ::std::fmt::Debug for ResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResourceType> for Coding {
    fn from(code: ResourceType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/resource-types".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResourceType> for CodeableConcept {
    fn from(code: ResourceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResourceValidationMode](http://hl7.org/fhir/ValueSet/resource-validation-mode)**. Codes indicating the type of validation to perform\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResourceValidationMode {
    /** **create**

Validate for Create. The server checks the content, and then checks that the content would be acceptable as a create (e.g. that the content would not violate any uniqueness constraints). */
    Create,
    /** **delete**

Validate for Delete. The server ignores the content, and checks that the nominated resource is allowed to be deleted (e.g. checking referential integrity rules). */
    Delete,
    /** **update**

Validate for Update. The server checks the content, and then checks that it would accept it as an update against the nominated specific resource (e.g. that there are no changes to immutable fields the server does not allow to change, and checking version integrity if appropriate). */
    Update,
}
impl ::core::str::FromStr for ResourceValidationMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "update" => Ok(Self::Update),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResourceValidationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Create => "create",
            Self::Delete => "delete",
            Self::Update => "update",
        }
    }
}
impl ::std::fmt::Debug for ResourceValidationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResourceValidationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResourceValidationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceValidationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResourceValidationMode> for Coding {
    fn from(code: ResourceValidationMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/resource-validation-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResourceValidationMode> for CodeableConcept {
    fn from(code: ResourceValidationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResourceVersionPolicy](http://hl7.org/fhir/ValueSet/versioning-policy)**. How the system supports versioning for a resource.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResourceVersionPolicy {
    /** **no-version**

No VersionId Support. VersionId meta-property is not supported (server) or used (client). */
    NoVersion,
    /** **versioned**

Versioned. VersionId meta-property is supported (server) or used (client). */
    Versioned,
    /** **versioned-update**

VersionId tracked fully. VersionId must be correct for updates (server) or will be specified (If-match header) for updates (client). */
    VersionedUpdate,
}
impl ::core::str::FromStr for ResourceVersionPolicy {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "no-version" => Ok(Self::NoVersion),
            "versioned" => Ok(Self::Versioned),
            "versioned-update" => Ok(Self::VersionedUpdate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResourceVersionPolicy {
    fn as_ref(&self) -> &str {
        match self {
            Self::NoVersion => "no-version",
            Self::Versioned => "versioned",
            Self::VersionedUpdate => "versioned-update",
        }
    }
}
impl ::std::fmt::Debug for ResourceVersionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResourceVersionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResourceVersionPolicy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceVersionPolicy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResourceVersionPolicy> for Coding {
    fn from(code: ResourceVersionPolicy) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/versioning-policy".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResourceVersionPolicy> for CodeableConcept {
    fn from(code: ResourceVersionPolicy) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResponseType](http://hl7.org/fhir/ValueSet/response-code)**. The kind of response to a message\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResponseType {
    /** **fatal-error**

Fatal Error. The message was rejected because of a problem with the content. There is no point in re-sending without change. The response narrative SHALL describe the issue. */
    FatalError,
    /** **ok**

OK. The message was accepted and processed without error. */
    Ok,
    /** **transient-error**

Transient Error. Some internal unexpected error occurred - wait and try again. Note - this is usually used for things like database unavailable, which may be expected to resolve, though human intervention may be required. */
    TransientError,
}
impl ::core::str::FromStr for ResponseType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fatal-error" => Ok(Self::FatalError),
            "ok" => Ok(Self::Ok),
            "transient-error" => Ok(Self::TransientError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResponseType {
    fn as_ref(&self) -> &str {
        match self {
            Self::FatalError => "fatal-error",
            Self::Ok => "ok",
            Self::TransientError => "transient-error",
        }
    }
}
impl ::std::fmt::Debug for ResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResponseType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResponseType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResponseType> for Coding {
    fn from(code: ResponseType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/response-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResponseType> for CodeableConcept {
    fn from(code: ResponseType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RestfulCapabilityMode](http://hl7.org/fhir/ValueSet/restful-capability-mode)**. The mode of a RESTful capability statement.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RestfulCapabilityMode {
    /** **client**

Client. The application acts as a client for this resource. */
    Client,
    /** **server**

Server. The application acts as a server for this resource. */
    Server,
}
impl ::core::str::FromStr for RestfulCapabilityMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client" => Ok(Self::Client),
            "server" => Ok(Self::Server),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RestfulCapabilityMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Client => "client",
            Self::Server => "server",
        }
    }
}
impl ::std::fmt::Debug for RestfulCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RestfulCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RestfulCapabilityMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RestfulCapabilityMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RestfulCapabilityMode> for Coding {
    fn from(code: RestfulCapabilityMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/restful-capability-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RestfulCapabilityMode> for CodeableConcept {
    fn from(code: RestfulCapabilityMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RestfulSecurityService](http://hl7.org/fhir/ValueSet/restful-security-service)**. Types of security services used with FHIR.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RestfulSecurityService {
    /** **Basic**

Basic. Basic authentication defined in HTTP specification. */
    Basic,
    /** **Certificates**

Certificates. SSL where client must have a certificate registered with the server. */
    Certificates,
    /** **Kerberos**

Kerberos. see http://www.ietf.org/rfc/rfc4120.txt. */
    Kerberos,
    /** **NTLM**

NTLM. Microsoft NTLM Authentication. */
    Ntlm,
    /** **OAuth**

OAuth. Oauth (unspecified version see oauth.net). */
    Oauth,
    /** **SMART-on-FHIR**

SMART-on-FHIR. OAuth2 using SMART-on-FHIR profile (see http://docs.smarthealthit.org/). */
    SmartOnFHIR,
}
impl ::core::str::FromStr for RestfulSecurityService {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Basic" => Ok(Self::Basic),
            "Certificates" => Ok(Self::Certificates),
            "Kerberos" => Ok(Self::Kerberos),
            "NTLM" => Ok(Self::Ntlm),
            "OAuth" => Ok(Self::Oauth),
            "SMART-on-FHIR" => Ok(Self::SmartOnFHIR),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RestfulSecurityService {
    fn as_ref(&self) -> &str {
        match self {
            Self::Basic => "Basic",
            Self::Certificates => "Certificates",
            Self::Kerberos => "Kerberos",
            Self::Ntlm => "NTLM",
            Self::Oauth => "OAuth",
            Self::SmartOnFHIR => "SMART-on-FHIR",
        }
    }
}
impl ::std::fmt::Debug for RestfulSecurityService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RestfulSecurityService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RestfulSecurityService {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RestfulSecurityService {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RestfulSecurityService> for Coding {
    fn from(code: RestfulSecurityService) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/restful-security-service".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RestfulSecurityService> for CodeableConcept {
    fn from(code: RestfulSecurityService) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SearchComparator](http://hl7.org/fhir/ValueSet/search-comparator)**. What Search Comparator Codes are supported in search\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SearchComparator {
    /** **ap**

Approximately. the value for the parameter in the resource is approximately the same to the provided value. */
    Ap,
    /** **eb**

Ends Before. the value for the parameter in the resource ends before the provided value */
    Eb,
    /** **eq**

Equals. the value for the parameter in the resource is equal to the provided value */
    Eq,
    /** **ge**

Greater or Equals. the value for the parameter in the resource is greater or equal to the provided value */
    Ge,
    /** **gt**

Greater Than. the value for the parameter in the resource is greater than the provided value */
    Gt,
    /** **le**

Less of Equal. the value for the parameter in the resource is less or equal to the provided value */
    Le,
    /** **lt**

Less Then. the value for the parameter in the resource is less than the provided value */
    Lt,
    /** **ne**

Not Equals. the value for the parameter in the resource is not equal to the provided value */
    Ne,
    /** **sa**

Starts After. the value for the parameter in the resource starts after the provided value */
    Sa,
}
impl ::core::str::FromStr for SearchComparator {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ap" => Ok(Self::Ap),
            "eb" => Ok(Self::Eb),
            "eq" => Ok(Self::Eq),
            "ge" => Ok(Self::Ge),
            "gt" => Ok(Self::Gt),
            "le" => Ok(Self::Le),
            "lt" => Ok(Self::Lt),
            "ne" => Ok(Self::Ne),
            "sa" => Ok(Self::Sa),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchComparator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ap => "ap",
            Self::Eb => "eb",
            Self::Eq => "eq",
            Self::Ge => "ge",
            Self::Gt => "gt",
            Self::Le => "le",
            Self::Lt => "lt",
            Self::Ne => "ne",
            Self::Sa => "sa",
        }
    }
}
impl ::std::fmt::Debug for SearchComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SearchComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SearchComparator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchComparator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchComparator> for Coding {
    fn from(code: SearchComparator) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-comparator".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SearchComparator> for CodeableConcept {
    fn from(code: SearchComparator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SearchEntryMode](http://hl7.org/fhir/ValueSet/search-entry-mode)**. Why an entry is in the result set - whether it's included as a match or because of an _include requirement.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SearchEntryMode {
    /** **include**

Include. This resource is returned because it is referred to from another resource in the search set. */
    Include,
    /** **match**

Match. This resource matched the search specification. */
    Match,
    /** **outcome**

Outcome. An OperationOutcome that provides additional information about the processing of a search. */
    Outcome,
}
impl ::core::str::FromStr for SearchEntryMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "include" => Ok(Self::Include),
            "match" => Ok(Self::Match),
            "outcome" => Ok(Self::Outcome),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchEntryMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Include => "include",
            Self::Match => "match",
            Self::Outcome => "outcome",
        }
    }
}
impl ::std::fmt::Debug for SearchEntryMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SearchEntryMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SearchEntryMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchEntryMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchEntryMode> for Coding {
    fn from(code: SearchEntryMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-entry-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SearchEntryMode> for CodeableConcept {
    fn from(code: SearchEntryMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SearchModifierCode](http://hl7.org/fhir/ValueSet/search-modifier-code)**. A supported modifier for a search parameter.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SearchModifierCode {
    /** **above**

Above. The search parameter tests whether the value in a resource subsumes the specified value (is-a, or hierarchical relationships). */
    Above,
    /** **below**

Below. The search parameter tests whether the value in a resource is subsumed by the specified value (is-a, or hierarchical relationships). */
    Below,
    /** **contains**

Contains. The search parameter returns resources that include the supplied parameter value anywhere within the field being searched. */
    Contains,
    /** **exact**

Exact. The search parameter returns resources that have a value that exactly matches the supplied parameter (the whole string, including casing and accents). */
    Exact,
    /** **in**

In. The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is in the specified value set. */
    In,
    /** **missing**

Missing. The search parameter returns resources that have a value or not. */
    Missing,
    /** **not**

Not. The search parameter returns resources that do not contain a match. */
    Not,
    /** **not-in**

Not In. The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is not in the specified value set. */
    NotIn,
    /** **text**

Text. The search parameter is processed as a string that searches text associated with the code/value - either CodeableConcept.text, Coding.display, or Identifier.type.text. */
    Text,
    /** **type**

Type. The search parameter only applies to the Resource Type specified as a modifier (e.g. the modifier is not actually :type, but :Patient etc.). */
    Type,
}
impl ::core::str::FromStr for SearchModifierCode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "above" => Ok(Self::Above),
            "below" => Ok(Self::Below),
            "contains" => Ok(Self::Contains),
            "exact" => Ok(Self::Exact),
            "in" => Ok(Self::In),
            "missing" => Ok(Self::Missing),
            "not" => Ok(Self::Not),
            "not-in" => Ok(Self::NotIn),
            "text" => Ok(Self::Text),
            "type" => Ok(Self::Type),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchModifierCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Above => "above",
            Self::Below => "below",
            Self::Contains => "contains",
            Self::Exact => "exact",
            Self::In => "in",
            Self::Missing => "missing",
            Self::Not => "not",
            Self::NotIn => "not-in",
            Self::Text => "text",
            Self::Type => "type",
        }
    }
}
impl ::std::fmt::Debug for SearchModifierCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SearchModifierCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SearchModifierCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchModifierCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchModifierCode> for Coding {
    fn from(code: SearchModifierCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-modifier-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SearchModifierCode> for CodeableConcept {
    fn from(code: SearchModifierCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SearchParamType](http://hl7.org/fhir/ValueSet/search-param-type)**. Data types allowed to be used for search parameters.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SearchParamType {
    /** **composite**

Composite. A composite search parameter that combines a search on two values together. */
    Composite,
    /** **date**

Date/DateTime. Search parameter is on a date/time. The date format is the standard XML format, though other formats may be supported. */
    Date,
    /** **number**

Number. Search parameter SHALL be a number (a whole number, or a decimal). */
    Number,
    /** **quantity**

Quantity. A search parameter that searches on a quantity. */
    Quantity,
    /** **reference**

Reference. A reference to another resource. */
    Reference,
    /** **string**

String. Search parameter is a simple string, like a name part. Search is case-insensitive and accent-insensitive. May match just the start of a string. String parameters may contain spaces. */
    String,
    /** **token**

Token. Search parameter on a coded element or identifier. May be used to search through the text, displayname, code and code/codesystem (for codes) and label, system and key (for identifier). Its value is either a string or a pair of namespace and value, separated by a "|", depending on the modifier used. */
    Token,
    /** **uri**

URI. A search parameter that searches on a URI (RFC 3986). */
    Uri,
}
impl ::core::str::FromStr for SearchParamType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "composite" => Ok(Self::Composite),
            "date" => Ok(Self::Date),
            "number" => Ok(Self::Number),
            "quantity" => Ok(Self::Quantity),
            "reference" => Ok(Self::Reference),
            "string" => Ok(Self::String),
            "token" => Ok(Self::Token),
            "uri" => Ok(Self::Uri),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchParamType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Composite => "composite",
            Self::Date => "date",
            Self::Number => "number",
            Self::Quantity => "quantity",
            Self::Reference => "reference",
            Self::String => "string",
            Self::Token => "token",
            Self::Uri => "uri",
        }
    }
}
impl ::std::fmt::Debug for SearchParamType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SearchParamType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SearchParamType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchParamType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchParamType> for Coding {
    fn from(code: SearchParamType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-param-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SearchParamType> for CodeableConcept {
    fn from(code: SearchParamType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SecurityRoleType](http://hl7.org/fhir/extra-security-role-type)**. This CodeSystem contains Additional FHIR-defined Security Role types not defined elsewhere\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum SecurityRoleType {
    /** **authserver**

authorization server. An entity providing authorization services to enable the electronic sharing of health-related information based on resource owner's preapproved permissions. For example, an UMA Authorization Server[UMA] */
    Authserver,
    /** **datacollector**

data collector. An entity that collects information over which the data subject may have certain rights under policy or law to control that information's management and distribution by data collectors, including the right to access, retrieve, distribute, or delete that information.  */
    Datacollector,
    /** **dataprocessor**

data processor. An entity that processes collected information over which the data subject may have certain rights under policy or law to control that information's management and distribution by data processors, including the right to access, retrieve, distribute, or delete that information. */
    Dataprocessor,
    /** **datasubject**

data subject. A person whose personal information is collected or processed, and who may have certain rights under policy or law to control that information's management and distribution by data collectors or processors, including the right to access, retrieve, distribute, or delete that information. */
    Datasubject,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SecurityRoleType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "authserver" => Ok(Self::Authserver),
            "datacollector" => Ok(Self::Datacollector),
            "dataprocessor" => Ok(Self::Dataprocessor),
            "datasubject" => Ok(Self::Datasubject),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SecurityRoleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Authserver => "authserver",
            Self::Datacollector => "datacollector",
            Self::Dataprocessor => "dataprocessor",
            Self::Datasubject => "datasubject",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for SecurityRoleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SecurityRoleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SecurityRoleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SecurityRoleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SecurityRoleType> for Coding {
    fn from(code: SecurityRoleType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/extra-security-role-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SecurityRoleType> for CodeableConcept {
    fn from(code: SecurityRoleType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ServiceProvisionConditions](http://hl7.org/fhir/ValueSet/service-provision-conditions)**. The code(s) that detail the conditions under which the healthcare service is available/offered.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ServiceProvisionConditions {
    /** **cost**

Fees apply. Fees apply for this service. */
    Cost,
    /** **disc**

Discounts Available. There are discounts available on this service for qualifying patients. */
    Disc,
    /** **free**

Free. This service is available for no patient cost. */
    Free,
}
impl ::core::str::FromStr for ServiceProvisionConditions {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cost" => Ok(Self::Cost),
            "disc" => Ok(Self::Disc),
            "free" => Ok(Self::Free),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ServiceProvisionConditions {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cost => "cost",
            Self::Disc => "disc",
            Self::Free => "free",
        }
    }
}
impl ::std::fmt::Debug for ServiceProvisionConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ServiceProvisionConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ServiceProvisionConditions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ServiceProvisionConditions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ServiceProvisionConditions> for Coding {
    fn from(code: ServiceProvisionConditions) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/service-provision-conditions".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ServiceProvisionConditions> for CodeableConcept {
    fn from(code: ServiceProvisionConditions) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SlicingRules](http://hl7.org/fhir/ValueSet/resource-slicing-rules)**. How slices are interpreted when evaluating an instance.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SlicingRules {
    /** **closed**

Closed. No additional content is allowed other than that described by the slices in this profile. */
    Closed,
    /** **open**

Open. Additional content is allowed anywhere in the list. */
    Open,
    /** **openAtEnd**

Open at End. Additional content is allowed, but only at the end of the list. Note that using this requires that the slices be ordered, which makes it hard to share uses. This should only be done where absolutely required. */
    OpenAtEnd,
}
impl ::core::str::FromStr for SlicingRules {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "closed" => Ok(Self::Closed),
            "open" => Ok(Self::Open),
            "openAtEnd" => Ok(Self::OpenAtEnd),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SlicingRules {
    fn as_ref(&self) -> &str {
        match self {
            Self::Closed => "closed",
            Self::Open => "open",
            Self::OpenAtEnd => "openAtEnd",
        }
    }
}
impl ::std::fmt::Debug for SlicingRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SlicingRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SlicingRules {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SlicingRules {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SlicingRules> for Coding {
    fn from(code: SlicingRules) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/resource-slicing-rules".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SlicingRules> for CodeableConcept {
    fn from(code: SlicingRules) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SlotStatus](http://hl7.org/fhir/ValueSet/slotstatus)**. The free/busy status of the slot.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SlotStatus {
    /** **busy**

Busy. Indicates that the time interval is busy because one  or more events have been scheduled for that interval. */
    Busy,
    /** **busy-tentative**

Busy (Tentative). Indicates that the time interval is busy because one or more events have been tentatively scheduled for that interval. */
    BusyTentative,
    /** **busy-unavailable**

Busy (Unavailable). Indicates that the time interval is busy and that the interval can not be scheduled. */
    BusyUnavailable,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **free**

Free. Indicates that the time interval is free for scheduling. */
    Free,
}
impl ::core::str::FromStr for SlotStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "busy" => Ok(Self::Busy),
            "busy-tentative" => Ok(Self::BusyTentative),
            "busy-unavailable" => Ok(Self::BusyUnavailable),
            "entered-in-error" => Ok(Self::EnteredInError),
            "free" => Ok(Self::Free),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SlotStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Busy => "busy",
            Self::BusyTentative => "busy-tentative",
            Self::BusyUnavailable => "busy-unavailable",
            Self::EnteredInError => "entered-in-error",
            Self::Free => "free",
        }
    }
}
impl ::std::fmt::Debug for SlotStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SlotStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SlotStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SlotStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SlotStatus> for Coding {
    fn from(code: SlotStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/slotstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SlotStatus> for CodeableConcept {
    fn from(code: SlotStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SpecialArrangements](http://hl7.org/fhir/ValueSet/encounter-special-arrangements)**. This value set defines a set of codes that can be used to indicate the kinds of special arrangements in place for a patients visit.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SpecialArrangements {
    /** **add-bed**

Additional bedding. An additional bed made available for a person accompanying the patient, for example a parent accompanying a child. */
    AddBed,
    /** **att**

Attendant. A person who accompanies a patient to provide assistive services necessary for the patient's care during the encounter. */
    Att,
    /** **dog**

Guide dog. The patient has a guide-dog and the location used for the encounter should be able to support the presence of the service animal. */
    Dog,
    /** **int**

Interpreter. The patient is not fluent in the local language and requires an interpreter to be available. Refer to the Patient.Language property for the type of interpreter required. */
    Int,
    /** **wheel**

Wheelchair. The patient requires a wheelchair to be made available for the encounter. */
    Wheel,
}
impl ::core::str::FromStr for SpecialArrangements {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "add-bed" => Ok(Self::AddBed),
            "att" => Ok(Self::Att),
            "dog" => Ok(Self::Dog),
            "int" => Ok(Self::Int),
            "wheel" => Ok(Self::Wheel),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecialArrangements {
    fn as_ref(&self) -> &str {
        match self {
            Self::AddBed => "add-bed",
            Self::Att => "att",
            Self::Dog => "dog",
            Self::Int => "int",
            Self::Wheel => "wheel",
        }
    }
}
impl ::std::fmt::Debug for SpecialArrangements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SpecialArrangements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SpecialArrangements {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecialArrangements {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecialArrangements> for Coding {
    fn from(code: SpecialArrangements) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/encounter-special-arrangements".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SpecialArrangements> for CodeableConcept {
    fn from(code: SpecialArrangements) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SpecialValues](http://hl7.org/fhir/ValueSet/special-values)**. A set of generally useful codes defined so they can be included in value sets.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SpecialValues {
    /** **false**

false. Boolean false. */
    False,
    /** **nil-known**

Nil Known. The are no known applicable values in this context. */
    NilKnown,
    /** **sufficient**

Sufficient Quantity. The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material. */
    Sufficient,
    /** **trace**

Trace Amount Detected. The content is greater than zero, but too small to be quantified. */
    Trace,
    /** **true**

true. Boolean true. */
    True,
    /** **withdrawn**

Value Withdrawn. The value is no longer available. */
    Withdrawn,
}
impl ::core::str::FromStr for SpecialValues {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "false" => Ok(Self::False),
            "nil-known" => Ok(Self::NilKnown),
            "sufficient" => Ok(Self::Sufficient),
            "trace" => Ok(Self::Trace),
            "true" => Ok(Self::True),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecialValues {
    fn as_ref(&self) -> &str {
        match self {
            Self::False => "false",
            Self::NilKnown => "nil-known",
            Self::Sufficient => "sufficient",
            Self::Trace => "trace",
            Self::True => "true",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Debug for SpecialValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SpecialValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SpecialValues {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecialValues {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecialValues> for Coding {
    fn from(code: SpecialValues) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/special-values".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SpecialValues> for CodeableConcept {
    fn from(code: SpecialValues) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SpecimenStatus](http://hl7.org/fhir/ValueSet/specimen-status)**. Codes providing the status/availability of a specimen.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SpecimenStatus {
    /** **available**

Available. The physical specimen is present and in good condition. */
    Available,
    /** **entered-in-error**

Entered-in-error. The specimen was entered in error and therefore nullified. */
    EnteredInError,
    /** **unavailable**

Unavailable. There is no physical specimen because it is either lost, destroyed or consumed. */
    Unavailable,
    /** **unsatisfactory**

Unsatisfactory. The specimen cannot be used because of a quality issue such as a broken container, contamination, or too old. */
    Unsatisfactory,
}
impl ::core::str::FromStr for SpecimenStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "entered-in-error" => Ok(Self::EnteredInError),
            "unavailable" => Ok(Self::Unavailable),
            "unsatisfactory" => Ok(Self::Unsatisfactory),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecimenStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::EnteredInError => "entered-in-error",
            Self::Unavailable => "unavailable",
            Self::Unsatisfactory => "unsatisfactory",
        }
    }
}
impl ::std::fmt::Debug for SpecimenStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SpecimenStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SpecimenStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecimenStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecimenStatus> for Coding {
    fn from(code: SpecimenStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/specimen-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SpecimenStatus> for CodeableConcept {
    fn from(code: SpecimenStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StatisticsCode](http://hl7.org/fhir/ValueSet/observation-statistics)**. The statistical operation parameter -\"statistic\" -  codes\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StatisticsCode {
    /** **20-percent**

20th Percentile. The 20th [Percentile](https://en.wikipedia.org/wiki/Percentile) of N measurements over the stated period */
    N20Percent,
    /** **4-dev**

Quartile Deviation. The difference between the upper and lower [Quartiles](https://en.wikipedia.org/wiki/Quartile) is called the Interquartile range. (IQR = Q3-Q1) Quartile deviation or Semi-interquartile range is one-half the difference between the first and the third quartiles. */
    N4Dev,
    /** **4-lower**

Lower Quartile. The lower [Quartile](https://en.wikipedia.org/wiki/Quartile) Boundary of N measurements over the stated period */
    N4Lower,
    /** **4-upper**

Upper Quartile. The upper [Quartile](https://en.wikipedia.org/wiki/Quartile) Boundary of N measurements over the stated period */
    N4Upper,
    /** **5-1**

1st Quintile. The lowest of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population */
    N51,
    /** **5-2**

2nd Quintile. The second of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population */
    N52,
    /** **5-3**

3rd Quintile. The third of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population */
    N53,
    /** **5-4**

4th Quintile. The fourth of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population */
    N54,
    /** **80-percent**

80th Percentile. The 80th [Percentile](https://en.wikipedia.org/wiki/Percentile) of N measurements over the stated period */
    N80Percent,
    /** **average**

Average. The [mean](https://en.wikipedia.org/wiki/Arithmetic_mean) of N measurements over the stated period */
    Average,
    /** **count**

Count. The [number] of valid measurements over the stated period that contributed to the other statistical outputs */
    Count,
    /** **kurtosis**

Kurtosis. Kurtosis  is a measure of the "tailedness" of the probability distribution of a real-valued random variable.   Source: [Wikipedia](https://en.wikipedia.org/wiki/Kurtosis) */
    Kurtosis,
    /** **maximum**

Maximum. The [maximum](https://en.wikipedia.org/wiki/Maximal_element) value of N measurements over the stated period */
    Maximum,
    /** **median**

Median. The [median](https://en.wikipedia.org/wiki/Median) of N measurements over the stated period */
    Median,
    /** **minimum**

Minimum. The [minimum](https://en.wikipedia.org/wiki/Minimal_element) value of N measurements over the stated period */
    Minimum,
    /** **regression**

Regression. Linear regression is an approach for modeling two-dimensional sample points with one independent variable and one dependent variable (conventionally, the x and y coordinates in a Cartesian coordinate system) and finds a linear function (a non-vertical straight line) that, as accurately as possible, predicts the dependent variable values as a function of the independent variables. Source: [Wikipedia](https://en.wikipedia.org/wiki/Simple_linear_regression)  This Statistic code will return both a gradient and an intercept value. */
    Regression,
    /** **skew**

Skew. Skewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean. The skewness value can be positive or negative, or even undefined.  Source: [Wikipedia](https://en.wikipedia.org/wiki/Skewness) */
    Skew,
    /** **std-dev**

Standard Deviation. The [standard deviation](https://en.wikipedia.org/wiki/Standard_deviation) of N measurements over the stated period */
    StdDev,
    /** **sum**

Sum. The [sum](https://en.wikipedia.org/wiki/Summation) of N measurements over the stated period */
    Sum,
    /** **totalcount**

Total Count. The total [number] of valid measurements over the stated period, including observations that were ignored because they did not contain valid result values */
    Totalcount,
    /** **variance**

Variance. The [variance](https://en.wikipedia.org/wiki/Variance) of N measurements over the stated period */
    Variance,
}
impl ::core::str::FromStr for StatisticsCode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "20-percent" => Ok(Self::N20Percent),
            "4-dev" => Ok(Self::N4Dev),
            "4-lower" => Ok(Self::N4Lower),
            "4-upper" => Ok(Self::N4Upper),
            "5-1" => Ok(Self::N51),
            "5-2" => Ok(Self::N52),
            "5-3" => Ok(Self::N53),
            "5-4" => Ok(Self::N54),
            "80-percent" => Ok(Self::N80Percent),
            "average" => Ok(Self::Average),
            "count" => Ok(Self::Count),
            "kurtosis" => Ok(Self::Kurtosis),
            "maximum" => Ok(Self::Maximum),
            "median" => Ok(Self::Median),
            "minimum" => Ok(Self::Minimum),
            "regression" => Ok(Self::Regression),
            "skew" => Ok(Self::Skew),
            "std-dev" => Ok(Self::StdDev),
            "sum" => Ok(Self::Sum),
            "totalcount" => Ok(Self::Totalcount),
            "variance" => Ok(Self::Variance),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StatisticsCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::N20Percent => "20-percent",
            Self::N4Dev => "4-dev",
            Self::N4Lower => "4-lower",
            Self::N4Upper => "4-upper",
            Self::N51 => "5-1",
            Self::N52 => "5-2",
            Self::N53 => "5-3",
            Self::N54 => "5-4",
            Self::N80Percent => "80-percent",
            Self::Average => "average",
            Self::Count => "count",
            Self::Kurtosis => "kurtosis",
            Self::Maximum => "maximum",
            Self::Median => "median",
            Self::Minimum => "minimum",
            Self::Regression => "regression",
            Self::Skew => "skew",
            Self::StdDev => "std-dev",
            Self::Sum => "sum",
            Self::Totalcount => "totalcount",
            Self::Variance => "variance",
        }
    }
}
impl ::std::fmt::Debug for StatisticsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StatisticsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StatisticsCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StatisticsCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StatisticsCode> for Coding {
    fn from(code: StatisticsCode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/observation-statistics".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StatisticsCode> for CodeableConcept {
    fn from(code: StatisticsCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StrengthOfRecommendationRating](http://hl7.org/fhir/ValueSet/cqif-recommendation-strength)**. A rating system that describes the strength of the recommendation, such as the GRADE, DynaMed, or HGPS systems\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StrengthOfRecommendationRating {
    /** **strong**

Strong. Strong recommendation */
    Strong,
    /** **weak**

Weak. Weak recommendation */
    Weak,
}
impl ::core::str::FromStr for StrengthOfRecommendationRating {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "strong" => Ok(Self::Strong),
            "weak" => Ok(Self::Weak),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StrengthOfRecommendationRating {
    fn as_ref(&self) -> &str {
        match self {
            Self::Strong => "strong",
            Self::Weak => "weak",
        }
    }
}
impl ::std::fmt::Debug for StrengthOfRecommendationRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StrengthOfRecommendationRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StrengthOfRecommendationRating {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StrengthOfRecommendationRating {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StrengthOfRecommendationRating> for Coding {
    fn from(code: StrengthOfRecommendationRating) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/cqif-recommendation-strength".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StrengthOfRecommendationRating> for CodeableConcept {
    fn from(code: StrengthOfRecommendationRating) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureDefinitionKind](http://hl7.org/fhir/ValueSet/structure-definition-kind)**. Defines the type of structure that a definition is describing.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureDefinitionKind {
    /** **complex-type**

Complex Data Type. A  complex structure that defines a set of data elements. These can be used throughout Resource and extension definitions, and in logical models. */
    ComplexType,
    /** **logical**

Logical Model. A conceptual package of data that will be mapped to resources for implementation. */
    Logical,
    /** **primitive-type**

Primitive Data Type. A primitive type that has a value and an extension. These can be used throughout Resource and extension definitions. Only the base specification can define primitive types. */
    PrimitiveType,
    /** **resource**

Resource. A resource defined by the FHIR specification. */
    Resource,
}
impl ::core::str::FromStr for StructureDefinitionKind {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complex-type" => Ok(Self::ComplexType),
            "logical" => Ok(Self::Logical),
            "primitive-type" => Ok(Self::PrimitiveType),
            "resource" => Ok(Self::Resource),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureDefinitionKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::ComplexType => "complex-type",
            Self::Logical => "logical",
            Self::PrimitiveType => "primitive-type",
            Self::Resource => "resource",
        }
    }
}
impl ::std::fmt::Debug for StructureDefinitionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureDefinitionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureDefinitionKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureDefinitionKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureDefinitionKind> for Coding {
    fn from(code: StructureDefinitionKind) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/structure-definition-kind".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureDefinitionKind> for CodeableConcept {
    fn from(code: StructureDefinitionKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapContextType](http://hl7.org/fhir/ValueSet/map-context-type)**. How to interpret the context\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapContextType {
    /** **type**

Type. The context specifies a type */
    Type,
    /** **variable**

Variable. The context specifies a variable */
    Variable,
}
impl ::core::str::FromStr for StructureMapContextType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "type" => Ok(Self::Type),
            "variable" => Ok(Self::Variable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapContextType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Type => "type",
            Self::Variable => "variable",
        }
    }
}
impl ::std::fmt::Debug for StructureMapContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapContextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapContextType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapContextType> for Coding {
    fn from(code: StructureMapContextType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-context-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapContextType> for CodeableConcept {
    fn from(code: StructureMapContextType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapGroupTypeMode](http://hl7.org/fhir/ValueSet/map-group-type-mode)**. If this is the default rule set to apply for the source type, or this combination of types\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapGroupTypeMode {
    /** **none**

Not a Default. This group is not a default group for the types */
    None,
    /** **type-and-types**

Default for type + combination. This group is a default mapping group for the specified types */
    TypeAndTypes,
    /** **types**

Default for Type Combination. This group is a default mapping group for the specified types and for the primary source type */
    Types,
}
impl ::core::str::FromStr for StructureMapGroupTypeMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "none" => Ok(Self::None),
            "type-and-types" => Ok(Self::TypeAndTypes),
            "types" => Ok(Self::Types),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapGroupTypeMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::None => "none",
            Self::TypeAndTypes => "type-and-types",
            Self::Types => "types",
        }
    }
}
impl ::std::fmt::Debug for StructureMapGroupTypeMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapGroupTypeMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapGroupTypeMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapGroupTypeMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapGroupTypeMode> for Coding {
    fn from(code: StructureMapGroupTypeMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-group-type-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapGroupTypeMode> for CodeableConcept {
    fn from(code: StructureMapGroupTypeMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapInputMode](http://hl7.org/fhir/ValueSet/map-input-mode)**. Mode for this instance of data\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapInputMode {
    /** **source**

Source Instance. Names an input instance used a source for mapping */
    Source,
    /** **target**

Target Instance. Names an instance that is being populated */
    Target,
}
impl ::core::str::FromStr for StructureMapInputMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "source" => Ok(Self::Source),
            "target" => Ok(Self::Target),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapInputMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Source => "source",
            Self::Target => "target",
        }
    }
}
impl ::std::fmt::Debug for StructureMapInputMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapInputMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapInputMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapInputMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapInputMode> for Coding {
    fn from(code: StructureMapInputMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-input-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapInputMode> for CodeableConcept {
    fn from(code: StructureMapInputMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapModelMode](http://hl7.org/fhir/ValueSet/map-model-mode)**. How the referenced structure is used in this mapping\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapModelMode {
    /** **produced**

Produced Structure Definition. This structure describes an instance that the mapping engine may ask to create that is used a target of data */
    Produced,
    /** **queried**

Queried Structure Definition. This structure describes an instance that the mapping engine may ask for that is used a source of data */
    Queried,
    /** **source**

Source Structure Definition. This structure describes an instance passed to the mapping engine that is used a source of data */
    Source,
    /** **target**

Target Structure Definition. This structure describes an instance passed to the mapping engine that is used a target of data */
    Target,
}
impl ::core::str::FromStr for StructureMapModelMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "produced" => Ok(Self::Produced),
            "queried" => Ok(Self::Queried),
            "source" => Ok(Self::Source),
            "target" => Ok(Self::Target),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapModelMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Produced => "produced",
            Self::Queried => "queried",
            Self::Source => "source",
            Self::Target => "target",
        }
    }
}
impl ::std::fmt::Debug for StructureMapModelMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapModelMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapModelMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapModelMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapModelMode> for Coding {
    fn from(code: StructureMapModelMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-model-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapModelMode> for CodeableConcept {
    fn from(code: StructureMapModelMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapSourceListMode](http://hl7.org/fhir/ValueSet/map-source-list-mode)**. If field is a list, how to manage the source\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapSourceListMode {
    /** **first**

First. Only process this rule for the first in the list */
    First,
    /** **last**

Last. Only process this rule for the last in the list */
    Last,
    /** **not_first**

All but the first. Process this rule for all but the first */
    NotFirst,
    /** **not_last**

All but the last. Process this rule for all but the last */
    NotLast,
    /** **only_one**

Enforce only one. Only process this rule is there is only item */
    OnlyOne,
}
impl ::core::str::FromStr for StructureMapSourceListMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "first" => Ok(Self::First),
            "last" => Ok(Self::Last),
            "not_first" => Ok(Self::NotFirst),
            "not_last" => Ok(Self::NotLast),
            "only_one" => Ok(Self::OnlyOne),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapSourceListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::First => "first",
            Self::Last => "last",
            Self::NotFirst => "not_first",
            Self::NotLast => "not_last",
            Self::OnlyOne => "only_one",
        }
    }
}
impl ::std::fmt::Debug for StructureMapSourceListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapSourceListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapSourceListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapSourceListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapSourceListMode> for Coding {
    fn from(code: StructureMapSourceListMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-source-list-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapSourceListMode> for CodeableConcept {
    fn from(code: StructureMapSourceListMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapTargetListMode](http://hl7.org/fhir/ValueSet/map-target-list-mode)**. If field is a list, how to manage the production\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapTargetListMode {
    /** **collate**

Collate. re-use the first item in the list, and keep adding content to it */
    Collate,
    /** **first**

First. when the target list is being assembled, the items for this rule go first. If more that one rule defines a first item (for a given instance of mapping) then this is an error */
    First,
    /** **last**

Last. when the target list is being assembled, the items for this rule go last. If more that one rule defines a last item (for a given instance of mapping) then this is an error */
    Last,
    /** **share**

Share. the target instance is shared with the target instances generated by another rule (up to the first common n items, then create new ones) */
    Share,
}
impl ::core::str::FromStr for StructureMapTargetListMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "collate" => Ok(Self::Collate),
            "first" => Ok(Self::First),
            "last" => Ok(Self::Last),
            "share" => Ok(Self::Share),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapTargetListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Collate => "collate",
            Self::First => "first",
            Self::Last => "last",
            Self::Share => "share",
        }
    }
}
impl ::std::fmt::Debug for StructureMapTargetListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapTargetListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapTargetListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapTargetListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapTargetListMode> for Coding {
    fn from(code: StructureMapTargetListMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-target-list-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapTargetListMode> for CodeableConcept {
    fn from(code: StructureMapTargetListMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapTransform](http://hl7.org/fhir/ValueSet/map-transform)**. How data is copied/created\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapTransform {
    /** **append**

append. append(source...) - source is element or string */
    Append,
    /** **c**

c. Create a Coding. Parameters = (system. Code[, display]) */
    C,
    /** **cast**

cast. cast(source, type?) - case source from one type to another. target type can be left as implicit if there is one and only one target type known */
    Cast,
    /** **cc**

cc. Create a CodeableConcept. Parameters = (text) or (system. Code[, display]) */
    Cc,
    /** **copy**

copy. copy(source) */
    Copy,
    /** **cp**

cp. Create a contact details. Parameters = (value) or (system, value). If no system is provided, the system should be inferred from the content of the value */
    Cp,
    /** **create**

create. create(type : string) - type is passed through to the application on the standard API, and must be known by it */
    Create,
    /** **dateOp**

dateOp. Perform a date operation. *Parameters to be documented* */
    DateOp,
    /** **escape**

escape. escape(source, fmt1, fmt2) - change source from one kind of escaping to another (plain, java, xml, json). note that this is for when the string itself is escaped */
    Escape,
    /** **evaluate**

evaluate. Execute the supplied fluentpath expression and use the value returned by that */
    Evaluate,
    /** **id**

id. Create an identifier. Parameters = (system, value[, type]) where type is a code from the identifier type value set */
    Id,
    /** **pointer**

pointer. Return the appropriate string to put in a reference that refers to the resource provided as a parameter */
    Pointer,
    /** **qty**

qty. Create a quantity. Parameters = (text) or (value, unit, [system, code]) where text is the natural representation e.g. [comparator]value[space]unit */
    Qty,
    /** **reference**

reference. reference(source : object) - return a string that references the provided tree properly */
    Reference,
    /** **translate**

translate. translate(source, uri_of_map) - use the translate operation */
    Translate,
    /** **truncate**

truncate. truncate(source, length) - source must be stringy type */
    Truncate,
    /** **uuid**

uuid. Generate a random UUID (in lowercase). No Parameters */
    Uuid,
}
impl ::core::str::FromStr for StructureMapTransform {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "append" => Ok(Self::Append),
            "c" => Ok(Self::C),
            "cast" => Ok(Self::Cast),
            "cc" => Ok(Self::Cc),
            "copy" => Ok(Self::Copy),
            "cp" => Ok(Self::Cp),
            "create" => Ok(Self::Create),
            "dateOp" => Ok(Self::DateOp),
            "escape" => Ok(Self::Escape),
            "evaluate" => Ok(Self::Evaluate),
            "id" => Ok(Self::Id),
            "pointer" => Ok(Self::Pointer),
            "qty" => Ok(Self::Qty),
            "reference" => Ok(Self::Reference),
            "translate" => Ok(Self::Translate),
            "truncate" => Ok(Self::Truncate),
            "uuid" => Ok(Self::Uuid),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapTransform {
    fn as_ref(&self) -> &str {
        match self {
            Self::Append => "append",
            Self::C => "c",
            Self::Cast => "cast",
            Self::Cc => "cc",
            Self::Copy => "copy",
            Self::Cp => "cp",
            Self::Create => "create",
            Self::DateOp => "dateOp",
            Self::Escape => "escape",
            Self::Evaluate => "evaluate",
            Self::Id => "id",
            Self::Pointer => "pointer",
            Self::Qty => "qty",
            Self::Reference => "reference",
            Self::Translate => "translate",
            Self::Truncate => "truncate",
            Self::Uuid => "uuid",
        }
    }
}
impl ::std::fmt::Debug for StructureMapTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapTransform {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapTransform {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapTransform> for Coding {
    fn from(code: StructureMapTransform) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-transform".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapTransform> for CodeableConcept {
    fn from(code: StructureMapTransform) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubscriptionChannelType](http://hl7.org/fhir/ValueSet/subscription-channel-type)**. The type of method used to execute a subscription.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubscriptionChannelType {
    /** **email**

Email. The channel is executed by sending an email to the email addressed in the URI (which must be a mailto:). */
    Email,
    /** **message**

Message. The channel is executed by sending a message (e.g. a Bundle with a MessageHeader resource etc.) to the application identified in the URI. */
    Message,
    /** **rest-hook**

Rest Hook. The channel is executed by making a post to the URI. If a payload is included, the URL is interpreted as the service base, and an update (PUT) is made. */
    RestHook,
    /** **sms**

SMS. The channel is executed by sending an SMS message to the phone number identified in the URL (tel:). */
    Sms,
    /** **websocket**

Websocket. The channel is executed by sending a packet across a web socket connection maintained by the client. The URL identifies the websocket, and the client binds to this URL. */
    Websocket,
}
impl ::core::str::FromStr for SubscriptionChannelType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "email" => Ok(Self::Email),
            "message" => Ok(Self::Message),
            "rest-hook" => Ok(Self::RestHook),
            "sms" => Ok(Self::Sms),
            "websocket" => Ok(Self::Websocket),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionChannelType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Email => "email",
            Self::Message => "message",
            Self::RestHook => "rest-hook",
            Self::Sms => "sms",
            Self::Websocket => "websocket",
        }
    }
}
impl ::std::fmt::Debug for SubscriptionChannelType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubscriptionChannelType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubscriptionChannelType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionChannelType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionChannelType> for Coding {
    fn from(code: SubscriptionChannelType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/subscription-channel-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubscriptionChannelType> for CodeableConcept {
    fn from(code: SubscriptionChannelType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubscriptionStatus](http://hl7.org/fhir/ValueSet/subscription-status)**. The status of a subscription.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubscriptionStatus {
    /** **active**

Active. The subscription is active. */
    Active,
    /** **error**

Error. The server has an error executing the notification. */
    Error,
    /** **off**

Off. Too many errors have occurred or the subscription has expired. */
    Off,
    /** **requested**

Requested. The client has requested the subscription, and the server has not yet set it up. */
    Requested,
}
impl ::core::str::FromStr for SubscriptionStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "error" => Ok(Self::Error),
            "off" => Ok(Self::Off),
            "requested" => Ok(Self::Requested),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Error => "error",
            Self::Off => "off",
            Self::Requested => "requested",
        }
    }
}
impl ::std::fmt::Debug for SubscriptionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubscriptionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubscriptionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionStatus> for Coding {
    fn from(code: SubscriptionStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/subscription-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubscriptionStatus> for CodeableConcept {
    fn from(code: SubscriptionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubscriptionTag](http://hl7.org/fhir/ValueSet/subscription-tag)**. Tags to put on a resource after subscriptions have been sent.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubscriptionTag {
    /** **delivered**

Delivered. The message has been delivered to its intended recipient. */
    Delivered,
    /** **queued**

Queued. The message has been queued for processing on a destination systems. */
    Queued,
}
impl ::core::str::FromStr for SubscriptionTag {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "delivered" => Ok(Self::Delivered),
            "queued" => Ok(Self::Queued),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionTag {
    fn as_ref(&self) -> &str {
        match self {
            Self::Delivered => "delivered",
            Self::Queued => "queued",
        }
    }
}
impl ::std::fmt::Debug for SubscriptionTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubscriptionTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubscriptionTag {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionTag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionTag> for Coding {
    fn from(code: SubscriptionTag) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/subscription-tag".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubscriptionTag> for CodeableConcept {
    fn from(code: SubscriptionTag) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SupplyDeliveryStatus](http://hl7.org/fhir/ValueSet/supplydelivery-status)**. Status of the supply delivery.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SupplyDeliveryStatus {
    /** **abandoned**

Abandoned. Delivery was not completed. */
    Abandoned,
    /** **completed**

Delivered. Supply has been delivered ("completed"). */
    Completed,
    /** **entered-in-error**

Entered In Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".) */
    EnteredInError,
    /** **in-progress**

In Progress. Supply has been requested, but not delivered. */
    InProgress,
}
impl ::core::str::FromStr for SupplyDeliveryStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abandoned" => Ok(Self::Abandoned),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyDeliveryStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abandoned => "abandoned",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
        }
    }
}
impl ::std::fmt::Debug for SupplyDeliveryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SupplyDeliveryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SupplyDeliveryStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyDeliveryStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyDeliveryStatus> for Coding {
    fn from(code: SupplyDeliveryStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/supplydelivery-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SupplyDeliveryStatus> for CodeableConcept {
    fn from(code: SupplyDeliveryStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SupplyRequestReason](http://hl7.org/fhir/ValueSet/supplyrequest-reason)**. Why the supply item was requested\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SupplyRequestReason {
    /** **patient-care**

Patient Care. The supply has been requested for use in direct patient care. */
    PatientCare,
    /** **ward-stock**

Ward Stock. The supply has been requested for for creating or replenishing ward stock. */
    WardStock,
}
impl ::core::str::FromStr for SupplyRequestReason {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "patient-care" => Ok(Self::PatientCare),
            "ward-stock" => Ok(Self::WardStock),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyRequestReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::PatientCare => "patient-care",
            Self::WardStock => "ward-stock",
        }
    }
}
impl ::std::fmt::Debug for SupplyRequestReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SupplyRequestReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SupplyRequestReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyRequestReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyRequestReason> for Coding {
    fn from(code: SupplyRequestReason) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/supplyrequest-reason".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SupplyRequestReason> for CodeableConcept {
    fn from(code: SupplyRequestReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SupplyRequestStatus](http://hl7.org/fhir/ValueSet/supplyrequest-status)**. Status of the supply request\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SupplyRequestStatus {
    /** **active**

Active. The request is ready to be acted upon */
    Active,
    /** **cancelled**

Cancelled. The authorization/request to act has been terminated prior to the full completion of the intended actions.  No further activity should occur. */
    Cancelled,
    /** **completed**

Completed. Activity against the request has been sufficiently completed to the satisfaction of the requester */
    Completed,
    /** **draft**

Draft. The request has been created but is not yet complete or ready for action */
    Draft,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".) */
    EnteredInError,
    /** **suspended**

Suspended. The authorization/request to act has been temporarily withdrawn but is expected to resume in the future */
    Suspended,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this request.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for SupplyRequestStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "suspended" => Ok(Self::Suspended),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyRequestStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Suspended => "suspended",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for SupplyRequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SupplyRequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SupplyRequestStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyRequestStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyRequestStatus> for Coding {
    fn from(code: SupplyRequestStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/supplyrequest-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SupplyRequestStatus> for CodeableConcept {
    fn from(code: SupplyRequestStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SystemVersionProcessingMode](http://hl7.org/fhir/ValueSet/system-version-processing-mode)**. How to manage the intersection between a fixed version in a value set, and a fixed version of the system in the expansion profile\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SystemVersionProcessingMode {
    /** **check**

Check ValueSet Version. Use this version of the code system. If a value set specifies a different version, the expansion operation should fail */
    Check,
    /** **default**

Default Version. Use this version of the code system if a value set doesn't specify a version */
    Default,
    /** **override**

Override ValueSet Version. Use this version of the code system irrespective of which version is specified by a value set. Note that this has obvious safety issues, in that it may result in a value set expansion giving a different list of codes that is both wrong and unsafe, and implementers should only use this capability reluctantly. It primarily exists to deal with situations where specifications have fallen into decay as time passes. If a  version is override, the version used SHALL explicitly be represented in the expansion parameters */
    Override,
}
impl ::core::str::FromStr for SystemVersionProcessingMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "check" => Ok(Self::Check),
            "default" => Ok(Self::Default),
            "override" => Ok(Self::Override),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SystemVersionProcessingMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Check => "check",
            Self::Default => "default",
            Self::Override => "override",
        }
    }
}
impl ::std::fmt::Debug for SystemVersionProcessingMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SystemVersionProcessingMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SystemVersionProcessingMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SystemVersionProcessingMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SystemVersionProcessingMode> for Coding {
    fn from(code: SystemVersionProcessingMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/system-version-processing-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SystemVersionProcessingMode> for CodeableConcept {
    fn from(code: SystemVersionProcessingMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TaskPerformerType](http://hl7.org/fhir/ValueSet/task-performer-type)**. The type(s) of task performers allowed\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TaskPerformerType {
    /** **acquirer**

Acquirer. A workflow participant that acquires resources (specimens, images, etc) necessary to perform the task. */
    Acquirer,
    /** **dispatcher**

Dispatcher. A workflow participant that dispatches services (assigns another task to a participant). */
    Dispatcher,
    /** **manager**

Manager. A workflow participant that manages task activity. */
    Manager,
    /** **monitor**

Monitor. A workflow participant that monitors task activity. */
    Monitor,
    /** **performer**

Performer. A workflow participant that performs services. */
    Performer,
    /** **requester**

Requester. A workflow participant that requests services. */
    Requester,
    /** **reviewer**

Reviewer. A workflow participant that reviews task inputs or outputs. */
    Reviewer,
    /** **scheduler**

Scheduler. A workflow participant that schedules (dispatches and sets the time or date for performance of) services. */
    Scheduler,
}
impl ::core::str::FromStr for TaskPerformerType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acquirer" => Ok(Self::Acquirer),
            "dispatcher" => Ok(Self::Dispatcher),
            "manager" => Ok(Self::Manager),
            "monitor" => Ok(Self::Monitor),
            "performer" => Ok(Self::Performer),
            "requester" => Ok(Self::Requester),
            "reviewer" => Ok(Self::Reviewer),
            "scheduler" => Ok(Self::Scheduler),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TaskPerformerType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acquirer => "acquirer",
            Self::Dispatcher => "dispatcher",
            Self::Manager => "manager",
            Self::Monitor => "monitor",
            Self::Performer => "performer",
            Self::Requester => "requester",
            Self::Reviewer => "reviewer",
            Self::Scheduler => "scheduler",
        }
    }
}
impl ::std::fmt::Debug for TaskPerformerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TaskPerformerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TaskPerformerType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskPerformerType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TaskPerformerType> for Coding {
    fn from(code: TaskPerformerType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/task-performer-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TaskPerformerType> for CodeableConcept {
    fn from(code: TaskPerformerType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TaskStatus](http://hl7.org/fhir/ValueSet/task-status)**. The current status of the task.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TaskStatus {
    /** **accepted**

Accepted. The potential performer has agreed to execute the task but has not yet started work. */
    Accepted,
    /** **cancelled**

Cancelled. The task was not completed. */
    Cancelled,
    /** **completed**

Completed. The task has been completed. */
    Completed,
    /** **draft**

Draft. The task is not yet ready to be acted upon. */
    Draft,
    /** **entered-in-error**

Entered in Error. The task should never have existed and is retained only because of the possibility it may have used. */
    EnteredInError,
    /** **failed**

Failed. The task was attempted but could not be completed due to some error. */
    Failed,
    /** **in-progress**

In Progress. Task has been started but is not yet complete. */
    InProgress,
    /** **on-hold**

On Hold. Task has been started but work has been paused. */
    OnHold,
    /** **ready**

Ready. Task is ready to be performed, but no action has yet been taken.  Used in place of requested/received/accepted/rejected when request assignment and acceptance is a given. */
    Ready,
    /** **received**

Received. A potential performer has claimed ownership of the task and is evaluating whether to perform it. */
    Received,
    /** **rejected**

Rejected. The potential performer who claimed ownership of the task has decided not to execute it prior to performing any action. */
    Rejected,
    /** **requested**

Requested. The task is ready to be acted upon and action is sought. */
    Requested,
}
impl ::core::str::FromStr for TaskStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "failed" => Ok(Self::Failed),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "ready" => Ok(Self::Ready),
            "received" => Ok(Self::Received),
            "rejected" => Ok(Self::Rejected),
            "requested" => Ok(Self::Requested),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TaskStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Failed => "failed",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::Ready => "ready",
            Self::Received => "received",
            Self::Rejected => "rejected",
            Self::Requested => "requested",
        }
    }
}
impl ::std::fmt::Debug for TaskStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TaskStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TaskStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TaskStatus> for Coding {
    fn from(code: TaskStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/task-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TaskStatus> for CodeableConcept {
    fn from(code: TaskStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestReportActionResult](http://hl7.org/fhir/ValueSet/report-action-result-codes)**. The results of executing an action.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestReportActionResult {
    /** **error**

Error. The action encountered a fatal error and the engine was unable to process. */
    Error,
    /** **fail**

Fail. The action failed. */
    Fail,
    /** **pass**

Pass. The action was successful. */
    Pass,
    /** **skip**

Skip. The action was skipped. */
    Skip,
    /** **warning**

Warning. The action passed but with warnings. */
    Warning,
}
impl ::core::str::FromStr for TestReportActionResult {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "fail" => Ok(Self::Fail),
            "pass" => Ok(Self::Pass),
            "skip" => Ok(Self::Skip),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportActionResult {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Fail => "fail",
            Self::Pass => "pass",
            Self::Skip => "skip",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Debug for TestReportActionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestReportActionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestReportActionResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportActionResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportActionResult> for Coding {
    fn from(code: TestReportActionResult) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/report-action-result-codes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestReportActionResult> for CodeableConcept {
    fn from(code: TestReportActionResult) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestReportParticipantType](http://hl7.org/fhir/ValueSet/report-participant-type)**. The type of participant.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestReportParticipantType {
    /** **client**

Client. A FHIR Client */
    Client,
    /** **server**

Server. A FHIR Server */
    Server,
    /** **test-engine**

Test Engine. The test execution engine. */
    TestEngine,
}
impl ::core::str::FromStr for TestReportParticipantType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client" => Ok(Self::Client),
            "server" => Ok(Self::Server),
            "test-engine" => Ok(Self::TestEngine),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Client => "client",
            Self::Server => "server",
            Self::TestEngine => "test-engine",
        }
    }
}
impl ::std::fmt::Debug for TestReportParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestReportParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestReportParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportParticipantType> for Coding {
    fn from(code: TestReportParticipantType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/report-participant-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestReportParticipantType> for CodeableConcept {
    fn from(code: TestReportParticipantType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestReportResult](http://hl7.org/fhir/ValueSet/report-result-codes)**. The reported execution result.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestReportResult {
    /** **fail**

Fail. One or more test operations failed one or more asserts */
    Fail,
    /** **pass**

Pass. All test operations successfully passed all asserts */
    Pass,
    /** **pending**

Pending. One or more test operations is pending execution completion */
    Pending,
}
impl ::core::str::FromStr for TestReportResult {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fail" => Ok(Self::Fail),
            "pass" => Ok(Self::Pass),
            "pending" => Ok(Self::Pending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportResult {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fail => "fail",
            Self::Pass => "pass",
            Self::Pending => "pending",
        }
    }
}
impl ::std::fmt::Debug for TestReportResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestReportResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestReportResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportResult> for Coding {
    fn from(code: TestReportResult) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/report-result-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestReportResult> for CodeableConcept {
    fn from(code: TestReportResult) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestReportStatus](http://hl7.org/fhir/ValueSet/report-status-codes)**. The current status of the test report.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestReportStatus {
    /** **completed**

Completed. All test operations have completed */
    Completed,
    /** **entered-in-error**

Entered In Error. This test report was entered or created in error */
    EnteredInError,
    /** **in-progress**

In Progress. A test operations is currently executing */
    InProgress,
    /** **stopped**

Stopped. The test script execution was manually stopped */
    Stopped,
    /** **waiting**

Waiting. A test operation is waiting for an external client request */
    Waiting,
}
impl ::core::str::FromStr for TestReportStatus {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "stopped" => Ok(Self::Stopped),
            "waiting" => Ok(Self::Waiting),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Stopped => "stopped",
            Self::Waiting => "waiting",
        }
    }
}
impl ::std::fmt::Debug for TestReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportStatus> for Coding {
    fn from(code: TestReportStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/report-status-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestReportStatus> for CodeableConcept {
    fn from(code: TestReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestScriptOperationCode](http://hl7.org/fhir/ValueSet/testscript-operation-codes)**. This value set defines a set of codes that are used to indicate the supported operations of a testing engine or tool.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestScriptOperationCode {
    /** **apply**

$apply. Realize a definition in a specific context */
    Apply,
    /** **batch**

Batch. Update, create or delete a set of resources as independent actions. */
    Batch,
    /** **cancel**

$cancel. Cancel Task */
    Cancel,
    /** **capabilities**

Capabilities. Get a capability statement for the system. */
    Capabilities,
    /** **closure**

$closure. Closure Table Maintenance */
    Closure,
    /** **compose**

$compose. Code Composition based on supplied properties */
    Compose,
    /** **conforms**

$conforms. Test if a server implements a client's required operations */
    Conforms,
    /** **create**

Create. Create a new resource with a server assigned id. */
    Create,
    /** **data-requirements**

$data-requirements. Aggregates and return the parameters and data requirements as a single module definition library */
    DataRequirements,
    /** **delete**

Delete. Delete a resource. */
    Delete,
    /** **deleteCondMultiple**

Conditional Delete Multiple. Conditionally delete one or more resources based on search parameters. */
    DeleteCondMultiple,
    /** **deleteCondSingle**

Conditional Delete Single. Conditionally delete a single resource based on search parameters. */
    DeleteCondSingle,
    /** **document**

$document. Generate a Document */
    Document,
    /** **evaluate**

$evaluate. Evaluate DecisionSupportRule / DecisionSupportServiceModule */
    Evaluate,
    /** **evaluate-measure**

$evaluate-measure. Evaluate Measure */
    EvaluateMeasure,
    /** **everything**

$everything. Fetch Encounter/Patient Record */
    Everything,
    /** **expand**

$expand. Value Set Expansion */
    Expand,
    /** **fail**

$fail. Fail Task */
    Fail,
    /** **find**

$find. Find a functional list */
    Find,
    /** **finish**

$finish. Finish Task */
    Finish,
    /** **history**

History. Retrieve the change history for a particular resource or resource type. */
    History,
    /** **implements**

$implements. Test if a server implements a client's required operations */
    Implements,
    /** **lookup**

$lookup. Concept Look Up */
    Lookup,
    /** **match**

$match. Find patient matches using MPI based logic */
    Match,
    /** **meta**

$meta. Access a list of profiles, tags, and security labels */
    Meta,
    /** **meta-add**

$meta-add. Add profiles, tags, and security labels to a resource */
    MetaAdd,
    /** **meta-delete**

$meta-delete. Delete profiles, tags, and security labels for a resource */
    MetaDelete,
    /** **populate**

$populate. Populate Questionnaire */
    Populate,
    /** **populatehtml**

$populatehtml. Generate HTML for Questionnaire */
    Populatehtml,
    /** **populatelink**

$populatelink. Generate a link to a Questionnaire completion webpage */
    Populatelink,
    /** **process-message**

$process-message. Process Message */
    ProcessMessage,
    /** **questionnaire**

$questionnaire. Build Questionnaire */
    Questionnaire,
    /** **read**

Read. Read the current state of the resource. */
    Read,
    /** **release**

$release. Release Task */
    Release,
    /** **reserve**

$reserve. Reserve Task */
    Reserve,
    /** **resume**

$resume. Resume Task */
    Resume,
    /** **search**

Search. Search based on some filter criteria. */
    Search,
    /** **set-input**

$set-input. Set Task Input */
    SetInput,
    /** **set-output**

$set-output. Set Task Output */
    SetOutput,
    /** **start**

$start. Start Task */
    Start,
    /** **stats**

$stats. Observation Statistics */
    Stats,
    /** **stop**

$stop. Stop Task */
    Stop,
    /** **subset**

$subset. Fetch a subset of the CapabilityStatement resource */
    Subset,
    /** **subsumes**

$subsumes. Determine if code A is subsumed by code B */
    Subsumes,
    /** **suspend**

$suspend. Suspend Task */
    Suspend,
    /** **transaction**

Transaction. Update, create or delete a set of resources as a single transaction. */
    Transaction,
    /** **transform**

$transform. Model Instance Transformation */
    Transform,
    /** **translate**

$translate. Concept Translation */
    Translate,
    /** **update**

Update. Update an existing resource by its id. */
    Update,
    /** **updateCreate**

Create using Update. Update an existing resource by its id (or create it if it is new). */
    UpdateCreate,
    /** **validate**

$validate. Validate a resource */
    Validate,
    /** **validate-code**

$validate-code. Value Set based Validation */
    ValidateCode,
    /** **vread**

Version Read. Read the state of a specific version of the resource. */
    Vread,
}
impl ::core::str::FromStr for TestScriptOperationCode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "apply" => Ok(Self::Apply),
            "batch" => Ok(Self::Batch),
            "cancel" => Ok(Self::Cancel),
            "capabilities" => Ok(Self::Capabilities),
            "closure" => Ok(Self::Closure),
            "compose" => Ok(Self::Compose),
            "conforms" => Ok(Self::Conforms),
            "create" => Ok(Self::Create),
            "data-requirements" => Ok(Self::DataRequirements),
            "delete" => Ok(Self::Delete),
            "deleteCondMultiple" => Ok(Self::DeleteCondMultiple),
            "deleteCondSingle" => Ok(Self::DeleteCondSingle),
            "document" => Ok(Self::Document),
            "evaluate" => Ok(Self::Evaluate),
            "evaluate-measure" => Ok(Self::EvaluateMeasure),
            "everything" => Ok(Self::Everything),
            "expand" => Ok(Self::Expand),
            "fail" => Ok(Self::Fail),
            "find" => Ok(Self::Find),
            "finish" => Ok(Self::Finish),
            "history" => Ok(Self::History),
            "implements" => Ok(Self::Implements),
            "lookup" => Ok(Self::Lookup),
            "match" => Ok(Self::Match),
            "meta" => Ok(Self::Meta),
            "meta-add" => Ok(Self::MetaAdd),
            "meta-delete" => Ok(Self::MetaDelete),
            "populate" => Ok(Self::Populate),
            "populatehtml" => Ok(Self::Populatehtml),
            "populatelink" => Ok(Self::Populatelink),
            "process-message" => Ok(Self::ProcessMessage),
            "questionnaire" => Ok(Self::Questionnaire),
            "read" => Ok(Self::Read),
            "release" => Ok(Self::Release),
            "reserve" => Ok(Self::Reserve),
            "resume" => Ok(Self::Resume),
            "search" => Ok(Self::Search),
            "set-input" => Ok(Self::SetInput),
            "set-output" => Ok(Self::SetOutput),
            "start" => Ok(Self::Start),
            "stats" => Ok(Self::Stats),
            "stop" => Ok(Self::Stop),
            "subset" => Ok(Self::Subset),
            "subsumes" => Ok(Self::Subsumes),
            "suspend" => Ok(Self::Suspend),
            "transaction" => Ok(Self::Transaction),
            "transform" => Ok(Self::Transform),
            "translate" => Ok(Self::Translate),
            "update" => Ok(Self::Update),
            "updateCreate" => Ok(Self::UpdateCreate),
            "validate" => Ok(Self::Validate),
            "validate-code" => Ok(Self::ValidateCode),
            "vread" => Ok(Self::Vread),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestScriptOperationCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Apply => "apply",
            Self::Batch => "batch",
            Self::Cancel => "cancel",
            Self::Capabilities => "capabilities",
            Self::Closure => "closure",
            Self::Compose => "compose",
            Self::Conforms => "conforms",
            Self::Create => "create",
            Self::DataRequirements => "data-requirements",
            Self::Delete => "delete",
            Self::DeleteCondMultiple => "deleteCondMultiple",
            Self::DeleteCondSingle => "deleteCondSingle",
            Self::Document => "document",
            Self::Evaluate => "evaluate",
            Self::EvaluateMeasure => "evaluate-measure",
            Self::Everything => "everything",
            Self::Expand => "expand",
            Self::Fail => "fail",
            Self::Find => "find",
            Self::Finish => "finish",
            Self::History => "history",
            Self::Implements => "implements",
            Self::Lookup => "lookup",
            Self::Match => "match",
            Self::Meta => "meta",
            Self::MetaAdd => "meta-add",
            Self::MetaDelete => "meta-delete",
            Self::Populate => "populate",
            Self::Populatehtml => "populatehtml",
            Self::Populatelink => "populatelink",
            Self::ProcessMessage => "process-message",
            Self::Questionnaire => "questionnaire",
            Self::Read => "read",
            Self::Release => "release",
            Self::Reserve => "reserve",
            Self::Resume => "resume",
            Self::Search => "search",
            Self::SetInput => "set-input",
            Self::SetOutput => "set-output",
            Self::Start => "start",
            Self::Stats => "stats",
            Self::Stop => "stop",
            Self::Subset => "subset",
            Self::Subsumes => "subsumes",
            Self::Suspend => "suspend",
            Self::Transaction => "transaction",
            Self::Transform => "transform",
            Self::Translate => "translate",
            Self::Update => "update",
            Self::UpdateCreate => "updateCreate",
            Self::Validate => "validate",
            Self::ValidateCode => "validate-code",
            Self::Vread => "vread",
        }
    }
}
impl ::std::fmt::Debug for TestScriptOperationCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestScriptOperationCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestScriptOperationCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptOperationCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptOperationCode> for Coding {
    fn from(code: TestScriptOperationCode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/testscript-operation-codes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestScriptOperationCode> for CodeableConcept {
    fn from(code: TestScriptOperationCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestScriptProfileDestinationType](http://hl7.org/fhir/ValueSet/testscript-profile-destination-types)**. This value set defines a set of codes that are used to indicate the profile type of a test system when acting as the destination within a TestScript.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestScriptProfileDestinationType {
    /** **FHIR-SDC-FormManager**

FHIR SDC FormManager. A FHIR server acting as a Structured Data Capture Form Manager. */
    FhirSdcFormManager,
    /** **FHIR-SDC-FormProcessor**

FHIR SDC FormProcessor. A FHIR server acting as a Structured Data Capture Form Processor. */
    FhirSdcFormProcessor,
    /** **FHIR-SDC-FormReceiver**

FHIR SDC FormReceiver. A FHIR server acting as a Structured Data Capture Form Receiver. */
    FhirSdcFormReceiver,
    /** **FHIR-Server**

FHIR Server. General FHIR server used to respond to operations sent from a FHIR client. */
    FhirServer,
}
impl ::core::str::FromStr for TestScriptProfileDestinationType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "FHIR-SDC-FormManager" => Ok(Self::FhirSdcFormManager),
            "FHIR-SDC-FormProcessor" => Ok(Self::FhirSdcFormProcessor),
            "FHIR-SDC-FormReceiver" => Ok(Self::FhirSdcFormReceiver),
            "FHIR-Server" => Ok(Self::FhirServer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestScriptProfileDestinationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::FhirSdcFormManager => "FHIR-SDC-FormManager",
            Self::FhirSdcFormProcessor => "FHIR-SDC-FormProcessor",
            Self::FhirSdcFormReceiver => "FHIR-SDC-FormReceiver",
            Self::FhirServer => "FHIR-Server",
        }
    }
}
impl ::std::fmt::Debug for TestScriptProfileDestinationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestScriptProfileDestinationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestScriptProfileDestinationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptProfileDestinationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptProfileDestinationType> for Coding {
    fn from(code: TestScriptProfileDestinationType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/testscript-profile-destination-types"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestScriptProfileDestinationType> for CodeableConcept {
    fn from(code: TestScriptProfileDestinationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestScriptProfileOriginType](http://hl7.org/fhir/ValueSet/testscript-profile-origin-types)**. This value set defines a set of codes that are used to indicate the profile type of a test system when acting as the origin within a TestScript.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestScriptProfileOriginType {
    /** **FHIR-Client**

FHIR Client. General FHIR client used to initiate operations against a FHIR server. */
    FhirClient,
    /** **FHIR-SDC-FormFiller**

FHIR SDC FormFiller. A FHIR client acting as a Structured Data Capture Form Filler. */
    FhirSdcFormFiller,
}
impl ::core::str::FromStr for TestScriptProfileOriginType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "FHIR-Client" => Ok(Self::FhirClient),
            "FHIR-SDC-FormFiller" => Ok(Self::FhirSdcFormFiller),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestScriptProfileOriginType {
    fn as_ref(&self) -> &str {
        match self {
            Self::FhirClient => "FHIR-Client",
            Self::FhirSdcFormFiller => "FHIR-SDC-FormFiller",
        }
    }
}
impl ::std::fmt::Debug for TestScriptProfileOriginType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestScriptProfileOriginType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestScriptProfileOriginType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptProfileOriginType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptProfileOriginType> for Coding {
    fn from(code: TestScriptProfileOriginType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/testscript-profile-origin-types".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestScriptProfileOriginType> for CodeableConcept {
    fn from(code: TestScriptProfileOriginType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestScriptRequestMethodCode](http://hl7.org/fhir/ValueSet/http-operations)**. The allowable request method or HTTP operation codes.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestScriptRequestMethodCode {
    /** **delete**

DELETE. HTTP DELETE operation */
    Delete,
    /** **get**

GET. HTTP GET operation */
    Get,
    /** **options**

OPTIONS. HTTP OPTIONS operation */
    Options,
    /** **patch**

PATCH. HTTP PATCH operation */
    Patch,
    /** **post**

POST. HTTP POST operation */
    Post,
    /** **put**

PUT. HTTP PUT operation */
    Put,
}
impl ::core::str::FromStr for TestScriptRequestMethodCode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "delete" => Ok(Self::Delete),
            "get" => Ok(Self::Get),
            "options" => Ok(Self::Options),
            "patch" => Ok(Self::Patch),
            "post" => Ok(Self::Post),
            "put" => Ok(Self::Put),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestScriptRequestMethodCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Delete => "delete",
            Self::Get => "get",
            Self::Options => "options",
            Self::Patch => "patch",
            Self::Post => "post",
            Self::Put => "put",
        }
    }
}
impl ::std::fmt::Debug for TestScriptRequestMethodCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestScriptRequestMethodCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestScriptRequestMethodCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptRequestMethodCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptRequestMethodCode> for Coding {
    fn from(code: TestScriptRequestMethodCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/http-operations".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestScriptRequestMethodCode> for CodeableConcept {
    fn from(code: TestScriptRequestMethodCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TransactionMode](http://hl7.org/fhir/ValueSet/transaction-mode)**. A code that indicates how transactions are supported.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TransactionMode {
    /** **batch**

Batches supported. Batches are  supported. */
    Batch,
    /** **both**

Batches & Transactions. Both batches and transactions are supported. */
    Both,
    /** **not-supported**

None. Neither batch or transaction is supported. */
    NotSupported,
    /** **transaction**

Transactions Supported. Transactions are supported. */
    Transaction,
}
impl ::core::str::FromStr for TransactionMode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "batch" => Ok(Self::Batch),
            "both" => Ok(Self::Both),
            "not-supported" => Ok(Self::NotSupported),
            "transaction" => Ok(Self::Transaction),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TransactionMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Batch => "batch",
            Self::Both => "both",
            Self::NotSupported => "not-supported",
            Self::Transaction => "transaction",
        }
    }
}
impl ::std::fmt::Debug for TransactionMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TransactionMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TransactionMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TransactionMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TransactionMode> for Coding {
    fn from(code: TransactionMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/transaction-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TransactionMode> for CodeableConcept {
    fn from(code: TransactionMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TriggerType](http://hl7.org/fhir/ValueSet/trigger-type)**. The type of trigger\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TriggerType {
    /** **data-access-ended**

Data Access Ended. The trigger occurs whenever access to data of a particular type is completed */
    DataAccessEnded,
    /** **data-accessed**

Data Accessed. The trigger occurs whenever data of a particular type is accessed */
    DataAccessed,
    /** **data-added**

Data Added. The trigger occurs whenever data of a particular type is added */
    DataAdded,
    /** **data-modified**

Data Modified. The trigger occurs whenever data of a particular type is modified */
    DataModified,
    /** **data-removed**

Data Removed. The trigger occurs whenever data of a particular type is removed */
    DataRemoved,
    /** **named-event**

Named Event. The trigger occurs in response to a specific named event */
    NamedEvent,
    /** **periodic**

Periodic. The trigger occurs at a specific time or periodically as described by a timing or schedule */
    Periodic,
}
impl ::core::str::FromStr for TriggerType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-access-ended" => Ok(Self::DataAccessEnded),
            "data-accessed" => Ok(Self::DataAccessed),
            "data-added" => Ok(Self::DataAdded),
            "data-modified" => Ok(Self::DataModified),
            "data-removed" => Ok(Self::DataRemoved),
            "named-event" => Ok(Self::NamedEvent),
            "periodic" => Ok(Self::Periodic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TriggerType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataAccessEnded => "data-access-ended",
            Self::DataAccessed => "data-accessed",
            Self::DataAdded => "data-added",
            Self::DataModified => "data-modified",
            Self::DataRemoved => "data-removed",
            Self::NamedEvent => "named-event",
            Self::Periodic => "periodic",
        }
    }
}
impl ::std::fmt::Debug for TriggerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TriggerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TriggerType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TriggerType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TriggerType> for Coding {
    fn from(code: TriggerType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/trigger-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TriggerType> for CodeableConcept {
    fn from(code: TriggerType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TypeDerivationRule](http://hl7.org/fhir/ValueSet/type-derivation-rule)**. How a type relates to its baseDefinition.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TypeDerivationRule {
    /** **constraint**

Constraint. This definition adds additional rules to an existing concrete type */
    Constraint,
    /** **specialization**

Specialization. This definition defines a new type that adds additional elements to the base type */
    Specialization,
}
impl ::core::str::FromStr for TypeDerivationRule {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "constraint" => Ok(Self::Constraint),
            "specialization" => Ok(Self::Specialization),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TypeDerivationRule {
    fn as_ref(&self) -> &str {
        match self {
            Self::Constraint => "constraint",
            Self::Specialization => "specialization",
        }
    }
}
impl ::std::fmt::Debug for TypeDerivationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TypeDerivationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TypeDerivationRule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TypeDerivationRule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TypeDerivationRule> for Coding {
    fn from(code: TypeDerivationRule) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/type-derivation-rule".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TypeDerivationRule> for CodeableConcept {
    fn from(code: TypeDerivationRule) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[UDIEntryType](http://hl7.org/fhir/ValueSet/udi-entry-type)**. Codes to identify how UDI data was entered\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum UDIEntryType {
    /** **barcode**

BarCode. A Barcode scanner captured the data from the device label */
    Barcode,
    /** **card**

Card. The data originated from a patient's implant card and read by an operator. */
    Card,
    /** **manual**

Manual. The data was read from the label by a person and manually entered. (e.g.  via a keyboard) */
    Manual,
    /** **rfid**

RFID. An RFID chip reader captured the data from the device label */
    Rfid,
    /** **self-reported**

Self Reported. The data originated from a patient source and not directly scanned or read from a label or card. */
    SelfReported,
    /** **unknown**

Unknown. The method of data capture has not been determined */
    Unknown,
}
impl ::core::str::FromStr for UDIEntryType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "barcode" => Ok(Self::Barcode),
            "card" => Ok(Self::Card),
            "manual" => Ok(Self::Manual),
            "rfid" => Ok(Self::Rfid),
            "self-reported" => Ok(Self::SelfReported),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UDIEntryType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Barcode => "barcode",
            Self::Card => "card",
            Self::Manual => "manual",
            Self::Rfid => "rfid",
            Self::SelfReported => "self-reported",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for UDIEntryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for UDIEntryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for UDIEntryType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UDIEntryType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UDIEntryType> for Coding {
    fn from(code: UDIEntryType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/udi-entry-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<UDIEntryType> for CodeableConcept {
    fn from(code: UDIEntryType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[UnknownContentCode](http://hl7.org/fhir/ValueSet/unknown-content-code)**. A code that indicates whether an application accepts unknown elements or extensions when reading resources.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum UnknownContentCode {
    /** **both**

Unknown Elements and Extensions. The application accepts unknown elements and extensions. */
    Both,
    /** **elements**

Unknown Elements. The application accepts unknown elements, but not unknown extensions. */
    Elements,
    /** **extensions**

Unknown Extensions. The application accepts unknown extensions, but not unknown elements. */
    Extensions,
    /** **no**

Neither Elements or Extensions. The application does not accept either unknown elements or extensions. */
    No,
}
impl ::core::str::FromStr for UnknownContentCode {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "both" => Ok(Self::Both),
            "elements" => Ok(Self::Elements),
            "extensions" => Ok(Self::Extensions),
            "no" => Ok(Self::No),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UnknownContentCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Both => "both",
            Self::Elements => "elements",
            Self::Extensions => "extensions",
            Self::No => "no",
        }
    }
}
impl ::std::fmt::Debug for UnknownContentCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for UnknownContentCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for UnknownContentCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UnknownContentCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UnknownContentCode> for Coding {
    fn from(code: UnknownContentCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/unknown-content-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<UnknownContentCode> for CodeableConcept {
    fn from(code: UnknownContentCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[UsageContextType](http://hl7.org/fhir/ValueSet/usage-context-type)**. A code that specifies a type of context being specified by a usage context\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum UsageContextType {
    /** **age**

Age Range. The age of the patient. For this context type, the value should be a range the specifies the applicable ages or a code from the MeSH value set http://hl7.org/fhir/ValueSet/v3-AgeGroupObservationValue */
    Age,
    /** **focus**

Clinical Focus. The clinical concept(s) addressed by the artifact. For example, disease, diagnostic test interpretation, medication ordering as in http://hl7.org/fhir/ValueSet/condition-code. */
    Focus,
    /** **gender**

Gender. The gender of the patient. For this context type, the value should be a code taken from the http://hl7.org/fhir/ValueSet/administrative-gender value set */
    Gender,
    /** **species**

Species. The species to which an artifact applies. For example, SNOMED - 387961004 | Kingdom Animalia (organism). */
    Species,
    /** **task**

Workflow Task. The context for the clinical task(s) represented by this artifact. Can be any task context represented by the HL7 ActTaskCode value set http://hl7.org/fhir/ValueSet/v3-ActTaskCode. General categories include: order entry, patient documentation and patient information review. */
    Task,
    /** **user**

User Type. The clinical specialty of the context in which the patient is being treated - For example, PCP, Patient, Cardiologist, Behavioral Professional, Oral Health Professional, Prescriber, etc... taken from the NUCC Health Care provider taxonomy value set http://hl7.org/fhir/ValueSet/provider-taxonomy. */
    User,
    /** **venue**

Clinical Venue. The venue in which an artifact could be used. For example, Outpatient, Inpatient, Home, Nursing home. The code value may originate from either the HL7 ActEncounterCode http://hl7.org/fhir/ValueSet/v3-ActEncounterCode or NUCC non-individual provider codes http://hl7.org/fhir/ValueSet/provider-taxonomy */
    Venue,
    /** **workflow**

Workflow Setting. The settings in which the artifact is intended for use. For example, admission, pre-op, etc. For example, the ActEncounterCode value set http://hl7.org/fhir/ValueSet/v3-ActEncounterCode */
    Workflow,
}
impl ::core::str::FromStr for UsageContextType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "age" => Ok(Self::Age),
            "focus" => Ok(Self::Focus),
            "gender" => Ok(Self::Gender),
            "species" => Ok(Self::Species),
            "task" => Ok(Self::Task),
            "user" => Ok(Self::User),
            "venue" => Ok(Self::Venue),
            "workflow" => Ok(Self::Workflow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UsageContextType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Age => "age",
            Self::Focus => "focus",
            Self::Gender => "gender",
            Self::Species => "species",
            Self::Task => "task",
            Self::User => "user",
            Self::Venue => "venue",
            Self::Workflow => "workflow",
        }
    }
}
impl ::std::fmt::Debug for UsageContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for UsageContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for UsageContextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UsageContextType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UsageContextType> for Coding {
    fn from(code: UsageContextType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/usage-context-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<UsageContextType> for CodeableConcept {
    fn from(code: UsageContextType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[Use](http://hl7.org/fhir/ValueSet/claim-use)**. Complete, proposed, exploratory, other\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum Use {
    /** **complete**

Complete. The treatment is complete and this represents a Claim for the services. */
    Complete,
    /** **exploratory**

Exploratory. The treatment is proposed and this represents a Pre-determination for the services. */
    Exploratory,
    /** **other**

Other. A locally defined or otherwise resolved status. */
    Other,
    /** **proposed**

Proposed. The treatment is proposed and this represents a Pre-authorization for the services. */
    Proposed,
}
impl ::core::str::FromStr for Use {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "exploratory" => Ok(Self::Exploratory),
            "other" => Ok(Self::Other),
            "proposed" => Ok(Self::Proposed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Use {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Exploratory => "exploratory",
            Self::Other => "other",
            Self::Proposed => "proposed",
        }
    }
}
impl ::std::fmt::Debug for Use {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for Use {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for Use {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Use {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<Use> for Coding {
    fn from(code: Use) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/claim-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<Use> for CodeableConcept {
    fn from(code: Use) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[VisionBase](http://hl7.org/fhir/ValueSet/vision-base-codes)**. A coded concept listing the base codes.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum VisionBase {
    /** **down**

Down. bottom */
    Down,
    /** **in**

In. inner edge */
    In,
    /** **out**

Out. outer edge */
    Out,
    /** **up**

Up. top */
    Up,
}
impl ::core::str::FromStr for VisionBase {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "down" => Ok(Self::Down),
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            "up" => Ok(Self::Up),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VisionBase {
    fn as_ref(&self) -> &str {
        match self {
            Self::Down => "down",
            Self::In => "in",
            Self::Out => "out",
            Self::Up => "up",
        }
    }
}
impl ::std::fmt::Debug for VisionBase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for VisionBase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for VisionBase {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VisionBase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<VisionBase> for Coding {
    fn from(code: VisionBase) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/vision-base-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<VisionBase> for CodeableConcept {
    fn from(code: VisionBase) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[VisionEyes](http://hl7.org/fhir/ValueSet/vision-eye-codes)**. A coded concept listing the eye codes.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum VisionEyes {
    /** **left**

Left Eye. Left Eye */
    Left,
    /** **right**

Right Eye. Right Eye */
    Right,
}
impl ::core::str::FromStr for VisionEyes {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VisionEyes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Left => "left",
            Self::Right => "right",
        }
    }
}
impl ::std::fmt::Debug for VisionEyes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for VisionEyes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for VisionEyes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VisionEyes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<VisionEyes> for Coding {
    fn from(code: VisionEyes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/vision-eye-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<VisionEyes> for CodeableConcept {
    fn from(code: VisionEyes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[W3cProvenanceActivityType](http://hl7.org/fhir/w3c-provenance-activity-type)**. This value set includes W3C PROV Data Model Activity concepts, which are treated as codes in this valueset.  Some adaptations were made to make these concepts suitable values for the Provenance.activity element. Coded concepts are from PROV-DM and the display names are their counterparts in PROV-N (human readable notation syntax specification).[code system OID: http://www.w3.org/TR/2013/REC-prov-dm-20130430/ and http://www.w3.org/TR/2013/REC-prov-n-20130430/]\n\nFHIR version: 1.1.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum W3cProvenanceActivityType {
    /** **Attribution**

wasAttributedTo. Ascribing of an entity (object/document) to an agent. */
    Attribution,
    /** **Collection**

isCollectionOf.  An aggregating activity that results in composition of an entity, which provides a structure to some constituents that must themselves be entities. These constituents are said to be member of the collections. */
    Collection,
    /** **Communication**

wasInformedBy. The exchange of some unspecified entity by two activities, one activity using some entity generated by the other. A communication implies that activity a2 is dependent on another activity, a1, by way of some unspecified entity that is generated by a1 and used by a2. */
    Communication,
    /** **Derivation**

wasDerivedFrom. A transformation of an entity into another, an update of an entity resulting in a new one, or the construction of a new entity based on a pre-existing entity. For an entity to be transformed from, created from, or resulting from an update to another, there must be some underpinning activity or activities performing the necessary action(s) resulting in such a derivation. A derivation can be described at various levels of precision. In its simplest form, derivation relates two entities. Optionally, attributes can be added to represent further information about the derivation. If the derivation is the result of a single known activity, then this activity can also be optionally expressed. To provide a completely accurate description of the derivation, the generation and usage of the generated and used entities, respectively, can be provided, so as to make the derivation path, through usage, activity, and generation, explicit. Optional information such as activity, generation, and usage can be linked to derivations to aid analysis of provenance and to facilitate provenance-based reproducibility. */
    Derivation,
    /** **End**

wasEndedBy. When an activity is deemed to have been ended by an entity, known as trigger. The activity no longer exists after its end. Any usage, generation, or invalidation involving an activity precedes the activity's end. An end may refer to a trigger entity that terminated the activity, or to an activity, known as ender that generated the trigger. */
    End,
    /** **Generation**

wasGeneratedBy. The completion of production of a new entity by an activity. This entity did not exist before generation and becomes available for usage after this generation. Given that a generation is the completion of production of an entity, it is instantaneous. */
    Generation,
    /** **Invalidation**

wasInvalidatedBy. The start of the destruction, cessation, or expiry of an existing entity by an activity. The entity is no longer available for use (or further invalidation) after invalidation. Any generation or usage of an entity precedes its invalidation. Given that an invalidation is the start of destruction, cessation, or expiry, it is instantaneous. */
    Invalidation,
    /** **Primary-Source**

wasPrimarySourceOf. Refers to something produced by some agent with direct experience and knowledge about the topic, at the time of the topic's study, without benefit from hindsight. Because of the directness of primary sources, they 'speak for themselves' in ways that cannot be captured through the filter of secondary sources. As such, it is important for secondary sources to reference those primary sources from which they were derived, so that their reliability can be investigated. It is also important to note that a given entity might be a primary source for one entity but not another. It is the reason why Primary Source is defined as a relation as opposed to a subtype of Entity. */
    PrimarySource,
    /** **Quotation**

wasQuotedFrom. The repeat of (some or all of) an entity, such as text or image, by someone who may or may not be its original author. A quotation relation is a kind of derivation relation, for which an entity was derived from a preceding entity by copying, or 'quoting', some or all of it. */
    Quotation,
    /** **Revision**

wasRevisionOf. A derivation for which the resulting entity is a revised version of some original. The implication here is that the resulting entity contains substantial content from the original. A revision relation is a kind of derivation relation from a revised entity to a preceding entity. */
    Revision,
    /** **Start**

wasStartedBy. When an activity is deemed to have been started by an entity, known as trigger. The activity did not exist before its start. Any usage, generation, or invalidation involving an activity follows the activity's start. A start may refer to a trigger entity that set off the activity, or to an activity, known as starter, that generated the trigger. Given that a start is when an activity is deemed to have started, it is instantaneous. */
    Start,
    /** **Usage**

used. the beginning of utilizing an entity by an activity. Before usage, the activity had not begun to utilize this entity and could not have been affected by the entity.  (Note: This definition is formulated for a given usage; it is permitted for an activity to have used a same entity multiple times.) Given that a usage is the beginning of utilizing an entity, it is instantaneous. */
    Usage,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for W3cProvenanceActivityType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Attribution" => Ok(Self::Attribution),
            "Collection" => Ok(Self::Collection),
            "Communication" => Ok(Self::Communication),
            "Derivation" => Ok(Self::Derivation),
            "End" => Ok(Self::End),
            "Generation" => Ok(Self::Generation),
            "Invalidation" => Ok(Self::Invalidation),
            "Primary-Source" => Ok(Self::PrimarySource),
            "Quotation" => Ok(Self::Quotation),
            "Revision" => Ok(Self::Revision),
            "Start" => Ok(Self::Start),
            "Usage" => Ok(Self::Usage),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for W3cProvenanceActivityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attribution => "Attribution",
            Self::Collection => "Collection",
            Self::Communication => "Communication",
            Self::Derivation => "Derivation",
            Self::End => "End",
            Self::Generation => "Generation",
            Self::Invalidation => "Invalidation",
            Self::PrimarySource => "Primary-Source",
            Self::Quotation => "Quotation",
            Self::Revision => "Revision",
            Self::Start => "Start",
            Self::Usage => "Usage",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for W3cProvenanceActivityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for W3cProvenanceActivityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for W3cProvenanceActivityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for W3cProvenanceActivityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<W3cProvenanceActivityType> for Coding {
    fn from(code: W3cProvenanceActivityType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/w3c-provenance-activity-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<W3cProvenanceActivityType> for CodeableConcept {
    fn from(code: W3cProvenanceActivityType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[XPathUsageType](http://hl7.org/fhir/ValueSet/search-xpath-usage)**. How a search parameter relates to the set of elements returned by evaluating its xpath query.\n\nFHIR version: 3.0.2."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum XPathUsageType {
    /** **distance**

Distance. The search parameter is based on a spatial transform of the selected nodes, using physical distance from the middle. */
    Distance,
    /** **nearby**

Nearby. The search parameter is based on a spatial transform of the selected nodes. */
    Nearby,
    /** **normal**

Normal. The search parameter is derived directly from the selected nodes based on the type definitions. */
    Normal,
    /** **other**

Other. The interpretation of the xpath statement is unknown (and can't be automated). */
    Other,
    /** **phonetic**

Phonetic. The search parameter is derived by a phonetic transform from the selected nodes. */
    Phonetic,
}
impl ::core::str::FromStr for XPathUsageType {
    type Err = String;
    #[allow(
        clippy::match_single_binding,
        reason = "Generated code; unknown number of variants"
    )]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "distance" => Ok(Self::Distance),
            "nearby" => Ok(Self::Nearby),
            "normal" => Ok(Self::Normal),
            "other" => Ok(Self::Other),
            "phonetic" => Ok(Self::Phonetic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for XPathUsageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Distance => "distance",
            Self::Nearby => "nearby",
            Self::Normal => "normal",
            Self::Other => "other",
            Self::Phonetic => "phonetic",
        }
    }
}
impl ::std::fmt::Debug for XPathUsageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for XPathUsageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for XPathUsageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for XPathUsageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<XPathUsageType> for Coding {
    fn from(code: XPathUsageType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-xpath-usage".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<XPathUsageType> for CodeableConcept {
    fn from(code: XPathUsageType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
