//! Generated code! Take a look at the generator-crate for changing this file!
#![allow(clippy::too_many_lines)]
use serde::{Serialize, Deserialize};
use super::super::types::{Coding, CodingInner, CodeableConcept, CodeableConceptInner};
#[doc = "**[ACMECholCodesBlood](http://hl7.org/fhir/CodeSystem/example)**. This is an example code system that includes all the ACME codes for serum/plasma cholesterol from v2.36.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ACMECholCodesBlood {
    /** **chol**

SChol. Serum Cholesterol */
    Chol,
    /** **chol-mass**

SChol (mg/L). Serum Cholesterol, in mg/L */
    CholMass,
    /** **chol-mmol**

SChol (mmol/L). Serum Cholesterol, in mmol/L */
    CholMmol,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ACMECholCodesBlood {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "chol" => Ok(Self::Chol),
            "chol-mass" => Ok(Self::CholMass),
            "chol-mmol" => Ok(Self::CholMmol),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ACMECholCodesBlood {
    fn as_ref(&self) -> &str {
        match self {
            Self::Chol => "chol",
            Self::CholMass => "chol-mass",
            Self::CholMmol => "chol-mmol",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ACMECholCodesBlood {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ACMECholCodesBlood {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ACMECholCodesBlood {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ACMECholCodesBlood {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ACMECholCodesBlood> for Coding {
    fn from(code: ACMECholCodesBlood) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/CodeSystem/example".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ACMECholCodesBlood> for CodeableConcept {
    fn from(code: ACMECholCodesBlood) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AbstractType](http://hl7.org/fhir/abstract-types)**. A list of the base types defined by this version of the FHIR specification - types that are defined, but for which only specializations actually are created.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum AbstractType {
    /** **Any**

Any. A place holder that means any kind of resource */
    Any,
    /** **Type**

Type. A place holder that means any kind of data type */
    Type,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AbstractType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Any" => Ok(Self::Any),
            "Type" => Ok(Self::Type),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AbstractType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Any => "Any",
            Self::Type => "Type",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for AbstractType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AbstractType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AbstractType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AbstractType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AbstractType> for Coding {
    fn from(code: AbstractType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/abstract-types".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AbstractType> for CodeableConcept {
    fn from(code: AbstractType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AccountStatus](http://hl7.org/fhir/ValueSet/account-status)**. Indicates whether the account is available to be used.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AccountStatus {
    /** **active**

Active. This account is active and may be used. */
    Active,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **inactive**

Inactive. This account is inactive and should not be used to track financial information. */
    Inactive,
    /** **on-hold**

On Hold. This account is on hold. */
    OnHold,
    /** **unknown**

Unknown. The account status is unknown. */
    Unknown,
}
impl ::core::str::FromStr for AccountStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "on-hold" => Ok(Self::OnHold),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AccountStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::OnHold => "on-hold",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for AccountStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AccountStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AccountStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AccountStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AccountStatus> for Coding {
    fn from(code: AccountStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/account-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AccountStatus> for CodeableConcept {
    fn from(code: AccountStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionCardinalityBehavior](http://hl7.org/fhir/ValueSet/action-cardinality-behavior)**. Defines behavior for an action or a group for how many times that item may be repeated.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionCardinalityBehavior {
    /** **multiple**

Multiple. The action may be selected multiple times. */
    Multiple,
    /** **single**

Single. The action may only be selected one time. */
    Single,
}
impl ::core::str::FromStr for ActionCardinalityBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "multiple" => Ok(Self::Multiple),
            "single" => Ok(Self::Single),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionCardinalityBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::Multiple => "multiple",
            Self::Single => "single",
        }
    }
}
impl ::std::fmt::Debug for ActionCardinalityBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionCardinalityBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionCardinalityBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionCardinalityBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionCardinalityBehavior> for Coding {
    fn from(code: ActionCardinalityBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-cardinality-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionCardinalityBehavior> for CodeableConcept {
    fn from(code: ActionCardinalityBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionCode](http://hl7.org/fhir/ValueSet/action-code)**. Provides examples of actions to be performed.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionCode {
    /** **collect-information**

Collect information. The action indicates that information should be collected from a participant in the process. */
    CollectInformation,
    /** **order-service**

Order a service. The action indicates that a particular service should be provided. */
    OrderService,
    /** **prescribe-medication**

Prescribe a medication. The action indicates that a particular medication should be prescribed to the patient. */
    PrescribeMedication,
    /** **propose-diagnosis**

Propose a diagnosis. The action indicates that a particular diagnosis should be proposed. */
    ProposeDiagnosis,
    /** **recommend-immunization**

Recommend an immunization. The action indicates that a particular immunization should be performed. */
    RecommendImmunization,
    /** **record-detected-issue**

Record a detected issue. The action indicates that a particular detected issue should be recorded. */
    RecordDetectedIssue,
    /** **record-inference**

Record an inference. The action indicates that a particular inference should be recorded. */
    RecordInference,
    /** **report-flag**

Report a flag. The action indicates that a particular flag should be reported. */
    ReportFlag,
    /** **send-message**

Send a message. The action indicates that a particular message should be sent to a participant in the process. */
    SendMessage,
}
impl ::core::str::FromStr for ActionCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "collect-information" => Ok(Self::CollectInformation),
            "order-service" => Ok(Self::OrderService),
            "prescribe-medication" => Ok(Self::PrescribeMedication),
            "propose-diagnosis" => Ok(Self::ProposeDiagnosis),
            "recommend-immunization" => Ok(Self::RecommendImmunization),
            "record-detected-issue" => Ok(Self::RecordDetectedIssue),
            "record-inference" => Ok(Self::RecordInference),
            "report-flag" => Ok(Self::ReportFlag),
            "send-message" => Ok(Self::SendMessage),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::CollectInformation => "collect-information",
            Self::OrderService => "order-service",
            Self::PrescribeMedication => "prescribe-medication",
            Self::ProposeDiagnosis => "propose-diagnosis",
            Self::RecommendImmunization => "recommend-immunization",
            Self::RecordDetectedIssue => "record-detected-issue",
            Self::RecordInference => "record-inference",
            Self::ReportFlag => "report-flag",
            Self::SendMessage => "send-message",
        }
    }
}
impl ::std::fmt::Debug for ActionCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionCode> for Coding {
    fn from(code: ActionCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/action-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionCode> for CodeableConcept {
    fn from(code: ActionCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionConditionKind](http://hl7.org/fhir/ValueSet/action-condition-kind)**. Defines the kinds of conditions that can appear on actions.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionConditionKind {
    /** **applicability**

Applicability. The condition describes whether or not a given action is applicable. */
    Applicability,
    /** **start**

Start. The condition is a starting condition for the action. */
    Start,
    /** **stop**

Stop. The condition is a stop, or exit condition for the action. */
    Stop,
}
impl ::core::str::FromStr for ActionConditionKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "applicability" => Ok(Self::Applicability),
            "start" => Ok(Self::Start),
            "stop" => Ok(Self::Stop),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionConditionKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Applicability => "applicability",
            Self::Start => "start",
            Self::Stop => "stop",
        }
    }
}
impl ::std::fmt::Debug for ActionConditionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionConditionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionConditionKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionConditionKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionConditionKind> for Coding {
    fn from(code: ActionConditionKind) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-condition-kind".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionConditionKind> for CodeableConcept {
    fn from(code: ActionConditionKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionGroupingBehavior](http://hl7.org/fhir/ValueSet/action-grouping-behavior)**. Defines organization behavior of a group.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionGroupingBehavior {
    /** **logical-group**

Logical Group. A group with this behavior logically groups its sub-elements, and may be shown as a visual group to the end user, but it is not required to do so. */
    LogicalGroup,
    /** **sentence-group**

Sentence Group. A group of related alternative actions is a sentence group if the target referenced by the action is the same in all the actions and each action simply constitutes a different variation on how to specify the details for the target. For example, two actions that could be in a SentenceGroup are "aspirin, 500 mg, 2 times per day" and "aspirin, 300 mg, 3 times per day". In both cases, aspirin is the target referenced by the action, and the two actions represent different options for how aspirin might be ordered for the patient. Note that a SentenceGroup would almost always have an associated selection behavior of "AtMostOne", unless it's a required action, in which case, it would be "ExactlyOne". */
    SentenceGroup,
    /** **visual-group**

Visual Group. Any group marked with this behavior should be displayed as a visual group to the end user. */
    VisualGroup,
}
impl ::core::str::FromStr for ActionGroupingBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "logical-group" => Ok(Self::LogicalGroup),
            "sentence-group" => Ok(Self::SentenceGroup),
            "visual-group" => Ok(Self::VisualGroup),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionGroupingBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::LogicalGroup => "logical-group",
            Self::SentenceGroup => "sentence-group",
            Self::VisualGroup => "visual-group",
        }
    }
}
impl ::std::fmt::Debug for ActionGroupingBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionGroupingBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionGroupingBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionGroupingBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionGroupingBehavior> for Coding {
    fn from(code: ActionGroupingBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-grouping-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionGroupingBehavior> for CodeableConcept {
    fn from(code: ActionGroupingBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionParticipantType](http://hl7.org/fhir/ValueSet/action-participant-type)**. The type of participant for the action.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionParticipantType {
    /** **device**

Device. The participant is a system or device used in the care of the patient. */
    Device,
    /** **patient**

Patient. The participant is the patient under evaluation. */
    Patient,
    /** **practitioner**

Practitioner. The participant is a practitioner involved in the patient's care. */
    Practitioner,
    /** **related-person**

Related Person. The participant is a person related to the patient. */
    RelatedPerson,
}
impl ::core::str::FromStr for ActionParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "device" => Ok(Self::Device),
            "patient" => Ok(Self::Patient),
            "practitioner" => Ok(Self::Practitioner),
            "related-person" => Ok(Self::RelatedPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "device",
            Self::Patient => "patient",
            Self::Practitioner => "practitioner",
            Self::RelatedPerson => "related-person",
        }
    }
}
impl ::std::fmt::Debug for ActionParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionParticipantType> for Coding {
    fn from(code: ActionParticipantType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-participant-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionParticipantType> for CodeableConcept {
    fn from(code: ActionParticipantType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionPrecheckBehavior](http://hl7.org/fhir/ValueSet/action-precheck-behavior)**. Defines selection frequency behavior for an action or group.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionPrecheckBehavior {
    /** **no**

No. An action with this behavior is one of the less frequent actions included by the end user, for the particular context in which the action occurs. The system displaying the actions to the end user would typically not "pre-check" such an action. */
    No,
    /** **yes**

Yes. An action with this behavior is one of the most frequent action that is, or should be, included by an end user, for the particular context in which the action occurs. The system displaying the action to the end user should consider "pre-checking" such an action as a convenience for the user. */
    Yes,
}
impl ::core::str::FromStr for ActionPrecheckBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "no" => Ok(Self::No),
            "yes" => Ok(Self::Yes),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionPrecheckBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::No => "no",
            Self::Yes => "yes",
        }
    }
}
impl ::std::fmt::Debug for ActionPrecheckBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionPrecheckBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionPrecheckBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionPrecheckBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionPrecheckBehavior> for Coding {
    fn from(code: ActionPrecheckBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-precheck-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionPrecheckBehavior> for CodeableConcept {
    fn from(code: ActionPrecheckBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionReasonCode](http://hl7.org/fhir/ValueSet/action-reason-code)**. Provides examples of reasons for actions to be performed.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionReasonCode {
    /** **care-gap**

Care gap detected. The action should be performed to address a detected care gap. */
    CareGap,
    /** **drug-drug-interaction**

Drug-drug interaction. The action should be performed to address a detected potential drug-drug interaction. */
    DrugDrugInteraction,
    /** **off-pathway**

Off pathway. The action should be performed because the patient was determined to be off pathway. */
    OffPathway,
    /** **quality-measure**

Quality measure. The action should be performed to bring the patient's care in line with a quality measure. */
    QualityMeasure,
    /** **risk-assessment**

Risk assessment. The action should be performed based on a particular risk assessment. */
    RiskAssessment,
}
impl ::core::str::FromStr for ActionReasonCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "care-gap" => Ok(Self::CareGap),
            "drug-drug-interaction" => Ok(Self::DrugDrugInteraction),
            "off-pathway" => Ok(Self::OffPathway),
            "quality-measure" => Ok(Self::QualityMeasure),
            "risk-assessment" => Ok(Self::RiskAssessment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionReasonCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::CareGap => "care-gap",
            Self::DrugDrugInteraction => "drug-drug-interaction",
            Self::OffPathway => "off-pathway",
            Self::QualityMeasure => "quality-measure",
            Self::RiskAssessment => "risk-assessment",
        }
    }
}
impl ::std::fmt::Debug for ActionReasonCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionReasonCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionReasonCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionReasonCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionReasonCode> for Coding {
    fn from(code: ActionReasonCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/action-reason-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionReasonCode> for CodeableConcept {
    fn from(code: ActionReasonCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionRelationshipType](http://hl7.org/fhir/ValueSet/action-relationship-type)**. Defines the types of relationships between actions.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionRelationshipType {
    /** **after**

After. The action must be performed after the related action. */
    After,
    /** **after-end**

After End. The action must be performed after the end of the related action. */
    AfterEnd,
    /** **after-start**

After Start. The action must be performed after the start of the related action. */
    AfterStart,
    /** **before**

Before. The action must be performed before the related action. */
    Before,
    /** **before-end**

Before End. The action must be performed before the end of the related action. */
    BeforeEnd,
    /** **before-start**

Before Start. The action must be performed before the start of the related action. */
    BeforeStart,
    /** **concurrent**

Concurrent. The action must be performed concurrent with the related action. */
    Concurrent,
    /** **concurrent-with-end**

Concurrent With End. The action must be performed concurrent with the end of the related action. */
    ConcurrentWithEnd,
    /** **concurrent-with-start**

Concurrent With Start. The action must be performed concurrent with the start of the related action. */
    ConcurrentWithStart,
}
impl ::core::str::FromStr for ActionRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "after" => Ok(Self::After),
            "after-end" => Ok(Self::AfterEnd),
            "after-start" => Ok(Self::AfterStart),
            "before" => Ok(Self::Before),
            "before-end" => Ok(Self::BeforeEnd),
            "before-start" => Ok(Self::BeforeStart),
            "concurrent" => Ok(Self::Concurrent),
            "concurrent-with-end" => Ok(Self::ConcurrentWithEnd),
            "concurrent-with-start" => Ok(Self::ConcurrentWithStart),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::After => "after",
            Self::AfterEnd => "after-end",
            Self::AfterStart => "after-start",
            Self::Before => "before",
            Self::BeforeEnd => "before-end",
            Self::BeforeStart => "before-start",
            Self::Concurrent => "concurrent",
            Self::ConcurrentWithEnd => "concurrent-with-end",
            Self::ConcurrentWithStart => "concurrent-with-start",
        }
    }
}
impl ::std::fmt::Debug for ActionRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionRelationshipType> for Coding {
    fn from(code: ActionRelationshipType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-relationship-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionRelationshipType> for CodeableConcept {
    fn from(code: ActionRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionRequiredBehavior](http://hl7.org/fhir/ValueSet/action-required-behavior)**. Defines expectations around whether an action or action group is required.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionRequiredBehavior {
    /** **could**

Could. An action with this behavior may be included in the set of actions processed by the end user. */
    Could,
    /** **must**

Must. An action with this behavior must be included in the actions processed by the end user; the end user SHALL NOT choose not to include this action. */
    Must,
    /** **must-unless-documented**

Must Unless Documented. An action with this behavior must be included in the set of actions processed by the end user, unless the end user provides documentation as to why the action was not included. */
    MustUnlessDocumented,
}
impl ::core::str::FromStr for ActionRequiredBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "could" => Ok(Self::Could),
            "must" => Ok(Self::Must),
            "must-unless-documented" => Ok(Self::MustUnlessDocumented),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionRequiredBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::Could => "could",
            Self::Must => "must",
            Self::MustUnlessDocumented => "must-unless-documented",
        }
    }
}
impl ::std::fmt::Debug for ActionRequiredBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionRequiredBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionRequiredBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionRequiredBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionRequiredBehavior> for Coding {
    fn from(code: ActionRequiredBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-required-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionRequiredBehavior> for CodeableConcept {
    fn from(code: ActionRequiredBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionSelectionBehavior](http://hl7.org/fhir/ValueSet/action-selection-behavior)**. Defines selection behavior of a group.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionSelectionBehavior {
    /** **all**

All. All the actions in the group must be selected as a single unit. */
    All,
    /** **all-or-none**

All Or None. All the actions in the group are meant to be chosen as a single unit: either all must be selected by the end user, or none may be selected. */
    AllOrNone,
    /** **any**

Any. Any number of the actions in the group may be chosen, from zero to all. */
    Any,
    /** **at-most-one**

At Most One. The end user may choose zero or at most one of the actions in the group. */
    AtMostOne,
    /** **exactly-one**

Exactly One. The end user must choose one and only one of the selectable actions in the group. The user SHALL NOT choose none of the actions in the group. */
    ExactlyOne,
    /** **one-or-more**

One Or More. The end user must choose a minimum of one, and as many additional as desired. */
    OneOrMore,
}
impl ::core::str::FromStr for ActionSelectionBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "all-or-none" => Ok(Self::AllOrNone),
            "any" => Ok(Self::Any),
            "at-most-one" => Ok(Self::AtMostOne),
            "exactly-one" => Ok(Self::ExactlyOne),
            "one-or-more" => Ok(Self::OneOrMore),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionSelectionBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::All => "all",
            Self::AllOrNone => "all-or-none",
            Self::Any => "any",
            Self::AtMostOne => "at-most-one",
            Self::ExactlyOne => "exactly-one",
            Self::OneOrMore => "one-or-more",
        }
    }
}
impl ::std::fmt::Debug for ActionSelectionBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionSelectionBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionSelectionBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionSelectionBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionSelectionBehavior> for Coding {
    fn from(code: ActionSelectionBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/action-selection-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionSelectionBehavior> for CodeableConcept {
    fn from(code: ActionSelectionBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ActionType](http://hl7.org/fhir/ValueSet/action-type)**. The type of action to be performed.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ActionType {
    /** **create**

Create. The action is to create a new resource. */
    Create,
    /** **fire-event**

Fire Event. The action is to fire a specific event. */
    FireEvent,
    /** **remove**

Remove. The action is to remove an existing resource. */
    Remove,
    /** **update**

Update. The action is to update an existing resource. */
    Update,
}
impl ::core::str::FromStr for ActionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "create" => Ok(Self::Create),
            "fire-event" => Ok(Self::FireEvent),
            "remove" => Ok(Self::Remove),
            "update" => Ok(Self::Update),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Create => "create",
            Self::FireEvent => "fire-event",
            Self::Remove => "remove",
            Self::Update => "update",
        }
    }
}
impl ::std::fmt::Debug for ActionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ActionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ActionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionType> for Coding {
    fn from(code: ActionType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/action-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ActionType> for CodeableConcept {
    fn from(code: ActionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdditionalMonitoring](http://hl7.org/fhir/ValueSet/medicinal-product-additional-monitoring)**. Extra monitoring defined for a Medicinal Product.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdditionalMonitoring {
    /** **BlackTriangleMonitoring**

Requirement for Black Triangle Monitoring. Requirement for Black Triangle Monitoring */
    BlackTriangleMonitoring,
}
impl ::core::str::FromStr for AdditionalMonitoring {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BlackTriangleMonitoring" => Ok(Self::BlackTriangleMonitoring),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdditionalMonitoring {
    fn as_ref(&self) -> &str {
        match self {
            Self::BlackTriangleMonitoring => "BlackTriangleMonitoring",
        }
    }
}
impl ::std::fmt::Debug for AdditionalMonitoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdditionalMonitoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdditionalMonitoring {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdditionalMonitoring {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdditionalMonitoring> for Coding {
    fn from(code: AdditionalMonitoring) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-additional-monitoring"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdditionalMonitoring> for CodeableConcept {
    fn from(code: AdditionalMonitoring) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AddressType](http://hl7.org/fhir/ValueSet/address-type)**. The type of an address (physical / postal).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AddressType {
    /** **both**

Postal & Physical. An address that is both physical and postal. */
    Both,
    /** **physical**

Physical. A physical address that can be visited. */
    Physical,
    /** **postal**

Postal. Mailing addresses - PO Boxes and care-of addresses. */
    Postal,
}
impl ::core::str::FromStr for AddressType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "both" => Ok(Self::Both),
            "physical" => Ok(Self::Physical),
            "postal" => Ok(Self::Postal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AddressType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Both => "both",
            Self::Physical => "physical",
            Self::Postal => "postal",
        }
    }
}
impl ::std::fmt::Debug for AddressType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AddressType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AddressType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AddressType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AddressType> for Coding {
    fn from(code: AddressType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/address-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AddressType> for CodeableConcept {
    fn from(code: AddressType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AddressUse](http://hl7.org/fhir/ValueSet/address-use)**. The use of an address.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AddressUse {
    /** **billing**

Billing. An address to be used to send bills, invoices, receipts etc. */
    Billing,
    /** **home**

Home. A communication address at a home. */
    Home,
    /** **old**

Old / Incorrect. This address is no longer in use (or was never correct but retained for records). */
    Old,
    /** **temp**

Temporary. A temporary address. The period can provide more detailed information. */
    Temp,
    /** **work**

Work. An office address. First choice for business related contacts during business hours. */
    Work,
}
impl ::core::str::FromStr for AddressUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "billing" => Ok(Self::Billing),
            "home" => Ok(Self::Home),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "work" => Ok(Self::Work),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AddressUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Billing => "billing",
            Self::Home => "home",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Work => "work",
        }
    }
}
impl ::std::fmt::Debug for AddressUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AddressUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AddressUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AddressUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AddressUse> for Coding {
    fn from(code: AddressUse) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/address-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AddressUse> for CodeableConcept {
    fn from(code: AddressUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdjudicationCodes](http://terminology.hl7.org/CodeSystem/adjudication)**. This value set includes a smattering of Adjudication codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum AdjudicationCodes {
    /** **benefit**

Benefit Amount. Amount payable under the coverage */
    Benefit,
    /** **copay**

CoPay. Patient Co-Payment */
    Copay,
    /** **deductible**

Deductible. Amount deducted from the eligible amount prior to adjudication. */
    Deductible,
    /** **eligible**

Eligible Amount. Amount of the change which is considered for adjudication. */
    Eligible,
    /** **eligpercent**

Eligible %. Eligible Percentage. */
    Eligpercent,
    /** **submitted**

Submitted Amount. The total submitted amount for the claim or group or line item. */
    Submitted,
    /** **tax**

Tax. The amount of tax. */
    Tax,
    /** **unallocdeduct**

Unallocated Deductible. The amount of deductible which could not allocated to other line items. */
    Unallocdeduct,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AdjudicationCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "benefit" => Ok(Self::Benefit),
            "copay" => Ok(Self::Copay),
            "deductible" => Ok(Self::Deductible),
            "eligible" => Ok(Self::Eligible),
            "eligpercent" => Ok(Self::Eligpercent),
            "submitted" => Ok(Self::Submitted),
            "tax" => Ok(Self::Tax),
            "unallocdeduct" => Ok(Self::Unallocdeduct),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AdjudicationCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Benefit => "benefit",
            Self::Copay => "copay",
            Self::Deductible => "deductible",
            Self::Eligible => "eligible",
            Self::Eligpercent => "eligpercent",
            Self::Submitted => "submitted",
            Self::Tax => "tax",
            Self::Unallocdeduct => "unallocdeduct",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for AdjudicationCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdjudicationCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdjudicationCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdjudicationCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdjudicationCodes> for Coding {
    fn from(code: AdjudicationCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/adjudication".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdjudicationCodes> for CodeableConcept {
    fn from(code: AdjudicationCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdjudicationReasonCodes](http://terminology.hl7.org/CodeSystem/adjudication-reason)**. This value set includes smattering of Adjudication Reason codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum AdjudicationReasonCodes {
    /** **ar001**

Not covered. Not covered */
    Ar001,
    /** **ar002**

Plan Limit Reached. Plan Limit Reached */
    Ar002,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AdjudicationReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ar001" => Ok(Self::Ar001),
            "ar002" => Ok(Self::Ar002),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AdjudicationReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ar001 => "ar001",
            Self::Ar002 => "ar002",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for AdjudicationReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdjudicationReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdjudicationReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdjudicationReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdjudicationReasonCodes> for Coding {
    fn from(code: AdjudicationReasonCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/adjudication-reason".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdjudicationReasonCodes> for CodeableConcept {
    fn from(code: AdjudicationReasonCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdministrableDoseForm](http://hl7.org/fhir/ValueSet/administrable-dose-form)**. Dose form for a medication, in the form suitable for administering to the patient, after mixing, where necessary.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdministrableDoseForm {
    /** **100000073362**

Oral suspension. */
    N100000073362,
    /** **100000073363**

Oral gel. */
    N100000073363,
    /** **100000073364**

Powder for oral solution. */
    N100000073364,
    /** **100000073365**

Granules for oral solution. */
    N100000073365,
    /** **100000073367**

Lyophilisate for suspension. */
    N100000073367,
    /** **100000073368**

Powder for syrup. */
    N100000073368,
    /** **100000073369**

Soluble tablet. */
    N100000073369,
    /** **100000073370**

Herbal tea. */
    N100000073370,
    /** **100000073371**

Instant herbal tea. */
    N100000073371,
    /** **100000073372**

Granules. */
    N100000073372,
    /** **100000073373**

Gastro-resistant granules. */
    N100000073373,
    /** **100000073374**

Modified-release granules. */
    N100000073374,
    /** **100000073375**

Capsule, hard. */
    N100000073375,
    /** **100000073376**

Gastro-resistant capsule, hard. */
    N100000073376,
    /** **100000073377**

Chewable capsule, soft. */
    N100000073377,
    /** **100000073378**

Prolonged-release capsule, soft. */
    N100000073378,
    /** **100000073379**

Modified-release capsule, soft. */
    N100000073379,
    /** **100000073380**

Coated tablet. */
    N100000073380,
    /** **100000073642**

Oral drops, solution. */
    N100000073642,
    /** **100000073643**

Oral drops, suspension. */
    N100000073643,
    /** **100000073644**

Oral drops, emulsion. */
    N100000073644,
    /** **100000073645**

Oral liquid. */
    N100000073645,
    /** **100000073646**

Oral solution. */
    N100000073646,
    /** **100000073647**

Oral emulsion. */
    N100000073647,
    /** **100000073648**

Oral paste. */
    N100000073648,
    /** **100000073649**

Powder for oral suspension. */
    N100000073649,
    /** **100000073650**

Granules for oral suspension. */
    N100000073650,
    /** **100000073652**

Syrup. */
    N100000073652,
    /** **100000073653**

Granules for syrup. */
    N100000073653,
    /** **100000073654**

Dispersible tablet. */
    N100000073654,
    /** **100000073655**

Oral powder. */
    N100000073655,
    /** **100000073656**

Effervescent powder. */
    N100000073656,
    /** **100000073657**

Effervescent granules. */
    N100000073657,
    /** **100000073658**

Prolonged-release granules. */
    N100000073658,
    /** **100000073659**

Cachet. */
    N100000073659,
    /** **100000073660**

Capsule, soft. */
    N100000073660,
    /** **100000073661**

Gastro-resistant capsule, soft. */
    N100000073661,
    /** **100000073662**

Prolonged-release capsule, hard. */
    N100000073662,
    /** **100000073663**

Modified-release capsule, hard. */
    N100000073663,
    /** **100000073664**

Tablet. */
    N100000073664,
    /** **100000073665**

Film-coated tablet. */
    N100000073665,
    /** **100000073666**

Orodispersible tablet. */
    N100000073666,
    /** **100000073667**

Gastro-resistant tablet. */
    N100000073667,
    /** **100000073668**

Modified-release tablet. */
    N100000073668,
    /** **100000073669**

Medicated chewing-gum. */
    N100000073669,
    /** **100000073670**

Pillules. */
    N100000073670,
    /** **100000073671**

Pulsatile-release intraruminal device. */
    N100000073671,
    /** **100000073672**

Premix for medicated feeding stuff. */
    N100000073672,
    /** **100000073673**

Gargle. */
    N100000073673,
    /** **100000073674**

Gargle, powder for solution. */
    N100000073674,
    /** **100000073675**

Oromucosal suspension. */
    N100000073675,
    /** **100000073676**

Oromucosal spray. */
    N100000073676,
    /** **100000073677**

Mouthwash. */
    N100000073677,
    /** **100000073678**

Gingival solution. */
    N100000073678,
    /** **100000073679**

Oromucosal paste. */
    N100000073679,
    /** **100000073680**

Gingival gel. */
    N100000073680,
    /** **100000073681**

Effervescent tablet. */
    N100000073681,
    /** **100000073682**

Oral lyophilisate. */
    N100000073682,
    /** **100000073683**

Prolonged-release tablet. */
    N100000073683,
    /** **100000073684**

Chewable tablet. */
    N100000073684,
    /** **100000073685**

Oral gum. */
    N100000073685,
    /** **100000073686**

Continuous-release intraruminal device. */
    N100000073686,
    /** **100000073687**

Lick block. */
    N100000073687,
    /** **100000073688**

Medicated pellets. */
    N100000073688,
    /** **100000073689**

Concentrate for gargle. */
    N100000073689,
    /** **100000073690**

Gargle, tablet for solution. */
    N100000073690,
    /** **100000073691**

Oromucosal solution. */
    N100000073691,
    /** **100000073692**

Oromucosal drops. */
    N100000073692,
    /** **100000073693**

Sublingual spray. */
    N100000073693,
    /** **100000073694**

Mouthwash, tablet for solution. */
    N100000073694,
    /** **100000073695**

Oromucosal gel. */
    N100000073695,
    /** **100000073696**

Oromucosal cream. */
    N100000073696,
    /** **100000073697**

Gingival paste. */
    N100000073697,
    /** **100000073698**

Sublingual tablet. */
    N100000073698,
    /** **100000073699**

Buccal tablet. */
    N100000073699,
    /** **100000073700**

Compressed lozenge. */
    N100000073700,
    /** **100000073701**

Oromucosal capsule. */
    N100000073701,
    /** **100000073702**

Muco-adhesive buccal tablet. */
    N100000073702,
    /** **100000073703**

Lozenge. */
    N100000073703,
    /** **100000073704**

Pastille. */
    N100000073704,
    /** **100000073705**

Dental gel. */
    N100000073705,
    /** **100000073706**

Dental insert. */
    N100000073706,
    /** **100000073707**

Dental powder. */
    N100000073707,
    /** **100000073708**

Dental suspension. */
    N100000073708,
    /** **100000073709**

Toothpaste. */
    N100000073709,
    /** **100000073710**

Periodontal gel. */
    N100000073710,
    /** **100000073711**

Bath additive. */
    N100000073711,
    /** **100000073712**

Cream. */
    N100000073712,
    /** **100000073713**

Ointment. */
    N100000073713,
    /** **100000073714**

Medicated plaster. */
    N100000073714,
    /** **100000073715**

Shampoo. */
    N100000073715,
    /** **100000073716**

Cutaneous spray, suspension. */
    N100000073716,
    /** **100000073717**

Cutaneous liquid. */
    N100000073717,
    /** **100000073718**

Concentrate for cutaneous solution. */
    N100000073718,
    /** **100000073719**

Cutaneous emulsion. */
    N100000073719,
    /** **100000073720**

Cutaneous patch. */
    N100000073720,
    /** **100000073721**

Periodontal powder. */
    N100000073721,
    /** **100000073722**

Dental stick. */
    N100000073722,
    /** **100000073723**

Dental solution. */
    N100000073723,
    /** **100000073724**

Dental emulsion. */
    N100000073724,
    /** **100000073725**

Periodontal insert. */
    N100000073725,
    /** **100000073726**

Gel. */
    N100000073726,
    /** **100000073727**

Cutaneous paste. */
    N100000073727,
    /** **100000073728**

Cutaneous foam. */
    N100000073728,
    /** **100000073729**

Cutaneous spray, solution. */
    N100000073729,
    /** **100000073730**

Cutaneous spray, powder. */
    N100000073730,
    /** **100000073731**

Cutaneous solution. */
    N100000073731,
    /** **100000073732**

Cutaneous suspension. */
    N100000073732,
    /** **100000073733**

Cutaneous powder. */
    N100000073733,
    /** **100000073734**

Solution for iontophoresis. */
    N100000073734,
    /** **100000073735**

Collodion. */
    N100000073735,
    /** **100000073736**

Poultice. */
    N100000073736,
    /** **100000073737**

Cutaneous sponge. */
    N100000073737,
    /** **100000073738**

Collar. */
    N100000073738,
    /** **100000073739**

Ear tag. */
    N100000073739,
    /** **100000073740**

Dip suspension. */
    N100000073740,
    /** **100000073741**

Transdermal patch. */
    N100000073741,
    /** **100000073742**

Medicated nail lacquer. */
    N100000073742,
    /** **100000073743**

Cutaneous stick. */
    N100000073743,
    /** **100000073744**

Impregnated dressing. */
    N100000073744,
    /** **100000073745**

Medicated pendant. */
    N100000073745,
    /** **100000073746**

Dip solution. */
    N100000073746,
    /** **100000073747**

Dip emulsion. */
    N100000073747,
    /** **100000073748**

Concentrate for dip suspension. */
    N100000073748,
    /** **100000073749**

Powder for dip solution. */
    N100000073749,
    /** **100000073750**

Powder for suspension for fish treatment. */
    N100000073750,
    /** **100000073751**

Pour-on suspension. */
    N100000073751,
    /** **100000073752**

Spot-on solution. */
    N100000073752,
    /** **100000073753**

Spot-on emulsion. */
    N100000073753,
    /** **100000073754**

Teat dip suspension. */
    N100000073754,
    /** **100000073755**

Teat spray solution. */
    N100000073755,
    /** **100000073756**

Solution for skin-prick test. */
    N100000073756,
    /** **100000073757**

Plaster for provocation test. */
    N100000073757,
    /** **100000073758**

Eye gel. */
    N100000073758,
    /** **100000073759**

Eye drops, solution. */
    N100000073759,
    /** **100000073760**

Eye drops, suspension. */
    N100000073760,
    /** **100000073761**

Concentrate for dip solution. */
    N100000073761,
    /** **100000073762**

Concentrate for dip emulsion. */
    N100000073762,
    /** **100000073763**

Concentrate for solution for fish treatment. */
    N100000073763,
    /** **100000073764**

Pour-on solution. */
    N100000073764,
    /** **100000073765**

Pour-on emulsion. */
    N100000073765,
    /** **100000073766**

Spot-on suspension. */
    N100000073766,
    /** **100000073767**

Teat dip solution. */
    N100000073767,
    /** **100000073768**

Teat dip emulsion. */
    N100000073768,
    /** **100000073769**

Transdermal system. */
    N100000073769,
    /** **100000073770**

Solution for skin-scratch test. */
    N100000073770,
    /** **100000073771**

Eye cream. */
    N100000073771,
    /** **100000073772**

Eye ointment. */
    N100000073772,
    /** **100000073773**

Eye drops, emulsion. */
    N100000073773,
    /** **100000073775**

Eye drops, solvent for reconstitution. */
    N100000073775,
    /** **100000073776**

Eye lotion. */
    N100000073776,
    /** **100000073777**

Ophthalmic insert. */
    N100000073777,
    /** **100000073778**

Ear cream. */
    N100000073778,
    /** **100000073779**

Ear ointment. */
    N100000073779,
    /** **100000073780**

Ear drops, suspension. */
    N100000073780,
    /** **100000073782**

Eye drops, prolonged-release. */
    N100000073782,
    /** **100000073783**

Eye lotion, solvent for reconstitution. */
    N100000073783,
    /** **100000073784**

Ophthalmic strip. */
    N100000073784,
    /** **100000073785**

Ear gel. */
    N100000073785,
    /** **100000073786**

Ear drops, solution. */
    N100000073786,
    /** **100000073787**

Ear drops, emulsion. */
    N100000073787,
    /** **100000073788**

Ear powder. */
    N100000073788,
    /** **100000073789**

Ear spray, suspension. */
    N100000073789,
    /** **100000073790**

Ear wash, solution. */
    N100000073790,
    /** **100000073791**

Ear tampon. */
    N100000073791,
    /** **100000073792**

Nasal cream. */
    N100000073792,
    /** **100000073793**

Nasal gel. */
    N100000073793,
    /** **100000073794**

Nasal drops, solution. */
    N100000073794,
    /** **100000073795**

Nasal drops, emulsion. */
    N100000073795,
    /** **100000073796**

Nasal spray, solution. */
    N100000073796,
    /** **100000073797**

Nasal spray, emulsion. */
    N100000073797,
    /** **100000073798**

Nasal stick. */
    N100000073798,
    /** **100000073799**

Vaginal gel. */
    N100000073799,
    /** **100000073800**

Vaginal foam. */
    N100000073800,
    /** **100000073802**

Ear spray, solution. */
    N100000073802,
    /** **100000073803**

Ear spray, emulsion. */
    N100000073803,
    /** **100000073804**

Ear wash, emulsion. */
    N100000073804,
    /** **100000073805**

Ear stick. */
    N100000073805,
    /** **100000073806**

Nasal ointment. */
    N100000073806,
    /** **100000073807**

Nasal drops, suspension. */
    N100000073807,
    /** **100000073808**

Nasal powder. */
    N100000073808,
    /** **100000073809**

Nasal spray, suspension. */
    N100000073809,
    /** **100000073810**

Nasal wash. */
    N100000073810,
    /** **100000073811**

Vaginal cream. */
    N100000073811,
    /** **100000073812**

Vaginal ointment. */
    N100000073812,
    /** **100000073813**

Vaginal solution. */
    N100000073813,
    /** **100000073814**

Vaginal emulsion. */
    N100000073814,
    /** **100000073815**

Pessary. */
    N100000073815,
    /** **100000073816**

Vaginal capsule, soft. */
    N100000073816,
    /** **100000073817**

Effervescent vaginal tablet. */
    N100000073817,
    /** **100000073818**

Vaginal delivery system. */
    N100000073818,
    /** **100000073819**

Rectal cream. */
    N100000073819,
    /** **100000073820**

Rectal foam. */
    N100000073820,
    /** **100000073821**

Vaginal suspension. */
    N100000073821,
    /** **100000073822**

Tablet for vaginal solution. */
    N100000073822,
    /** **100000073823**

Vaginal capsule, hard. */
    N100000073823,
    /** **100000073824**

Vaginal tablet. */
    N100000073824,
    /** **100000073825**

Medicated vaginal tampon. */
    N100000073825,
    /** **100000073826**

Vaginal sponge. */
    N100000073826,
    /** **100000073827**

Rectal gel. */
    N100000073827,
    /** **100000073863**

Solution for injection. */
    N100000073863,
}
impl ::core::str::FromStr for AdministrableDoseForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073362" => Ok(Self::N100000073362),
            "100000073363" => Ok(Self::N100000073363),
            "100000073364" => Ok(Self::N100000073364),
            "100000073365" => Ok(Self::N100000073365),
            "100000073367" => Ok(Self::N100000073367),
            "100000073368" => Ok(Self::N100000073368),
            "100000073369" => Ok(Self::N100000073369),
            "100000073370" => Ok(Self::N100000073370),
            "100000073371" => Ok(Self::N100000073371),
            "100000073372" => Ok(Self::N100000073372),
            "100000073373" => Ok(Self::N100000073373),
            "100000073374" => Ok(Self::N100000073374),
            "100000073375" => Ok(Self::N100000073375),
            "100000073376" => Ok(Self::N100000073376),
            "100000073377" => Ok(Self::N100000073377),
            "100000073378" => Ok(Self::N100000073378),
            "100000073379" => Ok(Self::N100000073379),
            "100000073380" => Ok(Self::N100000073380),
            "100000073642" => Ok(Self::N100000073642),
            "100000073643" => Ok(Self::N100000073643),
            "100000073644" => Ok(Self::N100000073644),
            "100000073645" => Ok(Self::N100000073645),
            "100000073646" => Ok(Self::N100000073646),
            "100000073647" => Ok(Self::N100000073647),
            "100000073648" => Ok(Self::N100000073648),
            "100000073649" => Ok(Self::N100000073649),
            "100000073650" => Ok(Self::N100000073650),
            "100000073652" => Ok(Self::N100000073652),
            "100000073653" => Ok(Self::N100000073653),
            "100000073654" => Ok(Self::N100000073654),
            "100000073655" => Ok(Self::N100000073655),
            "100000073656" => Ok(Self::N100000073656),
            "100000073657" => Ok(Self::N100000073657),
            "100000073658" => Ok(Self::N100000073658),
            "100000073659" => Ok(Self::N100000073659),
            "100000073660" => Ok(Self::N100000073660),
            "100000073661" => Ok(Self::N100000073661),
            "100000073662" => Ok(Self::N100000073662),
            "100000073663" => Ok(Self::N100000073663),
            "100000073664" => Ok(Self::N100000073664),
            "100000073665" => Ok(Self::N100000073665),
            "100000073666" => Ok(Self::N100000073666),
            "100000073667" => Ok(Self::N100000073667),
            "100000073668" => Ok(Self::N100000073668),
            "100000073669" => Ok(Self::N100000073669),
            "100000073670" => Ok(Self::N100000073670),
            "100000073671" => Ok(Self::N100000073671),
            "100000073672" => Ok(Self::N100000073672),
            "100000073673" => Ok(Self::N100000073673),
            "100000073674" => Ok(Self::N100000073674),
            "100000073675" => Ok(Self::N100000073675),
            "100000073676" => Ok(Self::N100000073676),
            "100000073677" => Ok(Self::N100000073677),
            "100000073678" => Ok(Self::N100000073678),
            "100000073679" => Ok(Self::N100000073679),
            "100000073680" => Ok(Self::N100000073680),
            "100000073681" => Ok(Self::N100000073681),
            "100000073682" => Ok(Self::N100000073682),
            "100000073683" => Ok(Self::N100000073683),
            "100000073684" => Ok(Self::N100000073684),
            "100000073685" => Ok(Self::N100000073685),
            "100000073686" => Ok(Self::N100000073686),
            "100000073687" => Ok(Self::N100000073687),
            "100000073688" => Ok(Self::N100000073688),
            "100000073689" => Ok(Self::N100000073689),
            "100000073690" => Ok(Self::N100000073690),
            "100000073691" => Ok(Self::N100000073691),
            "100000073692" => Ok(Self::N100000073692),
            "100000073693" => Ok(Self::N100000073693),
            "100000073694" => Ok(Self::N100000073694),
            "100000073695" => Ok(Self::N100000073695),
            "100000073696" => Ok(Self::N100000073696),
            "100000073697" => Ok(Self::N100000073697),
            "100000073698" => Ok(Self::N100000073698),
            "100000073699" => Ok(Self::N100000073699),
            "100000073700" => Ok(Self::N100000073700),
            "100000073701" => Ok(Self::N100000073701),
            "100000073702" => Ok(Self::N100000073702),
            "100000073703" => Ok(Self::N100000073703),
            "100000073704" => Ok(Self::N100000073704),
            "100000073705" => Ok(Self::N100000073705),
            "100000073706" => Ok(Self::N100000073706),
            "100000073707" => Ok(Self::N100000073707),
            "100000073708" => Ok(Self::N100000073708),
            "100000073709" => Ok(Self::N100000073709),
            "100000073710" => Ok(Self::N100000073710),
            "100000073711" => Ok(Self::N100000073711),
            "100000073712" => Ok(Self::N100000073712),
            "100000073713" => Ok(Self::N100000073713),
            "100000073714" => Ok(Self::N100000073714),
            "100000073715" => Ok(Self::N100000073715),
            "100000073716" => Ok(Self::N100000073716),
            "100000073717" => Ok(Self::N100000073717),
            "100000073718" => Ok(Self::N100000073718),
            "100000073719" => Ok(Self::N100000073719),
            "100000073720" => Ok(Self::N100000073720),
            "100000073721" => Ok(Self::N100000073721),
            "100000073722" => Ok(Self::N100000073722),
            "100000073723" => Ok(Self::N100000073723),
            "100000073724" => Ok(Self::N100000073724),
            "100000073725" => Ok(Self::N100000073725),
            "100000073726" => Ok(Self::N100000073726),
            "100000073727" => Ok(Self::N100000073727),
            "100000073728" => Ok(Self::N100000073728),
            "100000073729" => Ok(Self::N100000073729),
            "100000073730" => Ok(Self::N100000073730),
            "100000073731" => Ok(Self::N100000073731),
            "100000073732" => Ok(Self::N100000073732),
            "100000073733" => Ok(Self::N100000073733),
            "100000073734" => Ok(Self::N100000073734),
            "100000073735" => Ok(Self::N100000073735),
            "100000073736" => Ok(Self::N100000073736),
            "100000073737" => Ok(Self::N100000073737),
            "100000073738" => Ok(Self::N100000073738),
            "100000073739" => Ok(Self::N100000073739),
            "100000073740" => Ok(Self::N100000073740),
            "100000073741" => Ok(Self::N100000073741),
            "100000073742" => Ok(Self::N100000073742),
            "100000073743" => Ok(Self::N100000073743),
            "100000073744" => Ok(Self::N100000073744),
            "100000073745" => Ok(Self::N100000073745),
            "100000073746" => Ok(Self::N100000073746),
            "100000073747" => Ok(Self::N100000073747),
            "100000073748" => Ok(Self::N100000073748),
            "100000073749" => Ok(Self::N100000073749),
            "100000073750" => Ok(Self::N100000073750),
            "100000073751" => Ok(Self::N100000073751),
            "100000073752" => Ok(Self::N100000073752),
            "100000073753" => Ok(Self::N100000073753),
            "100000073754" => Ok(Self::N100000073754),
            "100000073755" => Ok(Self::N100000073755),
            "100000073756" => Ok(Self::N100000073756),
            "100000073757" => Ok(Self::N100000073757),
            "100000073758" => Ok(Self::N100000073758),
            "100000073759" => Ok(Self::N100000073759),
            "100000073760" => Ok(Self::N100000073760),
            "100000073761" => Ok(Self::N100000073761),
            "100000073762" => Ok(Self::N100000073762),
            "100000073763" => Ok(Self::N100000073763),
            "100000073764" => Ok(Self::N100000073764),
            "100000073765" => Ok(Self::N100000073765),
            "100000073766" => Ok(Self::N100000073766),
            "100000073767" => Ok(Self::N100000073767),
            "100000073768" => Ok(Self::N100000073768),
            "100000073769" => Ok(Self::N100000073769),
            "100000073770" => Ok(Self::N100000073770),
            "100000073771" => Ok(Self::N100000073771),
            "100000073772" => Ok(Self::N100000073772),
            "100000073773" => Ok(Self::N100000073773),
            "100000073775" => Ok(Self::N100000073775),
            "100000073776" => Ok(Self::N100000073776),
            "100000073777" => Ok(Self::N100000073777),
            "100000073778" => Ok(Self::N100000073778),
            "100000073779" => Ok(Self::N100000073779),
            "100000073780" => Ok(Self::N100000073780),
            "100000073782" => Ok(Self::N100000073782),
            "100000073783" => Ok(Self::N100000073783),
            "100000073784" => Ok(Self::N100000073784),
            "100000073785" => Ok(Self::N100000073785),
            "100000073786" => Ok(Self::N100000073786),
            "100000073787" => Ok(Self::N100000073787),
            "100000073788" => Ok(Self::N100000073788),
            "100000073789" => Ok(Self::N100000073789),
            "100000073790" => Ok(Self::N100000073790),
            "100000073791" => Ok(Self::N100000073791),
            "100000073792" => Ok(Self::N100000073792),
            "100000073793" => Ok(Self::N100000073793),
            "100000073794" => Ok(Self::N100000073794),
            "100000073795" => Ok(Self::N100000073795),
            "100000073796" => Ok(Self::N100000073796),
            "100000073797" => Ok(Self::N100000073797),
            "100000073798" => Ok(Self::N100000073798),
            "100000073799" => Ok(Self::N100000073799),
            "100000073800" => Ok(Self::N100000073800),
            "100000073802" => Ok(Self::N100000073802),
            "100000073803" => Ok(Self::N100000073803),
            "100000073804" => Ok(Self::N100000073804),
            "100000073805" => Ok(Self::N100000073805),
            "100000073806" => Ok(Self::N100000073806),
            "100000073807" => Ok(Self::N100000073807),
            "100000073808" => Ok(Self::N100000073808),
            "100000073809" => Ok(Self::N100000073809),
            "100000073810" => Ok(Self::N100000073810),
            "100000073811" => Ok(Self::N100000073811),
            "100000073812" => Ok(Self::N100000073812),
            "100000073813" => Ok(Self::N100000073813),
            "100000073814" => Ok(Self::N100000073814),
            "100000073815" => Ok(Self::N100000073815),
            "100000073816" => Ok(Self::N100000073816),
            "100000073817" => Ok(Self::N100000073817),
            "100000073818" => Ok(Self::N100000073818),
            "100000073819" => Ok(Self::N100000073819),
            "100000073820" => Ok(Self::N100000073820),
            "100000073821" => Ok(Self::N100000073821),
            "100000073822" => Ok(Self::N100000073822),
            "100000073823" => Ok(Self::N100000073823),
            "100000073824" => Ok(Self::N100000073824),
            "100000073825" => Ok(Self::N100000073825),
            "100000073826" => Ok(Self::N100000073826),
            "100000073827" => Ok(Self::N100000073827),
            "100000073863" => Ok(Self::N100000073863),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdministrableDoseForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073362 => "100000073362",
            Self::N100000073363 => "100000073363",
            Self::N100000073364 => "100000073364",
            Self::N100000073365 => "100000073365",
            Self::N100000073367 => "100000073367",
            Self::N100000073368 => "100000073368",
            Self::N100000073369 => "100000073369",
            Self::N100000073370 => "100000073370",
            Self::N100000073371 => "100000073371",
            Self::N100000073372 => "100000073372",
            Self::N100000073373 => "100000073373",
            Self::N100000073374 => "100000073374",
            Self::N100000073375 => "100000073375",
            Self::N100000073376 => "100000073376",
            Self::N100000073377 => "100000073377",
            Self::N100000073378 => "100000073378",
            Self::N100000073379 => "100000073379",
            Self::N100000073380 => "100000073380",
            Self::N100000073642 => "100000073642",
            Self::N100000073643 => "100000073643",
            Self::N100000073644 => "100000073644",
            Self::N100000073645 => "100000073645",
            Self::N100000073646 => "100000073646",
            Self::N100000073647 => "100000073647",
            Self::N100000073648 => "100000073648",
            Self::N100000073649 => "100000073649",
            Self::N100000073650 => "100000073650",
            Self::N100000073652 => "100000073652",
            Self::N100000073653 => "100000073653",
            Self::N100000073654 => "100000073654",
            Self::N100000073655 => "100000073655",
            Self::N100000073656 => "100000073656",
            Self::N100000073657 => "100000073657",
            Self::N100000073658 => "100000073658",
            Self::N100000073659 => "100000073659",
            Self::N100000073660 => "100000073660",
            Self::N100000073661 => "100000073661",
            Self::N100000073662 => "100000073662",
            Self::N100000073663 => "100000073663",
            Self::N100000073664 => "100000073664",
            Self::N100000073665 => "100000073665",
            Self::N100000073666 => "100000073666",
            Self::N100000073667 => "100000073667",
            Self::N100000073668 => "100000073668",
            Self::N100000073669 => "100000073669",
            Self::N100000073670 => "100000073670",
            Self::N100000073671 => "100000073671",
            Self::N100000073672 => "100000073672",
            Self::N100000073673 => "100000073673",
            Self::N100000073674 => "100000073674",
            Self::N100000073675 => "100000073675",
            Self::N100000073676 => "100000073676",
            Self::N100000073677 => "100000073677",
            Self::N100000073678 => "100000073678",
            Self::N100000073679 => "100000073679",
            Self::N100000073680 => "100000073680",
            Self::N100000073681 => "100000073681",
            Self::N100000073682 => "100000073682",
            Self::N100000073683 => "100000073683",
            Self::N100000073684 => "100000073684",
            Self::N100000073685 => "100000073685",
            Self::N100000073686 => "100000073686",
            Self::N100000073687 => "100000073687",
            Self::N100000073688 => "100000073688",
            Self::N100000073689 => "100000073689",
            Self::N100000073690 => "100000073690",
            Self::N100000073691 => "100000073691",
            Self::N100000073692 => "100000073692",
            Self::N100000073693 => "100000073693",
            Self::N100000073694 => "100000073694",
            Self::N100000073695 => "100000073695",
            Self::N100000073696 => "100000073696",
            Self::N100000073697 => "100000073697",
            Self::N100000073698 => "100000073698",
            Self::N100000073699 => "100000073699",
            Self::N100000073700 => "100000073700",
            Self::N100000073701 => "100000073701",
            Self::N100000073702 => "100000073702",
            Self::N100000073703 => "100000073703",
            Self::N100000073704 => "100000073704",
            Self::N100000073705 => "100000073705",
            Self::N100000073706 => "100000073706",
            Self::N100000073707 => "100000073707",
            Self::N100000073708 => "100000073708",
            Self::N100000073709 => "100000073709",
            Self::N100000073710 => "100000073710",
            Self::N100000073711 => "100000073711",
            Self::N100000073712 => "100000073712",
            Self::N100000073713 => "100000073713",
            Self::N100000073714 => "100000073714",
            Self::N100000073715 => "100000073715",
            Self::N100000073716 => "100000073716",
            Self::N100000073717 => "100000073717",
            Self::N100000073718 => "100000073718",
            Self::N100000073719 => "100000073719",
            Self::N100000073720 => "100000073720",
            Self::N100000073721 => "100000073721",
            Self::N100000073722 => "100000073722",
            Self::N100000073723 => "100000073723",
            Self::N100000073724 => "100000073724",
            Self::N100000073725 => "100000073725",
            Self::N100000073726 => "100000073726",
            Self::N100000073727 => "100000073727",
            Self::N100000073728 => "100000073728",
            Self::N100000073729 => "100000073729",
            Self::N100000073730 => "100000073730",
            Self::N100000073731 => "100000073731",
            Self::N100000073732 => "100000073732",
            Self::N100000073733 => "100000073733",
            Self::N100000073734 => "100000073734",
            Self::N100000073735 => "100000073735",
            Self::N100000073736 => "100000073736",
            Self::N100000073737 => "100000073737",
            Self::N100000073738 => "100000073738",
            Self::N100000073739 => "100000073739",
            Self::N100000073740 => "100000073740",
            Self::N100000073741 => "100000073741",
            Self::N100000073742 => "100000073742",
            Self::N100000073743 => "100000073743",
            Self::N100000073744 => "100000073744",
            Self::N100000073745 => "100000073745",
            Self::N100000073746 => "100000073746",
            Self::N100000073747 => "100000073747",
            Self::N100000073748 => "100000073748",
            Self::N100000073749 => "100000073749",
            Self::N100000073750 => "100000073750",
            Self::N100000073751 => "100000073751",
            Self::N100000073752 => "100000073752",
            Self::N100000073753 => "100000073753",
            Self::N100000073754 => "100000073754",
            Self::N100000073755 => "100000073755",
            Self::N100000073756 => "100000073756",
            Self::N100000073757 => "100000073757",
            Self::N100000073758 => "100000073758",
            Self::N100000073759 => "100000073759",
            Self::N100000073760 => "100000073760",
            Self::N100000073761 => "100000073761",
            Self::N100000073762 => "100000073762",
            Self::N100000073763 => "100000073763",
            Self::N100000073764 => "100000073764",
            Self::N100000073765 => "100000073765",
            Self::N100000073766 => "100000073766",
            Self::N100000073767 => "100000073767",
            Self::N100000073768 => "100000073768",
            Self::N100000073769 => "100000073769",
            Self::N100000073770 => "100000073770",
            Self::N100000073771 => "100000073771",
            Self::N100000073772 => "100000073772",
            Self::N100000073773 => "100000073773",
            Self::N100000073775 => "100000073775",
            Self::N100000073776 => "100000073776",
            Self::N100000073777 => "100000073777",
            Self::N100000073778 => "100000073778",
            Self::N100000073779 => "100000073779",
            Self::N100000073780 => "100000073780",
            Self::N100000073782 => "100000073782",
            Self::N100000073783 => "100000073783",
            Self::N100000073784 => "100000073784",
            Self::N100000073785 => "100000073785",
            Self::N100000073786 => "100000073786",
            Self::N100000073787 => "100000073787",
            Self::N100000073788 => "100000073788",
            Self::N100000073789 => "100000073789",
            Self::N100000073790 => "100000073790",
            Self::N100000073791 => "100000073791",
            Self::N100000073792 => "100000073792",
            Self::N100000073793 => "100000073793",
            Self::N100000073794 => "100000073794",
            Self::N100000073795 => "100000073795",
            Self::N100000073796 => "100000073796",
            Self::N100000073797 => "100000073797",
            Self::N100000073798 => "100000073798",
            Self::N100000073799 => "100000073799",
            Self::N100000073800 => "100000073800",
            Self::N100000073802 => "100000073802",
            Self::N100000073803 => "100000073803",
            Self::N100000073804 => "100000073804",
            Self::N100000073805 => "100000073805",
            Self::N100000073806 => "100000073806",
            Self::N100000073807 => "100000073807",
            Self::N100000073808 => "100000073808",
            Self::N100000073809 => "100000073809",
            Self::N100000073810 => "100000073810",
            Self::N100000073811 => "100000073811",
            Self::N100000073812 => "100000073812",
            Self::N100000073813 => "100000073813",
            Self::N100000073814 => "100000073814",
            Self::N100000073815 => "100000073815",
            Self::N100000073816 => "100000073816",
            Self::N100000073817 => "100000073817",
            Self::N100000073818 => "100000073818",
            Self::N100000073819 => "100000073819",
            Self::N100000073820 => "100000073820",
            Self::N100000073821 => "100000073821",
            Self::N100000073822 => "100000073822",
            Self::N100000073823 => "100000073823",
            Self::N100000073824 => "100000073824",
            Self::N100000073825 => "100000073825",
            Self::N100000073826 => "100000073826",
            Self::N100000073827 => "100000073827",
            Self::N100000073863 => "100000073863",
        }
    }
}
impl ::std::fmt::Debug for AdministrableDoseForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdministrableDoseForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdministrableDoseForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdministrableDoseForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdministrableDoseForm> for Coding {
    fn from(code: AdministrableDoseForm) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/administrable-dose-form".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdministrableDoseForm> for CodeableConcept {
    fn from(code: AdministrableDoseForm) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdministrativeGender](http://hl7.org/fhir/ValueSet/administrative-gender)**. The gender of a person used for administrative purposes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdministrativeGender {
    /** **female**

Female. Female. */
    Female,
    /** **male**

Male. Male. */
    Male,
    /** **other**

Other. Other. */
    Other,
    /** **unknown**

Unknown. Unknown. */
    Unknown,
}
impl ::core::str::FromStr for AdministrativeGender {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "female" => Ok(Self::Female),
            "male" => Ok(Self::Male),
            "other" => Ok(Self::Other),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdministrativeGender {
    fn as_ref(&self) -> &str {
        match self {
            Self::Female => "female",
            Self::Male => "male",
            Self::Other => "other",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for AdministrativeGender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdministrativeGender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdministrativeGender {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdministrativeGender {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdministrativeGender> for Coding {
    fn from(code: AdministrativeGender) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/administrative-gender".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdministrativeGender> for CodeableConcept {
    fn from(code: AdministrativeGender) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdmitSource](http://terminology.hl7.org/CodeSystem/admit-source)**. This codesystem defines a set of codes that can be used to indicate from where the patient came in.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum AdmitSource {
    /** **born**

Born in hospital. The patient is a newborn and the encounter will track the baby related activities (as opposed to the Mothers encounter - that may be associated using the newborn encounters partof property) */
    Born,
    /** **emd**

From accident/emergency department. The patient has been transferred from the emergency department within the hospital. This is typically used in the transition to an inpatient encounter */
    Emd,
    /** **gp**

General Practitioner referral. The patient has been admitted due to a referred from a General Practitioner. */
    Gp,
    /** **hosp-trans**

Transferred from other hospital. The Patient has been transferred from another hospital for this encounter. */
    HospTrans,
    /** **mp**

Medical Practitioner/physician referral. The patient has been admitted due to a referred from a Specialist (as opposed to a General Practitioner). */
    Mp,
    /** **nursing**

From nursing home. The patient has been transferred from a nursing home. */
    Nursing,
    /** **other**

Other. The patient has been admitted from a source otherwise not specified here. */
    Other,
    /** **outp**

From outpatient department. The patient has been transferred from an outpatient department within the hospital. */
    Outp,
    /** **psych**

From psychiatric hospital. The patient has been transferred from a psychiatric facility. */
    Psych,
    /** **rehab**

From rehabilitation facility. The patient has been transferred from a rehabilitation facility or clinic. */
    Rehab,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AdmitSource {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "born" => Ok(Self::Born),
            "emd" => Ok(Self::Emd),
            "gp" => Ok(Self::Gp),
            "hosp-trans" => Ok(Self::HospTrans),
            "mp" => Ok(Self::Mp),
            "nursing" => Ok(Self::Nursing),
            "other" => Ok(Self::Other),
            "outp" => Ok(Self::Outp),
            "psych" => Ok(Self::Psych),
            "rehab" => Ok(Self::Rehab),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AdmitSource {
    fn as_ref(&self) -> &str {
        match self {
            Self::Born => "born",
            Self::Emd => "emd",
            Self::Gp => "gp",
            Self::HospTrans => "hosp-trans",
            Self::Mp => "mp",
            Self::Nursing => "nursing",
            Self::Other => "other",
            Self::Outp => "outp",
            Self::Psych => "psych",
            Self::Rehab => "rehab",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for AdmitSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdmitSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdmitSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdmitSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdmitSource> for Coding {
    fn from(code: AdmitSource) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/admit-source".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdmitSource> for CodeableConcept {
    fn from(code: AdmitSource) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventActuality](http://hl7.org/fhir/ValueSet/adverse-event-actuality)**. Overall nature of the adverse event, e.g. real or potential.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventActuality {
    /** **actual**

Adverse Event. The adverse event actually happened regardless of whether anyone was affected or harmed. */
    Actual,
    /** **potential**

Potential Adverse Event. A potential adverse event. */
    Potential,
}
impl ::core::str::FromStr for AdverseEventActuality {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "actual" => Ok(Self::Actual),
            "potential" => Ok(Self::Potential),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventActuality {
    fn as_ref(&self) -> &str {
        match self {
            Self::Actual => "actual",
            Self::Potential => "potential",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventActuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventActuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventActuality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventActuality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventActuality> for Coding {
    fn from(code: AdverseEventActuality) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-actuality".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventActuality> for CodeableConcept {
    fn from(code: AdverseEventActuality) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventCategory](http://hl7.org/fhir/ValueSet/adverse-event-category)**. Overall categorization of the event, e.g. product-related or situational.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventCategory {
    /** **expired-drug**

Expired Drug. The adverse event pertains to an expired drug. */
    ExpiredDrug,
    /** **incorrect-prescribing-information**

Incorrect Prescribing Information. The adverse event pertains to incorrect perscribing information. */
    IncorrectPrescribingInformation,
    /** **medical-device-use-error**

Medical Device Use Error. The adverse event pertains to a medical device use error. */
    MedicalDeviceUseError,
    /** **problem-different-manufacturer**

Problem with Different Manufacturer of Same Medicine. The adverse event pertains to a problem with a different manufacturer of the same medication. */
    ProblemDifferentManufacturer,
    /** **product-problem**

Product Problem. The adverse event pertains to a product problem. */
    ProductProblem,
    /** **product-quality**

Product Quality. The adverse event pertains to product quality. */
    ProductQuality,
    /** **product-use-error**

Product Use Error. The adverse event pertains to a product use error. */
    ProductUseError,
    /** **unsafe-physical-environment**

Unsafe Physical Environment. The adverse event pertains to an unsafe physical environment. */
    UnsafePhysicalEnvironment,
    /** **wrong-dose**

Wrong Dose. The adverse event pertains to a wrong dose. */
    WrongDose,
    /** **wrong-duration**

Wrong Duration. The adverse event pertains to a wrong duration. */
    WrongDuration,
    /** **wrong-rate**

Wrong Rate. The adverse event pertains to a wrong rate. */
    WrongRate,
    /** **wrong-route-of-administration**

Wrong Route of Administration. The adverse event pertains to a wrong route of administration. */
    WrongRouteOfAdministration,
    /** **wrong-technique**

Wrong Technique. The adverse event pertains to a wrong technique. */
    WrongTechnique,
    /** **wrong-time**

Wrong Time. The adverse event pertains to a wrong time. */
    WrongTime,
}
impl ::core::str::FromStr for AdverseEventCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "expired-drug" => Ok(Self::ExpiredDrug),
            "incorrect-prescribing-information" => {
                Ok(Self::IncorrectPrescribingInformation)
            }
            "medical-device-use-error" => Ok(Self::MedicalDeviceUseError),
            "problem-different-manufacturer" => Ok(Self::ProblemDifferentManufacturer),
            "product-problem" => Ok(Self::ProductProblem),
            "product-quality" => Ok(Self::ProductQuality),
            "product-use-error" => Ok(Self::ProductUseError),
            "unsafe-physical-environment" => Ok(Self::UnsafePhysicalEnvironment),
            "wrong-dose" => Ok(Self::WrongDose),
            "wrong-duration" => Ok(Self::WrongDuration),
            "wrong-rate" => Ok(Self::WrongRate),
            "wrong-route-of-administration" => Ok(Self::WrongRouteOfAdministration),
            "wrong-technique" => Ok(Self::WrongTechnique),
            "wrong-time" => Ok(Self::WrongTime),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::ExpiredDrug => "expired-drug",
            Self::IncorrectPrescribingInformation => "incorrect-prescribing-information",
            Self::MedicalDeviceUseError => "medical-device-use-error",
            Self::ProblemDifferentManufacturer => "problem-different-manufacturer",
            Self::ProductProblem => "product-problem",
            Self::ProductQuality => "product-quality",
            Self::ProductUseError => "product-use-error",
            Self::UnsafePhysicalEnvironment => "unsafe-physical-environment",
            Self::WrongDose => "wrong-dose",
            Self::WrongDuration => "wrong-duration",
            Self::WrongRate => "wrong-rate",
            Self::WrongRouteOfAdministration => "wrong-route-of-administration",
            Self::WrongTechnique => "wrong-technique",
            Self::WrongTime => "wrong-time",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventCategory> for Coding {
    fn from(code: AdverseEventCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventCategory> for CodeableConcept {
    fn from(code: AdverseEventCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventCausalityAssessment](http://hl7.org/fhir/ValueSet/adverse-event-causality-assess)**. Codes for the assessment of whether the entity caused the event.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventCausalityAssessment {
    /** **Certain**

Certain. i) Event or laboratory test abnormality, with plausible time relationship to drug intake; ii) Cannot be explained by disease or other drugs; iii) Response to withdrawal plausible (pharmacologically, pathologically); iv) Event definitive pharmacologically or phenomenologically (i.e. an objective and specific medical disorder or a recognized pharmacological phenomenon); or v) Re-challenge satisfactory, if necessary. */
    Certain,
    /** **Conditional-Classified**

Conditional/Classified. i) Event or laboratory test abnormality; ii) More data for proper assessment needed; or iii) Additional data under examination. */
    ConditionalClassified,
    /** **Possible**

Possible. i) Event or laboratory test abnormality, with reasonable time relationship to drug intake; ii) Could also be explained by disease or other drugs; or iii) Information on drug withdrawal may be lacking or unclear. */
    Possible,
    /** **Probably-Likely**

Probably/Likely. i) Event or laboratory test abnormality, with reasonable time relationship to drug intake; ii) Unlikely to be attributed to disease or other drugs; iii) Response to withdrawal clinically reasonable; or iv) Re-challenge not required. */
    ProbablyLikely,
    /** **Unassessable-Unclassifiable**

Unassessable/Unclassifiable. i) Report suggesting an adverse reaction; ii) Cannot be judged because information is insufficient or contradictory; or iii) Data cannot be supplemented or verified. */
    UnassessableUnclassifiable,
    /** **Unlikely**

Unlikely. i) Event or laboratory test abnormality, with a time to drug intake that makes a relationship improbable (but not impossible); or ii) Disease or other drugs provide plausible explanations. */
    Unlikely,
}
impl ::core::str::FromStr for AdverseEventCausalityAssessment {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Certain" => Ok(Self::Certain),
            "Conditional-Classified" => Ok(Self::ConditionalClassified),
            "Possible" => Ok(Self::Possible),
            "Probably-Likely" => Ok(Self::ProbablyLikely),
            "Unassessable-Unclassifiable" => Ok(Self::UnassessableUnclassifiable),
            "Unlikely" => Ok(Self::Unlikely),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCausalityAssessment {
    fn as_ref(&self) -> &str {
        match self {
            Self::Certain => "Certain",
            Self::ConditionalClassified => "Conditional-Classified",
            Self::Possible => "Possible",
            Self::ProbablyLikely => "Probably-Likely",
            Self::UnassessableUnclassifiable => "Unassessable-Unclassifiable",
            Self::Unlikely => "Unlikely",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventCausalityAssessment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventCausalityAssessment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventCausalityAssessment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCausalityAssessment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventCausalityAssessment> for Coding {
    fn from(code: AdverseEventCausalityAssessment) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-causality-assess".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventCausalityAssessment> for CodeableConcept {
    fn from(code: AdverseEventCausalityAssessment) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventCausalityMethod](http://hl7.org/fhir/ValueSet/adverse-event-causality-method)**. TODO.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventCausalityMethod {
    /** **Bayesian**

Bayesian. */
    Bayesian,
    /** **Checklist**

Checklist. */
    Checklist,
    /** **ProbabilityScale**

Probability Scale. */
    ProbabilityScale,
}
impl ::core::str::FromStr for AdverseEventCausalityMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Bayesian" => Ok(Self::Bayesian),
            "Checklist" => Ok(Self::Checklist),
            "ProbabilityScale" => Ok(Self::ProbabilityScale),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCausalityMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bayesian => "Bayesian",
            Self::Checklist => "Checklist",
            Self::ProbabilityScale => "ProbabilityScale",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventCausalityMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventCausalityMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventCausalityMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCausalityMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventCausalityMethod> for Coding {
    fn from(code: AdverseEventCausalityMethod) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-causality-method".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventCausalityMethod> for CodeableConcept {
    fn from(code: AdverseEventCausalityMethod) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventOutcome](http://hl7.org/fhir/ValueSet/adverse-event-outcome)**. TODO (and should this be required?).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventOutcome {
    /** **fatal**

Fatal. */
    Fatal,
    /** **ongoing**

Ongoing. */
    Ongoing,
    /** **recovering**

Recovering. */
    Recovering,
    /** **resolved**

Resolved. */
    Resolved,
    /** **resolvedWithSequelae**

Resolved with Sequelae. */
    ResolvedWithSequelae,
    /** **unknown**

Unknown. */
    Unknown,
}
impl ::core::str::FromStr for AdverseEventOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fatal" => Ok(Self::Fatal),
            "ongoing" => Ok(Self::Ongoing),
            "recovering" => Ok(Self::Recovering),
            "resolved" => Ok(Self::Resolved),
            "resolvedWithSequelae" => Ok(Self::ResolvedWithSequelae),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fatal => "fatal",
            Self::Ongoing => "ongoing",
            Self::Recovering => "recovering",
            Self::Resolved => "resolved",
            Self::ResolvedWithSequelae => "resolvedWithSequelae",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventOutcome> for Coding {
    fn from(code: AdverseEventOutcome) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-outcome".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventOutcome> for CodeableConcept {
    fn from(code: AdverseEventOutcome) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventSeriousness](http://hl7.org/fhir/ValueSet/adverse-event-seriousness)**. Overall seriousness of this event for the patient.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventSeriousness {
    /** **Non-serious**

Non-serious. Non-serious. */
    NonSerious,
    /** **Serious**

Serious. Serious. */
    Serious,
    /** **SeriousIsBirthDefect**

Is a congenital anomaly/birth defect. Is a congenital anomaly/birth defect. */
    SeriousIsBirthDefect,
    /** **SeriousIsLifeThreatening**

Is Life-threatening. Is Life-threatening. */
    SeriousIsLifeThreatening,
    /** **SeriousRequiresPreventImpairment**

Requires intervention to prevent permanent impairment. Requires intervention to prevent permanent impairment or damage (i.e., an important medical event that requires medical judgement). */
    SeriousRequiresPreventImpairment,
    /** **SeriousResultsInDeath**

Results in death. Results in death. */
    SeriousResultsInDeath,
    /** **SeriousResultsInDisability**

Results in persistent or significant disability/incapacity. Results in persistent or significant disability/incapacity. */
    SeriousResultsInDisability,
    /** **SeriousResultsInHospitalization**

Requires or prolongs inpatient hospitalization. Requires inpatient hospitalization or causes prolongation of existing hospitalization. */
    SeriousResultsInHospitalization,
}
impl ::core::str::FromStr for AdverseEventSeriousness {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Non-serious" => Ok(Self::NonSerious),
            "Serious" => Ok(Self::Serious),
            "SeriousIsBirthDefect" => Ok(Self::SeriousIsBirthDefect),
            "SeriousIsLifeThreatening" => Ok(Self::SeriousIsLifeThreatening),
            "SeriousRequiresPreventImpairment" => {
                Ok(Self::SeriousRequiresPreventImpairment)
            }
            "SeriousResultsInDeath" => Ok(Self::SeriousResultsInDeath),
            "SeriousResultsInDisability" => Ok(Self::SeriousResultsInDisability),
            "SeriousResultsInHospitalization" => {
                Ok(Self::SeriousResultsInHospitalization)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventSeriousness {
    fn as_ref(&self) -> &str {
        match self {
            Self::NonSerious => "Non-serious",
            Self::Serious => "Serious",
            Self::SeriousIsBirthDefect => "SeriousIsBirthDefect",
            Self::SeriousIsLifeThreatening => "SeriousIsLifeThreatening",
            Self::SeriousRequiresPreventImpairment => "SeriousRequiresPreventImpairment",
            Self::SeriousResultsInDeath => "SeriousResultsInDeath",
            Self::SeriousResultsInDisability => "SeriousResultsInDisability",
            Self::SeriousResultsInHospitalization => "SeriousResultsInHospitalization",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventSeriousness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventSeriousness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventSeriousness {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventSeriousness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventSeriousness> for Coding {
    fn from(code: AdverseEventSeriousness) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-seriousness".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventSeriousness> for CodeableConcept {
    fn from(code: AdverseEventSeriousness) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AdverseEventSeverity](http://hl7.org/fhir/ValueSet/adverse-event-severity)**. The severity of the adverse event itself, in direct relation to the subject.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AdverseEventSeverity {
    /** **mild**

Mild. */
    Mild,
    /** **moderate**

Moderate. */
    Moderate,
    /** **severe**

Severe. */
    Severe,
}
impl ::core::str::FromStr for AdverseEventSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mild" => Ok(Self::Mild),
            "moderate" => Ok(Self::Moderate),
            "severe" => Ok(Self::Severe),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mild => "mild",
            Self::Moderate => "moderate",
            Self::Severe => "severe",
        }
    }
}
impl ::std::fmt::Debug for AdverseEventSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AdverseEventSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AdverseEventSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventSeverity> for Coding {
    fn from(code: AdverseEventSeverity) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/adverse-event-severity".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AdverseEventSeverity> for CodeableConcept {
    fn from(code: AdverseEventSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AggregationMode](http://hl7.org/fhir/ValueSet/resource-aggregation-mode)**. How resource references can be aggregated.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AggregationMode {
    /** **bundled**

Bundled. The resource the reference points to will be found in the same bundle as the resource that includes the reference. */
    Bundled,
    /** **contained**

Contained. The reference is a local reference to a contained resource. */
    Contained,
    /** **referenced**

Referenced. The reference to a resource that has to be resolved externally to the resource that includes the reference. */
    Referenced,
}
impl ::core::str::FromStr for AggregationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bundled" => Ok(Self::Bundled),
            "contained" => Ok(Self::Contained),
            "referenced" => Ok(Self::Referenced),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AggregationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bundled => "bundled",
            Self::Contained => "contained",
            Self::Referenced => "referenced",
        }
    }
}
impl ::std::fmt::Debug for AggregationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AggregationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AggregationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AggregationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AggregationMode> for Coding {
    fn from(code: AggregationMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/resource-aggregation-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AggregationMode> for CodeableConcept {
    fn from(code: AggregationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceCategory](http://hl7.org/fhir/ValueSet/allergy-intolerance-category)**. Category of an identified substance associated with allergies or intolerances.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceCategory {
    /** **biologic**

Biologic. A preparation that is synthesized from living organisms or their products, especially a human or animal protein, such as a hormone or antitoxin, that is used as a diagnostic, preventive, or therapeutic agent. Examples of biologic medications include: vaccines; allergenic extracts, which are used for both diagnosis and treatment (for example, allergy shots); gene therapies; cellular therapies.  There are other biologic products, such as tissues, which are not typically associated with allergies. */
    Biologic,
    /** **environment**

Environment. Any substances that are encountered in the environment, including any substance not already classified as food, medication, or biologic. */
    Environment,
    /** **food**

Food. Any substance consumed to provide nutritional support for the body. */
    Food,
    /** **medication**

Medication. Substances administered to achieve a physiological effect. */
    Medication,
}
impl ::core::str::FromStr for AllergyIntoleranceCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "biologic" => Ok(Self::Biologic),
            "environment" => Ok(Self::Environment),
            "food" => Ok(Self::Food),
            "medication" => Ok(Self::Medication),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Biologic => "biologic",
            Self::Environment => "environment",
            Self::Food => "food",
            Self::Medication => "medication",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceCategory> for Coding {
    fn from(code: AllergyIntoleranceCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergy-intolerance-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceCategory> for CodeableConcept {
    fn from(code: AllergyIntoleranceCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceCertainty](http://hl7.org/fhir/ValueSet/reaction-event-certainty)**. Statement about the degree of clinical certainty that a specific substance was the cause    of the manifestation in a reaction event.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceCertainty {
    /** **confirmed**

Confirmed. There is a very high level of clinical certainty that the reaction was due to the identified      substance, which may include clinical evidence by testing or rechallenge. */
    Confirmed,
    /** **likely**

Likely. There is a high level of clinical certainty that the reaction was caused by the identified      substance. */
    Likely,
    /** **unknown**

Unknown. The clinical certainty that the reaction was caused by the identified substance is unknown.       It is an explicit assertion that certainty is not known. */
    Unknown,
    /** **unlikely**

Unlikely. There is a low level of clinical certainty that the reaction was caused by the identified      substance. */
    Unlikely,
}
impl ::core::str::FromStr for AllergyIntoleranceCertainty {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(Self::Confirmed),
            "likely" => Ok(Self::Likely),
            "unknown" => Ok(Self::Unknown),
            "unlikely" => Ok(Self::Unlikely),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCertainty {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confirmed => "confirmed",
            Self::Likely => "likely",
            Self::Unknown => "unknown",
            Self::Unlikely => "unlikely",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceCertainty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceCertainty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCertainty {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCertainty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceCertainty> for Coding {
    fn from(code: AllergyIntoleranceCertainty) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/reaction-event-certainty".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceCertainty> for CodeableConcept {
    fn from(code: AllergyIntoleranceCertainty) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceClinicalStatusCodes](http://hl7.org/fhir/ValueSet/allergyintolerance-clinical)**. Preferred value set for AllergyIntolerance Clinical Status.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceClinicalStatusCodes {
    /** **active**

Active. The subject is currently experiencing, or is at risk of, a reaction to the identified substance. */
    Active,
    /** **inactive**

Inactive. The subject is no longer at risk of a reaction to the identified substance. */
    Inactive,
    /** **resolved**

Resolved. A reaction to the identified substance has been clinically reassessed by testing or re-exposure and is considered no longer to be present. Re-exposure could be accidental, unplanned, or outside of any clinical setting. */
    Resolved,
}
impl ::core::str::FromStr for AllergyIntoleranceClinicalStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "resolved" => Ok(Self::Resolved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceClinicalStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Resolved => "resolved",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceClinicalStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceClinicalStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceClinicalStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceClinicalStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceClinicalStatusCodes> for Coding {
    fn from(code: AllergyIntoleranceClinicalStatusCodes) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergyintolerance-clinical".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceClinicalStatusCodes> for CodeableConcept {
    fn from(code: AllergyIntoleranceClinicalStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceCriticality](http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality)**. Estimate of the potential clinical harm, or seriousness, of a reaction to an identified substance.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceCriticality {
    /** **high**

High Risk. Worst case result of a future exposure is assessed to be life-threatening or having high potential for organ system failure. */
    High,
    /** **low**

Low Risk. Worst case result of a future exposure is not assessed to be life-threatening or having high potential for organ system failure. */
    Low,
    /** **unable-to-assess**

Unable to Assess Risk. Unable to assess the worst case result of a future exposure. */
    UnableToAssess,
}
impl ::core::str::FromStr for AllergyIntoleranceCriticality {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "unable-to-assess" => Ok(Self::UnableToAssess),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCriticality {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::UnableToAssess => "unable-to-assess",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceCriticality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceCriticality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCriticality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCriticality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceCriticality> for Coding {
    fn from(code: AllergyIntoleranceCriticality) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceCriticality> for CodeableConcept {
    fn from(code: AllergyIntoleranceCriticality) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceSeverity](http://hl7.org/fhir/ValueSet/reaction-event-severity)**. Clinical assessment of the severity of a reaction event as a whole, potentially considering multiple different manifestations.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceSeverity {
    /** **mild**

Mild. Causes mild physiological effects. */
    Mild,
    /** **moderate**

Moderate. Causes moderate physiological effects. */
    Moderate,
    /** **severe**

Severe. Causes severe physiological effects. */
    Severe,
}
impl ::core::str::FromStr for AllergyIntoleranceSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mild" => Ok(Self::Mild),
            "moderate" => Ok(Self::Moderate),
            "severe" => Ok(Self::Severe),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mild => "mild",
            Self::Moderate => "moderate",
            Self::Severe => "severe",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceSeverity> for Coding {
    fn from(code: AllergyIntoleranceSeverity) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/reaction-event-severity".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceSeverity> for CodeableConcept {
    fn from(code: AllergyIntoleranceSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceType](http://hl7.org/fhir/ValueSet/allergy-intolerance-type)**. Identification of the underlying physiological mechanism for a Reaction Risk.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceType {
    /** **allergy**

Allergy. A propensity for hypersensitive reaction(s) to a substance.  These reactions are most typically type I hypersensitivity, plus other "allergy-like" reactions, including pseudoallergy. */
    Allergy,
    /** **intolerance**

Intolerance. A propensity for adverse reactions to a substance that is not judged to be allergic or "allergy-like".  These reactions are typically (but not necessarily) non-immune.  They are to some degree idiosyncratic and/or patient-specific (i.e. are not a reaction that is expected to occur with most or all patients given similar circumstances). */
    Intolerance,
}
impl ::core::str::FromStr for AllergyIntoleranceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "allergy" => Ok(Self::Allergy),
            "intolerance" => Ok(Self::Intolerance),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Allergy => "allergy",
            Self::Intolerance => "intolerance",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceType> for Coding {
    fn from(code: AllergyIntoleranceType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergy-intolerance-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceType> for CodeableConcept {
    fn from(code: AllergyIntoleranceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AllergyIntoleranceVerificationStatusCodes](http://hl7.org/fhir/ValueSet/allergyintolerance-verification)**. Preferred value set for AllergyIntolerance Verification Status.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AllergyIntoleranceVerificationStatusCodes {
    /** **confirmed**

Confirmed. A high level of certainty about the propensity for a reaction to the identified substance, which may include clinical evidence by testing or rechallenge. */
    Confirmed,
    /** **entered-in-error**

Entered in Error. The statement was entered in error and is not valid. */
    EnteredInError,
    /** **refuted**

Refuted. A propensity for a reaction to the identified substance has been disputed or disproven with a sufficient level of clinical certainty to justify invalidating the assertion. This might or might not include testing or rechallenge. */
    Refuted,
    /** **unconfirmed**

Unconfirmed. A low level of certainty about the propensity for a reaction to the identified substance. */
    Unconfirmed,
}
impl ::core::str::FromStr for AllergyIntoleranceVerificationStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(Self::Confirmed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "refuted" => Ok(Self::Refuted),
            "unconfirmed" => Ok(Self::Unconfirmed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceVerificationStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confirmed => "confirmed",
            Self::EnteredInError => "entered-in-error",
            Self::Refuted => "refuted",
            Self::Unconfirmed => "unconfirmed",
        }
    }
}
impl ::std::fmt::Debug for AllergyIntoleranceVerificationStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AllergyIntoleranceVerificationStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceVerificationStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceVerificationStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceVerificationStatusCodes> for Coding {
    fn from(code: AllergyIntoleranceVerificationStatusCodes) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/allergyintolerance-verification".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AllergyIntoleranceVerificationStatusCodes> for CodeableConcept {
    fn from(code: AllergyIntoleranceVerificationStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AnimalSpecies](http://hl7.org/fhir/animal-species)**. This example value set defines a set of codes that can be used to indicate species of animal patients.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum AnimalSpecies {
    /** **canislf**

Dog. Canis lupus familiaris */
    Canislf,
    /** **ovisa**

Sheep. Ovis aries */
    Ovisa,
    /** **serinuscd**

Domestic Canary. Serinus canaria domestica */
    Serinuscd,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AnimalSpecies {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "canislf" => Ok(Self::Canislf),
            "ovisa" => Ok(Self::Ovisa),
            "serinuscd" => Ok(Self::Serinuscd),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AnimalSpecies {
    fn as_ref(&self) -> &str {
        match self {
            Self::Canislf => "canislf",
            Self::Ovisa => "ovisa",
            Self::Serinuscd => "serinuscd",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for AnimalSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AnimalSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AnimalSpecies {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AnimalSpecies {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AnimalSpecies> for Coding {
    fn from(code: AnimalSpecies) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/animal-species".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AnimalSpecies> for CodeableConcept {
    fn from(code: AnimalSpecies) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AnimalTissueType](http://hl7.org/fhir/ValueSet/animal-tissue-type)**. A tissue type of an animal.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AnimalTissueType {
    /** **100000072091**

All relevant tissues. */
    N100000072091,
    /** **100000072092**

Fat. */
    N100000072092,
    /** **100000072093**

Honey. */
    N100000072093,
    /** **100000072094**

Liver. */
    N100000072094,
    /** **100000072095**

Fresh Milk. */
    N100000072095,
    /** **100000072096**

Muscle and skin in natural proportions. */
    N100000072096,
    /** **100000072104**

Eggs. */
    N100000072104,
    /** **100000072105**

Skin and fat. */
    N100000072105,
    /** **100000072106**

Kidney. */
    N100000072106,
    /** **100000072107**

Meat and offal. */
    N100000072107,
    /** **100000072108**

Muscle. */
    N100000072108,
    /** **100000072109**

Unspecified. */
    N100000072109,
    /** **100000111053**

Adipose tissue. */
    N100000111053,
    /** **100000111054**

Adrenal. */
    N100000111054,
    /** **100000111055**

Blood vessels. */
    N100000111055,
    /** **100000111056**

Bone. */
    N100000111056,
    /** **100000111057**

Bone marrow. */
    N100000111057,
    /** **100000111058**

Brain. */
    N100000111058,
    /** **100000111059**

Connective tissue. */
    N100000111059,
    /** **100000111060**

Cornea. */
    N100000111060,
    /** **100000111061**

Dental pulp. */
    N100000111061,
    /** **100000111062**

Duodenum. */
    N100000111062,
    /** **100000111063**

Dura mater. */
    N100000111063,
    /** **100000111064**

Egg, embryonated. */
    N100000111064,
    /** **100000111065**

Egg. */
    N100000111065,
    /** **100000111066**

Egg white. */
    N100000111066,
    /** **100000111067**

Egg yolk. */
    N100000111067,
    /** **100000111068**

Embryos. */
    N100000111068,
    /** **100000111069**

Enteric plexuses. */
    N100000111069,
    /** **100000111070**

Esophagus. */
    N100000111070,
    /** **100000111071**

Feathers. */
    N100000111071,
    /** **100000111072**

Foetus. */
    N100000111072,
    /** **100000111073**

Fore-stomach (ruminants only). */
    N100000111073,
    /** **100000111074**

Gingival tissue. */
    N100000111074,
    /** **100000111075**

Hair. */
    N100000111075,
    /** **100000111076**

Heart/pericardium. */
    N100000111076,
    /** **100000111077**

Hide. */
    N100000111077,
    /** **100000111078**

Hooves. */
    N100000111078,
    /** **100000111079**

Ileum. */
    N100000111079,
    /** **100000111080**

Jejunum. */
    N100000111080,
    /** **100000111081**

Kidney. */
    N100000111081,
    /** **100000111082**

Lard/lard oil. */
    N100000111082,
    /** **100000111083**

Large intestine. */
    N100000111083,
    /** **100000111084**

Liver. */
    N100000111084,
    /** **100000111085**

Lung. */
    N100000111085,
    /** **100000111086**

Lymph nodes. */
    N100000111086,
    /** **100000111087**

Mammary gland. */
    N100000111087,
    /** **100000111088**

Udder. */
    N100000111088,
    /** **100000111089**

Mammary tumour. */
    N100000111089,
    /** **100000111090**

Meat extract. */
    N100000111090,
    /** **100000111091**

Nasopharyngeal. */
    N100000111091,
    /** **100000111092**

Nictitating membrane. */
    N100000111092,
    /** **100000111093**

Nasal mucosa. */
    N100000111093,
    /** **100000111094**

Ovary. */
    N100000111094,
    /** **100000111095**

Pancreas. */
    N100000111095,
    /** **100000111096**

Peripheral nerves. */
    N100000111096,
    /** **100000111097**

Pituitary gland. */
    N100000111097,
    /** **100000111098**

Placenta. */
    N100000111098,
    /** **100000111099**

Prostate. */
    N100000111099,
    /** **100000111100**

Epididymis. */
    N100000111100,
    /** **100000111101**

Seminal vesicle. */
    N100000111101,
    /** **100000111102**

Rennet, calf. */
    N100000111102,
    /** **100000111103**

Retina. */
    N100000111103,
    /** **100000111104**

Optic nerve. */
    N100000111104,
    /** **100000111105**

Salivary gland. */
    N100000111105,
    /** **100000111106**

Shank. */
    N100000111106,
    /** **100000111107**

Skeletal muscle. */
    N100000111107,
    /** **100000111108**

Skin. */
    N100000111108,
    /** **100000111109**

Spinal ganglia. */
    N100000111109,
    /** **100000111110**

Spinal cord. */
    N100000111110,
    /** **100000111111**

Spleen. */
    N100000111111,
    /** **100000111112**

Stomach. */
    N100000111112,
    /** **100000111113**

Abomasum. */
    N100000111113,
    /** **100000111114**

Submaxillary glands. */
    N100000111114,
    /** **100000111115**

Tallow. */
    N100000111115,
    /** **100000111116**

Tendon. */
    N100000111116,
    /** **100000111117**

Testis. */
    N100000111117,
    /** **100000111118**

Thymus. */
    N100000111118,
    /** **100000111119**

Thyroid gland. */
    N100000111119,
    /** **100000111120**

Tongue. */
    N100000111120,
    /** **100000111121**

Tonsil. */
    N100000111121,
    /** **100000111122**

Trachea. */
    N100000111122,
    /** **100000111123**

Trigeminal ganglia. */
    N100000111123,
    /** **100000111124**

Tripe. */
    N100000111124,
    /** **100000111125**

Uterus (Non-gravid). */
    N100000111125,
    /** **100000111126**

Wool. */
    N100000111126,
    /** **100000111127**

Ascites fluid. */
    N100000111127,
    /** **100000111128**

Bile. */
    N100000111128,
    /** **100000111129**

Blood1. */
    N100000111129,
    /** **100000111130**

Blood, foetal. */
    N100000111130,
    /** **100000111131**

Colostrum. */
    N100000111131,
    /** **100000111132**

Cord blood. */
    N100000111132,
    /** **100000111133**

CSF. */
    N100000111133,
    /** **100000111134**

Faeces. */
    N100000111134,
    /** **100000111135**

Milk. */
    N100000111135,
    /** **100000111136**

Nasal mucus. */
    N100000111136,
    /** **100000111137**

Placenta fluids. */
    N100000111137,
    /** **100000111138**

Plasma. */
    N100000111138,
    /** **100000111139**

Saliva. */
    N100000111139,
    /** **100000111140**

Secretion from bees. */
    N100000111140,
    /** **100000111141**

Semen. */
    N100000111141,
    /** **100000111142**

Serum, calf. */
    N100000111142,
    /** **100000111143**

Serum, donor adult bovine. */
    N100000111143,
    /** **100000111144**

Serum, donor calf. */
    N100000111144,
    /** **100000111145**

Serum, foetal bovine. */
    N100000111145,
    /** **100000111146**

Serum, newborn calf. */
    N100000111146,
    /** **100000111147**

Serum/plasma derivate, adult bovine. */
    N100000111147,
    /** **100000111148**

Serum/plasma, adult bovine. */
    N100000111148,
    /** **100000111149**

Sweat. */
    N100000111149,
    /** **100000111150**

Tears. */
    N100000111150,
    /** **100000111151**

Urine. */
    N100000111151,
    /** **100000111152**

Venom. */
    N100000111152,
    /** **100000111153**

Whey. */
    N100000111153,
    /** **100000111154**

Casein. */
    N100000111154,
    /** **100000111155**

Fermentation products. */
    N100000111155,
    /** **100000111156**

Gelatin. */
    N100000111156,
    /** **100000111157**

Lactose. */
    N100000111157,
    /** **100000111158**

Protein. */
    N100000111158,
    /** **100000111159**

Insulin. */
    N100000111159,
    /** **100000111160**

Collagen. */
    N100000111160,
    /** **100000111161**

Animal Charcoal. */
    N100000111161,
    /** **100000111162**

Peptones. */
    N100000111162,
    /** **100000111163**

Fatty acids. */
    N100000111163,
    /** **100000111164**

Glycerol. */
    N100000111164,
    /** **100000125717**

Not applicable. */
    N100000125717,
    /** **100000136180**

Meat and offal, milk. */
    N100000136180,
    /** **100000136181**

Agar blood. */
    N100000136181,
    /** **100000136182**

Casamino acid. */
    N100000136182,
    /** **100000136183**

Casein, hydrolysate. */
    N100000136183,
    /** **100000136184**

Casein, pancreatic digest. */
    N100000136184,
    /** **100000136185**

Casein, peptides N3. */
    N100000136185,
    /** **100000136186**

Cells. */
    N100000136186,
    /** **100000136187**

Cells, BHK21. */
    N100000136187,
    /** **100000136188**

Cells, CHO. */
    N100000136188,
    /** **100000136189**

Cells, CRFK. */
    N100000136189,
    /** **100000136190**

Cells, embryo SPF. */
    N100000136190,
    /** **100000136191**

Cells, IRC5. */
    N100000136191,
    /** **100000136192**

Cells, kidney. */
    N100000136192,
    /** **100000136193**

Cells, MDCK. */
    N100000136193,
    /** **100000136194**

Cells, red blood. */
    N100000136194,
    /** **100000136195**

Collagen, hydrolysate. */
    N100000136195,
    /** **100000136196**

Cholesterol. */
    N100000136196,
    /** **100000136197**

Egg, SPF embryonated. */
    N100000136197,
    /** **100000136198**

Enzyme. */
    N100000136198,
    /** **100000136199**

Enzyme, pancreatic enzymes. */
    N100000136199,
    /** **100000136200**

Enzyme, pancreatin 6NF. */
    N100000136200,
    /** **100000136201**

Enzyme, pepsin. */
    N100000136201,
    /** **100000136202**

Enzyme, pronase. */
    N100000136202,
    /** **100000136203**

Enzyme, trypsin. */
    N100000136203,
    /** **100000136204**

Heart, digest. */
    N100000136204,
    /** **100000136205**

Heart, extract. */
    N100000136205,
    /** **100000136206**

Intestinal mucosae. */
    N100000136206,
    /** **100000136207**

Lactalbumin hydrolysate. */
    N100000136207,
    /** **100000136208**

Liver, digest. */
    N100000136208,
    /** **100000136209**

Lymphocytes. */
    N100000136209,
    /** **100000136210**

Meat. */
    N100000136210,
    /** **100000136211**

Meat, enzymic hydrolysate. */
    N100000136211,
    /** **100000136212**

Medium, cooked meat. */
    N100000136212,
    /** **100000136213**

Medium, F10-199 medium. */
    N100000136213,
    /** **100000136214**

Medium, FMD culture medium. */
    N100000136214,
    /** **100000136215**

Medium, Glasgow MEM culture. */
    N100000136215,
    /** **100000136216**

Medium, LB Agar Lennox. */
    N100000136216,
    /** **100000136217**

Medium, LB Broth Lennox. */
    N100000136217,
    /** **100000136218**

Medium, modified thioglycolate medium. */
    N100000136218,
    /** **100000136219**

Medium, trypticase soy broth. */
    N100000136219,
    /** **100000136220**

Medium, tryptose phosphate broth. */
    N100000136220,
    /** **100000136221**

Milk, skimmed. */
    N100000136221,
    /** **100000136222**

Pancreas, extract. */
    N100000136222,
    /** **100000136223**

Peptones, casein hydrochloric peptone. */
    N100000136223,
    /** **100000136224**

Peptones, casein tryptic peptone. */
    N100000136224,
    /** **100000136225**

Pituitary extract. */
    N100000136225,
    /** **100000136226**

Rennet. */
    N100000136226,
    /** **100000136227**

Medium, nutrient broth. */
    N100000136227,
    /** **100000136228**

Medium, NZ-Amine. */
    N100000136228,
    /** **100000136229**

Medium, thioglycolate medium. */
    N100000136229,
    /** **100000136230**

Peptones, proteose peptone. */
    N100000136230,
    /** **100000136231**

Serum. */
    N100000136231,
    /** **100000136232**

Serum, albumin. */
    N100000136232,
    /** **100000136233**

Serum, Iron fortified calf. */
    N100000136233,
    /** **100000136234**

Skin, connective tissue and bone. */
    N100000136234,
    /** **100000136235**

Sperm. */
    N100000136235,
    /** **100000136236**

Tryptone. */
    N100000136236,
    /** **100000136237**

Meat, extract desiccated. */
    N100000136237,
    /** **100000136247**

Stomach mucosa. */
    N100000136247,
    /** **100000136248**

Transferin. */
    N100000136248,
    /** **100000136554**

Non-neural. */
    N100000136554,
    /** **100000136555**

Not specified. */
    N100000136555,
    /** **100000136556**

Organ tissue. */
    N100000136556,
    /** **100000142485**

Skin and fat in natural proportions. */
    N100000142485,
}
impl ::core::str::FromStr for AnimalTissueType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000072091" => Ok(Self::N100000072091),
            "100000072092" => Ok(Self::N100000072092),
            "100000072093" => Ok(Self::N100000072093),
            "100000072094" => Ok(Self::N100000072094),
            "100000072095" => Ok(Self::N100000072095),
            "100000072096" => Ok(Self::N100000072096),
            "100000072104" => Ok(Self::N100000072104),
            "100000072105" => Ok(Self::N100000072105),
            "100000072106" => Ok(Self::N100000072106),
            "100000072107" => Ok(Self::N100000072107),
            "100000072108" => Ok(Self::N100000072108),
            "100000072109" => Ok(Self::N100000072109),
            "100000111053" => Ok(Self::N100000111053),
            "100000111054" => Ok(Self::N100000111054),
            "100000111055" => Ok(Self::N100000111055),
            "100000111056" => Ok(Self::N100000111056),
            "100000111057" => Ok(Self::N100000111057),
            "100000111058" => Ok(Self::N100000111058),
            "100000111059" => Ok(Self::N100000111059),
            "100000111060" => Ok(Self::N100000111060),
            "100000111061" => Ok(Self::N100000111061),
            "100000111062" => Ok(Self::N100000111062),
            "100000111063" => Ok(Self::N100000111063),
            "100000111064" => Ok(Self::N100000111064),
            "100000111065" => Ok(Self::N100000111065),
            "100000111066" => Ok(Self::N100000111066),
            "100000111067" => Ok(Self::N100000111067),
            "100000111068" => Ok(Self::N100000111068),
            "100000111069" => Ok(Self::N100000111069),
            "100000111070" => Ok(Self::N100000111070),
            "100000111071" => Ok(Self::N100000111071),
            "100000111072" => Ok(Self::N100000111072),
            "100000111073" => Ok(Self::N100000111073),
            "100000111074" => Ok(Self::N100000111074),
            "100000111075" => Ok(Self::N100000111075),
            "100000111076" => Ok(Self::N100000111076),
            "100000111077" => Ok(Self::N100000111077),
            "100000111078" => Ok(Self::N100000111078),
            "100000111079" => Ok(Self::N100000111079),
            "100000111080" => Ok(Self::N100000111080),
            "100000111081" => Ok(Self::N100000111081),
            "100000111082" => Ok(Self::N100000111082),
            "100000111083" => Ok(Self::N100000111083),
            "100000111084" => Ok(Self::N100000111084),
            "100000111085" => Ok(Self::N100000111085),
            "100000111086" => Ok(Self::N100000111086),
            "100000111087" => Ok(Self::N100000111087),
            "100000111088" => Ok(Self::N100000111088),
            "100000111089" => Ok(Self::N100000111089),
            "100000111090" => Ok(Self::N100000111090),
            "100000111091" => Ok(Self::N100000111091),
            "100000111092" => Ok(Self::N100000111092),
            "100000111093" => Ok(Self::N100000111093),
            "100000111094" => Ok(Self::N100000111094),
            "100000111095" => Ok(Self::N100000111095),
            "100000111096" => Ok(Self::N100000111096),
            "100000111097" => Ok(Self::N100000111097),
            "100000111098" => Ok(Self::N100000111098),
            "100000111099" => Ok(Self::N100000111099),
            "100000111100" => Ok(Self::N100000111100),
            "100000111101" => Ok(Self::N100000111101),
            "100000111102" => Ok(Self::N100000111102),
            "100000111103" => Ok(Self::N100000111103),
            "100000111104" => Ok(Self::N100000111104),
            "100000111105" => Ok(Self::N100000111105),
            "100000111106" => Ok(Self::N100000111106),
            "100000111107" => Ok(Self::N100000111107),
            "100000111108" => Ok(Self::N100000111108),
            "100000111109" => Ok(Self::N100000111109),
            "100000111110" => Ok(Self::N100000111110),
            "100000111111" => Ok(Self::N100000111111),
            "100000111112" => Ok(Self::N100000111112),
            "100000111113" => Ok(Self::N100000111113),
            "100000111114" => Ok(Self::N100000111114),
            "100000111115" => Ok(Self::N100000111115),
            "100000111116" => Ok(Self::N100000111116),
            "100000111117" => Ok(Self::N100000111117),
            "100000111118" => Ok(Self::N100000111118),
            "100000111119" => Ok(Self::N100000111119),
            "100000111120" => Ok(Self::N100000111120),
            "100000111121" => Ok(Self::N100000111121),
            "100000111122" => Ok(Self::N100000111122),
            "100000111123" => Ok(Self::N100000111123),
            "100000111124" => Ok(Self::N100000111124),
            "100000111125" => Ok(Self::N100000111125),
            "100000111126" => Ok(Self::N100000111126),
            "100000111127" => Ok(Self::N100000111127),
            "100000111128" => Ok(Self::N100000111128),
            "100000111129" => Ok(Self::N100000111129),
            "100000111130" => Ok(Self::N100000111130),
            "100000111131" => Ok(Self::N100000111131),
            "100000111132" => Ok(Self::N100000111132),
            "100000111133" => Ok(Self::N100000111133),
            "100000111134" => Ok(Self::N100000111134),
            "100000111135" => Ok(Self::N100000111135),
            "100000111136" => Ok(Self::N100000111136),
            "100000111137" => Ok(Self::N100000111137),
            "100000111138" => Ok(Self::N100000111138),
            "100000111139" => Ok(Self::N100000111139),
            "100000111140" => Ok(Self::N100000111140),
            "100000111141" => Ok(Self::N100000111141),
            "100000111142" => Ok(Self::N100000111142),
            "100000111143" => Ok(Self::N100000111143),
            "100000111144" => Ok(Self::N100000111144),
            "100000111145" => Ok(Self::N100000111145),
            "100000111146" => Ok(Self::N100000111146),
            "100000111147" => Ok(Self::N100000111147),
            "100000111148" => Ok(Self::N100000111148),
            "100000111149" => Ok(Self::N100000111149),
            "100000111150" => Ok(Self::N100000111150),
            "100000111151" => Ok(Self::N100000111151),
            "100000111152" => Ok(Self::N100000111152),
            "100000111153" => Ok(Self::N100000111153),
            "100000111154" => Ok(Self::N100000111154),
            "100000111155" => Ok(Self::N100000111155),
            "100000111156" => Ok(Self::N100000111156),
            "100000111157" => Ok(Self::N100000111157),
            "100000111158" => Ok(Self::N100000111158),
            "100000111159" => Ok(Self::N100000111159),
            "100000111160" => Ok(Self::N100000111160),
            "100000111161" => Ok(Self::N100000111161),
            "100000111162" => Ok(Self::N100000111162),
            "100000111163" => Ok(Self::N100000111163),
            "100000111164" => Ok(Self::N100000111164),
            "100000125717" => Ok(Self::N100000125717),
            "100000136180" => Ok(Self::N100000136180),
            "100000136181" => Ok(Self::N100000136181),
            "100000136182" => Ok(Self::N100000136182),
            "100000136183" => Ok(Self::N100000136183),
            "100000136184" => Ok(Self::N100000136184),
            "100000136185" => Ok(Self::N100000136185),
            "100000136186" => Ok(Self::N100000136186),
            "100000136187" => Ok(Self::N100000136187),
            "100000136188" => Ok(Self::N100000136188),
            "100000136189" => Ok(Self::N100000136189),
            "100000136190" => Ok(Self::N100000136190),
            "100000136191" => Ok(Self::N100000136191),
            "100000136192" => Ok(Self::N100000136192),
            "100000136193" => Ok(Self::N100000136193),
            "100000136194" => Ok(Self::N100000136194),
            "100000136195" => Ok(Self::N100000136195),
            "100000136196" => Ok(Self::N100000136196),
            "100000136197" => Ok(Self::N100000136197),
            "100000136198" => Ok(Self::N100000136198),
            "100000136199" => Ok(Self::N100000136199),
            "100000136200" => Ok(Self::N100000136200),
            "100000136201" => Ok(Self::N100000136201),
            "100000136202" => Ok(Self::N100000136202),
            "100000136203" => Ok(Self::N100000136203),
            "100000136204" => Ok(Self::N100000136204),
            "100000136205" => Ok(Self::N100000136205),
            "100000136206" => Ok(Self::N100000136206),
            "100000136207" => Ok(Self::N100000136207),
            "100000136208" => Ok(Self::N100000136208),
            "100000136209" => Ok(Self::N100000136209),
            "100000136210" => Ok(Self::N100000136210),
            "100000136211" => Ok(Self::N100000136211),
            "100000136212" => Ok(Self::N100000136212),
            "100000136213" => Ok(Self::N100000136213),
            "100000136214" => Ok(Self::N100000136214),
            "100000136215" => Ok(Self::N100000136215),
            "100000136216" => Ok(Self::N100000136216),
            "100000136217" => Ok(Self::N100000136217),
            "100000136218" => Ok(Self::N100000136218),
            "100000136219" => Ok(Self::N100000136219),
            "100000136220" => Ok(Self::N100000136220),
            "100000136221" => Ok(Self::N100000136221),
            "100000136222" => Ok(Self::N100000136222),
            "100000136223" => Ok(Self::N100000136223),
            "100000136224" => Ok(Self::N100000136224),
            "100000136225" => Ok(Self::N100000136225),
            "100000136226" => Ok(Self::N100000136226),
            "100000136227" => Ok(Self::N100000136227),
            "100000136228" => Ok(Self::N100000136228),
            "100000136229" => Ok(Self::N100000136229),
            "100000136230" => Ok(Self::N100000136230),
            "100000136231" => Ok(Self::N100000136231),
            "100000136232" => Ok(Self::N100000136232),
            "100000136233" => Ok(Self::N100000136233),
            "100000136234" => Ok(Self::N100000136234),
            "100000136235" => Ok(Self::N100000136235),
            "100000136236" => Ok(Self::N100000136236),
            "100000136237" => Ok(Self::N100000136237),
            "100000136247" => Ok(Self::N100000136247),
            "100000136248" => Ok(Self::N100000136248),
            "100000136554" => Ok(Self::N100000136554),
            "100000136555" => Ok(Self::N100000136555),
            "100000136556" => Ok(Self::N100000136556),
            "100000142485" => Ok(Self::N100000142485),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AnimalTissueType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000072091 => "100000072091",
            Self::N100000072092 => "100000072092",
            Self::N100000072093 => "100000072093",
            Self::N100000072094 => "100000072094",
            Self::N100000072095 => "100000072095",
            Self::N100000072096 => "100000072096",
            Self::N100000072104 => "100000072104",
            Self::N100000072105 => "100000072105",
            Self::N100000072106 => "100000072106",
            Self::N100000072107 => "100000072107",
            Self::N100000072108 => "100000072108",
            Self::N100000072109 => "100000072109",
            Self::N100000111053 => "100000111053",
            Self::N100000111054 => "100000111054",
            Self::N100000111055 => "100000111055",
            Self::N100000111056 => "100000111056",
            Self::N100000111057 => "100000111057",
            Self::N100000111058 => "100000111058",
            Self::N100000111059 => "100000111059",
            Self::N100000111060 => "100000111060",
            Self::N100000111061 => "100000111061",
            Self::N100000111062 => "100000111062",
            Self::N100000111063 => "100000111063",
            Self::N100000111064 => "100000111064",
            Self::N100000111065 => "100000111065",
            Self::N100000111066 => "100000111066",
            Self::N100000111067 => "100000111067",
            Self::N100000111068 => "100000111068",
            Self::N100000111069 => "100000111069",
            Self::N100000111070 => "100000111070",
            Self::N100000111071 => "100000111071",
            Self::N100000111072 => "100000111072",
            Self::N100000111073 => "100000111073",
            Self::N100000111074 => "100000111074",
            Self::N100000111075 => "100000111075",
            Self::N100000111076 => "100000111076",
            Self::N100000111077 => "100000111077",
            Self::N100000111078 => "100000111078",
            Self::N100000111079 => "100000111079",
            Self::N100000111080 => "100000111080",
            Self::N100000111081 => "100000111081",
            Self::N100000111082 => "100000111082",
            Self::N100000111083 => "100000111083",
            Self::N100000111084 => "100000111084",
            Self::N100000111085 => "100000111085",
            Self::N100000111086 => "100000111086",
            Self::N100000111087 => "100000111087",
            Self::N100000111088 => "100000111088",
            Self::N100000111089 => "100000111089",
            Self::N100000111090 => "100000111090",
            Self::N100000111091 => "100000111091",
            Self::N100000111092 => "100000111092",
            Self::N100000111093 => "100000111093",
            Self::N100000111094 => "100000111094",
            Self::N100000111095 => "100000111095",
            Self::N100000111096 => "100000111096",
            Self::N100000111097 => "100000111097",
            Self::N100000111098 => "100000111098",
            Self::N100000111099 => "100000111099",
            Self::N100000111100 => "100000111100",
            Self::N100000111101 => "100000111101",
            Self::N100000111102 => "100000111102",
            Self::N100000111103 => "100000111103",
            Self::N100000111104 => "100000111104",
            Self::N100000111105 => "100000111105",
            Self::N100000111106 => "100000111106",
            Self::N100000111107 => "100000111107",
            Self::N100000111108 => "100000111108",
            Self::N100000111109 => "100000111109",
            Self::N100000111110 => "100000111110",
            Self::N100000111111 => "100000111111",
            Self::N100000111112 => "100000111112",
            Self::N100000111113 => "100000111113",
            Self::N100000111114 => "100000111114",
            Self::N100000111115 => "100000111115",
            Self::N100000111116 => "100000111116",
            Self::N100000111117 => "100000111117",
            Self::N100000111118 => "100000111118",
            Self::N100000111119 => "100000111119",
            Self::N100000111120 => "100000111120",
            Self::N100000111121 => "100000111121",
            Self::N100000111122 => "100000111122",
            Self::N100000111123 => "100000111123",
            Self::N100000111124 => "100000111124",
            Self::N100000111125 => "100000111125",
            Self::N100000111126 => "100000111126",
            Self::N100000111127 => "100000111127",
            Self::N100000111128 => "100000111128",
            Self::N100000111129 => "100000111129",
            Self::N100000111130 => "100000111130",
            Self::N100000111131 => "100000111131",
            Self::N100000111132 => "100000111132",
            Self::N100000111133 => "100000111133",
            Self::N100000111134 => "100000111134",
            Self::N100000111135 => "100000111135",
            Self::N100000111136 => "100000111136",
            Self::N100000111137 => "100000111137",
            Self::N100000111138 => "100000111138",
            Self::N100000111139 => "100000111139",
            Self::N100000111140 => "100000111140",
            Self::N100000111141 => "100000111141",
            Self::N100000111142 => "100000111142",
            Self::N100000111143 => "100000111143",
            Self::N100000111144 => "100000111144",
            Self::N100000111145 => "100000111145",
            Self::N100000111146 => "100000111146",
            Self::N100000111147 => "100000111147",
            Self::N100000111148 => "100000111148",
            Self::N100000111149 => "100000111149",
            Self::N100000111150 => "100000111150",
            Self::N100000111151 => "100000111151",
            Self::N100000111152 => "100000111152",
            Self::N100000111153 => "100000111153",
            Self::N100000111154 => "100000111154",
            Self::N100000111155 => "100000111155",
            Self::N100000111156 => "100000111156",
            Self::N100000111157 => "100000111157",
            Self::N100000111158 => "100000111158",
            Self::N100000111159 => "100000111159",
            Self::N100000111160 => "100000111160",
            Self::N100000111161 => "100000111161",
            Self::N100000111162 => "100000111162",
            Self::N100000111163 => "100000111163",
            Self::N100000111164 => "100000111164",
            Self::N100000125717 => "100000125717",
            Self::N100000136180 => "100000136180",
            Self::N100000136181 => "100000136181",
            Self::N100000136182 => "100000136182",
            Self::N100000136183 => "100000136183",
            Self::N100000136184 => "100000136184",
            Self::N100000136185 => "100000136185",
            Self::N100000136186 => "100000136186",
            Self::N100000136187 => "100000136187",
            Self::N100000136188 => "100000136188",
            Self::N100000136189 => "100000136189",
            Self::N100000136190 => "100000136190",
            Self::N100000136191 => "100000136191",
            Self::N100000136192 => "100000136192",
            Self::N100000136193 => "100000136193",
            Self::N100000136194 => "100000136194",
            Self::N100000136195 => "100000136195",
            Self::N100000136196 => "100000136196",
            Self::N100000136197 => "100000136197",
            Self::N100000136198 => "100000136198",
            Self::N100000136199 => "100000136199",
            Self::N100000136200 => "100000136200",
            Self::N100000136201 => "100000136201",
            Self::N100000136202 => "100000136202",
            Self::N100000136203 => "100000136203",
            Self::N100000136204 => "100000136204",
            Self::N100000136205 => "100000136205",
            Self::N100000136206 => "100000136206",
            Self::N100000136207 => "100000136207",
            Self::N100000136208 => "100000136208",
            Self::N100000136209 => "100000136209",
            Self::N100000136210 => "100000136210",
            Self::N100000136211 => "100000136211",
            Self::N100000136212 => "100000136212",
            Self::N100000136213 => "100000136213",
            Self::N100000136214 => "100000136214",
            Self::N100000136215 => "100000136215",
            Self::N100000136216 => "100000136216",
            Self::N100000136217 => "100000136217",
            Self::N100000136218 => "100000136218",
            Self::N100000136219 => "100000136219",
            Self::N100000136220 => "100000136220",
            Self::N100000136221 => "100000136221",
            Self::N100000136222 => "100000136222",
            Self::N100000136223 => "100000136223",
            Self::N100000136224 => "100000136224",
            Self::N100000136225 => "100000136225",
            Self::N100000136226 => "100000136226",
            Self::N100000136227 => "100000136227",
            Self::N100000136228 => "100000136228",
            Self::N100000136229 => "100000136229",
            Self::N100000136230 => "100000136230",
            Self::N100000136231 => "100000136231",
            Self::N100000136232 => "100000136232",
            Self::N100000136233 => "100000136233",
            Self::N100000136234 => "100000136234",
            Self::N100000136235 => "100000136235",
            Self::N100000136236 => "100000136236",
            Self::N100000136237 => "100000136237",
            Self::N100000136247 => "100000136247",
            Self::N100000136248 => "100000136248",
            Self::N100000136554 => "100000136554",
            Self::N100000136555 => "100000136555",
            Self::N100000136556 => "100000136556",
            Self::N100000142485 => "100000142485",
        }
    }
}
impl ::std::fmt::Debug for AnimalTissueType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AnimalTissueType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AnimalTissueType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AnimalTissueType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AnimalTissueType> for Coding {
    fn from(code: AnimalTissueType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/animal-tissue-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AnimalTissueType> for CodeableConcept {
    fn from(code: AnimalTissueType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AppointmentStatus](http://hl7.org/fhir/ValueSet/appointmentstatus)**. The free/busy status of an appointment.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AppointmentStatus {
    /** **arrived**

Arrived. The patient/patients has/have arrived and is/are waiting to be seen. */
    Arrived,
    /** **booked**

Booked. All participant(s) have been considered and the appointment is confirmed to go ahead at the date/times specified. */
    Booked,
    /** **cancelled**

Cancelled. The appointment has been cancelled. */
    Cancelled,
    /** **checked-in**

Checked In. When checked in, all pre-encounter administrative work is complete, and the encounter may begin. (where multiple patients are involved, they are all present). */
    CheckedIn,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **fulfilled**

Fulfilled. The planning stages of the appointment are now complete, the encounter resource will exist and will track further status changes. Note that an encounter may exist before the appointment status is fulfilled for many reasons. */
    Fulfilled,
    /** **noshow**

No Show. Some or all of the participant(s) have not/did not appear for the appointment (usually the patient). */
    Noshow,
    /** **pending**

Pending. Some or all of the participant(s) have not finalized their acceptance of the appointment request. */
    Pending,
    /** **proposed**

Proposed. None of the participant(s) have finalized their acceptance of the appointment request, and the start/end time might not be set yet. */
    Proposed,
    /** **waitlist**

Waitlisted. The appointment has been placed on a waitlist, to be scheduled/confirmed in the future when a slot/service is available.
A specific time might or might not be pre-allocated. */
    Waitlist,
}
impl ::core::str::FromStr for AppointmentStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "arrived" => Ok(Self::Arrived),
            "booked" => Ok(Self::Booked),
            "cancelled" => Ok(Self::Cancelled),
            "checked-in" => Ok(Self::CheckedIn),
            "entered-in-error" => Ok(Self::EnteredInError),
            "fulfilled" => Ok(Self::Fulfilled),
            "noshow" => Ok(Self::Noshow),
            "pending" => Ok(Self::Pending),
            "proposed" => Ok(Self::Proposed),
            "waitlist" => Ok(Self::Waitlist),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AppointmentStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Arrived => "arrived",
            Self::Booked => "booked",
            Self::Cancelled => "cancelled",
            Self::CheckedIn => "checked-in",
            Self::EnteredInError => "entered-in-error",
            Self::Fulfilled => "fulfilled",
            Self::Noshow => "noshow",
            Self::Pending => "pending",
            Self::Proposed => "proposed",
            Self::Waitlist => "waitlist",
        }
    }
}
impl ::std::fmt::Debug for AppointmentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AppointmentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AppointmentStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AppointmentStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AppointmentStatus> for Coding {
    fn from(code: AppointmentStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/appointmentstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AppointmentStatus> for CodeableConcept {
    fn from(code: AppointmentStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ArticleUrlType](http://hl7.org/fhir/ValueSet/article-url-type)**. Code the reason for different URLs, eg abstract and full-text.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ArticleUrlType {
    /** **abstract**

Abstract. URL to reach the abstract for the article. */
    Abstract,
    /** **abstract-version**

Abstract Version. URL to reach a specific version of the abstract for the article. */
    AbstractVersion,
    /** **compressed-file**

Compressed file. Compressed archive file (e.g. a zip file) that contains multiple files */
    CompressedFile,
    /** **doi-based**

DOI Based. URL derived from DOI. */
    DoiBased,
    /** **full-text**

Full-Text. URL to reach the full-text of the article. */
    FullText,
    /** **full-text-version**

Full-Text Version. URL to reach a specific version of the full-text of the article. */
    FullTextVersion,
    /** **json**

JSON. URL to reach computable content in JSON format. */
    Json,
    /** **json-version**

JSON Version. URL to reach a specific version of computable content in JSON format. */
    JsonVersion,
    /** **not-specified**

Not Specified. Used when URL type is not specified, commonly when only a single URL is provided. */
    NotSpecified,
    /** **pdf**

PDF. URL to reach the full-text of the article in PDF form. */
    Pdf,
    /** **pdf-version**

PDF Version. URL to reach a specific version of the full-text of the article in PDF form. */
    PdfVersion,
    /** **supplement**

Supplement. Supplement */
    Supplement,
    /** **supplementary-file-directory**

Supplementary file directory. Supplementary file directory */
    SupplementaryFileDirectory,
    /** **webpage**

Webpage. Used when URL type is a webpage, but other codes do not apply. */
    Webpage,
    /** **xml**

XML. URL to reach computable content in XML format. */
    Xml,
    /** **xml-version**

XML. URL to reach a specific version of computable content in XML format. */
    XmlVersion,
}
impl ::core::str::FromStr for ArticleUrlType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abstract" => Ok(Self::Abstract),
            "abstract-version" => Ok(Self::AbstractVersion),
            "compressed-file" => Ok(Self::CompressedFile),
            "doi-based" => Ok(Self::DoiBased),
            "full-text" => Ok(Self::FullText),
            "full-text-version" => Ok(Self::FullTextVersion),
            "json" => Ok(Self::Json),
            "json-version" => Ok(Self::JsonVersion),
            "not-specified" => Ok(Self::NotSpecified),
            "pdf" => Ok(Self::Pdf),
            "pdf-version" => Ok(Self::PdfVersion),
            "supplement" => Ok(Self::Supplement),
            "supplementary-file-directory" => Ok(Self::SupplementaryFileDirectory),
            "webpage" => Ok(Self::Webpage),
            "xml" => Ok(Self::Xml),
            "xml-version" => Ok(Self::XmlVersion),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArticleUrlType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abstract => "abstract",
            Self::AbstractVersion => "abstract-version",
            Self::CompressedFile => "compressed-file",
            Self::DoiBased => "doi-based",
            Self::FullText => "full-text",
            Self::FullTextVersion => "full-text-version",
            Self::Json => "json",
            Self::JsonVersion => "json-version",
            Self::NotSpecified => "not-specified",
            Self::Pdf => "pdf",
            Self::PdfVersion => "pdf-version",
            Self::Supplement => "supplement",
            Self::SupplementaryFileDirectory => "supplementary-file-directory",
            Self::Webpage => "webpage",
            Self::Xml => "xml",
            Self::XmlVersion => "xml-version",
        }
    }
}
impl ::std::fmt::Debug for ArticleUrlType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ArticleUrlType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ArticleUrlType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArticleUrlType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArticleUrlType> for Coding {
    fn from(code: ArticleUrlType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/article-url-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ArticleUrlType> for CodeableConcept {
    fn from(code: ArticleUrlType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ArtifactContributionInstanceType](http://hl7.org/fhir/ValueSet/artifact-contribution-instance-type)**. Artifact Contribution Instance Type\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ArtifactContributionInstanceType {
    /** **approved**

Approved. Approved */
    Approved,
    /** **edited**

Edited. Edited */
    Edited,
    /** **reviewed**

Reviewed. Reviewed */
    Reviewed,
}
impl ::core::str::FromStr for ArtifactContributionInstanceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "approved" => Ok(Self::Approved),
            "edited" => Ok(Self::Edited),
            "reviewed" => Ok(Self::Reviewed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactContributionInstanceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Approved => "approved",
            Self::Edited => "edited",
            Self::Reviewed => "reviewed",
        }
    }
}
impl ::std::fmt::Debug for ArtifactContributionInstanceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ArtifactContributionInstanceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ArtifactContributionInstanceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactContributionInstanceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArtifactContributionInstanceType> for Coding {
    fn from(code: ArtifactContributionInstanceType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/artifact-contribution-instance-type"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ArtifactContributionInstanceType> for CodeableConcept {
    fn from(code: ArtifactContributionInstanceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ArtifactContributionType](http://hl7.org/fhir/ValueSet/artifact-contribution-type)**. Citation contribution.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ArtifactContributionType {
    /** **conceptualization**

Conceptualization. Conceptualization (see https://jats4r.org/credit-taxonomy). */
    Conceptualization,
    /** **data-curation**

Data curation. Data curation (see https://jats4r.org/credit-taxonomy). */
    DataCuration,
    /** **formal-analysis**

Formal analysis. Formal analysis (see https://jats4r.org/credit-taxonomy). */
    FormalAnalysis,
    /** **funding-acquisition**

Funding acquisition. Funding acquisition (see https://jats4r.org/credit-taxonomy). */
    FundingAcquisition,
    /** **investigation**

Investigation. Investigation (see https://jats4r.org/credit-taxonomy). */
    Investigation,
    /** **methodology**

Methodology. Methodology (see https://jats4r.org/credit-taxonomy). */
    Methodology,
    /** **project-administration**

Project administration. Project administration (see https://jats4r.org/credit-taxonomy). */
    ProjectAdministration,
    /** **resources**

Resources. Resources (see https://jats4r.org/credit-taxonomy). */
    Resources,
    /** **software**

Software. Software (see https://jats4r.org/credit-taxonomy). */
    Software,
    /** **supervision**

Supervision. Supervision (see https://jats4r.org/credit-taxonomy). */
    Supervision,
    /** **validation**

Validation. Validation (see https://jats4r.org/credit-taxonomy). */
    Validation,
    /** **visualization**

Visualization. Visualization (see https://jats4r.org/credit-taxonomy). */
    Visualization,
    /** **writing-original-draft**

Writing - original draft. Writing - original draft (see https://jats4r.org/credit-taxonomy). */
    WritingOriginalDraft,
    /** **writing-review-editing**

Writing - review & editing. Writing - review & editing (see https://jats4r.org/credit-taxonomy). */
    WritingReviewEditing,
}
impl ::core::str::FromStr for ArtifactContributionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "conceptualization" => Ok(Self::Conceptualization),
            "data-curation" => Ok(Self::DataCuration),
            "formal-analysis" => Ok(Self::FormalAnalysis),
            "funding-acquisition" => Ok(Self::FundingAcquisition),
            "investigation" => Ok(Self::Investigation),
            "methodology" => Ok(Self::Methodology),
            "project-administration" => Ok(Self::ProjectAdministration),
            "resources" => Ok(Self::Resources),
            "software" => Ok(Self::Software),
            "supervision" => Ok(Self::Supervision),
            "validation" => Ok(Self::Validation),
            "visualization" => Ok(Self::Visualization),
            "writing-original-draft" => Ok(Self::WritingOriginalDraft),
            "writing-review-editing" => Ok(Self::WritingReviewEditing),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactContributionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Conceptualization => "conceptualization",
            Self::DataCuration => "data-curation",
            Self::FormalAnalysis => "formal-analysis",
            Self::FundingAcquisition => "funding-acquisition",
            Self::Investigation => "investigation",
            Self::Methodology => "methodology",
            Self::ProjectAdministration => "project-administration",
            Self::Resources => "resources",
            Self::Software => "software",
            Self::Supervision => "supervision",
            Self::Validation => "validation",
            Self::Visualization => "visualization",
            Self::WritingOriginalDraft => "writing-original-draft",
            Self::WritingReviewEditing => "writing-review-editing",
        }
    }
}
impl ::std::fmt::Debug for ArtifactContributionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ArtifactContributionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ArtifactContributionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactContributionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArtifactContributionType> for Coding {
    fn from(code: ArtifactContributionType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/artifact-contribution-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ArtifactContributionType> for CodeableConcept {
    fn from(code: ArtifactContributionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ArtifactRelationshipType](http://hl7.org/fhir/ValueSet/artifact-relationship-type)**. Artifact Relationship Type\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ArtifactRelationshipType {
    /** **amended-with**

Amended with. Amended with */
    AmendedWith,
    /** **amends**

Amends. Amends */
    Amends,
    /** **appended-with**

Appended with. Appended with */
    AppendedWith,
    /** **appends**

Appends. Appends */
    Appends,
    /** **cited-by**

Cited by. Cited by */
    CitedBy,
    /** **cites**

Cites. Cites */
    Cites,
    /** **comment-in**

Comment In. Comment In */
    CommentIn,
    /** **comments-on**

Comments On. Comments On */
    CommentsOn,
    /** **composed-of**

Composed of. Composed of */
    ComposedOf,
    /** **correction-in**

Correction In. Correction In */
    CorrectionIn,
    /** **corrects**

Corrects. Corrects */
    Corrects,
    /** **depends-on**

Depends on. Depends on */
    DependsOn,
    /** **derived-from**

Derived from. Derived from */
    DerivedFrom,
    /** **part-of**

Part of. Part of */
    PartOf,
    /** **replaced-with**

Replaced with. Replaced with */
    ReplacedWith,
    /** **replaces**

Replaces. Replaces */
    Replaces,
    /** **retracted-by**

Retracted by. Retracted by */
    RetractedBy,
    /** **retracts**

Retracts. Retracts */
    Retracts,
    /** **similar-to**

Similar to. Similar to */
    SimilarTo,
    /** **supported-with**

Supported with. Supported with */
    SupportedWith,
    /** **supports**

Supports. Supports */
    Supports,
    /** **transformed-into**

Transformed into. Transformed into */
    TransformedInto,
    /** **transformed-with**

Transformed with. Transformed with */
    TransformedWith,
    /** **transforms**

Transforms. Transforms */
    Transforms,
}
impl ::core::str::FromStr for ArtifactRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended-with" => Ok(Self::AmendedWith),
            "amends" => Ok(Self::Amends),
            "appended-with" => Ok(Self::AppendedWith),
            "appends" => Ok(Self::Appends),
            "cited-by" => Ok(Self::CitedBy),
            "cites" => Ok(Self::Cites),
            "comment-in" => Ok(Self::CommentIn),
            "comments-on" => Ok(Self::CommentsOn),
            "composed-of" => Ok(Self::ComposedOf),
            "correction-in" => Ok(Self::CorrectionIn),
            "corrects" => Ok(Self::Corrects),
            "depends-on" => Ok(Self::DependsOn),
            "derived-from" => Ok(Self::DerivedFrom),
            "part-of" => Ok(Self::PartOf),
            "replaced-with" => Ok(Self::ReplacedWith),
            "replaces" => Ok(Self::Replaces),
            "retracted-by" => Ok(Self::RetractedBy),
            "retracts" => Ok(Self::Retracts),
            "similar-to" => Ok(Self::SimilarTo),
            "supported-with" => Ok(Self::SupportedWith),
            "supports" => Ok(Self::Supports),
            "transformed-into" => Ok(Self::TransformedInto),
            "transformed-with" => Ok(Self::TransformedWith),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AmendedWith => "amended-with",
            Self::Amends => "amends",
            Self::AppendedWith => "appended-with",
            Self::Appends => "appends",
            Self::CitedBy => "cited-by",
            Self::Cites => "cites",
            Self::CommentIn => "comment-in",
            Self::CommentsOn => "comments-on",
            Self::ComposedOf => "composed-of",
            Self::CorrectionIn => "correction-in",
            Self::Corrects => "corrects",
            Self::DependsOn => "depends-on",
            Self::DerivedFrom => "derived-from",
            Self::PartOf => "part-of",
            Self::ReplacedWith => "replaced-with",
            Self::Replaces => "replaces",
            Self::RetractedBy => "retracted-by",
            Self::Retracts => "retracts",
            Self::SimilarTo => "similar-to",
            Self::SupportedWith => "supported-with",
            Self::Supports => "supports",
            Self::TransformedInto => "transformed-into",
            Self::TransformedWith => "transformed-with",
            Self::Transforms => "transforms",
        }
    }
}
impl ::std::fmt::Debug for ArtifactRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ArtifactRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ArtifactRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArtifactRelationshipType> for Coding {
    fn from(code: ArtifactRelationshipType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/artifact-relationship-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ArtifactRelationshipType> for CodeableConcept {
    fn from(code: ArtifactRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AssertionDirectionType](http://hl7.org/fhir/ValueSet/assert-direction-codes)**. The type of direction to use for assertion.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AssertionDirectionType {
    /** **request**

request. The assertion is evaluated on the request. */
    Request,
    /** **response**

response. The assertion is evaluated on the response. This is the default value. */
    Response,
}
impl ::core::str::FromStr for AssertionDirectionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "request" => Ok(Self::Request),
            "response" => Ok(Self::Response),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionDirectionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Request => "request",
            Self::Response => "response",
        }
    }
}
impl ::std::fmt::Debug for AssertionDirectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AssertionDirectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AssertionDirectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionDirectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionDirectionType> for Coding {
    fn from(code: AssertionDirectionType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/assert-direction-codes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AssertionDirectionType> for CodeableConcept {
    fn from(code: AssertionDirectionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AssertionOperatorType](http://hl7.org/fhir/ValueSet/assert-operator-codes)**. The type of operator to use for assertion.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AssertionOperatorType {
    /** **contains**

contains. Compare value string contains a known value. */
    Contains,
    /** **empty**

empty. Compare value is empty. */
    Empty,
    /** **equals**

equals. Default value. Equals comparison. */
    Equals,
    /** **eval**

evaluate. Evaluate the FHIRPath expression as a boolean condition. */
    Eval,
    /** **greaterThan**

greaterThan. Compare value to be greater than a known value. */
    GreaterThan,
    /** **in**

in. Compare value within a known set of values. */
    In,
    /** **lessThan**

lessThan. Compare value to be less than a known value. */
    LessThan,
    /** **notContains**

notContains. Compare value string does not contain a known value. */
    NotContains,
    /** **notEmpty**

notEmpty. Compare value is not empty. */
    NotEmpty,
    /** **notEquals**

notEquals. Not equals comparison. */
    NotEquals,
    /** **notIn**

notIn. Compare value not within a known set of values. */
    NotIn,
}
impl ::core::str::FromStr for AssertionOperatorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contains" => Ok(Self::Contains),
            "empty" => Ok(Self::Empty),
            "equals" => Ok(Self::Equals),
            "eval" => Ok(Self::Eval),
            "greaterThan" => Ok(Self::GreaterThan),
            "in" => Ok(Self::In),
            "lessThan" => Ok(Self::LessThan),
            "notContains" => Ok(Self::NotContains),
            "notEmpty" => Ok(Self::NotEmpty),
            "notEquals" => Ok(Self::NotEquals),
            "notIn" => Ok(Self::NotIn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionOperatorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contains => "contains",
            Self::Empty => "empty",
            Self::Equals => "equals",
            Self::Eval => "eval",
            Self::GreaterThan => "greaterThan",
            Self::In => "in",
            Self::LessThan => "lessThan",
            Self::NotContains => "notContains",
            Self::NotEmpty => "notEmpty",
            Self::NotEquals => "notEquals",
            Self::NotIn => "notIn",
        }
    }
}
impl ::std::fmt::Debug for AssertionOperatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AssertionOperatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AssertionOperatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionOperatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionOperatorType> for Coding {
    fn from(code: AssertionOperatorType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/assert-operator-codes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AssertionOperatorType> for CodeableConcept {
    fn from(code: AssertionOperatorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AssertionResponseTypes](http://hl7.org/fhir/ValueSet/assert-response-code-types)**. The type of response code to use for assertion.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AssertionResponseTypes {
    /** **bad**

bad. Response code is 400. */
    Bad,
    /** **conflict**

conflict. Response code is 409. */
    Conflict,
    /** **created**

created. Response code is 201. */
    Created,
    /** **forbidden**

forbidden. Response code is 403. */
    Forbidden,
    /** **gone**

gone. Response code is 410. */
    Gone,
    /** **methodNotAllowed**

methodNotAllowed. Response code is 405. */
    MethodNotAllowed,
    /** **noContent**

noContent. Response code is 204. */
    NoContent,
    /** **notFound**

notFound. Response code is 404. */
    NotFound,
    /** **notModified**

notModified. Response code is 304. */
    NotModified,
    /** **okay**

okay. Response code is 200. */
    Okay,
    /** **preconditionFailed**

preconditionFailed. Response code is 412. */
    PreconditionFailed,
    /** **unprocessable**

unprocessable. Response code is 422. */
    Unprocessable,
}
impl ::core::str::FromStr for AssertionResponseTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bad" => Ok(Self::Bad),
            "conflict" => Ok(Self::Conflict),
            "created" => Ok(Self::Created),
            "forbidden" => Ok(Self::Forbidden),
            "gone" => Ok(Self::Gone),
            "methodNotAllowed" => Ok(Self::MethodNotAllowed),
            "noContent" => Ok(Self::NoContent),
            "notFound" => Ok(Self::NotFound),
            "notModified" => Ok(Self::NotModified),
            "okay" => Ok(Self::Okay),
            "preconditionFailed" => Ok(Self::PreconditionFailed),
            "unprocessable" => Ok(Self::Unprocessable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionResponseTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bad => "bad",
            Self::Conflict => "conflict",
            Self::Created => "created",
            Self::Forbidden => "forbidden",
            Self::Gone => "gone",
            Self::MethodNotAllowed => "methodNotAllowed",
            Self::NoContent => "noContent",
            Self::NotFound => "notFound",
            Self::NotModified => "notModified",
            Self::Okay => "okay",
            Self::PreconditionFailed => "preconditionFailed",
            Self::Unprocessable => "unprocessable",
        }
    }
}
impl ::std::fmt::Debug for AssertionResponseTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AssertionResponseTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AssertionResponseTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionResponseTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionResponseTypes> for Coding {
    fn from(code: AssertionResponseTypes) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/assert-response-code-types".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AssertionResponseTypes> for CodeableConcept {
    fn from(code: AssertionResponseTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AttributeEstimateType](http://hl7.org/fhir/ValueSet/attribute-estimate-type)**. A statistic about a statistic, e.g.  Confidence interval or p-value\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AttributeEstimateType {
    /** **0000037**

Standard error of the mean. The standard deviation of the sample-mean's estimate of a population mean. It is calculated by dividing the sample standard deviation (i.e., the sample-based estimate of the standard deviation of the population) by the square root of n , the size (number of observations) of the sample. */
    N0000037,
    /** **0000419**

Cochran's Q statistic. A measure of heterogeneity across study computed by summing the squared deviations of each study's estimate from the overall meta-analytic estimate, weighting each study's contribution in the same manner as in the meta-analysis. */
    N0000419,
    /** **0000420**

I-squared. The percentage of total variation across studies that is due to heterogeneity rather than chance. I2 can be readily calculated from basic results obtained from a typical meta-analysis as i2 = 100%×(q - df)/q, where q is cochran's heterogeneity statistic and df the degrees of freedom. Negative values of i2 are put equal to zero so that i2 lies between 0% and 100%. A value of 0% indicates no observed heterogeneity, and larger values show increasing heterogeneity. Unlike cochran's q, it does not inherently depend upon the number of studies considered. A confidence interval for i² is constructed using either i) the iterative non-central chi-squared distribution method of hedges and piggott (2001); or ii) the test-based method of higgins and thompson (2002). The non-central chi-square method is currently the method of choice (higgins, personal communication, 2006) – it is computed if the 'exact' option is selected. */
    N0000420,
    /** **0000421**

Tau squared. An estimate of the between-study variance in a random-effects meta-analysis. The square root of this number (i.e. Tau) is the estimated standard deviation of underlying effects across studies. */
    N0000421,
    /** **0000455**

Credible interval. An interval of a posterior distribution which is such that the density at any point inside the interval is greater than the density at any point outside and that the area under the curve for that interval is equal to a prespecified probability level. For any probability level there is generally only one such interval, which is also often known as the highest posterior density region. Unlike the usual confidence interval associated with frequentist inference, here the intervals specify the range within which parameters lie with a certain probability. The bayesian counterparts of the confidence interval used in frequentists statistics. */
    N0000455,
    /** **C38013**

Range. The difference between the lowest and highest numerical values; the limits or scale of variation. */
    C38013,
    /** **C44185**

P-value. The probability of obtaining the results obtained, or more extreme results, if the hypothesis being tested and all other model assumptions are true */
    C44185,
    /** **C48918**

Variance. A measure of the variability in a sample or population. It is calculated as the mean squared deviation (MSD) of the individual values from their common mean. In calculating the MSD, the divisor n is commonly used for a population variance and the divisor n-1 for a sample variance. */
    C48918,
    /** **C53245**

Interquartile range. The difference between the 3d and 1st quartiles is called the interquartile range and it is used as a measure of variability (dispersion). */
    C53245,
    /** **C53322**

Standard deviation. A measure of the range of values in a set of numbers. Standard deviation is a statistic used as a measure of the dispersion or variation in a distribution, equal to the square root of the arithmetic mean of the squares of the deviations from the arithmetic mean. */
    C53322,
    /** **C53324**

Confidence interval. A range of values considered compatible with the observed data at the specified confidence level */
    C53324,
}
impl ::core::str::FromStr for AttributeEstimateType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0000037" => Ok(Self::N0000037),
            "0000419" => Ok(Self::N0000419),
            "0000420" => Ok(Self::N0000420),
            "0000421" => Ok(Self::N0000421),
            "0000455" => Ok(Self::N0000455),
            "C38013" => Ok(Self::C38013),
            "C44185" => Ok(Self::C44185),
            "C48918" => Ok(Self::C48918),
            "C53245" => Ok(Self::C53245),
            "C53322" => Ok(Self::C53322),
            "C53324" => Ok(Self::C53324),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AttributeEstimateType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0000037 => "0000037",
            Self::N0000419 => "0000419",
            Self::N0000420 => "0000420",
            Self::N0000421 => "0000421",
            Self::N0000455 => "0000455",
            Self::C38013 => "C38013",
            Self::C44185 => "C44185",
            Self::C48918 => "C48918",
            Self::C53245 => "C53245",
            Self::C53322 => "C53322",
            Self::C53324 => "C53324",
        }
    }
}
impl ::std::fmt::Debug for AttributeEstimateType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AttributeEstimateType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AttributeEstimateType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AttributeEstimateType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AttributeEstimateType> for Coding {
    fn from(code: AttributeEstimateType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/attribute-estimate-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AttributeEstimateType> for CodeableConcept {
    fn from(code: AttributeEstimateType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventAction](http://hl7.org/fhir/ValueSet/audit-event-action)**. Indicator for type of action performed during the event that generated the event.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AuditEventAction {
    /** **C**

Create. Create a new database object, such as placing an order. */
    C,
    /** **D**

Delete. Delete items, such as a doctor master file record. */
    D,
    /** **E**

Execute. Perform a system or application function such as log-on, program execution or use of an object's method, or perform a query/search operation. */
    E,
    /** **R**

Read/View/Print. Display or print data, such as a doctor census. */
    R,
    /** **U**

Update. Update data, such as revise patient information. */
    U,
}
impl ::core::str::FromStr for AuditEventAction {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "C" => Ok(Self::C),
            "D" => Ok(Self::D),
            "E" => Ok(Self::E),
            "R" => Ok(Self::R),
            "U" => Ok(Self::U),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventAction {
    fn as_ref(&self) -> &str {
        match self {
            Self::C => "C",
            Self::D => "D",
            Self::E => "E",
            Self::R => "R",
            Self::U => "U",
        }
    }
}
impl ::std::fmt::Debug for AuditEventAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventAction> for Coding {
    fn from(code: AuditEventAction) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/audit-event-action".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventAction> for CodeableConcept {
    fn from(code: AuditEventAction) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventAgentNetworkType](http://hl7.org/fhir/ValueSet/network-type)**. The type of network access point of this agent in the audit event.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AuditEventAgentNetworkType {
    /** **1**

Machine Name. The machine name, including DNS name. */
    N1,
    /** **2**

IP Address. The assigned Internet Protocol (IP) address. */
    N2,
    /** **3**

Telephone Number. The assigned telephone number. */
    N3,
    /** **4**

Email address. The assigned email address. */
    N4,
    /** **5**

URI. URI (User directory, HTTP-PUT, ftp, etc.). */
    N5,
}
impl ::core::str::FromStr for AuditEventAgentNetworkType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "2" => Ok(Self::N2),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventAgentNetworkType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N2 => "2",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::N5 => "5",
        }
    }
}
impl ::std::fmt::Debug for AuditEventAgentNetworkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventAgentNetworkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventAgentNetworkType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventAgentNetworkType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventAgentNetworkType> for Coding {
    fn from(code: AuditEventAgentNetworkType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/network-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventAgentNetworkType> for CodeableConcept {
    fn from(code: AuditEventAgentNetworkType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventEntityRole](http://hl7.org/fhir/ValueSet/object-role)**. Code representing the role the entity played in the audit event.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AuditEventEntityRole {
    /** **1**

Patient. This object is the patient that is the subject of care related to this event.  It is identifiable by patient ID or equivalent.  The patient may be either human or animal. */
    N1,
    /** **10**

Guarantor. Insurance company, or any other organization who accepts responsibility for paying for the healthcare event. */
    N10,
    /** **11**

Security User Entity. A person or active system object involved in the event with a security role. */
    N11,
    /** **12**

Security User Group. A person or system object involved in the event with the authority to modify security roles of other objects. */
    N12,
    /** **13**

Security Resource. A passive object, such as a role table, that is relevant to the event. */
    N13,
    /** **14**

Security Granularity Definition. (deprecated)  Relevant to certain RBAC security methodologies. */
    N14,
    /** **15**

Practitioner. Any person or organization responsible for providing care.  This encompasses all forms of care, licensed or otherwise, and all sorts of teams and care groups. Note the distinction between practitioner and the doctor that actually provided the care to the patient. */
    N15,
    /** **16**

Data Destination. The source or destination for data transfer, when it does not match some other role. */
    N16,
    /** **17**

Data Repository. A source or destination for data transfer that acts as an archive, database, or similar role. */
    N17,
    /** **18**

Schedule. An object that holds schedule information.  This could be an appointment book, availability information, etc. */
    N18,
    /** **19**

Customer. An organization or person that is the recipient of services.  This could be an organization that is buying services for a patient, or a person that is buying services for an animal. */
    N19,
    /** **2**

Location. This is a location identified as related to the event.  This is usually the location where the event took place.  Note that for shipping, the usual events are arrival at a location or departure from a location. */
    N2,
    /** **20**

Job. An order, task, work item, procedure step, or other description of work to be performed; e.g. a particular instance of an MPPS. */
    N20,
    /** **21**

Job Stream. A list of jobs or a system that provides lists of jobs; e.g. an MWL SCP. */
    N21,
    /** **22**

Table. (Deprecated). */
    N22,
    /** **23**

Routing Criteria. An object that specifies or controls the routing or delivery of items.  For example, a distribution list is the routing criteria for mail.  The items delivered may be documents, jobs, or other objects. */
    N23,
    /** **24**

Query. The contents of a query.  This is used to capture the contents of any kind of query.  For security surveillance purposes knowing the queries being made is very important. */
    N24,
    /** **3**

Report. This object is any kind of persistent document created as a result of the event.  This could be a paper report, film, electronic report, DICOM Study, etc.  Issues related to medical records life cycle management are conveyed elsewhere. */
    N3,
    /** **4**

Domain Resource. A logical object related to a health record event.  This is any healthcare  specific resource (object) not restricted to FHIR defined Resources. */
    N4,
    /** **5**

Master file. This is any configurable file used to control creation of documents.  Examples include the objects maintained by the HL7 Master File transactions, Value Sets, etc. */
    N5,
    /** **6**

User. A human participant not otherwise identified by some other category. */
    N6,
    /** **7**

List. (deprecated). */
    N7,
    /** **8**

Doctor. Typically, a licensed person who is providing or performing care related to the event, generally a physician.   The key distinction between doctor and practitioner is with regards to their role, not the licensing.  The doctor is the human who actually performed the work.  The practitioner is the human or organization that is responsible for the work. */
    N8,
    /** **9**

Subscriber. A person or system that is being notified as part of the event.  This is relevant in situations where automated systems provide notifications to other parties when an event took place. */
    N9,
}
impl ::core::str::FromStr for AuditEventEntityRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "10" => Ok(Self::N10),
            "11" => Ok(Self::N11),
            "12" => Ok(Self::N12),
            "13" => Ok(Self::N13),
            "14" => Ok(Self::N14),
            "15" => Ok(Self::N15),
            "16" => Ok(Self::N16),
            "17" => Ok(Self::N17),
            "18" => Ok(Self::N18),
            "19" => Ok(Self::N19),
            "2" => Ok(Self::N2),
            "20" => Ok(Self::N20),
            "21" => Ok(Self::N21),
            "22" => Ok(Self::N22),
            "23" => Ok(Self::N23),
            "24" => Ok(Self::N24),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            "6" => Ok(Self::N6),
            "7" => Ok(Self::N7),
            "8" => Ok(Self::N8),
            "9" => Ok(Self::N9),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventEntityRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N10 => "10",
            Self::N11 => "11",
            Self::N12 => "12",
            Self::N13 => "13",
            Self::N14 => "14",
            Self::N15 => "15",
            Self::N16 => "16",
            Self::N17 => "17",
            Self::N18 => "18",
            Self::N19 => "19",
            Self::N2 => "2",
            Self::N20 => "20",
            Self::N21 => "21",
            Self::N22 => "22",
            Self::N23 => "23",
            Self::N24 => "24",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::N5 => "5",
            Self::N6 => "6",
            Self::N7 => "7",
            Self::N8 => "8",
            Self::N9 => "9",
        }
    }
}
impl ::std::fmt::Debug for AuditEventEntityRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventEntityRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventEntityRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventEntityRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventEntityRole> for Coding {
    fn from(code: AuditEventEntityRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/object-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventEntityRole> for CodeableConcept {
    fn from(code: AuditEventEntityRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventEntityType](http://terminology.hl7.org/CodeSystem/audit-entity-type)**. Code for the entity type involved in the audit event (derived from ATNA).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum AuditEventEntityType {
    /** **1**

Person. Person */
    N1,
    /** **2**

System Object. System Object */
    N2,
    /** **3**

Organization. Organization */
    N3,
    /** **4**

Other. Other */
    N4,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AuditEventEntityType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "2" => Ok(Self::N2),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AuditEventEntityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N2 => "2",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for AuditEventEntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventEntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventEntityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventEntityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventEntityType> for Coding {
    fn from(code: AuditEventEntityType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/audit-entity-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventEntityType> for CodeableConcept {
    fn from(code: AuditEventEntityType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventID](http://terminology.hl7.org/CodeSystem/audit-event-type)**. Event Types for Audit Events - defined by DICOM with some FHIR specific additions.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum AuditEventID {
    /** **rest**

RESTful Operation. Audit Event: Execution of a RESTful operation as defined by FHIR. */
    Rest,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AuditEventID {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "rest" => Ok(Self::Rest),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AuditEventID {
    fn as_ref(&self) -> &str {
        match self {
            Self::Rest => "rest",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for AuditEventID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventID {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventID {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventID> for Coding {
    fn from(code: AuditEventID) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/audit-event-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventID> for CodeableConcept {
    fn from(code: AuditEventID) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventOutcome](http://hl7.org/fhir/ValueSet/audit-event-outcome)**. Indicates whether the event succeeded or failed.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum AuditEventOutcome {
    /** **0**

Success. The operation completed successfully (whether with warnings or not). */
    N0,
    /** **12**

Major failure. An error of such magnitude occurred that the system is no longer available for use (i.e. the system died). */
    N12,
    /** **4**

Minor failure. The action was not successful due to some kind of minor failure (often equivalent to an HTTP 400 response). */
    N4,
    /** **8**

Serious failure. The action was not successful due to some kind of unexpected error (often equivalent to an HTTP 500 response). */
    N8,
}
impl ::core::str::FromStr for AuditEventOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0" => Ok(Self::N0),
            "12" => Ok(Self::N12),
            "4" => Ok(Self::N4),
            "8" => Ok(Self::N8),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0 => "0",
            Self::N12 => "12",
            Self::N4 => "4",
            Self::N8 => "8",
        }
    }
}
impl ::std::fmt::Debug for AuditEventOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventOutcome> for Coding {
    fn from(code: AuditEventOutcome) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/audit-event-outcome".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventOutcome> for CodeableConcept {
    fn from(code: AuditEventOutcome) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[AuditEventSourceType](http://terminology.hl7.org/CodeSystem/security-source-type)**. The type of process where the audit event originated from.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum AuditEventSourceType {
    /** **1**

User Device. End-user display device, diagnostic device. */
    N1,
    /** **2**

Data Interface. Data acquisition device or instrument. */
    N2,
    /** **3**

Web Server. Web Server process or thread. */
    N3,
    /** **4**

Application Server. Application Server process or thread. */
    N4,
    /** **5**

Database Server. Database Server process or thread. */
    N5,
    /** **6**

Security Server. Security server, e.g. a domain controller. */
    N6,
    /** **7**

Network Device. ISO level 1-3 network component. */
    N7,
    /** **8**

Network Router. ISO level 4-6 operating software. */
    N8,
    /** **9**

Other. Other kind of device (defined by DICOM, but some other code/system can be used). */
    N9,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AuditEventSourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "2" => Ok(Self::N2),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            "6" => Ok(Self::N6),
            "7" => Ok(Self::N7),
            "8" => Ok(Self::N8),
            "9" => Ok(Self::N9),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AuditEventSourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N2 => "2",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::N5 => "5",
            Self::N6 => "6",
            Self::N7 => "7",
            Self::N8 => "8",
            Self::N9 => "9",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for AuditEventSourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for AuditEventSourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for AuditEventSourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventSourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventSourceType> for Coding {
    fn from(code: AuditEventSourceType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/security-source-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<AuditEventSourceType> for CodeableConcept {
    fn from(code: AuditEventSourceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BasicResourceTypes](http://terminology.hl7.org/CodeSystem/basic-resource-type)**. This value set defines codes for resources not yet supported by (or which will never be supported by) FHIR.  Many of the codes listed here will eventually be turned into official resources.  However, there is no guarantee that any particular resource will be created nor that the scope will be exactly as defined by the codes presented here.  Codes in this set will be deprecated if/when formal resources are defined that encompass these concepts.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum BasicResourceTypes {
    /** **account**

Account. A financial instrument used to track costs, charges or other amounts. */
    Account,
    /** **adjudicat**

Invoice Adjudication. The determination of what will be paid against a particular invoice based on coverage, plan rules, etc. */
    Adjudicat,
    /** **adminact**

Administrative Activity. An occurrence of a non-care-related event in the healthcare domain, such as approvals, reviews, etc. */
    Adminact,
    /** **advevent**

Adverse Event. An undesired reaction caused by exposure to some agent (e.g. a medication, immunization, food, or environmental agent). */
    Advevent,
    /** **aptmtreq**

Appointment Request. A request that a time be scheduled for a type of service for a specified patient, potentially subject to other constraints */
    Aptmtreq,
    /** **consent**

Consent. An assertion of permission for an activity or set of activities to occur, possibly subject to particular limitations; e.g. surgical consent, information disclosure consent, etc. */
    Consent,
    /** **diet**

Diet. The specification of a set of food and/or other nutritional material to be delivered to a patient. */
    Diet,
    /** **exposure**

Exposure. Record of a situation where a subject was exposed to a substance.  Usually of interest to public health. */
    Exposure,
    /** **investigation**

Investigation. A formalized inquiry into the circumstances surrounding a particular unplanned event or potential event for the purposes of identifying possible causes and contributing factors for the event */
    Investigation,
    /** **invoice**

Invoice. A request for payment for goods and/or services.  Includes the idea of a healthcare insurance claim. */
    Invoice,
    /** **predetermine**

Predetermination. An adjudication of what would be paid under an insurance plan for a hypothetical claim for goods or services */
    Predetermine,
    /** **predetreq**

Pre-determination Request. A request for a pre-determination of the cost that would be paid under an insurance plan for a hypothetical claim for goods or services */
    Predetreq,
    /** **protocol**

Protocol. A set of (possibly conditional) steps to be taken to achieve some aim.  Includes study protocols, treatment protocols, emergency protocols, etc. */
    Protocol,
    /** **referral**

Referral. A request that care of a particular type be provided to a patient.  Could involve the transfer of care, a consult, etc. */
    Referral,
    /** **study**

Study. An investigation to determine information about a particular therapy or product */
    Study,
    /** **transfer**

Transfer. The transition of a patient or set of material from one location to another */
    Transfer,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for BasicResourceTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "account" => Ok(Self::Account),
            "adjudicat" => Ok(Self::Adjudicat),
            "adminact" => Ok(Self::Adminact),
            "advevent" => Ok(Self::Advevent),
            "aptmtreq" => Ok(Self::Aptmtreq),
            "consent" => Ok(Self::Consent),
            "diet" => Ok(Self::Diet),
            "exposure" => Ok(Self::Exposure),
            "investigation" => Ok(Self::Investigation),
            "invoice" => Ok(Self::Invoice),
            "predetermine" => Ok(Self::Predetermine),
            "predetreq" => Ok(Self::Predetreq),
            "protocol" => Ok(Self::Protocol),
            "referral" => Ok(Self::Referral),
            "study" => Ok(Self::Study),
            "transfer" => Ok(Self::Transfer),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for BasicResourceTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Account => "account",
            Self::Adjudicat => "adjudicat",
            Self::Adminact => "adminact",
            Self::Advevent => "advevent",
            Self::Aptmtreq => "aptmtreq",
            Self::Consent => "consent",
            Self::Diet => "diet",
            Self::Exposure => "exposure",
            Self::Investigation => "investigation",
            Self::Invoice => "invoice",
            Self::Predetermine => "predetermine",
            Self::Predetreq => "predetreq",
            Self::Protocol => "protocol",
            Self::Referral => "referral",
            Self::Study => "study",
            Self::Transfer => "transfer",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for BasicResourceTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BasicResourceTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BasicResourceTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BasicResourceTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BasicResourceTypes> for Coding {
    fn from(code: BasicResourceTypes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/basic-resource-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BasicResourceTypes> for CodeableConcept {
    fn from(code: BasicResourceTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BenefitCategoryCodes](http://terminology.hl7.org/CodeSystem/ex-benefitcategory)**. This value set includes a smattering of Benefit SubCategory codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum BenefitCategoryCodes {
    /** **1**

Medical Care. Medical Care. */
    N1,
    /** **14**

Renal Supplies. Renal Supplies excluding Dialysis. */
    N14,
    /** **2**

Surgical. Surgical. */
    N2,
    /** **23**

Diagnostic Dental. Diagnostic Dental. */
    N23,
    /** **24**

Periodontics. Periodontics. */
    N24,
    /** **25**

Restorative. Restorative. */
    N25,
    /** **26**

Endodontics. Endodontics. */
    N26,
    /** **27**

Maxillofacial Prosthetics. Maxillofacial Prosthetics. */
    N27,
    /** **28**

Adjunctive Dental Services. Adjunctive Dental Services. */
    N28,
    /** **3**

Consultation. Consultation. */
    N3,
    /** **30**

Health Benefit Plan Coverage. Health Benefit Plan Coverage. */
    N30,
    /** **35**

Dental Care. Dental Care. */
    N35,
    /** **36**

Dental Crowns. Dental Crowns. */
    N36,
    /** **37**

Dental Accident. Dental Accident. */
    N37,
    /** **4**

Diagnostic XRay. Diagnostic XRay. */
    N4,
    /** **49**

Hospital Room and Board. Hospital Room and Board. */
    N49,
    /** **5**

Diagnostic Lab. Diagnostic Lab. */
    N5,
    /** **55**

Major Medical. Major Medical. */
    N55,
    /** **56**

Medically Related Transportation. Medically Related Transportation. */
    N56,
    /** **61**

In-vitro Fertilization. In-vitro Fertilization. */
    N61,
    /** **62**

MRI Scan. MRI Scan. */
    N62,
    /** **63**

Donor Procedures. Donor Procedures such as organ harvest. */
    N63,
    /** **69**

Maternity. Maternity. */
    N69,
    /** **76**

Renal Dialysis. Renal dialysis. */
    N76,
    /** **F1**

Medical Coverage. Medical Coverage. */
    F1,
    /** **F3**

Dental Coverage. Dental Coverage. */
    F3,
    /** **F4**

Hearing Coverage. Hearing Coverage. */
    F4,
    /** **F6**

Vision Coverage. Vision Coverage. */
    F6,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for BenefitCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "14" => Ok(Self::N14),
            "2" => Ok(Self::N2),
            "23" => Ok(Self::N23),
            "24" => Ok(Self::N24),
            "25" => Ok(Self::N25),
            "26" => Ok(Self::N26),
            "27" => Ok(Self::N27),
            "28" => Ok(Self::N28),
            "3" => Ok(Self::N3),
            "30" => Ok(Self::N30),
            "35" => Ok(Self::N35),
            "36" => Ok(Self::N36),
            "37" => Ok(Self::N37),
            "4" => Ok(Self::N4),
            "49" => Ok(Self::N49),
            "5" => Ok(Self::N5),
            "55" => Ok(Self::N55),
            "56" => Ok(Self::N56),
            "61" => Ok(Self::N61),
            "62" => Ok(Self::N62),
            "63" => Ok(Self::N63),
            "69" => Ok(Self::N69),
            "76" => Ok(Self::N76),
            "F1" => Ok(Self::F1),
            "F3" => Ok(Self::F3),
            "F4" => Ok(Self::F4),
            "F6" => Ok(Self::F6),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for BenefitCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N14 => "14",
            Self::N2 => "2",
            Self::N23 => "23",
            Self::N24 => "24",
            Self::N25 => "25",
            Self::N26 => "26",
            Self::N27 => "27",
            Self::N28 => "28",
            Self::N3 => "3",
            Self::N30 => "30",
            Self::N35 => "35",
            Self::N36 => "36",
            Self::N37 => "37",
            Self::N4 => "4",
            Self::N49 => "49",
            Self::N5 => "5",
            Self::N55 => "55",
            Self::N56 => "56",
            Self::N61 => "61",
            Self::N62 => "62",
            Self::N63 => "63",
            Self::N69 => "69",
            Self::N76 => "76",
            Self::F1 => "F1",
            Self::F3 => "F3",
            Self::F4 => "F4",
            Self::F6 => "F6",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for BenefitCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BenefitCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BenefitCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BenefitCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BenefitCategoryCodes> for Coding {
    fn from(code: BenefitCategoryCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-benefitcategory".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BenefitCategoryCodes> for CodeableConcept {
    fn from(code: BenefitCategoryCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BenefitCostApplicability](http://hl7.org/fhir/ValueSet/applicability)**. Whether the cost applies to in-network or out-of-network providers.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum BenefitCostApplicability {
    /** **in-network**

In Network. Provider is contracted with the health insurance company to provide services to plan members for specific pre-negotiated rates */
    InNetwork,
    /** **other**

Other. Other applicability */
    Other,
    /** **out-of-network**

Out of Network. Provider is  not contracted with the health insurance company to provide services to plan members for specific pre-negotiated rates */
    OutOfNetwork,
}
impl ::core::str::FromStr for BenefitCostApplicability {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "in-network" => Ok(Self::InNetwork),
            "other" => Ok(Self::Other),
            "out-of-network" => Ok(Self::OutOfNetwork),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BenefitCostApplicability {
    fn as_ref(&self) -> &str {
        match self {
            Self::InNetwork => "in-network",
            Self::Other => "other",
            Self::OutOfNetwork => "out-of-network",
        }
    }
}
impl ::std::fmt::Debug for BenefitCostApplicability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BenefitCostApplicability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BenefitCostApplicability {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BenefitCostApplicability {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BenefitCostApplicability> for Coding {
    fn from(code: BenefitCostApplicability) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/applicability".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BenefitCostApplicability> for CodeableConcept {
    fn from(code: BenefitCostApplicability) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BenefitTermCodes](http://terminology.hl7.org/CodeSystem/benefit-term)**. This value set includes a smattering of Benefit Term codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum BenefitTermCodes {
    /** **annual**

Annual. Annual, renewing on the anniversary */
    Annual,
    /** **day**

Day. Per day */
    Day,
    /** **lifetime**

Lifetime. For the total term, lifetime, of the policy or coverage */
    Lifetime,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for BenefitTermCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "annual" => Ok(Self::Annual),
            "day" => Ok(Self::Day),
            "lifetime" => Ok(Self::Lifetime),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for BenefitTermCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Annual => "annual",
            Self::Day => "day",
            Self::Lifetime => "lifetime",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for BenefitTermCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BenefitTermCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BenefitTermCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BenefitTermCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BenefitTermCodes> for Coding {
    fn from(code: BenefitTermCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/benefit-term".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BenefitTermCodes> for CodeableConcept {
    fn from(code: BenefitTermCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BenefitTypeCodes](http://terminology.hl7.org/CodeSystem/benefit-type)**. This value set includes a smattering of Benefit type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum BenefitTypeCodes {
    /** **benefit**

Benefit. Maximum benefit allowable. */
    Benefit,
    /** **copay**

Copayment per service. Copayment per service */
    Copay,
    /** **copay-maximum**

Copayment maximum per service. Copayment maximum per service */
    CopayMaximum,
    /** **copay-percent**

Copayment Percent per service. Copayment percentage per service */
    CopayPercent,
    /** **deductible**

Deductible. Cost to be incurred before benefits are applied */
    Deductible,
    /** **medical-primarycare**

Medical Primary Health Coverage. Medical Primary Health Coverage */
    MedicalPrimarycare,
    /** **pharmacy-dispense**

Pharmacy Dispense Coverage. Pharmacy Dispense Coverage */
    PharmacyDispense,
    /** **room**

Room. Type of room */
    Room,
    /** **vision-contacts**

Vision Contacts Coverage. Contact Lenses */
    VisionContacts,
    /** **vision-exam**

Vision Exam. Vision Exam */
    VisionExam,
    /** **vision-glasses**

Vision Glasses. Frames and lenses */
    VisionGlasses,
    /** **visit**

Visit. Service visit */
    Visit,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for BenefitTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "benefit" => Ok(Self::Benefit),
            "copay" => Ok(Self::Copay),
            "copay-maximum" => Ok(Self::CopayMaximum),
            "copay-percent" => Ok(Self::CopayPercent),
            "deductible" => Ok(Self::Deductible),
            "medical-primarycare" => Ok(Self::MedicalPrimarycare),
            "pharmacy-dispense" => Ok(Self::PharmacyDispense),
            "room" => Ok(Self::Room),
            "vision-contacts" => Ok(Self::VisionContacts),
            "vision-exam" => Ok(Self::VisionExam),
            "vision-glasses" => Ok(Self::VisionGlasses),
            "visit" => Ok(Self::Visit),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for BenefitTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Benefit => "benefit",
            Self::Copay => "copay",
            Self::CopayMaximum => "copay-maximum",
            Self::CopayPercent => "copay-percent",
            Self::Deductible => "deductible",
            Self::MedicalPrimarycare => "medical-primarycare",
            Self::PharmacyDispense => "pharmacy-dispense",
            Self::Room => "room",
            Self::VisionContacts => "vision-contacts",
            Self::VisionExam => "vision-exam",
            Self::VisionGlasses => "vision-glasses",
            Self::Visit => "visit",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for BenefitTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BenefitTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BenefitTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BenefitTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BenefitTypeCodes> for Coding {
    fn from(code: BenefitTypeCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/benefit-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BenefitTypeCodes> for CodeableConcept {
    fn from(code: BenefitTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BindingStrength](http://hl7.org/fhir/ValueSet/binding-strength)**. Indication of the degree of conformance expectations associated with a binding.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum BindingStrength {
    /** **example**

Example. Instances are not expected or even encouraged to draw from the specified value set.  The value set merely provides examples of the types of concepts intended to be included. */
    Example,
    /** **extensible**

Extensible. To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated.  If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead. */
    Extensible,
    /** **preferred**

Preferred. Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. */
    Preferred,
    /** **required**

Required. To be conformant, the concept in this element SHALL be from the specified value set. */
    Required,
}
impl ::core::str::FromStr for BindingStrength {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "example" => Ok(Self::Example),
            "extensible" => Ok(Self::Extensible),
            "preferred" => Ok(Self::Preferred),
            "required" => Ok(Self::Required),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BindingStrength {
    fn as_ref(&self) -> &str {
        match self {
            Self::Example => "example",
            Self::Extensible => "extensible",
            Self::Preferred => "preferred",
            Self::Required => "required",
        }
    }
}
impl ::std::fmt::Debug for BindingStrength {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BindingStrength {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BindingStrength {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BindingStrength {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BindingStrength> for Coding {
    fn from(code: BindingStrength) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/binding-strength".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BindingStrength> for CodeableConcept {
    fn from(code: BindingStrength) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BiologicallyDerivedProductCategory](http://hl7.org/fhir/ValueSet/product-category)**. Biologically Derived Product Category.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductCategory {
    /** **biologicalAgent**

BiologicalAgent. Biological agent of unspecified type. */
    BiologicalAgent,
    /** **cells**

Cells. Collection of cells. */
    Cells,
    /** **fluid**

Fluid. Body fluid. */
    Fluid,
    /** **organ**

Organ. A collection of tissues joined in a structural unit to serve a common function. */
    Organ,
    /** **tissue**

Tissue. An ensemble of similar cells and their extracellular matrix from the same origin that together carry out a specific function. */
    Tissue,
}
impl ::core::str::FromStr for BiologicallyDerivedProductCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "biologicalAgent" => Ok(Self::BiologicalAgent),
            "cells" => Ok(Self::Cells),
            "fluid" => Ok(Self::Fluid),
            "organ" => Ok(Self::Organ),
            "tissue" => Ok(Self::Tissue),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::BiologicalAgent => "biologicalAgent",
            Self::Cells => "cells",
            Self::Fluid => "fluid",
            Self::Organ => "organ",
            Self::Tissue => "tissue",
        }
    }
}
impl ::std::fmt::Debug for BiologicallyDerivedProductCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductCategory> for Coding {
    fn from(code: BiologicallyDerivedProductCategory) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/product-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BiologicallyDerivedProductCategory> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BiologicallyDerivedProductStatus](http://hl7.org/fhir/ValueSet/product-status)**. Biologically Derived Product Status.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductStatus {
    /** **available**

Available. Product is currently available for use. */
    Available,
    /** **unavailable**

Unavailable. Product is not currently available for use. */
    Unavailable,
}
impl ::core::str::FromStr for BiologicallyDerivedProductStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "unavailable" => Ok(Self::Unavailable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::Unavailable => "unavailable",
        }
    }
}
impl ::std::fmt::Debug for BiologicallyDerivedProductStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductStatus> for Coding {
    fn from(code: BiologicallyDerivedProductStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/product-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BiologicallyDerivedProductStatus> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BiologicallyDerivedProductStorageScale](http://hl7.org/fhir/ValueSet/product-storage-scale)**. BiologicallyDerived Product Storage Scale.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductStorageScale {
    /** **celsius**

Celsius. Celsius or centigrade temperature scale. */
    Celsius,
    /** **farenheit**

Fahrenheit. Fahrenheit temperature scale. */
    Farenheit,
    /** **kelvin**

Kelvin. Kelvin absolute thermodynamic temperature scale. */
    Kelvin,
}
impl ::core::str::FromStr for BiologicallyDerivedProductStorageScale {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "celsius" => Ok(Self::Celsius),
            "farenheit" => Ok(Self::Farenheit),
            "kelvin" => Ok(Self::Kelvin),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductStorageScale {
    fn as_ref(&self) -> &str {
        match self {
            Self::Celsius => "celsius",
            Self::Farenheit => "farenheit",
            Self::Kelvin => "kelvin",
        }
    }
}
impl ::std::fmt::Debug for BiologicallyDerivedProductStorageScale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductStorageScale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductStorageScale {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductStorageScale {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductStorageScale> for Coding {
    fn from(code: BiologicallyDerivedProductStorageScale) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/product-storage-scale".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BiologicallyDerivedProductStorageScale> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductStorageScale) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[BundleType](http://hl7.org/fhir/ValueSet/bundle-type)**. Indicates the purpose of a bundle - how it is intended to be used.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum BundleType {
    /** **batch**

Batch. The bundle is a set of actions - intended to be processed by a server as a group of independent actions. */
    Batch,
    /** **batch-response**

Batch Response. The bundle is a batch response. Note that as a batch, some responses may indicate failure and others success. */
    BatchResponse,
    /** **collection**

Collection. The bundle is a set of resources collected into a single package for ease of distribution that imposes no processing obligations or behavioral rules beyond persistence. */
    Collection,
    /** **document**

Document. The bundle is a document. The first resource is a Composition. */
    Document,
    /** **history**

History List. The bundle is a list of resources from a history interaction on a server. */
    History,
    /** **message**

Message. The bundle is a message. The first resource is a MessageHeader. */
    Message,
    /** **searchset**

Search Results. The bundle is a list of resources returned as a result of a search/query interaction, operation, or message. */
    Searchset,
    /** **transaction**

Transaction. The bundle is a transaction - intended to be processed by a server as an atomic commit. */
    Transaction,
    /** **transaction-response**

Transaction Response. The bundle is a transaction response. Because the response is a transaction response, the transaction has succeeded, and all responses are error free. */
    TransactionResponse,
}
impl ::core::str::FromStr for BundleType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "batch" => Ok(Self::Batch),
            "batch-response" => Ok(Self::BatchResponse),
            "collection" => Ok(Self::Collection),
            "document" => Ok(Self::Document),
            "history" => Ok(Self::History),
            "message" => Ok(Self::Message),
            "searchset" => Ok(Self::Searchset),
            "transaction" => Ok(Self::Transaction),
            "transaction-response" => Ok(Self::TransactionResponse),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BundleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Batch => "batch",
            Self::BatchResponse => "batch-response",
            Self::Collection => "collection",
            Self::Document => "document",
            Self::History => "history",
            Self::Message => "message",
            Self::Searchset => "searchset",
            Self::Transaction => "transaction",
            Self::TransactionResponse => "transaction-response",
        }
    }
}
impl ::std::fmt::Debug for BundleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for BundleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for BundleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BundleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BundleType> for Coding {
    fn from(code: BundleType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/bundle-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<BundleType> for CodeableConcept {
    fn from(code: BundleType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CapabilityStatementKind](http://hl7.org/fhir/ValueSet/capability-statement-kind)**. How a capability statement is intended to be used.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CapabilityStatementKind {
    /** **capability**

Capability. The CapabilityStatement instance represents the capabilities of a system or piece of software, independent of a particular installation. */
    Capability,
    /** **instance**

Instance. The CapabilityStatement instance represents the present capabilities of a specific system instance.  This is the kind returned by /metadata for a FHIR server end-point. */
    Instance,
    /** **requirements**

Requirements. The CapabilityStatement instance represents a set of requirements for other systems to meet; e.g. as part of an implementation guide or 'request for proposal'. */
    Requirements,
}
impl ::core::str::FromStr for CapabilityStatementKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "capability" => Ok(Self::Capability),
            "instance" => Ok(Self::Instance),
            "requirements" => Ok(Self::Requirements),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CapabilityStatementKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Capability => "capability",
            Self::Instance => "instance",
            Self::Requirements => "requirements",
        }
    }
}
impl ::std::fmt::Debug for CapabilityStatementKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CapabilityStatementKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CapabilityStatementKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CapabilityStatementKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CapabilityStatementKind> for Coding {
    fn from(code: CapabilityStatementKind) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/capability-statement-kind".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CapabilityStatementKind> for CodeableConcept {
    fn from(code: CapabilityStatementKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CarePlanActivityStatus](http://hl7.org/fhir/ValueSet/care-plan-activity-status)**. Codes that reflect the current state of a care plan activity within its overall life cycle.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CarePlanActivityStatus {
    /** **cancelled**

Cancelled. The planned care plan activity has been withdrawn. */
    Cancelled,
    /** **completed**

Completed. Care plan activity has been completed (more or less) as planned. */
    Completed,
    /** **entered-in-error**

Entered in Error. Care plan activity was entered in error and voided. */
    EnteredInError,
    /** **in-progress**

In Progress. Care plan activity has been started but is not yet complete. */
    InProgress,
    /** **not-started**

Not Started. Care plan activity is planned but no action has yet been taken. */
    NotStarted,
    /** **on-hold**

On Hold. Care plan activity was started but has temporarily ceased with an expectation of resumption at a future time. */
    OnHold,
    /** **scheduled**

Scheduled. Appointment or other booking has occurred but activity has not yet begun. */
    Scheduled,
    /** **stopped**

Stopped. The planned care plan activity has been ended prior to completion after the activity was started. */
    Stopped,
    /** **unknown**

Unknown. The current state of the care plan activity is not known.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which one. */
    Unknown,
}
impl ::core::str::FromStr for CarePlanActivityStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "not-started" => Ok(Self::NotStarted),
            "on-hold" => Ok(Self::OnHold),
            "scheduled" => Ok(Self::Scheduled),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CarePlanActivityStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::NotStarted => "not-started",
            Self::OnHold => "on-hold",
            Self::Scheduled => "scheduled",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for CarePlanActivityStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CarePlanActivityStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CarePlanActivityStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CarePlanActivityStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CarePlanActivityStatus> for Coding {
    fn from(code: CarePlanActivityStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/care-plan-activity-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CarePlanActivityStatus> for CodeableConcept {
    fn from(code: CarePlanActivityStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CareTeamStatus](http://hl7.org/fhir/ValueSet/care-team-status)**. Indicates the status of the care team.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CareTeamStatus {
    /** **active**

Active. The care team is currently participating in the coordination and delivery of care. */
    Active,
    /** **entered-in-error**

Entered in Error. The care team should have never existed. */
    EnteredInError,
    /** **inactive**

Inactive. The care team was, but is no longer, participating in the coordination and delivery of care. */
    Inactive,
    /** **proposed**

Proposed. The care team has been drafted and proposed, but not yet participating in the coordination and delivery of patient care. */
    Proposed,
    /** **suspended**

Suspended. The care team is temporarily on hold or suspended and not participating in the coordination and delivery of care. */
    Suspended,
}
impl ::core::str::FromStr for CareTeamStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "proposed" => Ok(Self::Proposed),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CareTeamStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Proposed => "proposed",
            Self::Suspended => "suspended",
        }
    }
}
impl ::std::fmt::Debug for CareTeamStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CareTeamStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CareTeamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CareTeamStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CareTeamStatus> for Coding {
    fn from(code: CareTeamStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/care-team-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CareTeamStatus> for CodeableConcept {
    fn from(code: CareTeamStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CatalogEntryRelationType](http://hl7.org/fhir/ValueSet/relation-type)**. The type of relations between entries.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CatalogEntryRelationType {
    /** **is-replaced-by**

Replaced By. the related entry represents an item that replaces the current retired item. */
    IsReplacedBy,
    /** **triggers**

Triggers. the related entry represents an activity that may be triggered by the current item. */
    Triggers,
}
impl ::core::str::FromStr for CatalogEntryRelationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "is-replaced-by" => Ok(Self::IsReplacedBy),
            "triggers" => Ok(Self::Triggers),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CatalogEntryRelationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::IsReplacedBy => "is-replaced-by",
            Self::Triggers => "triggers",
        }
    }
}
impl ::std::fmt::Debug for CatalogEntryRelationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CatalogEntryRelationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CatalogEntryRelationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CatalogEntryRelationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CatalogEntryRelationType> for Coding {
    fn from(code: CatalogEntryRelationType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/relation-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CatalogEntryRelationType> for CodeableConcept {
    fn from(code: CatalogEntryRelationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CatalogType](http://hl7.org/fhir/catalogType)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum CatalogType {
    /** **device**

Device Catalog. Device Catalog. */
    Device,
    /** **medication**

Medication Catalog. Medication Catalog. */
    Medication,
    /** **protocol**

Protocol List. Protocol List. */
    Protocol,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CatalogType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "device" => Ok(Self::Device),
            "medication" => Ok(Self::Medication),
            "protocol" => Ok(Self::Protocol),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CatalogType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "device",
            Self::Medication => "medication",
            Self::Protocol => "protocol",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for CatalogType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CatalogType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CatalogType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CatalogType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CatalogType> for Coding {
    fn from(code: CatalogType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/catalogType".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CatalogType> for CodeableConcept {
    fn from(code: CatalogType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CharacteristicCombination](http://hl7.org/fhir/ValueSet/characteristic-combination)**. Logical grouping of characteristics.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CharacteristicCombination {
    /** **intersection**

intersection. Combine characteristics with AND. */
    Intersection,
    /** **union**

union. Combine characteristics with OR. */
    Union,
}
impl ::core::str::FromStr for CharacteristicCombination {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "intersection" => Ok(Self::Intersection),
            "union" => Ok(Self::Union),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CharacteristicCombination {
    fn as_ref(&self) -> &str {
        match self {
            Self::Intersection => "intersection",
            Self::Union => "union",
        }
    }
}
impl ::std::fmt::Debug for CharacteristicCombination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CharacteristicCombination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CharacteristicCombination {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CharacteristicCombination {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CharacteristicCombination> for Coding {
    fn from(code: CharacteristicCombination) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/characteristic-combination".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CharacteristicCombination> for CodeableConcept {
    fn from(code: CharacteristicCombination) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CharacteristicMethod](http://hl7.org/fhir/ValueSet/characteristic-method)**. The method used to determine the characteristic(s) of the variable.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CharacteristicMethod {
    /** **Default**

Default. Default. */
    Default,
}
impl ::core::str::FromStr for CharacteristicMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Default" => Ok(Self::Default),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CharacteristicMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Default => "Default",
        }
    }
}
impl ::std::fmt::Debug for CharacteristicMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CharacteristicMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CharacteristicMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CharacteristicMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CharacteristicMethod> for Coding {
    fn from(code: CharacteristicMethod) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/characteristic-method".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CharacteristicMethod> for CodeableConcept {
    fn from(code: CharacteristicMethod) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ChargeItemCode](http://hl7.org/fhir/ValueSet/chargeitem-billingcodes)**. Example set of codes that can be used for billing purposes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ChargeItemCode {
    /** **1100**

Unvorhergesehene Inanspruchnahme. From German EBM billing system:
Unvorhergesehene Inanspruchnahme des Vertragsarztes durch einen Patienten;zwischen 19:00 und 22:00 Uhr;an Samstagen, Sonntagen und gesetzlichen Feiertagen, am 24.12. und 31.12. zwischen 07:00 und 19:00 Uhr. */
    N1100,
    /** **1210**

Notfallpauschale. From German EBM billing system:
Notfallpauschale im organisierten Not(-fall)dienst und für nicht an der vertragsärztlichen Versorgung teilnehmende Ärzte, Institute und Krankenhäuser bei Inanspruchnahme;zwischen 07:00 und 19:00 Uhr. */
    N1210,
    /** **1320**

Grundpauschale. From German EBM billing system:
Grundpauschale für Ärzte, Institute und Krankenhäuser, die zur Erbringung von Leistungen innerhalb mindestens eines der Fachgebiete Anästhesiologie, Frauenheilkunde und Geburtshilfe, Haut- und Geschlechtskrankheiten, Mund-, Kiefer- und Gesichtschirurgie und Humangenetik ermächtigt sind. */
    N1320,
}
impl ::core::str::FromStr for ChargeItemCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1100" => Ok(Self::N1100),
            "1210" => Ok(Self::N1210),
            "1320" => Ok(Self::N1320),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ChargeItemCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1100 => "1100",
            Self::N1210 => "1210",
            Self::N1320 => "1320",
        }
    }
}
impl ::std::fmt::Debug for ChargeItemCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ChargeItemCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ChargeItemCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ChargeItemCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ChargeItemCode> for Coding {
    fn from(code: ChargeItemCode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/chargeitem-billingcodes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ChargeItemCode> for CodeableConcept {
    fn from(code: ChargeItemCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ChargeItemStatus](http://hl7.org/fhir/ValueSet/chargeitem-status)**. Codes identifying the lifecycle stage of a ChargeItem.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ChargeItemStatus {
    /** **aborted**

Aborted. The processing of the charge was aborted. */
    Aborted,
    /** **billable**

Billable. The charge item is ready for billing. */
    Billable,
    /** **billed**

Billed. The charge item has been billed (e.g. a billing engine has generated financial transactions by applying the associated ruled for the charge item to the context of the Encounter, and placed them into Claims/Invoices. */
    Billed,
    /** **entered-in-error**

Entered in Error. The charge item has been entered in error and should not be processed for billing. */
    EnteredInError,
    /** **not-billable**

Not billable. The charge item has been determined to be not billable (e.g. due to rules associated with the billing code). */
    NotBillable,
    /** **planned**

Planned. The charge item has been entered, but the charged service is not  yet complete, so it shall not be billed yet but might be used in the context of pre-authorization. */
    Planned,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this charge item  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for ChargeItemStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aborted" => Ok(Self::Aborted),
            "billable" => Ok(Self::Billable),
            "billed" => Ok(Self::Billed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "not-billable" => Ok(Self::NotBillable),
            "planned" => Ok(Self::Planned),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ChargeItemStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aborted => "aborted",
            Self::Billable => "billable",
            Self::Billed => "billed",
            Self::EnteredInError => "entered-in-error",
            Self::NotBillable => "not-billable",
            Self::Planned => "planned",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for ChargeItemStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ChargeItemStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ChargeItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ChargeItemStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ChargeItemStatus> for Coding {
    fn from(code: ChargeItemStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/chargeitem-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ChargeItemStatus> for CodeableConcept {
    fn from(code: ChargeItemStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CitationArtifactClassifier](http://hl7.org/fhir/ValueSet/citation-artifact-classifier)**. Citation artifact classifier\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CitationArtifactClassifier {
    /** **68059040**

Video-Audio Media. Used with articles which include video files or clips, or for articles which are entirely video. */
    N68059040,
    /** **D000076942**

Preprint. Scientific manuscript made available prior to PEER REVIEW. */
    D000076942,
    /** **D001877**

Book. Non-periodical written or printed works consisting of sheets of pages fastened or bound together within covers. */
    D001877,
    /** **D016420**

Comment. Comment */
    D016420,
    /** **D016422**

Letter. Letter */
    D016422,
    /** **D016425**

Published Erratum. Published Erratum */
    D016425,
    /** **D016428**

Journal Article. Journal Article */
    D016428,
    /** **D019991**

Database. A structured file of information or a set of logically related data stored and retrieved using computer-based means. */
    D019991,
    /** **D064886**

Dataset. Works consisting of organized collections of data, which have been stored permanently in a formalized manner suitable for communication, interpretation, or processing. */
    D064886,
    /** **Electronic**

Electronic. the journal is published in electronic format only */
    Electronic,
    /** **Electronic-Print**

Electronic-Print. the journal is published first in electronic format followed by print (this value is currently used for just one journal, Nucleic Acids Research) */
    ElectronicPrint,
    /** **Electronic-eCollection**

Electronic-eCollection. used for electronic-only journals that publish individual articles first and then later collect them into an "issue" date that is typically called an eCollection. */
    ElectronicECollection,
    /** **Print**

Print. the journal is published in print format only */
    Print,
    /** **Print-Electronic**

Print Electronic. the journal is published in both print and electronic format */
    PrintElectronic,
    /** **audio**

Audio file. The article cited is an audio file. */
    Audio,
    /** **common-share**

Common Share. Citation Resource containing value added data that is openly shared */
    CommonShare,
    /** **executable-app**

Executable app. Executable app */
    ExecutableApp,
    /** **fhir-resource**

FHIR Resource. The article cited is a FHIR resource. */
    FhirResource,
    /** **image**

Image file. The article cited is an audio file. */
    Image,
    /** **machine-code**

Machine code. The article cited is machine code. */
    MachineCode,
    /** **medline-base**

Medline Base. Citation Resource containing only data from Medline */
    MedlineBase,
    /** **project-specific**

Project Specific. Citation Resource containing value added data specific to a project */
    ProjectSpecific,
    /** **protocol**

Protocol. The article cited is the protocol of an activity and not the results or findings. */
    Protocol,
    /** **webpage**

Webpage. Webpage */
    Webpage,
}
impl ::core::str::FromStr for CitationArtifactClassifier {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "68059040" => Ok(Self::N68059040),
            "D000076942" => Ok(Self::D000076942),
            "D001877" => Ok(Self::D001877),
            "D016420" => Ok(Self::D016420),
            "D016422" => Ok(Self::D016422),
            "D016425" => Ok(Self::D016425),
            "D016428" => Ok(Self::D016428),
            "D019991" => Ok(Self::D019991),
            "D064886" => Ok(Self::D064886),
            "Electronic" => Ok(Self::Electronic),
            "Electronic-Print" => Ok(Self::ElectronicPrint),
            "Electronic-eCollection" => Ok(Self::ElectronicECollection),
            "Print" => Ok(Self::Print),
            "Print-Electronic" => Ok(Self::PrintElectronic),
            "audio" => Ok(Self::Audio),
            "common-share" => Ok(Self::CommonShare),
            "executable-app" => Ok(Self::ExecutableApp),
            "fhir-resource" => Ok(Self::FhirResource),
            "image" => Ok(Self::Image),
            "machine-code" => Ok(Self::MachineCode),
            "medline-base" => Ok(Self::MedlineBase),
            "project-specific" => Ok(Self::ProjectSpecific),
            "protocol" => Ok(Self::Protocol),
            "webpage" => Ok(Self::Webpage),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationArtifactClassifier {
    fn as_ref(&self) -> &str {
        match self {
            Self::N68059040 => "68059040",
            Self::D000076942 => "D000076942",
            Self::D001877 => "D001877",
            Self::D016420 => "D016420",
            Self::D016422 => "D016422",
            Self::D016425 => "D016425",
            Self::D016428 => "D016428",
            Self::D019991 => "D019991",
            Self::D064886 => "D064886",
            Self::Electronic => "Electronic",
            Self::ElectronicPrint => "Electronic-Print",
            Self::ElectronicECollection => "Electronic-eCollection",
            Self::Print => "Print",
            Self::PrintElectronic => "Print-Electronic",
            Self::Audio => "audio",
            Self::CommonShare => "common-share",
            Self::ExecutableApp => "executable-app",
            Self::FhirResource => "fhir-resource",
            Self::Image => "image",
            Self::MachineCode => "machine-code",
            Self::MedlineBase => "medline-base",
            Self::ProjectSpecific => "project-specific",
            Self::Protocol => "protocol",
            Self::Webpage => "webpage",
        }
    }
}
impl ::std::fmt::Debug for CitationArtifactClassifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CitationArtifactClassifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CitationArtifactClassifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationArtifactClassifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitationArtifactClassifier> for Coding {
    fn from(code: CitationArtifactClassifier) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/citation-artifact-classifier".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CitationArtifactClassifier> for CodeableConcept {
    fn from(code: CitationArtifactClassifier) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CitationClassificationType](http://hl7.org/fhir/ValueSet/citation-classification-type)**. Citation classification type\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CitationClassificationType {
    /** **citation-source**

Citation Source. Citation repository where this citation was created or copied from */
    CitationSource,
    /** **fevir-platform-use**

FEvIR Platform Use. Used for Citation sharing on the Fast Evidence Interoperability Resources (FEvIR) Platform */
    FevirPlatformUse,
    /** **medline-owner**

MEDLINE Citation Owner. The party responsible for creating and validating the MEDLINE citation */
    MedlineOwner,
}
impl ::core::str::FromStr for CitationClassificationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "citation-source" => Ok(Self::CitationSource),
            "fevir-platform-use" => Ok(Self::FevirPlatformUse),
            "medline-owner" => Ok(Self::MedlineOwner),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationClassificationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::CitationSource => "citation-source",
            Self::FevirPlatformUse => "fevir-platform-use",
            Self::MedlineOwner => "medline-owner",
        }
    }
}
impl ::std::fmt::Debug for CitationClassificationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CitationClassificationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CitationClassificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationClassificationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitationClassificationType> for Coding {
    fn from(code: CitationClassificationType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/citation-classification-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CitationClassificationType> for CodeableConcept {
    fn from(code: CitationClassificationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CitationStatusType](http://hl7.org/fhir/ValueSet/citation-status-type)**. Citation status type\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CitationStatusType {
    /** **medline-completed**

Medline Citation Status of Completed. Medline Citation Status of Completed */
    MedlineCompleted,
    /** **medline-in-data-review**

Medline Citation Status of In-Data-Review. Medline Citation Status of In-Data-Review */
    MedlineInDataReview,
    /** **medline-in-process**

Medline Citation Status of In-Process. Medline Citation Status of In-Process */
    MedlineInProcess,
    /** **medline-medline**

Medline Citation Status of MEDLINE. Medline Citation Status of MEDLINE */
    MedlineMedline,
    /** **medline-oldmedline**

Medline Citation Status of OLDMEDLINE. Medline Citation Status of OLDMEDLINE */
    MedlineOldmedline,
    /** **medline-publisher**

Medline Citation Status of Publisher. Medline Citation Status of Publisher */
    MedlinePublisher,
    /** **medline-pubmed-not-medline**

Medline Citation Status of PubMed-not-MEDLINE. Medline Citation Status of PubMed-not-MEDLINE */
    MedlinePubmedNotMedline,
    /** **pubmed-publication-status-aheadofprint**

PubMed PublicationStatus of aheadofprint. electronically published, but followed by print */
    PubmedPublicationStatusAheadofprint,
    /** **pubmed-publication-status-epublish**

PubMed PublicationStatus of epublish. electronically published only, never published in print */
    PubmedPublicationStatusEpublish,
    /** **pubmed-publication-status-ppublish**

PubMed PublicationStatus of ppublish. published in print */
    PubmedPublicationStatusPpublish,
    /** **pubmed-pubstatus-accepted**

PubMed Pubstatus of Accepted. PubMed Pubstatus of Accepted */
    PubmedPubstatusAccepted,
    /** **pubmed-pubstatus-aheadofprint**

PubMed Pubstatus of aheadofprint. PubMed Pubstatus of aheadofprint */
    PubmedPubstatusAheadofprint,
    /** **pubmed-pubstatus-ecollection**

PubMed Pubstatus of Ecollection. PubMed Pubstatus of Ecollection */
    PubmedPubstatusEcollection,
    /** **pubmed-pubstatus-entrez**

PubMed Pubstatus of Entrez. PubMed Pubstatus of Entrez */
    PubmedPubstatusEntrez,
    /** **pubmed-pubstatus-epublish**

PubMed Pubstatus of Epublish. PubMed Pubstatus of Epublish */
    PubmedPubstatusEpublish,
    /** **pubmed-pubstatus-medline**

PubMed Pubstatus of Medline. PubMed Pubstatus of Medline */
    PubmedPubstatusMedline,
    /** **pubmed-pubstatus-medliner**

PubMed Pubstatus of Medliner. PubMed Pubstatus of Medliner */
    PubmedPubstatusMedliner,
    /** **pubmed-pubstatus-pmc**

PubMed Pubstatus of PMC. PubMed Pubstatus of PMC */
    PubmedPubstatusPmc,
    /** **pubmed-pubstatus-pmc-release**

PubMed Pubstatus of PMC release. PubMed Pubstatus of PMC release */
    PubmedPubstatusPmcRelease,
    /** **pubmed-pubstatus-pmcr**

PubMed Pubstatus of PMCr. PubMed Pubstatus of PMCr */
    PubmedPubstatusPmcr,
    /** **pubmed-pubstatus-ppublish**

PubMed Pubstatus of Ppublish. PubMed Pubstatus of Ppublish */
    PubmedPubstatusPpublish,
    /** **pubmed-pubstatus-premedline**

PubMed Pubstatus of Premedline. PubMed Pubstatus of Premedline */
    PubmedPubstatusPremedline,
    /** **pubmed-pubstatus-pubmed**

PubMed Pubstatus of PubMed. PubMed Pubstatus of PubMed */
    PubmedPubstatusPubmed,
    /** **pubmed-pubstatus-pubmedr**

PubMed Pubstatus of PubMedr. PubMed Pubstatus of PubMedr */
    PubmedPubstatusPubmedr,
    /** **pubmed-pubstatus-received**

PubMed Pubstatus of Received. PubMed Pubstatus of Received */
    PubmedPubstatusReceived,
    /** **pubmed-pubstatus-retracted**

PubMed Pubstatus of Retracted. PubMed Pubstatus of Retracted */
    PubmedPubstatusRetracted,
    /** **pubmed-pubstatus-revised**

PubMed Pubstatus of Revised. PubMed Pubstatus of Revised */
    PubmedPubstatusRevised,
}
impl ::core::str::FromStr for CitationStatusType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "medline-completed" => Ok(Self::MedlineCompleted),
            "medline-in-data-review" => Ok(Self::MedlineInDataReview),
            "medline-in-process" => Ok(Self::MedlineInProcess),
            "medline-medline" => Ok(Self::MedlineMedline),
            "medline-oldmedline" => Ok(Self::MedlineOldmedline),
            "medline-publisher" => Ok(Self::MedlinePublisher),
            "medline-pubmed-not-medline" => Ok(Self::MedlinePubmedNotMedline),
            "pubmed-publication-status-aheadofprint" => {
                Ok(Self::PubmedPublicationStatusAheadofprint)
            }
            "pubmed-publication-status-epublish" => {
                Ok(Self::PubmedPublicationStatusEpublish)
            }
            "pubmed-publication-status-ppublish" => {
                Ok(Self::PubmedPublicationStatusPpublish)
            }
            "pubmed-pubstatus-accepted" => Ok(Self::PubmedPubstatusAccepted),
            "pubmed-pubstatus-aheadofprint" => Ok(Self::PubmedPubstatusAheadofprint),
            "pubmed-pubstatus-ecollection" => Ok(Self::PubmedPubstatusEcollection),
            "pubmed-pubstatus-entrez" => Ok(Self::PubmedPubstatusEntrez),
            "pubmed-pubstatus-epublish" => Ok(Self::PubmedPubstatusEpublish),
            "pubmed-pubstatus-medline" => Ok(Self::PubmedPubstatusMedline),
            "pubmed-pubstatus-medliner" => Ok(Self::PubmedPubstatusMedliner),
            "pubmed-pubstatus-pmc" => Ok(Self::PubmedPubstatusPmc),
            "pubmed-pubstatus-pmc-release" => Ok(Self::PubmedPubstatusPmcRelease),
            "pubmed-pubstatus-pmcr" => Ok(Self::PubmedPubstatusPmcr),
            "pubmed-pubstatus-ppublish" => Ok(Self::PubmedPubstatusPpublish),
            "pubmed-pubstatus-premedline" => Ok(Self::PubmedPubstatusPremedline),
            "pubmed-pubstatus-pubmed" => Ok(Self::PubmedPubstatusPubmed),
            "pubmed-pubstatus-pubmedr" => Ok(Self::PubmedPubstatusPubmedr),
            "pubmed-pubstatus-received" => Ok(Self::PubmedPubstatusReceived),
            "pubmed-pubstatus-retracted" => Ok(Self::PubmedPubstatusRetracted),
            "pubmed-pubstatus-revised" => Ok(Self::PubmedPubstatusRevised),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationStatusType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MedlineCompleted => "medline-completed",
            Self::MedlineInDataReview => "medline-in-data-review",
            Self::MedlineInProcess => "medline-in-process",
            Self::MedlineMedline => "medline-medline",
            Self::MedlineOldmedline => "medline-oldmedline",
            Self::MedlinePublisher => "medline-publisher",
            Self::MedlinePubmedNotMedline => "medline-pubmed-not-medline",
            Self::PubmedPublicationStatusAheadofprint => {
                "pubmed-publication-status-aheadofprint"
            }
            Self::PubmedPublicationStatusEpublish => "pubmed-publication-status-epublish",
            Self::PubmedPublicationStatusPpublish => "pubmed-publication-status-ppublish",
            Self::PubmedPubstatusAccepted => "pubmed-pubstatus-accepted",
            Self::PubmedPubstatusAheadofprint => "pubmed-pubstatus-aheadofprint",
            Self::PubmedPubstatusEcollection => "pubmed-pubstatus-ecollection",
            Self::PubmedPubstatusEntrez => "pubmed-pubstatus-entrez",
            Self::PubmedPubstatusEpublish => "pubmed-pubstatus-epublish",
            Self::PubmedPubstatusMedline => "pubmed-pubstatus-medline",
            Self::PubmedPubstatusMedliner => "pubmed-pubstatus-medliner",
            Self::PubmedPubstatusPmc => "pubmed-pubstatus-pmc",
            Self::PubmedPubstatusPmcRelease => "pubmed-pubstatus-pmc-release",
            Self::PubmedPubstatusPmcr => "pubmed-pubstatus-pmcr",
            Self::PubmedPubstatusPpublish => "pubmed-pubstatus-ppublish",
            Self::PubmedPubstatusPremedline => "pubmed-pubstatus-premedline",
            Self::PubmedPubstatusPubmed => "pubmed-pubstatus-pubmed",
            Self::PubmedPubstatusPubmedr => "pubmed-pubstatus-pubmedr",
            Self::PubmedPubstatusReceived => "pubmed-pubstatus-received",
            Self::PubmedPubstatusRetracted => "pubmed-pubstatus-retracted",
            Self::PubmedPubstatusRevised => "pubmed-pubstatus-revised",
        }
    }
}
impl ::std::fmt::Debug for CitationStatusType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CitationStatusType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CitationStatusType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationStatusType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitationStatusType> for Coding {
    fn from(code: CitationStatusType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/citation-status-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CitationStatusType> for CodeableConcept {
    fn from(code: CitationStatusType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CitationSummaryStyle](http://hl7.org/fhir/ValueSet/citation-summary-style)**. The format for display of the citation.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CitationSummaryStyle {
    /** **acs**

American Chemical Society. Chemistry. */
    Acs,
    /** **ama11**

American Medical Association 11th edition. Medicine. */
    Ama11,
    /** **apa6**

American Psychological Association 6th edition. APA 6th edition used by Education, Psychology and Sciences. */
    Apa6,
    /** **apa7**

American Psychological Association 7th edition. APA 7th edition (October 2019) used by Education, Psychology and Sciences. */
    Apa7,
    /** **asa6**

American Sociological Association 6th edition. Sociology. */
    Asa6,
    /** **chicago-a-17**

Chicago Style Version 17 Author Date. Used by Business, History and the Fine Arts. */
    ChicagoA17,
    /** **chicago-b-17**

Chicago Style Version 17 Full note. Used by Business, History and the Fine Arts. */
    ChicagoB17,
    /** **cochrane**

Cochrane Style. Used by Cochrane reviews, example: Huang, M, Tang T, Pang, P, Li, M, Ma R, Lu, J, et al. Treating COVID-19 with Chloroquine. J Mol Cell Biol 2020; 12(4):322–5. */
    Cochrane,
    /** **comppub**

Computable Publishing. Citation style to report human-readable and/or machine-readable access paths, example: Alper BS, Dehnbostel J, Shahin K. 14-day mortality remdesivir vs placebo meta-analysis (ACTT-1, Wang et al, WHO SOLIDARITY).  Fast Evidence Interoperability Resources (FEvIR) Platform, entry 55, version 4. Created 2020 Dec 17. Revised 2020 Dec 21. Accessed 2021 Mar 13. Computable resource at: https://fevir.net/resources/Evidence/55. */
    Comppub,
    /** **elsevier-harvard**

Elsevier-Harvard Style. Biology ecology. */
    ElsevierHarvard,
    /** **ieee**

Institute of Electrical and Electronics Engineers. IT, Engineering. */
    Ieee,
    /** **mla8**

Modern Language Association 8th edition. MLA 8th edition used by the Humanities. */
    Mla8,
    /** **nature**

Nature Referencing style. Biology. */
    Nature,
    /** **vancouver**

Vancouver style. Citation style used by International Committee of Medical Journal Editors and maintained by US National Library of Medicine. */
    Vancouver,
}
impl ::core::str::FromStr for CitationSummaryStyle {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acs" => Ok(Self::Acs),
            "ama11" => Ok(Self::Ama11),
            "apa6" => Ok(Self::Apa6),
            "apa7" => Ok(Self::Apa7),
            "asa6" => Ok(Self::Asa6),
            "chicago-a-17" => Ok(Self::ChicagoA17),
            "chicago-b-17" => Ok(Self::ChicagoB17),
            "cochrane" => Ok(Self::Cochrane),
            "comppub" => Ok(Self::Comppub),
            "elsevier-harvard" => Ok(Self::ElsevierHarvard),
            "ieee" => Ok(Self::Ieee),
            "mla8" => Ok(Self::Mla8),
            "nature" => Ok(Self::Nature),
            "vancouver" => Ok(Self::Vancouver),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationSummaryStyle {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acs => "acs",
            Self::Ama11 => "ama11",
            Self::Apa6 => "apa6",
            Self::Apa7 => "apa7",
            Self::Asa6 => "asa6",
            Self::ChicagoA17 => "chicago-a-17",
            Self::ChicagoB17 => "chicago-b-17",
            Self::Cochrane => "cochrane",
            Self::Comppub => "comppub",
            Self::ElsevierHarvard => "elsevier-harvard",
            Self::Ieee => "ieee",
            Self::Mla8 => "mla8",
            Self::Nature => "nature",
            Self::Vancouver => "vancouver",
        }
    }
}
impl ::std::fmt::Debug for CitationSummaryStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CitationSummaryStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CitationSummaryStyle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationSummaryStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitationSummaryStyle> for Coding {
    fn from(code: CitationSummaryStyle) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/citation-summary-style".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CitationSummaryStyle> for CodeableConcept {
    fn from(code: CitationSummaryStyle) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CitedArtifactAbstractType](http://hl7.org/fhir/ValueSet/cited-artifact-abstract-type)**. Used to express the reason and specific aspect for the variant abstract, such as language and specific language\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CitedArtifactAbstractType {
    /** **autotranslated**

Different language derived from autotranslation. Machine translated form of abstract in a different language, language element codes the language into which it was translated by machine */
    Autotranslated,
    /** **different-publisher**

Different publisher for abstract. Abstract produced by a different publisher than the cited artifact */
    DifferentPublisher,
    /** **duplicate-pmid**

Different text in additional Medline entry. Alternative form of abstract in two or more Medline entries */
    DuplicatePmid,
    /** **earlier-abstract**

Different text in an earlier version. Alternative form of abstract in an earlier version such as epub ahead of print */
    EarlierAbstract,
    /** **language**

Different language. Additional form of abstract in a different language */
    Language,
    /** **long-abstract**

Long abstract. Long version of the abstract, for use when abstracts are provided in different sizes or lengths */
    LongAbstract,
    /** **plain-language**

Plain language. Additional form of abstract written for the general public */
    PlainLanguage,
    /** **primary-human-use**

Primary human use. Human-friendly main or official abstract */
    PrimaryHumanUse,
    /** **primary-machine-use**

Primary machine use. Machine-friendly main or official abstract */
    PrimaryMachineUse,
    /** **short-abstract**

Short abstract. Brief abstract, for use when abstracts are provided in different sizes or lengths */
    ShortAbstract,
    /** **truncated**

Truncated. Truncated abstract */
    Truncated,
}
impl ::core::str::FromStr for CitedArtifactAbstractType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "autotranslated" => Ok(Self::Autotranslated),
            "different-publisher" => Ok(Self::DifferentPublisher),
            "duplicate-pmid" => Ok(Self::DuplicatePmid),
            "earlier-abstract" => Ok(Self::EarlierAbstract),
            "language" => Ok(Self::Language),
            "long-abstract" => Ok(Self::LongAbstract),
            "plain-language" => Ok(Self::PlainLanguage),
            "primary-human-use" => Ok(Self::PrimaryHumanUse),
            "primary-machine-use" => Ok(Self::PrimaryMachineUse),
            "short-abstract" => Ok(Self::ShortAbstract),
            "truncated" => Ok(Self::Truncated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactAbstractType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Autotranslated => "autotranslated",
            Self::DifferentPublisher => "different-publisher",
            Self::DuplicatePmid => "duplicate-pmid",
            Self::EarlierAbstract => "earlier-abstract",
            Self::Language => "language",
            Self::LongAbstract => "long-abstract",
            Self::PlainLanguage => "plain-language",
            Self::PrimaryHumanUse => "primary-human-use",
            Self::PrimaryMachineUse => "primary-machine-use",
            Self::ShortAbstract => "short-abstract",
            Self::Truncated => "truncated",
        }
    }
}
impl ::std::fmt::Debug for CitedArtifactAbstractType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CitedArtifactAbstractType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CitedArtifactAbstractType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactAbstractType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedArtifactAbstractType> for Coding {
    fn from(code: CitedArtifactAbstractType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/cited-artifact-abstract-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CitedArtifactAbstractType> for CodeableConcept {
    fn from(code: CitedArtifactAbstractType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CitedArtifactClassificationType](http://hl7.org/fhir/ValueSet/cited-artifact-classification-type)**. Cited Artifact Classification Type\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CitedArtifactClassificationType {
    /** **chemical**

Chemical. Chemical */
    Chemical,
    /** **citation-subset**

Citation subset. Citation subset */
    CitationSubset,
    /** **coverage**

Coverage. The spatial or temporal topic of the resource, spatial applicability of the resource, or jurisdiction under which the resource is relevant */
    Coverage,
    /** **keyword**

Keyword. Keyword */
    Keyword,
    /** **knowledge-artifact-type**

Knowledge Artifact Type. Knowledge Artifact Type */
    KnowledgeArtifactType,
    /** **mesh-heading**

MeSH heading. MeSH heading */
    MeshHeading,
    /** **publication-type**

Publication type. Publication type */
    PublicationType,
    /** **publishing-model**

Publishing Model. Used for PubModel attribute in Medline */
    PublishingModel,
    /** **supplemental-mesh-disease**

Supplemental MeSH for Disease. Supplemental MeSH for Disease */
    SupplementalMeshDisease,
    /** **supplemental-mesh-organism**

Supplemental MeSH for Organism. Supplemental MeSH for Organism */
    SupplementalMeshOrganism,
    /** **supplemental-mesh-protocol**

Supplemental MeSH for Protocol. Supplemental MeSH for Protocol */
    SupplementalMeshProtocol,
}
impl ::core::str::FromStr for CitedArtifactClassificationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "chemical" => Ok(Self::Chemical),
            "citation-subset" => Ok(Self::CitationSubset),
            "coverage" => Ok(Self::Coverage),
            "keyword" => Ok(Self::Keyword),
            "knowledge-artifact-type" => Ok(Self::KnowledgeArtifactType),
            "mesh-heading" => Ok(Self::MeshHeading),
            "publication-type" => Ok(Self::PublicationType),
            "publishing-model" => Ok(Self::PublishingModel),
            "supplemental-mesh-disease" => Ok(Self::SupplementalMeshDisease),
            "supplemental-mesh-organism" => Ok(Self::SupplementalMeshOrganism),
            "supplemental-mesh-protocol" => Ok(Self::SupplementalMeshProtocol),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactClassificationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Chemical => "chemical",
            Self::CitationSubset => "citation-subset",
            Self::Coverage => "coverage",
            Self::Keyword => "keyword",
            Self::KnowledgeArtifactType => "knowledge-artifact-type",
            Self::MeshHeading => "mesh-heading",
            Self::PublicationType => "publication-type",
            Self::PublishingModel => "publishing-model",
            Self::SupplementalMeshDisease => "supplemental-mesh-disease",
            Self::SupplementalMeshOrganism => "supplemental-mesh-organism",
            Self::SupplementalMeshProtocol => "supplemental-mesh-protocol",
        }
    }
}
impl ::std::fmt::Debug for CitedArtifactClassificationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CitedArtifactClassificationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CitedArtifactClassificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactClassificationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedArtifactClassificationType> for Coding {
    fn from(code: CitedArtifactClassificationType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/cited-artifact-classification-type"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CitedArtifactClassificationType> for CodeableConcept {
    fn from(code: CitedArtifactClassificationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CitedArtifactPartType](http://hl7.org/fhir/ValueSet/cited-artifact-part-type)**. To describe the reason for the variant citation, such as version number or subpart specification.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CitedArtifactPartType {
    /** **article-set**

Part of an article set. Used to distinguish an individual article within an article set where the article set is a base citation. */
    ArticleSet,
    /** **figures**

figures. Denotes specific figure or figures of an article or artifact. */
    Figures,
    /** **lines**

lines. Denotes specific line or lines of an article or artifact. */
    Lines,
    /** **pages**

pages. Denotes specific page or pages of an article or artifact. */
    Pages,
    /** **paragraphs**

paragraphs. Denotes specific paragraph or paragraphs of an article or artifact. */
    Paragraphs,
    /** **sections**

sections. Denotes specific section or sections of an article or artifact. */
    Sections,
    /** **supplement**

Supplement or Appendix. Used to denote a supplementary file, appendix, or additional part that is not a subpart of the primary article. */
    Supplement,
    /** **supplement-subpart**

Supplement or Appendix Subpart. Used to denote a subpart within a supplementary file or appendix. */
    SupplementSubpart,
    /** **tables**

tables. Denotes specific table or tables of an article or artifact. */
    Tables,
}
impl ::core::str::FromStr for CitedArtifactPartType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "article-set" => Ok(Self::ArticleSet),
            "figures" => Ok(Self::Figures),
            "lines" => Ok(Self::Lines),
            "pages" => Ok(Self::Pages),
            "paragraphs" => Ok(Self::Paragraphs),
            "sections" => Ok(Self::Sections),
            "supplement" => Ok(Self::Supplement),
            "supplement-subpart" => Ok(Self::SupplementSubpart),
            "tables" => Ok(Self::Tables),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactPartType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ArticleSet => "article-set",
            Self::Figures => "figures",
            Self::Lines => "lines",
            Self::Pages => "pages",
            Self::Paragraphs => "paragraphs",
            Self::Sections => "sections",
            Self::Supplement => "supplement",
            Self::SupplementSubpart => "supplement-subpart",
            Self::Tables => "tables",
        }
    }
}
impl ::std::fmt::Debug for CitedArtifactPartType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CitedArtifactPartType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CitedArtifactPartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactPartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedArtifactPartType> for Coding {
    fn from(code: CitedArtifactPartType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/cited-artifact-part-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CitedArtifactPartType> for CodeableConcept {
    fn from(code: CitedArtifactPartType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CitedArtifactStatusType](http://hl7.org/fhir/ValueSet/cited-artifact-status-type)**. Cited Artifact Status Type\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CitedArtifactStatusType {
    /** **accepted**

Accepted. The content that was not published yet has been approved for publication by the publisher and/or editor. */
    Accepted,
    /** **active**

Active. The content is considered complete for its current state by the content creator. */
    Active,
    /** **approved**

Approved. The content has been approved for a state transition, with the focus of approval described in the text associated with this coding. */
    Approved,
    /** **archived**

Archived. The content is retired or considered no longer current but still available as part of the public record. */
    Archived,
    /** **created**

Created. The content was originally constructed or composed. */
    Created,
    /** **draft**

Draft. The content is considered unfinished or incomplete and not representative of the current state desired by the content creator. */
    Draft,
    /** **post-review-pre-published**

Post review pre published. The content is in a state between the review(s) being completed and being published. */
    PostReviewPrePublished,
    /** **pre-review**

Pre review. The content is awaiting assignment and delivery to reviewer(s). */
    PreReview,
    /** **published-early-form**

Published early form. The content is published but future changes to the published version are expected. */
    PublishedEarlyForm,
    /** **published-final-form**

Published final form. The content is published and further changes to the content are not expected. */
    PublishedFinalForm,
    /** **rejected**

Rejected. The content that was not published has been removed from consideration for publishing by a publisher or editor. */
    Rejected,
    /** **retracted**

Retracted. The content that was published is removed from publication and should no longer be considered part of the public record. */
    Retracted,
    /** **submitted**

Submitted. The content was sent to the publisher for consideration of publication. */
    Submitted,
    /** **under-review**

Under review. The content is in a state of being reviewed. */
    UnderReview,
    /** **withdrawn**

Withdrawn. The content that was not published has been removed from consideration for publishing by the submitter. */
    Withdrawn,
}
impl ::core::str::FromStr for CitedArtifactStatusType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "active" => Ok(Self::Active),
            "approved" => Ok(Self::Approved),
            "archived" => Ok(Self::Archived),
            "created" => Ok(Self::Created),
            "draft" => Ok(Self::Draft),
            "post-review-pre-published" => Ok(Self::PostReviewPrePublished),
            "pre-review" => Ok(Self::PreReview),
            "published-early-form" => Ok(Self::PublishedEarlyForm),
            "published-final-form" => Ok(Self::PublishedFinalForm),
            "rejected" => Ok(Self::Rejected),
            "retracted" => Ok(Self::Retracted),
            "submitted" => Ok(Self::Submitted),
            "under-review" => Ok(Self::UnderReview),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactStatusType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Active => "active",
            Self::Approved => "approved",
            Self::Archived => "archived",
            Self::Created => "created",
            Self::Draft => "draft",
            Self::PostReviewPrePublished => "post-review-pre-published",
            Self::PreReview => "pre-review",
            Self::PublishedEarlyForm => "published-early-form",
            Self::PublishedFinalForm => "published-final-form",
            Self::Rejected => "rejected",
            Self::Retracted => "retracted",
            Self::Submitted => "submitted",
            Self::UnderReview => "under-review",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Debug for CitedArtifactStatusType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CitedArtifactStatusType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CitedArtifactStatusType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactStatusType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedArtifactStatusType> for Coding {
    fn from(code: CitedArtifactStatusType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/cited-artifact-status-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CitedArtifactStatusType> for CodeableConcept {
    fn from(code: CitedArtifactStatusType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CitedMedium](http://hl7.org/fhir/ValueSet/cited-medium)**. NLM codes Internet or Print.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CitedMedium {
    /** **internet**

Internet. Online publication in a periodic release. Used to match NLM JournalIssue CitedMedium code for online version. */
    Internet,
    /** **internet-without-issue**

Internet without issue. Online publication without any periodic release. Used for article specific publication date which could be the same as or different from journal issue publication date. */
    InternetWithoutIssue,
    /** **offline-digital-storage**

Offline Digital Storage. Publication in a physical device for electronic data storage, organized in issues for periodic release. */
    OfflineDigitalStorage,
    /** **offline-digital-storage-without-issue**

Offline Digital Storage without issue. Publication in a physical device for electronic data storage, without any periodic release. */
    OfflineDigitalStorageWithoutIssue,
    /** **print**

Print. Print publication in a periodic release. Used to match NLM JournalIssue CitedMedium code for print version. */
    Print,
    /** **print-without-issue**

Print without issue. Print publication without any periodic release. */
    PrintWithoutIssue,
}
impl ::core::str::FromStr for CitedMedium {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "internet" => Ok(Self::Internet),
            "internet-without-issue" => Ok(Self::InternetWithoutIssue),
            "offline-digital-storage" => Ok(Self::OfflineDigitalStorage),
            "offline-digital-storage-without-issue" => {
                Ok(Self::OfflineDigitalStorageWithoutIssue)
            }
            "print" => Ok(Self::Print),
            "print-without-issue" => Ok(Self::PrintWithoutIssue),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedMedium {
    fn as_ref(&self) -> &str {
        match self {
            Self::Internet => "internet",
            Self::InternetWithoutIssue => "internet-without-issue",
            Self::OfflineDigitalStorage => "offline-digital-storage",
            Self::OfflineDigitalStorageWithoutIssue => {
                "offline-digital-storage-without-issue"
            }
            Self::Print => "print",
            Self::PrintWithoutIssue => "print-without-issue",
        }
    }
}
impl ::std::fmt::Debug for CitedMedium {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CitedMedium {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CitedMedium {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedMedium {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedMedium> for Coding {
    fn from(code: CitedMedium) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/cited-medium".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CitedMedium> for CodeableConcept {
    fn from(code: CitedMedium) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ClaimCareTeamRoleCodes](http://terminology.hl7.org/CodeSystem/claimcareteamrole)**. This value set includes sample Claim Care Team Role codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ClaimCareTeamRoleCodes {
    /** **assist**

Assisting Provider. Assisting care provider. */
    Assist,
    /** **other**

Other. Other role on the care team. */
    Other,
    /** **primary**

Primary provider. The primary care provider. */
    Primary,
    /** **supervisor**

Supervising Provider. Supervising care provider. */
    Supervisor,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ClaimCareTeamRoleCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assist" => Ok(Self::Assist),
            "other" => Ok(Self::Other),
            "primary" => Ok(Self::Primary),
            "supervisor" => Ok(Self::Supervisor),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ClaimCareTeamRoleCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assist => "assist",
            Self::Other => "other",
            Self::Primary => "primary",
            Self::Supervisor => "supervisor",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ClaimCareTeamRoleCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ClaimCareTeamRoleCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ClaimCareTeamRoleCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimCareTeamRoleCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClaimCareTeamRoleCodes> for Coding {
    fn from(code: ClaimCareTeamRoleCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/claimcareteamrole".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ClaimCareTeamRoleCodes> for CodeableConcept {
    fn from(code: ClaimCareTeamRoleCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ClaimInformationCategoryCodes](http://terminology.hl7.org/CodeSystem/claiminformationcategory)**. This value set includes sample Information Category codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ClaimInformationCategoryCodes {
    /** **attachment**

Attachment. Materials attached such as images, documents and resources. */
    Attachment,
    /** **discharge**

Discharge. Discharge status and discharge to locations. */
    Discharge,
    /** **employmentimpacted**

EmploymentImpacted. An indication that the patient was unable to work, the period if known otherwise a Yes/No (boolean). */
    Employmentimpacted,
    /** **exception**

Exception. Insurance policy exceptions. */
    Exception,
    /** **externalcause**

External Caause. The external cause of an illness or injury. */
    Externalcause,
    /** **hospitalized**

Hospitalized. An indication that the patient was hospitalized, the period if known otherwise a Yes/No (boolean). */
    Hospitalized,
    /** **info**

Information. Codes conveying additional situation and condition information. */
    Info,
    /** **material**

Materials Forwarded. Materials being forwarded, e.g. Models, molds, images, documents. */
    Material,
    /** **missingtooth**

Missing Tooth. Teeth which are missing for any reason, for example: prior extraction, never developed. */
    Missingtooth,
    /** **onset**

Onset. Period, start or end dates of aspects of the Condition. */
    Onset,
    /** **other**

Other. Other information identified by the type.system. */
    Other,
    /** **patientreasonforvisit**

Patient Reason for Visit. The reason for the patient visit. */
    Patientreasonforvisit,
    /** **prosthesis**

Prosthesis. The type of prosthesis and date of supply if a previously supplied prosthesis. */
    Prosthesis,
    /** **related**

Related Services. Nature and date of the related event e.g. Last exam, service, X-ray etc. */
    Related,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ClaimInformationCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "attachment" => Ok(Self::Attachment),
            "discharge" => Ok(Self::Discharge),
            "employmentimpacted" => Ok(Self::Employmentimpacted),
            "exception" => Ok(Self::Exception),
            "externalcause" => Ok(Self::Externalcause),
            "hospitalized" => Ok(Self::Hospitalized),
            "info" => Ok(Self::Info),
            "material" => Ok(Self::Material),
            "missingtooth" => Ok(Self::Missingtooth),
            "onset" => Ok(Self::Onset),
            "other" => Ok(Self::Other),
            "patientreasonforvisit" => Ok(Self::Patientreasonforvisit),
            "prosthesis" => Ok(Self::Prosthesis),
            "related" => Ok(Self::Related),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ClaimInformationCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attachment => "attachment",
            Self::Discharge => "discharge",
            Self::Employmentimpacted => "employmentimpacted",
            Self::Exception => "exception",
            Self::Externalcause => "externalcause",
            Self::Hospitalized => "hospitalized",
            Self::Info => "info",
            Self::Material => "material",
            Self::Missingtooth => "missingtooth",
            Self::Onset => "onset",
            Self::Other => "other",
            Self::Patientreasonforvisit => "patientreasonforvisit",
            Self::Prosthesis => "prosthesis",
            Self::Related => "related",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ClaimInformationCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ClaimInformationCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ClaimInformationCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimInformationCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClaimInformationCategoryCodes> for Coding {
    fn from(code: ClaimInformationCategoryCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/claiminformationcategory"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ClaimInformationCategoryCodes> for CodeableConcept {
    fn from(code: ClaimInformationCategoryCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ClaimTypeCodes](http://terminology.hl7.org/CodeSystem/claim-type)**. This value set includes Claim Type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ClaimTypeCodes {
    /** **institutional**

Institutional. Hospital, clinic and typically inpatient claims. */
    Institutional,
    /** **oral**

Oral. Dental, Denture and Hygiene claims. */
    Oral,
    /** **pharmacy**

Pharmacy. Pharmacy claims for goods and services. */
    Pharmacy,
    /** **professional**

Professional. Typically, outpatient claims from Physician, Psychological, Chiropractor, Physiotherapy, Speech Pathology, rehabilitative, consulting. */
    Professional,
    /** **vision**

Vision. Vision claims for professional services and products such as glasses and contact lenses. */
    Vision,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ClaimTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "institutional" => Ok(Self::Institutional),
            "oral" => Ok(Self::Oral),
            "pharmacy" => Ok(Self::Pharmacy),
            "professional" => Ok(Self::Professional),
            "vision" => Ok(Self::Vision),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ClaimTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Institutional => "institutional",
            Self::Oral => "oral",
            Self::Pharmacy => "pharmacy",
            Self::Professional => "professional",
            Self::Vision => "vision",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ClaimTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ClaimTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ClaimTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClaimTypeCodes> for Coding {
    fn from(code: ClaimTypeCodes) -> Self {
        CodingInner {
            system: Some("http://terminology.hl7.org/CodeSystem/claim-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ClaimTypeCodes> for CodeableConcept {
    fn from(code: ClaimTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ClinicalUseDefinitionCategory](http://hl7.org/fhir/ValueSet/clinical-use-definition-category)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ClinicalUseDefinitionCategory {
    /** **DriveAndMachines**

Effects on Ability to Drive and Use Machines. */
    DriveAndMachines,
    /** **Overdose**

Overdose. */
    Overdose,
    /** **Pregnancy**

Pregnancy and Lactation. */
    Pregnancy,
}
impl ::core::str::FromStr for ClinicalUseDefinitionCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "DriveAndMachines" => Ok(Self::DriveAndMachines),
            "Overdose" => Ok(Self::Overdose),
            "Pregnancy" => Ok(Self::Pregnancy),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClinicalUseDefinitionCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::DriveAndMachines => "DriveAndMachines",
            Self::Overdose => "Overdose",
            Self::Pregnancy => "Pregnancy",
        }
    }
}
impl ::std::fmt::Debug for ClinicalUseDefinitionCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ClinicalUseDefinitionCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ClinicalUseDefinitionCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClinicalUseDefinitionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClinicalUseDefinitionCategory> for Coding {
    fn from(code: ClinicalUseDefinitionCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/clinical-use-definition-category"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ClinicalUseDefinitionCategory> for CodeableConcept {
    fn from(code: ClinicalUseDefinitionCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ClinicalUseDefinitionType](http://hl7.org/fhir/ValueSet/clinical-use-definition-type)**. Overall defining type of this clinical use definition.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ClinicalUseDefinitionType {
    /** **contraindication**

Contraindication. A reason for not giving the medication. */
    Contraindication,
    /** **indication**

Indication. A reason for giving the medication. */
    Indication,
    /** **interaction**

Interaction. Interactions between the medication and other substances. */
    Interaction,
    /** **undesirable-effect**

Undesirable Effect. Side effects or adverse effects associated with the medication. */
    UndesirableEffect,
    /** **warning**

Warning. A general warning or issue that is not specifically one of the other types. */
    Warning,
}
impl ::core::str::FromStr for ClinicalUseDefinitionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contraindication" => Ok(Self::Contraindication),
            "indication" => Ok(Self::Indication),
            "interaction" => Ok(Self::Interaction),
            "undesirable-effect" => Ok(Self::UndesirableEffect),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClinicalUseDefinitionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contraindication => "contraindication",
            Self::Indication => "indication",
            Self::Interaction => "interaction",
            Self::UndesirableEffect => "undesirable-effect",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Debug for ClinicalUseDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ClinicalUseDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ClinicalUseDefinitionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClinicalUseDefinitionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClinicalUseDefinitionType> for Coding {
    fn from(code: ClinicalUseDefinitionType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/clinical-use-definition-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ClinicalUseDefinitionType> for CodeableConcept {
    fn from(code: ClinicalUseDefinitionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CodeSearchSupport](http://hl7.org/fhir/ValueSet/code-search-support)**. The degree to which the server supports the code search parameter on ValueSet, if it is supported.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CodeSearchSupport {
    /** **all**

Implicit Codes. The search for code on ValueSet only includes all codes based on the expansion of the value set. */
    All,
    /** **explicit**

Explicit Codes. The search for code on ValueSet only includes codes explicitly detailed on includes or expansions. */
    Explicit,
}
impl ::core::str::FromStr for CodeSearchSupport {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "explicit" => Ok(Self::Explicit),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSearchSupport {
    fn as_ref(&self) -> &str {
        match self {
            Self::All => "all",
            Self::Explicit => "explicit",
        }
    }
}
impl ::std::fmt::Debug for CodeSearchSupport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CodeSearchSupport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CodeSearchSupport {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSearchSupport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CodeSearchSupport> for Coding {
    fn from(code: CodeSearchSupport) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/code-search-support".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CodeSearchSupport> for CodeableConcept {
    fn from(code: CodeSearchSupport) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CodeSystemContentMode](http://hl7.org/fhir/ValueSet/codesystem-content-mode)**. The extent of the content of the code system (the concepts and codes it defines) are represented in a code system resource.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CodeSystemContentMode {
    /** **complete**

Complete. All the concepts defined by the code system are included in the code system resource. */
    Complete,
    /** **example**

Example. A few representative concepts are included in the code system resource. There is no useful intent in the subset choice and there's no process to make it workable: it's not intended to be workable. */
    Example,
    /** **fragment**

Fragment. A subset of the code system concepts are included in the code system resource. This is a curated subset released for a specific purpose under the governance of the code system steward, and that the intent, bounds and consequences of the fragmentation are clearly defined in the fragment or the code system documentation. Fragments are also known as partitions. */
    Fragment,
    /** **not-present**

Not Present. None of the concepts defined by the code system are included in the code system resource. */
    NotPresent,
    /** **supplement**

Supplement. The resource doesn't define any new concepts; it just provides additional designations and properties to another code system. */
    Supplement,
}
impl ::core::str::FromStr for CodeSystemContentMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "example" => Ok(Self::Example),
            "fragment" => Ok(Self::Fragment),
            "not-present" => Ok(Self::NotPresent),
            "supplement" => Ok(Self::Supplement),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSystemContentMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Example => "example",
            Self::Fragment => "fragment",
            Self::NotPresent => "not-present",
            Self::Supplement => "supplement",
        }
    }
}
impl ::std::fmt::Debug for CodeSystemContentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CodeSystemContentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CodeSystemContentMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSystemContentMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CodeSystemContentMode> for Coding {
    fn from(code: CodeSystemContentMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/codesystem-content-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CodeSystemContentMode> for CodeableConcept {
    fn from(code: CodeSystemContentMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CodeSystemHierarchyMeaning](http://hl7.org/fhir/ValueSet/codesystem-hierarchy-meaning)**. The meaning of the hierarchy of concepts in a code system.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CodeSystemHierarchyMeaning {
    /** **classified-with**

Classified With. Child concepts in the hierarchy may have only one parent, and there is a presumption that the code system is a "closed world" meaning all things must be in the hierarchy. This results in concepts such as "not otherwise classified.". */
    ClassifiedWith,
    /** **grouped-by**

Grouped By. No particular relationship between the concepts can be assumed, except what can be determined by inspection of the definitions of the elements (possible reasons to use this: importing from a source where this is not defined, or where various parts of the hierarchy have different meanings). */
    GroupedBy,
    /** **is-a**

Is-A. A hierarchy where the child concepts have an IS-A relationship with the parents - that is, all the properties of the parent are also true for its child concepts. Not that is-a is a property of the concepts, so additional subsumption relationships may be defined using properties or the [subsumes](extension-codesystem-subsumes.html) extension. */
    IsA,
    /** **part-of**

Part Of. Child elements list the individual parts of a composite whole (e.g. body site). */
    PartOf,
}
impl ::core::str::FromStr for CodeSystemHierarchyMeaning {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "classified-with" => Ok(Self::ClassifiedWith),
            "grouped-by" => Ok(Self::GroupedBy),
            "is-a" => Ok(Self::IsA),
            "part-of" => Ok(Self::PartOf),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSystemHierarchyMeaning {
    fn as_ref(&self) -> &str {
        match self {
            Self::ClassifiedWith => "classified-with",
            Self::GroupedBy => "grouped-by",
            Self::IsA => "is-a",
            Self::PartOf => "part-of",
        }
    }
}
impl ::std::fmt::Debug for CodeSystemHierarchyMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CodeSystemHierarchyMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CodeSystemHierarchyMeaning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSystemHierarchyMeaning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CodeSystemHierarchyMeaning> for Coding {
    fn from(code: CodeSystemHierarchyMeaning) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/codesystem-hierarchy-meaning".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CodeSystemHierarchyMeaning> for CodeableConcept {
    fn from(code: CodeSystemHierarchyMeaning) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CombinedDoseForm](http://hl7.org/fhir/ValueSet/combined-dose-form)**. Dose forms for a product as a whole, considering all individual parts, but before any mixing\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CombinedDoseForm {
    /** **100000073366**

Powder and solvent for oral solution. */
    N100000073366,
    /** **100000073651**

Powder and solvent for oral suspension. */
    N100000073651,
    /** **100000073774**

Eye drops, powder and solvent for solution. */
    N100000073774,
    /** **100000073781**

Eye drops, powder and solvent for suspension. */
    N100000073781,
    /** **100000073801**

Ear drops, powder and solvent for suspension. */
    N100000073801,
    /** **100000073860**

Powder and solvent for solution for infusion. */
    N100000073860,
    /** **100000073868**

Powder and solvent for solution for injection. */
    N100000073868,
    /** **100000073869**

Powder and solvent for suspension for injection. */
    N100000073869,
    /** **100000073884**

Powder and solvent for implantation paste. */
    N100000073884,
    /** **100000073891**

Endotracheopulmonary instillation, powder and solvent for solution. */
    N100000073891,
    /** **100000073892**

Powder and solvent for endocervical gel. */
    N100000073892,
    /** **100000073941**

Powder and solvent for sealant. */
    N100000073941,
    /** **100000073972**

Concentrate and solvent for concentrate for solution for infusion. */
    N100000073972,
    /** **100000073973**

Concentrate and solvent for cutaneous use. */
    N100000073973,
    /** **100000073974**

Concentrate and solvent for injection. */
    N100000073974,
    /** **100000073975**

Concentrate and solvent for solution for infusion. */
    N100000073975,
    /** **100000073987**

Concentrate and diluent for solution for infusion. */
    N100000073987,
    /** **100000073988**

Concentrate and solvent for cutaneous solution. */
    N100000073988,
    /** **100000073989**

Concentrate and solvent for solution for injection. */
    N100000073989,
    /** **100000073990**

Concentrate and solvent for suspension for injection. */
    N100000073990,
    /** **100000073999**

Granules and solvent for suspension for injection. */
    N100000073999,
    /** **100000074015**

Powder and solvent for concentrate for solution for infusion. */
    N100000074015,
    /** **100000074016**

Powder and solvent for cutaneous solution. */
    N100000074016,
    /** **100000074017**

Powder and solvent for gingival gel. */
    N100000074017,
    /** **100000074018**

Powder and solvent for prolonged-release suspension for injection. */
    N100000074018,
    /** **100000074030**

Powder and solvent for endosinusial solution. */
    N100000074030,
    /** **100000074031**

Powder and solvent for intraocular instillation solution. */
    N100000074031,
    /** **100000074032**

Powder and suspension for suspension for injection. */
    N100000074032,
    /** **100000074048**

Suspension and effervescent granules for oral suspension. */
    N100000074048,
    /** **100000074051**

Tablet and solvent for rectal suspension. */
    N100000074051,
    /** **100000074053**

Powder and solvent for dental gel. */
    N100000074053,
    /** **100000074056**

Gas and solvent for dispersion for injection/infusion. */
    N100000074056,
    /** **100000074057**

Powder and solvent for solution for injection/infusion. */
    N100000074057,
    /** **100000074061**

Suspension and solution for spray. */
    N100000074061,
    /** **100000074064**

Tablet and powder for oral solution. */
    N100000074064,
    /** **100000075580**

Emulsion and suspension for emulsion for injection. */
    N100000075580,
    /** **100000075584**

Powder and solvent for dispersion for injection. */
    N100000075584,
    /** **100000075587**

Powder for mouth wash. */
    N100000075587,
    /** **100000116137**

Lyophilisate and solvent for solution for injection. */
    N100000116137,
    /** **100000116141**

Fibrin sealant-powder and solvent for fibrin sealant. */
    N100000116141,
    /** **100000116155**

Granules and solvent for oral suspension. */
    N100000116155,
    /** **100000116160**

Lyophilisate and solvent for suspension for injection. */
    N100000116160,
    /** **100000116172**

Powder and gel for gel. */
    N100000116172,
    /** **100000116173**

Powder and solution for solution for injection. */
    N100000116173,
    /** **100000116174**

Powder and solvent for epilesional solution. */
    N100000116174,
    /** **100000116175**

Powder and solvent for intravesical solution. */
    N100000116175,
    /** **100000116176**

Powder and solvent for intravesical suspension. */
    N100000116176,
    /** **100000116177**

Powder and solvent for nebuliser solution. */
    N100000116177,
    /** **100000116179**

Powder, dispersion and solvent for concentrate for dispersion for infusion. */
    N100000116179,
    /** **100000125746**

Powder and solvent for emulsion for injection. */
    N100000125746,
    /** **100000125747**

Nasal drops, powder and solvent for solution. */
    N100000125747,
    /** **100000125777**

Suspension and solvent for suspension for injection. */
    N100000125777,
    /** **100000136318**

Concentrate and solvent for solution for injection/infusion. */
    N100000136318,
    /** **100000136325**

Powder and solvent for solution for injection/skin-prick test. */
    N100000136325,
    /** **100000136558**

Lyophilisate and solvent for suspension for nasal administration. */
    N100000136558,
    /** **100000136560**

Powder and solvent for solution for sealant. */
    N100000136560,
    /** **100000136907**

Solution for dispersion for injection/infusion. */
    N100000136907,
    /** **100000143502**

Powder and solution for dental cement. */
    N100000143502,
    /** **100000143546**

Endotracheopulmonary instillation, powder and solvent for suspension. */
    N100000143546,
    /** **100000143552**

Powder, solvent and matrix for implantation matrix. */
    N100000143552,
    /** **100000156068**

Nasal drops, lyophilisate and solvent for suspension. */
    N100000156068,
    /** **100000157796**

Lyophilisate and suspension for suspension for injection. */
    N100000157796,
    /** **100000164467**

Powder for concentrate and solution for solution for infusion. */
    N100000164467,
    /** **100000169997**

Powder and solution for bee-hive solution. */
    N100000169997,
    /** **100000170588**

Suspension and solvent for oral spray. */
    N100000170588,
    /** **100000171127**

Lyophilisate and solvent for oral suspension. */
    N100000171127,
    /** **100000171193**

Concentrate and solvent for concentrate for oral spray, suspension. */
    N100000171193,
    /** **100000171238**

Lyophilisate and solvent for oculonasal suspension. */
    N100000171238,
    /** **100000171935**

Emulsion and lyophilisate for suspension for injection. */
    N100000171935,
    /** **100000174065**

Powder and solvent for syrup. */
    N100000174065,
    /** **200000002161**

Nasal spray, lyophilisate and solvent for suspension. */
    N200000002161,
    /** **200000002287**

Powder and solution for bee-hive dispersion. */
    N200000002287,
    /** **200000004201**

Solution and dispersion for nebuliser dispersion. */
    N200000004201,
    /** **200000004819**

Effervescent powder and powder for oral suspension. */
    N200000004819,
    /** **200000004820**

Lyophilisate and solvent for emulsion for injection. */
    N200000004820,
    /** **200000005547**

Powder and solution for suspension for injection. */
    N200000005547,
    /** **200000010382**

Lyophilisate and solvent for suspension for nasal spray or injection. */
    N200000010382,
}
impl ::core::str::FromStr for CombinedDoseForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073366" => Ok(Self::N100000073366),
            "100000073651" => Ok(Self::N100000073651),
            "100000073774" => Ok(Self::N100000073774),
            "100000073781" => Ok(Self::N100000073781),
            "100000073801" => Ok(Self::N100000073801),
            "100000073860" => Ok(Self::N100000073860),
            "100000073868" => Ok(Self::N100000073868),
            "100000073869" => Ok(Self::N100000073869),
            "100000073884" => Ok(Self::N100000073884),
            "100000073891" => Ok(Self::N100000073891),
            "100000073892" => Ok(Self::N100000073892),
            "100000073941" => Ok(Self::N100000073941),
            "100000073972" => Ok(Self::N100000073972),
            "100000073973" => Ok(Self::N100000073973),
            "100000073974" => Ok(Self::N100000073974),
            "100000073975" => Ok(Self::N100000073975),
            "100000073987" => Ok(Self::N100000073987),
            "100000073988" => Ok(Self::N100000073988),
            "100000073989" => Ok(Self::N100000073989),
            "100000073990" => Ok(Self::N100000073990),
            "100000073999" => Ok(Self::N100000073999),
            "100000074015" => Ok(Self::N100000074015),
            "100000074016" => Ok(Self::N100000074016),
            "100000074017" => Ok(Self::N100000074017),
            "100000074018" => Ok(Self::N100000074018),
            "100000074030" => Ok(Self::N100000074030),
            "100000074031" => Ok(Self::N100000074031),
            "100000074032" => Ok(Self::N100000074032),
            "100000074048" => Ok(Self::N100000074048),
            "100000074051" => Ok(Self::N100000074051),
            "100000074053" => Ok(Self::N100000074053),
            "100000074056" => Ok(Self::N100000074056),
            "100000074057" => Ok(Self::N100000074057),
            "100000074061" => Ok(Self::N100000074061),
            "100000074064" => Ok(Self::N100000074064),
            "100000075580" => Ok(Self::N100000075580),
            "100000075584" => Ok(Self::N100000075584),
            "100000075587" => Ok(Self::N100000075587),
            "100000116137" => Ok(Self::N100000116137),
            "100000116141" => Ok(Self::N100000116141),
            "100000116155" => Ok(Self::N100000116155),
            "100000116160" => Ok(Self::N100000116160),
            "100000116172" => Ok(Self::N100000116172),
            "100000116173" => Ok(Self::N100000116173),
            "100000116174" => Ok(Self::N100000116174),
            "100000116175" => Ok(Self::N100000116175),
            "100000116176" => Ok(Self::N100000116176),
            "100000116177" => Ok(Self::N100000116177),
            "100000116179" => Ok(Self::N100000116179),
            "100000125746" => Ok(Self::N100000125746),
            "100000125747" => Ok(Self::N100000125747),
            "100000125777" => Ok(Self::N100000125777),
            "100000136318" => Ok(Self::N100000136318),
            "100000136325" => Ok(Self::N100000136325),
            "100000136558" => Ok(Self::N100000136558),
            "100000136560" => Ok(Self::N100000136560),
            "100000136907" => Ok(Self::N100000136907),
            "100000143502" => Ok(Self::N100000143502),
            "100000143546" => Ok(Self::N100000143546),
            "100000143552" => Ok(Self::N100000143552),
            "100000156068" => Ok(Self::N100000156068),
            "100000157796" => Ok(Self::N100000157796),
            "100000164467" => Ok(Self::N100000164467),
            "100000169997" => Ok(Self::N100000169997),
            "100000170588" => Ok(Self::N100000170588),
            "100000171127" => Ok(Self::N100000171127),
            "100000171193" => Ok(Self::N100000171193),
            "100000171238" => Ok(Self::N100000171238),
            "100000171935" => Ok(Self::N100000171935),
            "100000174065" => Ok(Self::N100000174065),
            "200000002161" => Ok(Self::N200000002161),
            "200000002287" => Ok(Self::N200000002287),
            "200000004201" => Ok(Self::N200000004201),
            "200000004819" => Ok(Self::N200000004819),
            "200000004820" => Ok(Self::N200000004820),
            "200000005547" => Ok(Self::N200000005547),
            "200000010382" => Ok(Self::N200000010382),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CombinedDoseForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073366 => "100000073366",
            Self::N100000073651 => "100000073651",
            Self::N100000073774 => "100000073774",
            Self::N100000073781 => "100000073781",
            Self::N100000073801 => "100000073801",
            Self::N100000073860 => "100000073860",
            Self::N100000073868 => "100000073868",
            Self::N100000073869 => "100000073869",
            Self::N100000073884 => "100000073884",
            Self::N100000073891 => "100000073891",
            Self::N100000073892 => "100000073892",
            Self::N100000073941 => "100000073941",
            Self::N100000073972 => "100000073972",
            Self::N100000073973 => "100000073973",
            Self::N100000073974 => "100000073974",
            Self::N100000073975 => "100000073975",
            Self::N100000073987 => "100000073987",
            Self::N100000073988 => "100000073988",
            Self::N100000073989 => "100000073989",
            Self::N100000073990 => "100000073990",
            Self::N100000073999 => "100000073999",
            Self::N100000074015 => "100000074015",
            Self::N100000074016 => "100000074016",
            Self::N100000074017 => "100000074017",
            Self::N100000074018 => "100000074018",
            Self::N100000074030 => "100000074030",
            Self::N100000074031 => "100000074031",
            Self::N100000074032 => "100000074032",
            Self::N100000074048 => "100000074048",
            Self::N100000074051 => "100000074051",
            Self::N100000074053 => "100000074053",
            Self::N100000074056 => "100000074056",
            Self::N100000074057 => "100000074057",
            Self::N100000074061 => "100000074061",
            Self::N100000074064 => "100000074064",
            Self::N100000075580 => "100000075580",
            Self::N100000075584 => "100000075584",
            Self::N100000075587 => "100000075587",
            Self::N100000116137 => "100000116137",
            Self::N100000116141 => "100000116141",
            Self::N100000116155 => "100000116155",
            Self::N100000116160 => "100000116160",
            Self::N100000116172 => "100000116172",
            Self::N100000116173 => "100000116173",
            Self::N100000116174 => "100000116174",
            Self::N100000116175 => "100000116175",
            Self::N100000116176 => "100000116176",
            Self::N100000116177 => "100000116177",
            Self::N100000116179 => "100000116179",
            Self::N100000125746 => "100000125746",
            Self::N100000125747 => "100000125747",
            Self::N100000125777 => "100000125777",
            Self::N100000136318 => "100000136318",
            Self::N100000136325 => "100000136325",
            Self::N100000136558 => "100000136558",
            Self::N100000136560 => "100000136560",
            Self::N100000136907 => "100000136907",
            Self::N100000143502 => "100000143502",
            Self::N100000143546 => "100000143546",
            Self::N100000143552 => "100000143552",
            Self::N100000156068 => "100000156068",
            Self::N100000157796 => "100000157796",
            Self::N100000164467 => "100000164467",
            Self::N100000169997 => "100000169997",
            Self::N100000170588 => "100000170588",
            Self::N100000171127 => "100000171127",
            Self::N100000171193 => "100000171193",
            Self::N100000171238 => "100000171238",
            Self::N100000171935 => "100000171935",
            Self::N100000174065 => "100000174065",
            Self::N200000002161 => "200000002161",
            Self::N200000002287 => "200000002287",
            Self::N200000004201 => "200000004201",
            Self::N200000004819 => "200000004819",
            Self::N200000004820 => "200000004820",
            Self::N200000005547 => "200000005547",
            Self::N200000010382 => "200000010382",
        }
    }
}
impl ::std::fmt::Debug for CombinedDoseForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CombinedDoseForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CombinedDoseForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CombinedDoseForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CombinedDoseForm> for Coding {
    fn from(code: CombinedDoseForm) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/combined-dose-form".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CombinedDoseForm> for CodeableConcept {
    fn from(code: CombinedDoseForm) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CommonTags](http://hl7.org/fhir/ValueSet/common-tags)**. Common Tag Codes defined by FHIR project\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CommonTags {
    /** **actionable**

Actionable. This request is intended to be acted upon, not merely stored */
    Actionable,
}
impl ::core::str::FromStr for CommonTags {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "actionable" => Ok(Self::Actionable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommonTags {
    fn as_ref(&self) -> &str {
        match self {
            Self::Actionable => "actionable",
        }
    }
}
impl ::std::fmt::Debug for CommonTags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CommonTags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CommonTags {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommonTags {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CommonTags> for Coding {
    fn from(code: CommonTags) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/common-tags".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CommonTags> for CodeableConcept {
    fn from(code: CommonTags) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CommunicationCategory](http://hl7.org/fhir/ValueSet/communication-category)**. Codes for general categories of communications such as alerts, instructions, etc.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CommunicationCategory {
    /** **alert**

Alert. The communication conveys an alert. */
    Alert,
    /** **instruction**

Instruction. The communication conveys an instruction. */
    Instruction,
    /** **notification**

Notification. The communication conveys a notification. */
    Notification,
    /** **reminder**

Reminder. The communication conveys a reminder. */
    Reminder,
}
impl ::core::str::FromStr for CommunicationCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alert" => Ok(Self::Alert),
            "instruction" => Ok(Self::Instruction),
            "notification" => Ok(Self::Notification),
            "reminder" => Ok(Self::Reminder),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommunicationCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alert => "alert",
            Self::Instruction => "instruction",
            Self::Notification => "notification",
            Self::Reminder => "reminder",
        }
    }
}
impl ::std::fmt::Debug for CommunicationCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CommunicationCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CommunicationCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommunicationCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CommunicationCategory> for Coding {
    fn from(code: CommunicationCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/communication-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CommunicationCategory> for CodeableConcept {
    fn from(code: CommunicationCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CommunicationNotDoneReason](http://hl7.org/fhir/ValueSet/communication-not-done-reason)**. Codes for the reason why a communication did not happen.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CommunicationNotDoneReason {
    /** **family-objection**

Family Objection. The communication was not done due to a family objection. */
    FamilyObjection,
    /** **invalid-phone-number**

Invalid Phone Number. The communication was not done due to an invalid phone number. */
    InvalidPhoneNumber,
    /** **patient-objection**

Patient Objection. The communication was not done due to a patient objection. */
    PatientObjection,
    /** **recipient-unavailable**

Recipient Unavailable. The communication was not done due to the recipient being unavailable. */
    RecipientUnavailable,
    /** **system-error**

System Error. The communication was not done due to a system error. */
    SystemError,
    /** **unknown**

Unknown. The communication was not done due to an unknown reason. */
    Unknown,
}
impl ::core::str::FromStr for CommunicationNotDoneReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "family-objection" => Ok(Self::FamilyObjection),
            "invalid-phone-number" => Ok(Self::InvalidPhoneNumber),
            "patient-objection" => Ok(Self::PatientObjection),
            "recipient-unavailable" => Ok(Self::RecipientUnavailable),
            "system-error" => Ok(Self::SystemError),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommunicationNotDoneReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::FamilyObjection => "family-objection",
            Self::InvalidPhoneNumber => "invalid-phone-number",
            Self::PatientObjection => "patient-objection",
            Self::RecipientUnavailable => "recipient-unavailable",
            Self::SystemError => "system-error",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for CommunicationNotDoneReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CommunicationNotDoneReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CommunicationNotDoneReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommunicationNotDoneReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CommunicationNotDoneReason> for Coding {
    fn from(code: CommunicationNotDoneReason) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/communication-not-done-reason".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CommunicationNotDoneReason> for CodeableConcept {
    fn from(code: CommunicationNotDoneReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CommunicationTopic](http://hl7.org/fhir/ValueSet/communication-topic)**. Codes describing the purpose or content of the communication.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CommunicationTopic {
    /** **appointment-reminder**

Appointment Reminder. The purpose or content of the communication is an appointment reminder. */
    AppointmentReminder,
    /** **phone-consult**

Phone Consult. The purpose or content of the communication is a phone consult. */
    PhoneConsult,
    /** **prescription-refill-request**

Prescription Refill Request. The purpose or content of the communication is a prescription refill request. */
    PrescriptionRefillRequest,
    /** **progress-update**

Progress Update. The purpose or content of the communication is a progress update. */
    ProgressUpdate,
    /** **report-labs**

Report Labs. The purpose or content of the communication is to report labs. */
    ReportLabs,
    /** **summary-report**

Summary Report. The purpose or content of the communication is a summary report. */
    SummaryReport,
}
impl ::core::str::FromStr for CommunicationTopic {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "appointment-reminder" => Ok(Self::AppointmentReminder),
            "phone-consult" => Ok(Self::PhoneConsult),
            "prescription-refill-request" => Ok(Self::PrescriptionRefillRequest),
            "progress-update" => Ok(Self::ProgressUpdate),
            "report-labs" => Ok(Self::ReportLabs),
            "summary-report" => Ok(Self::SummaryReport),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommunicationTopic {
    fn as_ref(&self) -> &str {
        match self {
            Self::AppointmentReminder => "appointment-reminder",
            Self::PhoneConsult => "phone-consult",
            Self::PrescriptionRefillRequest => "prescription-refill-request",
            Self::ProgressUpdate => "progress-update",
            Self::ReportLabs => "report-labs",
            Self::SummaryReport => "summary-report",
        }
    }
}
impl ::std::fmt::Debug for CommunicationTopic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CommunicationTopic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CommunicationTopic {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommunicationTopic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CommunicationTopic> for Coding {
    fn from(code: CommunicationTopic) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/communication-topic".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CommunicationTopic> for CodeableConcept {
    fn from(code: CommunicationTopic) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CompartmentType](http://hl7.org/fhir/ValueSet/compartment-type)**. Which type a compartment definition describes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CompartmentType {
    /** **Device**

Device. The compartment definition is for the device compartment. */
    Device,
    /** **Encounter**

Encounter. The compartment definition is for the encounter compartment. */
    Encounter,
    /** **Patient**

Patient. The compartment definition is for the patient compartment. */
    Patient,
    /** **Practitioner**

Practitioner. The compartment definition is for the practitioner compartment. */
    Practitioner,
    /** **RelatedPerson**

RelatedPerson. The compartment definition is for the related-person compartment. */
    RelatedPerson,
}
impl ::core::str::FromStr for CompartmentType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Device" => Ok(Self::Device),
            "Encounter" => Ok(Self::Encounter),
            "Patient" => Ok(Self::Patient),
            "Practitioner" => Ok(Self::Practitioner),
            "RelatedPerson" => Ok(Self::RelatedPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompartmentType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "Device",
            Self::Encounter => "Encounter",
            Self::Patient => "Patient",
            Self::Practitioner => "Practitioner",
            Self::RelatedPerson => "RelatedPerson",
        }
    }
}
impl ::std::fmt::Debug for CompartmentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CompartmentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CompartmentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompartmentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompartmentType> for Coding {
    fn from(code: CompartmentType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/compartment-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CompartmentType> for CodeableConcept {
    fn from(code: CompartmentType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CompositeMeasureScoring](http://hl7.org/fhir/ValueSet/composite-measure-scoring)**. The composite scoring method of the measure.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CompositeMeasureScoring {
    /** **all-or-nothing**

All-or-nothing. All-or-nothing scoring includes an individual in the numerator of the composite measure if they are in the numerators of all of the component measures in which they are in the denominator. */
    AllOrNothing,
    /** **linear**

Linear. Linear scoring gives an individual a score based on the number of numerators in which they appear. */
    Linear,
    /** **opportunity**

Opportunity. Opportunity scoring combines the scores from component measures by combining the numerators and denominators for each component. */
    Opportunity,
    /** **weighted**

Weighted. Weighted scoring gives an individual a score based on a weighted factor for each component numerator in which they appear. */
    Weighted,
}
impl ::core::str::FromStr for CompositeMeasureScoring {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all-or-nothing" => Ok(Self::AllOrNothing),
            "linear" => Ok(Self::Linear),
            "opportunity" => Ok(Self::Opportunity),
            "weighted" => Ok(Self::Weighted),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositeMeasureScoring {
    fn as_ref(&self) -> &str {
        match self {
            Self::AllOrNothing => "all-or-nothing",
            Self::Linear => "linear",
            Self::Opportunity => "opportunity",
            Self::Weighted => "weighted",
        }
    }
}
impl ::std::fmt::Debug for CompositeMeasureScoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CompositeMeasureScoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CompositeMeasureScoring {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositeMeasureScoring {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompositeMeasureScoring> for Coding {
    fn from(code: CompositeMeasureScoring) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/composite-measure-scoring".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CompositeMeasureScoring> for CodeableConcept {
    fn from(code: CompositeMeasureScoring) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CompositionAttestationMode](http://hl7.org/fhir/ValueSet/composition-attestation-mode)**. The way in which a person authenticated a composition.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CompositionAttestationMode {
    /** **legal**

Legal. The person authenticated the content and accepted legal responsibility for its content. */
    Legal,
    /** **official**

Official. The organization authenticated the content as consistent with their policies and procedures. */
    Official,
    /** **personal**

Personal. The person authenticated the content in their personal capacity. */
    Personal,
    /** **professional**

Professional. The person authenticated the content in their professional capacity. */
    Professional,
}
impl ::core::str::FromStr for CompositionAttestationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "legal" => Ok(Self::Legal),
            "official" => Ok(Self::Official),
            "personal" => Ok(Self::Personal),
            "professional" => Ok(Self::Professional),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositionAttestationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Legal => "legal",
            Self::Official => "official",
            Self::Personal => "personal",
            Self::Professional => "professional",
        }
    }
}
impl ::std::fmt::Debug for CompositionAttestationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CompositionAttestationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CompositionAttestationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositionAttestationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompositionAttestationMode> for Coding {
    fn from(code: CompositionAttestationMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/composition-attestation-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CompositionAttestationMode> for CodeableConcept {
    fn from(code: CompositionAttestationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CompositionStatus](http://hl7.org/fhir/ValueSet/composition-status)**. The workflow/clinical status of the composition.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CompositionStatus {
    /** **amended**

Amended. The composition content or the referenced resources have been modified (edited or added to) subsequent to being released as "final" and the composition is complete and verified by an authorized person. */
    Amended,
    /** **entered-in-error**

Entered in Error. The composition or document was originally created/issued in error, and this is an amendment that marks that the entire series should not be considered as valid. */
    EnteredInError,
    /** **final**

Final. This version of the composition is complete and verified by an appropriate person and no further work is planned. Any subsequent updates would be on a new version of the composition. */
    Final,
    /** **preliminary**

Preliminary. This is a preliminary composition or document (also known as initial or interim). The content may be incomplete or unverified. */
    Preliminary,
}
impl ::core::str::FromStr for CompositionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "preliminary" => Ok(Self::Preliminary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Preliminary => "preliminary",
        }
    }
}
impl ::std::fmt::Debug for CompositionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CompositionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CompositionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompositionStatus> for Coding {
    fn from(code: CompositionStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/composition-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CompositionStatus> for CodeableConcept {
    fn from(code: CompositionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConceptMapEquivalence](http://hl7.org/fhir/ValueSet/concept-map-equivalence)**. The degree of equivalence between concepts.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConceptMapEquivalence {
    /** **disjoint**

Disjoint. This is an explicit assertion that there is no mapping between the source and target concept. */
    Disjoint,
    /** **equal**

Equal. The definitions of the concepts are exactly the same (i.e. only grammatical differences) and structural implications of meaning are identical or irrelevant (i.e. intentionally identical). */
    Equal,
    /** **equivalent**

Equivalent. The definitions of the concepts mean the same thing (including when structural implications of meaning are considered) (i.e. extensionally identical). */
    Equivalent,
    /** **inexact**

Inexact. The target mapping overlaps with the source concept, but both source and target cover additional meaning, or the definitions are imprecise and it is uncertain whether they have the same boundaries to their meaning. The sense in which the mapping is inexact SHALL be described in the comments in this case, and applications should be careful when attempting to use these mappings operationally. */
    Inexact,
    /** **narrower**

Narrower. The target mapping is narrower in meaning than the source concept. The sense in which the mapping is narrower SHALL be described in the comments in this case, and applications should be careful when attempting to use these mappings operationally. */
    Narrower,
    /** **relatedto**

Related To. The concepts are related to each other, and have at least some overlap in meaning, but the exact relationship is not known. */
    Relatedto,
    /** **specializes**

Specializes. The target mapping specializes the meaning of the source concept (e.g. the target is-a source). */
    Specializes,
    /** **subsumes**

Subsumes. The target mapping subsumes the meaning of the source concept (e.g. the source is-a target). */
    Subsumes,
    /** **unmatched**

Unmatched. There is no match for this concept in the target code system. */
    Unmatched,
    /** **wider**

Wider. The target mapping is wider in meaning than the source concept. */
    Wider,
}
impl ::core::str::FromStr for ConceptMapEquivalence {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "disjoint" => Ok(Self::Disjoint),
            "equal" => Ok(Self::Equal),
            "equivalent" => Ok(Self::Equivalent),
            "inexact" => Ok(Self::Inexact),
            "narrower" => Ok(Self::Narrower),
            "relatedto" => Ok(Self::Relatedto),
            "specializes" => Ok(Self::Specializes),
            "subsumes" => Ok(Self::Subsumes),
            "unmatched" => Ok(Self::Unmatched),
            "wider" => Ok(Self::Wider),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapEquivalence {
    fn as_ref(&self) -> &str {
        match self {
            Self::Disjoint => "disjoint",
            Self::Equal => "equal",
            Self::Equivalent => "equivalent",
            Self::Inexact => "inexact",
            Self::Narrower => "narrower",
            Self::Relatedto => "relatedto",
            Self::Specializes => "specializes",
            Self::Subsumes => "subsumes",
            Self::Unmatched => "unmatched",
            Self::Wider => "wider",
        }
    }
}
impl ::std::fmt::Debug for ConceptMapEquivalence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConceptMapEquivalence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConceptMapEquivalence {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapEquivalence {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptMapEquivalence> for Coding {
    fn from(code: ConceptMapEquivalence) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/concept-map-equivalence".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConceptMapEquivalence> for CodeableConcept {
    fn from(code: ConceptMapEquivalence) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConceptMapGroupUnmappedMode](http://hl7.org/fhir/ValueSet/conceptmap-unmapped-mode)**. Defines which action to take if there is no match in the group.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConceptMapGroupUnmappedMode {
    /** **fixed**

Fixed Code. Use the code explicitly provided in the group.unmapped. */
    Fixed,
    /** **other-map**

Other Map. Use the map identified by the canonical URL in the url element. */
    OtherMap,
    /** **provided**

Provided Code. Use the code as provided in the $translate request. */
    Provided,
}
impl ::core::str::FromStr for ConceptMapGroupUnmappedMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fixed" => Ok(Self::Fixed),
            "other-map" => Ok(Self::OtherMap),
            "provided" => Ok(Self::Provided),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapGroupUnmappedMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fixed => "fixed",
            Self::OtherMap => "other-map",
            Self::Provided => "provided",
        }
    }
}
impl ::std::fmt::Debug for ConceptMapGroupUnmappedMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConceptMapGroupUnmappedMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConceptMapGroupUnmappedMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapGroupUnmappedMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptMapGroupUnmappedMode> for Coding {
    fn from(code: ConceptMapGroupUnmappedMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/conceptmap-unmapped-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConceptMapGroupUnmappedMode> for CodeableConcept {
    fn from(code: ConceptMapGroupUnmappedMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConceptSubsumptionOutcome](http://hl7.org/fhir/concept-subsumption-outcome)**. Codes indicating the results of a subsumption check between codes\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ConceptSubsumptionOutcome {
    /** **equivalent**

Equivalent. The two concepts are equivalent (have the same properties). */
    Equivalent,
    /** **not-subsumed**

Not-Subsumed. Coding/code "A" and Coding/code "B" are disjoint (e.g. each has propeties that the other doesn't have). */
    NotSubsumed,
    /** **subsumed-by**

Subsumed-By. Coding/code "A" is subsumed by Coding/code "B" (e.g. A has all the properties B has, and some of it's own). */
    SubsumedBy,
    /** **subsumes**

Subsumes. Coding/code "A" subsumes Coding/code "B" (e.g. B has all the properties A has, and some of it's own). */
    Subsumes,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConceptSubsumptionOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "equivalent" => Ok(Self::Equivalent),
            "not-subsumed" => Ok(Self::NotSubsumed),
            "subsumed-by" => Ok(Self::SubsumedBy),
            "subsumes" => Ok(Self::Subsumes),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConceptSubsumptionOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equivalent => "equivalent",
            Self::NotSubsumed => "not-subsumed",
            Self::SubsumedBy => "subsumed-by",
            Self::Subsumes => "subsumes",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ConceptSubsumptionOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConceptSubsumptionOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConceptSubsumptionOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptSubsumptionOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptSubsumptionOutcome> for Coding {
    fn from(code: ConceptSubsumptionOutcome) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/concept-subsumption-outcome".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConceptSubsumptionOutcome> for CodeableConcept {
    fn from(code: ConceptSubsumptionOutcome) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConditionCategoryCodes](http://hl7.org/fhir/ValueSet/condition-category)**. Example value set for Condition Categories.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConditionCategoryCodes {
    /** **encounter-diagnosis**

Encounter Diagnosis. A point in time diagnosis (e.g. from a physician or nurse) in context of an encounter. */
    EncounterDiagnosis,
    /** **problem-list-item**

Problem List Item. An item on a problem list that can be managed over time and can be expressed by a practitioner (e.g. physician, nurse), patient, or related person. */
    ProblemListItem,
}
impl ::core::str::FromStr for ConditionCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "encounter-diagnosis" => Ok(Self::EncounterDiagnosis),
            "problem-list-item" => Ok(Self::ProblemListItem),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::EncounterDiagnosis => "encounter-diagnosis",
            Self::ProblemListItem => "problem-list-item",
        }
    }
}
impl ::std::fmt::Debug for ConditionCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConditionCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConditionCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionCategoryCodes> for Coding {
    fn from(code: ConditionCategoryCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/condition-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConditionCategoryCodes> for CodeableConcept {
    fn from(code: ConditionCategoryCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConditionClinicalStatusCodes](http://hl7.org/fhir/ValueSet/condition-clinical)**. Preferred value set for Condition Clinical Status.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConditionClinicalStatusCodes {
    /** **active**

Active. The subject is currently experiencing the symptoms of the condition or there is evidence of the condition. */
    Active,
    /** **inactive**

Inactive. The subject is no longer experiencing the symptoms of the condition or there is no longer evidence of the condition. */
    Inactive,
    /** **recurrence**

Recurrence. The subject is experiencing a re-occurence or repeating of a previously resolved condition, e.g. urinary tract infection, pancreatitis, cholangitis, conjunctivitis. */
    Recurrence,
    /** **relapse**

Relapse. The subject is experiencing a return of a condition, or signs and symptoms after a period of improvement or remission, e.g. relapse of cancer, multiple sclerosis, rheumatoid arthritis, systemic lupus erythematosus, bipolar disorder, [psychotic relapse of] schizophrenia, etc. */
    Relapse,
    /** **remission**

Remission. The subject is no longer experiencing the symptoms of the condition, but there is a risk of the symptoms returning. */
    Remission,
    /** **resolved**

Resolved. The subject is no longer experiencing the symptoms of the condition and there is a negligible perceived risk of the symptoms returning. */
    Resolved,
}
impl ::core::str::FromStr for ConditionClinicalStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "recurrence" => Ok(Self::Recurrence),
            "relapse" => Ok(Self::Relapse),
            "remission" => Ok(Self::Remission),
            "resolved" => Ok(Self::Resolved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionClinicalStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Recurrence => "recurrence",
            Self::Relapse => "relapse",
            Self::Remission => "remission",
            Self::Resolved => "resolved",
        }
    }
}
impl ::std::fmt::Debug for ConditionClinicalStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConditionClinicalStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConditionClinicalStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionClinicalStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionClinicalStatusCodes> for Coding {
    fn from(code: ConditionClinicalStatusCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/condition-clinical".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConditionClinicalStatusCodes> for CodeableConcept {
    fn from(code: ConditionClinicalStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConditionVerificationStatus](http://hl7.org/fhir/ValueSet/condition-ver-status)**. The verification status to support or decline the clinical status of the condition or diagnosis.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConditionVerificationStatus {
    /** **confirmed**

Confirmed. There is sufficient diagnostic and/or clinical evidence to treat this as a confirmed condition. */
    Confirmed,
    /** **differential**

Differential. One of a set of potential (and typically mutually exclusive) diagnoses asserted to further guide the diagnostic process and preliminary treatment. */
    Differential,
    /** **entered-in-error**

Entered in Error. The statement was entered in error and is not valid. */
    EnteredInError,
    /** **provisional**

Provisional. This is a tentative diagnosis - still a candidate that is under consideration. */
    Provisional,
    /** **refuted**

Refuted. This condition has been ruled out by diagnostic and clinical evidence. */
    Refuted,
    /** **unconfirmed**

Unconfirmed. There is not sufficient diagnostic and/or clinical evidence to treat this as a confirmed condition. */
    Unconfirmed,
}
impl ::core::str::FromStr for ConditionVerificationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(Self::Confirmed),
            "differential" => Ok(Self::Differential),
            "entered-in-error" => Ok(Self::EnteredInError),
            "provisional" => Ok(Self::Provisional),
            "refuted" => Ok(Self::Refuted),
            "unconfirmed" => Ok(Self::Unconfirmed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionVerificationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confirmed => "confirmed",
            Self::Differential => "differential",
            Self::EnteredInError => "entered-in-error",
            Self::Provisional => "provisional",
            Self::Refuted => "refuted",
            Self::Unconfirmed => "unconfirmed",
        }
    }
}
impl ::std::fmt::Debug for ConditionVerificationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConditionVerificationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConditionVerificationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionVerificationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionVerificationStatus> for Coding {
    fn from(code: ConditionVerificationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/condition-ver-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConditionVerificationStatus> for CodeableConcept {
    fn from(code: ConditionVerificationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConditionalDeleteStatus](http://hl7.org/fhir/ValueSet/conditional-delete-status)**. A code that indicates how the server supports conditional delete.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConditionalDeleteStatus {
    /** **multiple**

Multiple Deletes Supported. Conditional deletes are supported, and multiple resources can be deleted in a single interaction. */
    Multiple,
    /** **not-supported**

Not Supported. No support for conditional deletes. */
    NotSupported,
    /** **single**

Single Deletes Supported. Conditional deletes are supported, but only single resources at a time. */
    Single,
}
impl ::core::str::FromStr for ConditionalDeleteStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "multiple" => Ok(Self::Multiple),
            "not-supported" => Ok(Self::NotSupported),
            "single" => Ok(Self::Single),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionalDeleteStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Multiple => "multiple",
            Self::NotSupported => "not-supported",
            Self::Single => "single",
        }
    }
}
impl ::std::fmt::Debug for ConditionalDeleteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConditionalDeleteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConditionalDeleteStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionalDeleteStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionalDeleteStatus> for Coding {
    fn from(code: ConditionalDeleteStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/conditional-delete-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConditionalDeleteStatus> for CodeableConcept {
    fn from(code: ConditionalDeleteStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConditionalReadStatus](http://hl7.org/fhir/ValueSet/conditional-read-status)**. A code that indicates how the server supports conditional read.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConditionalReadStatus {
    /** **full-support**

Full Support. Conditional reads are supported, with both If-Modified-Since and If-None-Match HTTP Headers. */
    FullSupport,
    /** **modified-since**

If-Modified-Since. Conditional reads are supported, but only with the If-Modified-Since HTTP Header. */
    ModifiedSince,
    /** **not-match**

If-None-Match. Conditional reads are supported, but only with the If-None-Match HTTP Header. */
    NotMatch,
    /** **not-supported**

Not Supported. No support for conditional reads. */
    NotSupported,
}
impl ::core::str::FromStr for ConditionalReadStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "full-support" => Ok(Self::FullSupport),
            "modified-since" => Ok(Self::ModifiedSince),
            "not-match" => Ok(Self::NotMatch),
            "not-supported" => Ok(Self::NotSupported),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionalReadStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::FullSupport => "full-support",
            Self::ModifiedSince => "modified-since",
            Self::NotMatch => "not-match",
            Self::NotSupported => "not-supported",
        }
    }
}
impl ::std::fmt::Debug for ConditionalReadStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConditionalReadStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConditionalReadStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionalReadStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionalReadStatus> for Coding {
    fn from(code: ConditionalReadStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/conditional-read-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConditionalReadStatus> for CodeableConcept {
    fn from(code: ConditionalReadStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConsentActionCodes](http://terminology.hl7.org/CodeSystem/consentaction)**. This value set includes example Consent Action codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ConsentActionCodes {
    /** **access**

Access. Retrieval without permitting collection, use or disclosure. e.g., no screen-scraping for collection, use or disclosure (view-only access) */
    Access,
    /** **collect**

Collect. Gather retrieved information for storage */
    Collect,
    /** **correct**

Access and Correct. Allow retrieval of a patient's information for the purpose of update or rectify */
    Correct,
    /** **disclose**

Disclose. Transfer retrieved information */
    Disclose,
    /** **use**

Use. Utilize the retrieved information */
    Use,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConsentActionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "access" => Ok(Self::Access),
            "collect" => Ok(Self::Collect),
            "correct" => Ok(Self::Correct),
            "disclose" => Ok(Self::Disclose),
            "use" => Ok(Self::Use),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConsentActionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Access => "access",
            Self::Collect => "collect",
            Self::Correct => "correct",
            Self::Disclose => "disclose",
            Self::Use => "use",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ConsentActionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConsentActionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConsentActionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentActionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentActionCodes> for Coding {
    fn from(code: ConsentActionCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/consentaction".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConsentActionCodes> for CodeableConcept {
    fn from(code: ConsentActionCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConsentCategoryCodes](http://terminology.hl7.org/CodeSystem/consentcategorycodes)**. FHIR Specific Example codes for Consent Category\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ConsentCategoryCodes {
    /** **acd**

Advance Directive. Any instructions, written or given verbally by a patient to a health care provider in anticipation of potential need for medical treatment. [2005 Honor My Wishes] */
    Acd,
    /** **dnr**

Do Not Resuscitate. A legal document, signed by both the patient and their provider, stating a desire not to have CPR initiated in case of a cardiac event. Note: This form was replaced in 2003 with the Physician Orders for Life-Sustaining Treatment [POLST]. */
    Dnr,
    /** **emrgonly**

Emergency Only. Opt-in to disclosure of health information for emergency only consent directive. Comment: This general consent directive specifically limits disclosure of health information for purpose of emergency treatment. Additional parameters may further limit the disclosure to specific users, roles, duration, types of information, and impose uses obligations. [ActConsentDirective (2.16.840.1.113883.1.11.20425)] */
    Emrgonly,
    /** **hcd**

Health Care Directive. Patient's document telling patient's health care provider what the patient wants or does not want if the patient is diagnosed as being terminally ill and in a persistent vegetative state or in a permanently unconscious condition.[2005 Honor My Wishes] */
    Hcd,
    /** **npp**

Notice of Privacy Practices. Acknowledgement of custodian notice of privacy practices. Usage Notes: This type of consent directive acknowledges a custodian's notice of privacy practices including its permitted collection, access, use and disclosure of health information to users and for purposes of use specified. [ActConsentDirective (2.16.840.1.113883.1.11.20425)] */
    Npp,
    /** **polst**

POLST. The Physician Order for Life-Sustaining Treatment form records a person's health care wishes for end of life emergency treatment and translates them into an order by the physician. It must be reviewed and signed by both the patient and the physician, Advanced Registered Nurse Practitioner or Physician Assistant. [2005 Honor My Wishes] Comment: Opt-in Consent Directive with restrictions. */
    Polst,
    /** **research**

Research Information Access. Consent to have healthcare information in an electronic health record accessed for research purposes. [VALUE SET: ActConsentType (2.16.840.1.113883.1.11.19897)] */
    Research,
    /** **rsdid**

De-identified Information Access. Consent to have de-identified healthcare information in an electronic health record that is accessed for research purposes, but without consent to re-identify the information under any circumstance. [VALUE SET: ActConsentType (2.16.840.1.113883.1.11.19897) */
    Rsdid,
    /** **rsreid**

Re-identifiable Information Access. Consent to have de-identified healthcare information in an electronic health record that is accessed for research purposes re-identified under specific circumstances outlined in the consent. [VALUE SET: ActConsentType (2.16.840.1.113883.1.11.19897)] */
    Rsreid,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConsentCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acd" => Ok(Self::Acd),
            "dnr" => Ok(Self::Dnr),
            "emrgonly" => Ok(Self::Emrgonly),
            "hcd" => Ok(Self::Hcd),
            "npp" => Ok(Self::Npp),
            "polst" => Ok(Self::Polst),
            "research" => Ok(Self::Research),
            "rsdid" => Ok(Self::Rsdid),
            "rsreid" => Ok(Self::Rsreid),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConsentCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acd => "acd",
            Self::Dnr => "dnr",
            Self::Emrgonly => "emrgonly",
            Self::Hcd => "hcd",
            Self::Npp => "npp",
            Self::Polst => "polst",
            Self::Research => "research",
            Self::Rsdid => "rsdid",
            Self::Rsreid => "rsreid",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ConsentCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConsentCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConsentCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentCategoryCodes> for Coding {
    fn from(code: ConsentCategoryCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/consentcategorycodes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConsentCategoryCodes> for CodeableConcept {
    fn from(code: ConsentCategoryCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConsentDataMeaning](http://hl7.org/fhir/ValueSet/consent-data-meaning)**. How a resource reference is interpreted when testing consent restrictions.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConsentDataMeaning {
    /** **authoredby**

AuthoredBy. The consent applies to instances of resources that are authored by. */
    Authoredby,
    /** **dependents**

Dependents. The consent applies directly to the instance of the resource and instances that refer to it. */
    Dependents,
    /** **instance**

Instance. The consent applies directly to the instance of the resource. */
    Instance,
    /** **related**

Related. The consent applies directly to the instance of the resource and instances it refers to. */
    Related,
}
impl ::core::str::FromStr for ConsentDataMeaning {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "authoredby" => Ok(Self::Authoredby),
            "dependents" => Ok(Self::Dependents),
            "instance" => Ok(Self::Instance),
            "related" => Ok(Self::Related),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentDataMeaning {
    fn as_ref(&self) -> &str {
        match self {
            Self::Authoredby => "authoredby",
            Self::Dependents => "dependents",
            Self::Instance => "instance",
            Self::Related => "related",
        }
    }
}
impl ::std::fmt::Debug for ConsentDataMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConsentDataMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConsentDataMeaning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentDataMeaning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentDataMeaning> for Coding {
    fn from(code: ConsentDataMeaning) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/consent-data-meaning".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConsentDataMeaning> for CodeableConcept {
    fn from(code: ConsentDataMeaning) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConsentProvisionType](http://hl7.org/fhir/ValueSet/consent-provision-type)**. How a rule statement is applied, such as adding additional consent or removing consent.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConsentProvisionType {
    /** **deny**

Opt Out. Consent is denied for actions meeting these rules. */
    Deny,
    /** **permit**

Opt In. Consent is provided for actions meeting these rules. */
    Permit,
}
impl ::core::str::FromStr for ConsentProvisionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deny" => Ok(Self::Deny),
            "permit" => Ok(Self::Permit),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentProvisionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deny => "deny",
            Self::Permit => "permit",
        }
    }
}
impl ::std::fmt::Debug for ConsentProvisionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConsentProvisionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConsentProvisionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentProvisionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentProvisionType> for Coding {
    fn from(code: ConsentProvisionType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/consent-provision-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConsentProvisionType> for CodeableConcept {
    fn from(code: ConsentProvisionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConsentScopeCodes](http://terminology.hl7.org/CodeSystem/consentscope)**. This value set includes the current scopes for the Consent resources.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ConsentScopeCodes {
    /** **adr**

Advanced Care Directive. Actions to be taken if they are no longer able to make decisions for themselves */
    Adr,
    /** **patient-privacy**

Privacy Consent. Agreement to collect, access, use or disclose (share) information */
    PatientPrivacy,
    /** **research**

Research. Consent to participate in research protocol and information sharing required */
    Research,
    /** **treatment**

Treatment. Consent to undergo a specific treatment */
    Treatment,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConsentScopeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "adr" => Ok(Self::Adr),
            "patient-privacy" => Ok(Self::PatientPrivacy),
            "research" => Ok(Self::Research),
            "treatment" => Ok(Self::Treatment),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConsentScopeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adr => "adr",
            Self::PatientPrivacy => "patient-privacy",
            Self::Research => "research",
            Self::Treatment => "treatment",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ConsentScopeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConsentScopeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConsentScopeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentScopeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentScopeCodes> for Coding {
    fn from(code: ConsentScopeCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/consentscope".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConsentScopeCodes> for CodeableConcept {
    fn from(code: ConsentScopeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConsentState](http://hl7.org/fhir/ValueSet/consent-state-codes)**. Indicates the state of the consent.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConsentState {
    /** **active**

Active. The consent is to be followed and enforced. */
    Active,
    /** **draft**

Pending. The consent is in development or awaiting use but is not yet intended to be acted upon. */
    Draft,
    /** **entered-in-error**

Entered in Error. The consent was created wrongly (e.g. wrong patient) and should be ignored. */
    EnteredInError,
    /** **inactive**

Inactive. The consent is terminated or replaced. */
    Inactive,
    /** **proposed**

Proposed. The consent has been proposed but not yet agreed to by all parties. The negotiation stage. */
    Proposed,
    /** **rejected**

Rejected. The consent has been rejected by one or more of the parties. */
    Rejected,
}
impl ::core::str::FromStr for ConsentState {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "proposed" => Ok(Self::Proposed),
            "rejected" => Ok(Self::Rejected),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Proposed => "proposed",
            Self::Rejected => "rejected",
        }
    }
}
impl ::std::fmt::Debug for ConsentState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConsentState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConsentState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentState> for Coding {
    fn from(code: ConsentState) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/consent-state-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConsentState> for CodeableConcept {
    fn from(code: ConsentState) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ConstraintSeverity](http://hl7.org/fhir/ValueSet/constraint-severity)**. SHALL applications comply with this constraint?\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ConstraintSeverity {
    /** **error**

Error. If the constraint is violated, the resource is not conformant. */
    Error,
    /** **warning**

Warning. If the constraint is violated, the resource is conformant, but it is not necessarily following best practice. */
    Warning,
}
impl ::core::str::FromStr for ConstraintSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConstraintSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Debug for ConstraintSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ConstraintSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ConstraintSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConstraintSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConstraintSeverity> for Coding {
    fn from(code: ConstraintSeverity) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/constraint-severity".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ConstraintSeverity> for CodeableConcept {
    fn from(code: ConstraintSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContactEntityType](http://terminology.hl7.org/CodeSystem/contactentity-type)**. This example value set defines a set of codes that can be used to indicate the purpose for which you would contact a contact party.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContactEntityType {
    /** **ADMIN**

Administrative. Contact details for administrative enquiries. */
    Admin,
    /** **BILL**

Billing. Contact details for information regarding to billing/general finance enquiries. */
    Bill,
    /** **HR**

Human Resource. Contact details for issues related to Human Resources, such as staff matters, OH&S etc. */
    Hr,
    /** **PATINF**

Patient. Generic information contact for patients. */
    Patinf,
    /** **PAYOR**

Payor. Contact details for dealing with issues related to insurance claims/adjudication/payment. */
    Payor,
    /** **PRESS**

Press. Dedicated contact point for matters relating to press enquiries. */
    Press,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContactEntityType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ADMIN" => Ok(Self::Admin),
            "BILL" => Ok(Self::Bill),
            "HR" => Ok(Self::Hr),
            "PATINF" => Ok(Self::Patinf),
            "PAYOR" => Ok(Self::Payor),
            "PRESS" => Ok(Self::Press),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContactEntityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Admin => "ADMIN",
            Self::Bill => "BILL",
            Self::Hr => "HR",
            Self::Patinf => "PATINF",
            Self::Payor => "PAYOR",
            Self::Press => "PRESS",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContactEntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContactEntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContactEntityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactEntityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContactEntityType> for Coding {
    fn from(code: ContactEntityType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/contactentity-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContactEntityType> for CodeableConcept {
    fn from(code: ContactEntityType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContactPointSystem](http://hl7.org/fhir/ValueSet/contact-point-system)**. Telecommunications form for contact point.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContactPointSystem {
    /** **email**

Email. The value is an email address. */
    Email,
    /** **fax**

Fax. The value is a fax machine. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required. */
    Fax,
    /** **other**

Other. A contact that is not a phone, fax, page or email address and is not expressible as a URL.  E.g. Internal mail address.  This SHOULD NOT be used for contacts that are expressible as a URL (e.g. Skype, Twitter, Facebook, etc.)  Extensions may be used to distinguish "other" contact types. */
    Other,
    /** **pager**

Pager. The value is a pager number. These may be local pager numbers that are only usable on a particular pager system. */
    Pager,
    /** **phone**

Phone. The value is a telephone number used for voice calls. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required. */
    Phone,
    /** **sms**

SMS. A contact that can be used for sending an sms message (e.g. mobile phones, some landlines). */
    Sms,
    /** **url**

URL. A contact that is not a phone, fax, pager or email address and is expressed as a URL.  This is intended for various institutional or personal contacts including web sites, blogs, Skype, Twitter, Facebook, etc. Do not use for email addresses. */
    Url,
}
impl ::core::str::FromStr for ContactPointSystem {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "email" => Ok(Self::Email),
            "fax" => Ok(Self::Fax),
            "other" => Ok(Self::Other),
            "pager" => Ok(Self::Pager),
            "phone" => Ok(Self::Phone),
            "sms" => Ok(Self::Sms),
            "url" => Ok(Self::Url),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContactPointSystem {
    fn as_ref(&self) -> &str {
        match self {
            Self::Email => "email",
            Self::Fax => "fax",
            Self::Other => "other",
            Self::Pager => "pager",
            Self::Phone => "phone",
            Self::Sms => "sms",
            Self::Url => "url",
        }
    }
}
impl ::std::fmt::Debug for ContactPointSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContactPointSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContactPointSystem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactPointSystem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContactPointSystem> for Coding {
    fn from(code: ContactPointSystem) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/contact-point-system".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContactPointSystem> for CodeableConcept {
    fn from(code: ContactPointSystem) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContactPointUse](http://hl7.org/fhir/ValueSet/contact-point-use)**. Use of contact point.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContactPointUse {
    /** **home**

Home. A communication contact point at a home; attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available. */
    Home,
    /** **mobile**

Mobile. A telecommunication device that moves and stays with its owner. May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business. */
    Mobile,
    /** **old**

Old. This contact point is no longer in use (or was never correct, but retained for records). */
    Old,
    /** **temp**

Temp. A temporary contact point. The period can provide more detailed information. */
    Temp,
    /** **work**

Work. An office contact point. First choice for business related contacts during business hours. */
    Work,
}
impl ::core::str::FromStr for ContactPointUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "home" => Ok(Self::Home),
            "mobile" => Ok(Self::Mobile),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "work" => Ok(Self::Work),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContactPointUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Home => "home",
            Self::Mobile => "mobile",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Work => "work",
        }
    }
}
impl ::std::fmt::Debug for ContactPointUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContactPointUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContactPointUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactPointUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContactPointUse> for Coding {
    fn from(code: ContactPointUse) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/contact-point-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContactPointUse> for CodeableConcept {
    fn from(code: ContactPointUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContainerCap](http://hl7.org/fhir/ValueSet/container-cap)**. Color of the container cap.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContainerCap {
    /** **black**

black cap. black cap. */
    Black,
    /** **brown**

brown cap. brown cap. */
    Brown,
    /** **dark-yellow**

dark yellow cap. dark yellow cap. */
    DarkYellow,
    /** **green**

green cap. green cap. */
    Green,
    /** **grey**

grey cap. grey cap. */
    Grey,
    /** **lavender**

lavender cap. lavender cap. */
    Lavender,
    /** **light-blue**

light blue cap. light blue cap. */
    LightBlue,
    /** **light-green**

light green cap. light green cap. */
    LightGreen,
    /** **pink**

pink cap. pink cap. */
    Pink,
    /** **red**

red cap. red cap. */
    Red,
    /** **white**

white cap. white cap. */
    White,
    /** **yellow**

yellow cap. yellow cap. */
    Yellow,
}
impl ::core::str::FromStr for ContainerCap {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "black" => Ok(Self::Black),
            "brown" => Ok(Self::Brown),
            "dark-yellow" => Ok(Self::DarkYellow),
            "green" => Ok(Self::Green),
            "grey" => Ok(Self::Grey),
            "lavender" => Ok(Self::Lavender),
            "light-blue" => Ok(Self::LightBlue),
            "light-green" => Ok(Self::LightGreen),
            "pink" => Ok(Self::Pink),
            "red" => Ok(Self::Red),
            "white" => Ok(Self::White),
            "yellow" => Ok(Self::Yellow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContainerCap {
    fn as_ref(&self) -> &str {
        match self {
            Self::Black => "black",
            Self::Brown => "brown",
            Self::DarkYellow => "dark-yellow",
            Self::Green => "green",
            Self::Grey => "grey",
            Self::Lavender => "lavender",
            Self::LightBlue => "light-blue",
            Self::LightGreen => "light-green",
            Self::Pink => "pink",
            Self::Red => "red",
            Self::White => "white",
            Self::Yellow => "yellow",
        }
    }
}
impl ::std::fmt::Debug for ContainerCap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContainerCap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContainerCap {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContainerCap {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContainerCap> for Coding {
    fn from(code: ContainerCap) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/container-cap".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContainerCap> for CodeableConcept {
    fn from(code: ContainerCap) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractActionCodes](http://hl7.org/fhir/contract-action)**. This value set includes sample Contract Action codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractActionCodes {
    /** **action-a**

Action A. Definition for Action A */
    ActionA,
    /** **action-b**

Action B. Definition for Action B */
    ActionB,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractActionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "action-a" => Ok(Self::ActionA),
            "action-b" => Ok(Self::ActionB),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractActionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActionA => "action-a",
            Self::ActionB => "action-b",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractActionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractActionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractActionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractActionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractActionCodes> for Coding {
    fn from(code: ContractActionCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-action".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractActionCodes> for CodeableConcept {
    fn from(code: ContractActionCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractActionStatus](http://hl7.org/fhir/contract-actionstatus)**. This CodeSystem contains FHIR-defined contract action status types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractActionStatus {
    /** **complete**

Complete. To be completed */
    Complete,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractActionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractActionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractActionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractActionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractActionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractActionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractActionStatus> for Coding {
    fn from(code: ContractActionStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-actionstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractActionStatus> for CodeableConcept {
    fn from(code: ContractActionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractActorRoleCodes](http://hl7.org/fhir/contract-actorrole)**. This value set includes sample Contract Actor Role codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractActorRoleCodes {
    /** **patient**

Patient. A receiver, human or animal, of health care related goods and services. */
    Patient,
    /** **practitioner**

Practitioner. Someone who provides health care related services to people or animals including both clinical and support services. */
    Practitioner,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractActorRoleCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "patient" => Ok(Self::Patient),
            "practitioner" => Ok(Self::Practitioner),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractActorRoleCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Patient => "patient",
            Self::Practitioner => "practitioner",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractActorRoleCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractActorRoleCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractActorRoleCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractActorRoleCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractActorRoleCodes> for Coding {
    fn from(code: ContractActorRoleCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-actorrole".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractActorRoleCodes> for CodeableConcept {
    fn from(code: ContractActorRoleCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractAssetAvailability](http://hl7.org/fhir/asset-availability)**. This CodeSystem contains FHIR-defined contract asset availability types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractAssetAvailability {
    /** **lease**

Lease. To be completed */
    Lease,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetAvailability {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "lease" => Ok(Self::Lease),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetAvailability {
    fn as_ref(&self) -> &str {
        match self {
            Self::Lease => "lease",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractAssetAvailability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractAssetAvailability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractAssetAvailability {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetAvailability {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetAvailability> for Coding {
    fn from(code: ContractAssetAvailability) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/asset-availability".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractAssetAvailability> for CodeableConcept {
    fn from(code: ContractAssetAvailability) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractAssetContext](http://hl7.org/fhir/contract-assetcontext)**. This CodeSystem contains FHIR-defined contract asset context types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractAssetContext {
    /** **custodian**

Custodian. To be completed */
    Custodian,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetContext {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "custodian" => Ok(Self::Custodian),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetContext {
    fn as_ref(&self) -> &str {
        match self {
            Self::Custodian => "custodian",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractAssetContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractAssetContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractAssetContext {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetContext {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetContext> for Coding {
    fn from(code: ContractAssetContext) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-assetcontext".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractAssetContext> for CodeableConcept {
    fn from(code: ContractAssetContext) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractAssetScope](http://hl7.org/fhir/contract-assetscope)**. This CodeSystem contains FHIR-defined contract asset scope types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractAssetScope {
    /** **thing**

Thing. To be completed */
    Thing,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetScope {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "thing" => Ok(Self::Thing),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetScope {
    fn as_ref(&self) -> &str {
        match self {
            Self::Thing => "thing",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractAssetScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractAssetScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractAssetScope {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetScope {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetScope> for Coding {
    fn from(code: ContractAssetScope) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-assetscope".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractAssetScope> for CodeableConcept {
    fn from(code: ContractAssetScope) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractAssetSubtype](http://hl7.org/fhir/contract-assetsubtype)**. This CodeSystem contains FHIR-defined contract asset type sub-types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractAssetSubtype {
    /** **participation**

Participation. To be completed */
    Participation,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetSubtype {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "participation" => Ok(Self::Participation),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetSubtype {
    fn as_ref(&self) -> &str {
        match self {
            Self::Participation => "participation",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractAssetSubtype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractAssetSubtype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractAssetSubtype {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetSubtype {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetSubtype> for Coding {
    fn from(code: ContractAssetSubtype) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-assetsubtype".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractAssetSubtype> for CodeableConcept {
    fn from(code: ContractAssetSubtype) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractAssetType](http://hl7.org/fhir/contract-assettype)**. This CodeSystem contains FHIR-defined contract asset type types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractAssetType {
    /** **participation**

Participation. To be completed */
    Participation,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "participation" => Ok(Self::Participation),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Participation => "participation",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractAssetType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractAssetType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractAssetType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetType> for Coding {
    fn from(code: ContractAssetType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-assettype".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractAssetType> for CodeableConcept {
    fn from(code: ContractAssetType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractContentDerivative](http://hl7.org/fhir/contract-content-derivative)**. This is an example set of Content Derivative type codes, which represent the minimal content derived from the basal information source at a specific stage in its lifecycle, which is sufficient to manage that source information, for example, in a repository, registry, processes and workflows, for making access control decisions, and providing query responses.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractContentDerivative {
    /** **registration**

Content Registration. Content derivative that conveys sufficient information needed to register the source basal content from which it is derived.  This derivative content may be used to register the basal content as it changes status in its lifecycle.  For example, content registration may occur when the basal content is created, updated, inactive, or deleted. */
    Registration,
    /** **retrieval**

Content Retrieval. A content derivative that conveys sufficient information to locate and retrieve the content. */
    Retrieval,
    /** **shareable**

Shareable Content. A Content Derivative that conveys sufficient information to determine the authorized entities with which the content may be shared. */
    Shareable,
    /** **statement**

Content Statement. Content derivative that has less than full fidelity to the basal information source from which it was 'transcribed'. It provides recipients with the full content representation they may require for compliance purposes, and typically include a reference to or an attached unstructured representation for recipients needing an exact copy of the legal agreement. */
    Statement,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractContentDerivative {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "registration" => Ok(Self::Registration),
            "retrieval" => Ok(Self::Retrieval),
            "shareable" => Ok(Self::Shareable),
            "statement" => Ok(Self::Statement),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractContentDerivative {
    fn as_ref(&self) -> &str {
        match self {
            Self::Registration => "registration",
            Self::Retrieval => "retrieval",
            Self::Shareable => "shareable",
            Self::Statement => "statement",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractContentDerivative {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractContentDerivative {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractContentDerivative {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractContentDerivative {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractContentDerivative> for Coding {
    fn from(code: ContractContentDerivative) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-content-derivative".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractContentDerivative> for CodeableConcept {
    fn from(code: ContractContentDerivative) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractDecisionMode](http://hl7.org/fhir/contract-decision-mode)**. This CodeSystem contains FHIR-defined contract decision mode types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractDecisionMode {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractDecisionMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractDecisionMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractDecisionMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractDecisionMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractDecisionMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractDecisionMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractDecisionMode> for Coding {
    fn from(code: ContractDecisionMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-decision-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractDecisionMode> for CodeableConcept {
    fn from(code: ContractDecisionMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractDefinitionSubtype](http://hl7.org/fhir/contract-definition-subtype)**. This CodeSystem contains FHIR-defined contract definition subtypes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractDefinitionSubtype {
    /** **temp**

Temporary Value. To be completed */
    Temp,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractDefinitionSubtype {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "temp" => Ok(Self::Temp),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractDefinitionSubtype {
    fn as_ref(&self) -> &str {
        match self {
            Self::Temp => "temp",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractDefinitionSubtype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractDefinitionSubtype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractDefinitionSubtype {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractDefinitionSubtype {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractDefinitionSubtype> for Coding {
    fn from(code: ContractDefinitionSubtype) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-definition-subtype".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractDefinitionSubtype> for CodeableConcept {
    fn from(code: ContractDefinitionSubtype) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractDefinitionType](http://hl7.org/fhir/contract-definition-type)**. This CodeSystem contains FHIR-defined contract definition types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractDefinitionType {
    /** **temp**

Temporary Value. To be completed */
    Temp,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractDefinitionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "temp" => Ok(Self::Temp),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractDefinitionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Temp => "temp",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractDefinitionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractDefinitionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractDefinitionType> for Coding {
    fn from(code: ContractDefinitionType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-definition-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractDefinitionType> for CodeableConcept {
    fn from(code: ContractDefinitionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractExpirationType](http://hl7.org/fhir/contract-expiration-type)**. This CodeSystem contains FHIR-defined contract Expiration types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractExpirationType {
    /** **breach**

Breach. To be completed */
    Breach,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractExpirationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "breach" => Ok(Self::Breach),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractExpirationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Breach => "breach",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractExpirationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractExpirationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractExpirationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractExpirationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractExpirationType> for Coding {
    fn from(code: ContractExpirationType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-expiration-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractExpirationType> for CodeableConcept {
    fn from(code: ContractExpirationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractLegalState](http://hl7.org/fhir/contract-legalstate)**. This CodeSystem contains FHIR-defined contract status types. Each definition includes usage notes explaining the precedence order in contract lifecycle - i.e., while only some stages are required, the order in which they may occur is deterministic; and a map to comparable FHIR and v.3 status codes. It follows guidance about use of status codes in FHIR at http://build.fhir.org/sc.html.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractLegalState {
    /** **amended**

Amended. Contract is augmented with additional information to correct errors in a predecessor or to updated values in a predecessor. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: revised; replaced. */
    Amended,
    /** **appended**

Appended. Contract is augmented with additional information that was missing from a predecessor Contract. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: updated, replaced. */
    Appended,
    /** **cancelled**

Cancelled. Contract is terminated due to failure of the Grantor and/or the Grantee to fulfil one or more contract provisions. Usage: Abnormal contract termination. Precedence Order = 10. Comparable FHIR and v.3 status codes: stopped; failed; aborted. */
    Cancelled,
    /** **disputed**

Disputed. Contract is pended to rectify failure of the Grantor or the Grantee to fulfil contract provision(s). E.g., Grantee complaint about Grantor's failure to comply with contract provisions. Usage: Contract pended. Precedence Order = 7. Comparable FHIR and v.3 status codes: on hold; pended; suspended. */
    Disputed,
    /** **entered-in-error**

Entered in Error. Contract was created in error. No Precedence Order.  Status may be applied to a Contract with any status. */
    EnteredInError,
    /** **executable**

Executable. Contract execution pending; may be executed when either the Grantor or the Grantee accepts the contract provisions by signing. I.e., where either the Grantor or the Grantee has signed, but not both. E.g., when an insurance applicant signs the insurers application, which references the policy. Usage: Optional first step of contract execution activity.  May be skipped and contracting activity moves directly to executed state. Precedence Order = 3. Comparable FHIR and v.3 status codes: draft; preliminary; planned; intended; active. */
    Executable,
    /** **executed**

Executed. Contract is activated for period stipulated when both the Grantor and Grantee have signed it. Usage: Required state for normal completion of contracting activity.  Precedence Order = 6. Comparable FHIR and v.3 status codes: accepted; completed. */
    Executed,
    /** **negotiable**

Negotiable. Contract execution is suspended while either or both the Grantor and Grantee propose and consider new or revised contract provisions. I.e., where the party which has not signed proposes changes to the terms.  E .g., a life insurer declines to agree to the signed application because the life insurer has evidence that the applicant, who asserted to being younger or a non-smoker to get a lower premium rate - but offers instead to agree to a higher premium based on the applicants actual age or smoking status. Usage: Optional contract activity between executable and executed state. Precedence Order = 4. Comparable FHIR and v.3 status codes: in progress; review; held. */
    Negotiable,
    /** **offered**

Offered. Contract is a proposal by either the Grantor or the Grantee. Aka - A Contract hard copy or electronic 'template', 'form' or 'application'. E.g., health insurance application; consent directive form. Usage: Beginning of contract negotiation, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 2. Comparable FHIR and v.3 status codes: requested; new. */
    Offered,
    /** **policy**

Policy. Contract template is available as the basis for an application or offer by the Grantor or Grantee. E.g., health insurance policy; consent directive policy.  Usage: Required initial contract activity, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 1. Comparable FHIR and v.3 status codes: proposed; intended. */
    Policy,
    /** **rejected**

Rejected.  Execution of the Contract is not completed because either or both the Grantor and Grantee decline to accept some or all of the contract provisions. Usage: Optional contract activity between executable and abnormal termination. Precedence Order = 5. Comparable FHIR and v.3 status codes:  stopped; cancelled. */
    Rejected,
    /** **renewed**

Renewed. Beginning of a successor Contract at the termination of predecessor Contract lifecycle. Usage: Follows termination of a preceding Contract that has reached its expiry date. Precedence Order = 13. Comparable FHIR and v.3 status codes: superseded. */
    Renewed,
    /** **resolved**

Resolved. Contract is reactivated after being pended because of faulty execution. *E.g., competency of the signer(s), or where the policy is substantially different from and did not accompany the application/form so that the applicant could not compare them. Aka - ''reactivated''. Usage: Optional stage where a pended contract is reactivated. Precedence Order = 8. Comparable FHIR and v.3 status codes: reactivated. */
    Resolved,
    /** **revoked**

Revoked. A Contract that is rescinded.  May be required prior to replacing with an updated Contract. Comparable FHIR and v.3 status codes: nullified. */
    Revoked,
    /** **terminated**

Terminated. Contract reaches its expiry date. It might or might not be renewed or renegotiated. Usage: Normal end of contract period. Precedence Order = 12. Comparable FHIR and v.3 status codes: Obsoleted. */
    Terminated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractLegalState {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "disputed" => Ok(Self::Disputed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "executable" => Ok(Self::Executable),
            "executed" => Ok(Self::Executed),
            "negotiable" => Ok(Self::Negotiable),
            "offered" => Ok(Self::Offered),
            "policy" => Ok(Self::Policy),
            "rejected" => Ok(Self::Rejected),
            "renewed" => Ok(Self::Renewed),
            "resolved" => Ok(Self::Resolved),
            "revoked" => Ok(Self::Revoked),
            "terminated" => Ok(Self::Terminated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractLegalState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Disputed => "disputed",
            Self::EnteredInError => "entered-in-error",
            Self::Executable => "executable",
            Self::Executed => "executed",
            Self::Negotiable => "negotiable",
            Self::Offered => "offered",
            Self::Policy => "policy",
            Self::Rejected => "rejected",
            Self::Renewed => "renewed",
            Self::Resolved => "resolved",
            Self::Revoked => "revoked",
            Self::Terminated => "terminated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractLegalState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractLegalState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractLegalState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractLegalState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractLegalState> for Coding {
    fn from(code: ContractLegalState) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-legalstate".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractLegalState> for CodeableConcept {
    fn from(code: ContractLegalState) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractPartyRole](http://hl7.org/fhir/contract-party-role)**. This CodeSystem contains FHIR-defined contract party role types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractPartyRole {
    /** **flunky**

FLunky. To be completed */
    Flunky,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractPartyRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "flunky" => Ok(Self::Flunky),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractPartyRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Flunky => "flunky",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractPartyRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractPartyRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractPartyRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractPartyRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractPartyRole> for Coding {
    fn from(code: ContractPartyRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-party-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractPartyRole> for CodeableConcept {
    fn from(code: ContractPartyRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractPublicationStatus](http://hl7.org/fhir/contract-publicationstatus)**. This CodeSystem contains FHIR-defined contract publication status types. Each definition includes usage notes explaining the precedence order in contract publication lifecycle - i.e., while only some stages are required, the order in which they may occur is deterministic.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractPublicationStatus {
    /** **amended**

Amended. Contract is augmented with additional information to correct errors in a predecessor or to updated values in a predecessor. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: revised; replaced. */
    Amended,
    /** **appended**

Appended. Contract is augmented with additional information that was missing from a predecessor Contract. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: updated, replaced. */
    Appended,
    /** **cancelled**

Cancelled. Contract is terminated due to failure of the Grantor and/or the Grantee to fulfil one or more contract provisions. Usage: Abnormal contract termination. Precedence Order = 10. Comparable FHIR and v.3 status codes: stopped; failed; aborted. */
    Cancelled,
    /** **disputed**

Disputed. Contract is pended to rectify failure of the Grantor or the Grantee to fulfil contract provision(s). E.g., Grantee complaint about Grantor's failure to comply with contract provisions. Usage: Contract pended. Precedence Order = 7. Comparable FHIR and v.3 status codes: on hold; pended; suspended. */
    Disputed,
    /** **entered-in-error**

Entered in Error. Contract was created in error. No Precedence Order.  Status may be applied to a Contract with any status. */
    EnteredInError,
    /** **executable**

Executable. Contract execution pending; may be executed when either the Grantor or the Grantee accepts the contract provisions by signing. I.e., where either the Grantor or the Grantee has signed, but not both. E.g., when an insurance applicant signs the insurers application, which references the policy. Usage: Optional first step of contract execution activity.  May be skipped and contracting activity moves directly to executed state. Precedence Order = 3. Comparable FHIR and v.3 status codes: draft; preliminary; planned; intended; active. */
    Executable,
    /** **executed**

Executed. Contract is activated for period stipulated when both the Grantor and Grantee have signed it. Usage: Required state for normal completion of contracting activity.  Precedence Order = 6. Comparable FHIR and v.3 status codes: accepted; completed. */
    Executed,
    /** **negotiable**

Negotiable. Contract execution is suspended while either or both the Grantor and Grantee propose and consider new or revised contract provisions. I.e., where the party which has not signed proposes changes to the terms.  E .g., a life insurer declines to agree to the signed application because the life insurer has evidence that the applicant, who asserted to being younger or a non-smoker to get a lower premium rate - but offers instead to agree to a higher premium based on the applicants actual age or smoking status. Usage: Optional contract activity between executable and executed state. Precedence Order = 4. Comparable FHIR and v.3 status codes: in progress; review; held. */
    Negotiable,
    /** **offered**

Offered. Contract is a proposal by either the Grantor or the Grantee. Aka - A Contract hard copy or electronic 'template', 'form' or 'application'. E.g., health insurance application; consent directive form. Usage: Beginning of contract negotiation, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 2. Comparable FHIR and v.3 status codes: requested; new. */
    Offered,
    /** **policy**

Policy. Contract template is available as the basis for an application or offer by the Grantor or Grantee. E.g., health insurance policy; consent directive policy.  Usage: Required initial contract activity, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 1. Comparable FHIR and v.3 status codes: proposed; intended. */
    Policy,
    /** **rejected**

Rejected.  Execution of the Contract is not completed because either or both the Grantor and Grantee decline to accept some or all of the contract provisions. Usage: Optional contract activity between executable and abnormal termination. Precedence Order = 5. Comparable FHIR and v.3 status codes:  stopped; cancelled. */
    Rejected,
    /** **renewed**

Renewed. Beginning of a successor Contract at the termination of predecessor Contract lifecycle. Usage: Follows termination of a preceding Contract that has reached its expiry date. Precedence Order = 13. Comparable FHIR and v.3 status codes: superseded. */
    Renewed,
    /** **resolved**

Resolved. Contract is reactivated after being pended because of faulty execution. *E.g., competency of the signer(s), or where the policy is substantially different from and did not accompany the application/form so that the applicant could not compare them. Aka - ''reactivated''. Usage: Optional stage where a pended contract is reactivated. Precedence Order = 8. Comparable FHIR and v.3 status codes: reactivated. */
    Resolved,
    /** **revoked**

Revoked. A Contract that is rescinded.  May be required prior to replacing with an updated Contract. Comparable FHIR and v.3 status codes: nullified. */
    Revoked,
    /** **terminated**

Terminated. Contract reaches its expiry date. It might or might not be renewed or renegotiated. Usage: Normal end of contract period. Precedence Order = 12. Comparable FHIR and v.3 status codes: Obsoleted. */
    Terminated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractPublicationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "disputed" => Ok(Self::Disputed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "executable" => Ok(Self::Executable),
            "executed" => Ok(Self::Executed),
            "negotiable" => Ok(Self::Negotiable),
            "offered" => Ok(Self::Offered),
            "policy" => Ok(Self::Policy),
            "rejected" => Ok(Self::Rejected),
            "renewed" => Ok(Self::Renewed),
            "resolved" => Ok(Self::Resolved),
            "revoked" => Ok(Self::Revoked),
            "terminated" => Ok(Self::Terminated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractPublicationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Disputed => "disputed",
            Self::EnteredInError => "entered-in-error",
            Self::Executable => "executable",
            Self::Executed => "executed",
            Self::Negotiable => "negotiable",
            Self::Offered => "offered",
            Self::Policy => "policy",
            Self::Rejected => "rejected",
            Self::Renewed => "renewed",
            Self::Resolved => "resolved",
            Self::Revoked => "revoked",
            Self::Terminated => "terminated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractPublicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractPublicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractPublicationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractPublicationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractPublicationStatus> for Coding {
    fn from(code: ContractPublicationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-publicationstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractPublicationStatus> for CodeableConcept {
    fn from(code: ContractPublicationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractScope](http://hl7.org/fhir/contract-scope)**. This CodeSystem contains FHIR-defined contract Expiration types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractScope {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractScope {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractScope {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractScope {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractScope {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractScope> for Coding {
    fn from(code: ContractScope) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-scope".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractScope> for CodeableConcept {
    fn from(code: ContractScope) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractSecurityCategory](http://hl7.org/fhir/contract-security-category)**. This CodeSystem contains FHIR-defined contract security category types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractSecurityCategory {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSecurityCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSecurityCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractSecurityCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractSecurityCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractSecurityCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSecurityCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractSecurityCategory> for Coding {
    fn from(code: ContractSecurityCategory) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-security-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractSecurityCategory> for CodeableConcept {
    fn from(code: ContractSecurityCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractSecurityClassification](http://hl7.org/fhir/contract-security-classification)**. This CodeSystem contains FHIR-defined contract security classification types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractSecurityClassification {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSecurityClassification {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSecurityClassification {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractSecurityClassification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractSecurityClassification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractSecurityClassification {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSecurityClassification {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractSecurityClassification> for Coding {
    fn from(code: ContractSecurityClassification) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/contract-security-classification".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractSecurityClassification> for CodeableConcept {
    fn from(code: ContractSecurityClassification) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractSecurityControl](http://hl7.org/fhir/contract-security-control)**. This CodeSystem contains FHIR-defined contract security control types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractSecurityControl {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSecurityControl {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSecurityControl {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractSecurityControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractSecurityControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractSecurityControl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSecurityControl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractSecurityControl> for Coding {
    fn from(code: ContractSecurityControl) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-security-control".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractSecurityControl> for CodeableConcept {
    fn from(code: ContractSecurityControl) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractSignerTypeCodes](http://hl7.org/fhir/contract-signer-type)**. This value set includes sample Contract Signer Type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractSignerTypeCodes {
    /** **AFFL**

Affiliate. An entity that has a business or professional relationship with another entity in accordance with an agreement. */
    Affl,
    /** **AGNT**

Agent. An entity that acts or is authorized to act on behalf of another entity in accordance with an agreement. */
    Agnt,
    /** **AMENDER**

Amender. A person who has corrected, edited, or amended pre-existing information. */
    Amender,
    /** **ASSIGNED**

Assigned Entity. An agent role in which the agent is an Entity acting in the employ of an organization. The focus is on functional role on behalf of the organization, unlike the Employee role where the focus is on the 'Human Resources' relationship between the employee and the organization. */
    Assigned,
    /** **AUT**

Author. An entity that authored specific content. There can be multiple authors of content, which may take such forms as a contract, a healthcare record entry or document, a policy, or a consent directive. */
    Aut,
    /** **AUTHN**

Authenticator. A person in the role of verifier who attests to the accuracy of an act, but who does not have privileges to legally authenticate information content. An example would be a resident physician who sees a patient and dictates a note, then later signs it. The resident's signature constitutes an authentication. */
    Authn,
    /** **CIT**

Citizen. The member of a jurisdiction afforded certain rights and encumbered with certain obligation in accordance with jurisdictional policy. */
    Cit,
    /** **CLAIMANT**

Claimant. A party that makes a claim for coverage under a policy. */
    Claimant,
    /** **COAUTH**

Co-Author. The entity that co-authored content. There can be multiple co-authors of content, which may take such forms as a contract, a healthcare record entry or document, a policy, or a consent directive. */
    Coauth,
    /** **CONSENTER**

Consenter. A patient or patient representative who is the grantee in a healthcare related agreement such as a consent for healthcare services, advanced directive, or a privacy consent directive in accordance with jurisdictional, organizational, or patient policy. */
    Consenter,
    /** **CONSWIT**

Consent Witness. A person who has witnessed and attests to observing a patient being counseled about a healthcare related agreement such as a consent for healthcare services, advanced directive, or a privacy consent directive. */
    Conswit,
    /** **CONT**

Contact. A person or an organization that provides or receives information regarding another entity. Examples; patient NOK and emergency contacts; guarantor contact; employer contact. */
    Cont,
    /** **COPART**

Co-Participant. A person who participates in the generation of and attest to veracity of content but is not an author or co-author. For example, a surgeon who is required by institutional, regulatory, or legal rules to sign an operative report, but who was not involved in the authorship of that report. */
    Copart,
    /** **COVPTY**

Covered Party. An entity, which is the insured, that receives benefits such as healthcare services, reimbursement for out-of-pocket expenses, or compensation for losses through coverage under the terms of an insurance policy. The underwriter of that policy is the scoping entity. The covered party receives coverage because of some contractual or other relationship with the holder of that policy. Note that a particular policy may cover several individuals one of whom may be, but need not be, the policy holder. Thus the notion of covered party is a role that is distinct from that of the policy holder. */
    Covpty,
    /** **DELEGATEE**

Delegatee. A party to whom some right or authority is delegated by a delegator. */
    Delegatee,
    /** **DEPEND**

Dependent. A person covered under an insurance policy or program based on an association with a subscriber, which is recognized by the policy holder. The dependent has an association with the subscriber such as a financial dependency or personal relationship such as that of a spouse, or a natural or adopted child. The policy holder may be required by law to recognize certain associations or may have discretion about the associations. For example, a policy holder may dictate the criteria for the dependent status of adult children who are students, such as requiring full time enrollment, or may recognize domestic partners as dependents. Under certain circumstances, the dependent may be under the indirect authority of a responsible party acting as a surrogate for the subscriber, for example, if the subscriber is differently-abled or deceased, a guardian ad lidem or estate executor may be appointed to assume the subscriber's legal standing in the relationship with the dependent. */
    Depend,
    /** **DPOWATT**

Durable Power of Attorney. A person who has been granted the authority to represent or act on another's behalf generally in a manner which is a legally binding upon the person giving such authority as if he or she personally were to do the acts. Unlike ordinary powers of attorney, durable powers can survive for long periods of time, and again, unlike standard powers of attorney, durable powers can continue after incompetency. */
    Dpowatt,
    /** **EMGCON**

Emergency Contact. An entity to be contacted in the event of an emergency */
    Emgcon,
    /** **EVTWIT**

Event Witness. A person who attests to observing an occurrence.  For example, the witness has observed a procedure and is attesting to this fact. */
    Evtwit,
    /** **EXCEST**

Executor of Estate. A person who has been granted the authority to act as an estate executor for a deceased person who was the responsible party. */
    Excest,
    /** **GRANTEE**

Grantee. A person who grants to another person the authority to represent or act on that person's behalf.  Examples include (1) exercising specific rights belonging to the grantee; (2) performing specific duties on behalf of a grantee; and (3) making specific decisions concerning a grantee. */
    Grantee,
    /** **GRANTOR**

Grantor. A person who has been granted the authority to represent or act on another's behalf. Examples include (1) exercising specific rights belonging to the grantee; (2) performing specific duties on behalf of a grantee; and (3) making specific decisions concerning a grantee. */
    Grantor,
    /** **GUADLTM**

Guardian ad lidem. A person appointed by the court to look out for the best interests of a minor child during the course of legal proceedings. */
    Guadltm,
    /** **GUAR**

Guarantor. A person or organization contractually recognized by the issuer as an entity that has assumed fiscal responsibility (e.g., by making or giving a promise, assurance, or pledge) for another entity's financial obligations by guaranteeing to pay for amounts owed to a particular account.  In a healthcare context, the account may be a patient's billing account for services rendered by a provider or a health plan premium account. */
    Guar,
    /** **GUARD**

Guardian. A person or organization legally empowered with responsibility for the care of a ward. */
    Guard,
    /** **HPOWATT**

Healthcare Power of Attorney. A person who has been granted the authority to represent or act on another's behalf for healthcare related matters in a manner which is a legally binding upon the person giving such authority as if he or she personally were to do the acts. Examples include (1) exercising specific healthcare legal rights belonging to the grantee such as signing a consent directive; (2) performing specific healthcare related legal duties on behalf of a grantee such as claims payment; and (3) making specific healthcare legal decisions concerning a grantee such as consenting to healthcare services. */
    Hpowatt,
    /** **HPROV**

Healthcare Provider. An entity that is authorized to provide health care services by an authorizing organization or jurisdiction. */
    Hprov,
    /** **INF**

Informant. An entity that is the source of reported information (e.g., a next of kin who answers questions about the patient's history). For history questions, the patient is logically an informant, yet the informant of history questions is implicitly the subject. */
    Inf,
    /** **INSBJ**

Investigation Subject. An entity that is the subject of an investigation. This role is scoped by the party responsible for the investigation. */
    Insbj,
    /** **INTPRT**

Interpreter. A person who converts spoken or written language into the language of key participants in an event such as when a provider is obtaining a patient's consent to treatment or permission to disclose information. */
    Intprt,
    /** **LEGAUTHN**

Legal Authenticator. A person in the role of verifier who attests to the accuracy of information content, and who has privileges to certify the legal authenticity of that content with a signature that constitutes a legal authentication.  For example, a licensed physician who signs a consult authored by a resident physician who authenticated it. */
    Legauthn,
    /** **NMDINS**

Named Insured. A party to an insurance policy under which the insurer agrees to indemnify for losses, provides benefits for, or renders services. A named insured may be either a person, non-person living subject, or an organization, or a group of persons, non-person living subject that is the named insured under a comprehensive automobile, disability, or property and casualty policy.  The named insured and might or might not be the policy holder. */
    Nmdins,
    /** **NOK**

Next of Kin. A person, who is a type of contact, designated to receive notifications on behalf of another person who is a relative. */
    Nok,
    /** **NOTARY**

Notary. The party credentialed to legally attest to the contract binding by verifying the identity and capacity of the grantor and grantee, and witnessing their signing of the contract or agreement such as a real estate transaction, pre-nuptial agreement, or a will. */
    Notary,
    /** **PAT**

Patient. A person, animal, or other living subject that is the actual or potential recipient of health care services. */
    Pat,
    /** **POWATT**

Power of Attorney. A person who has been granted the authority to represent or act on another's behalf generally in a manner which is a legally binding upon the person giving such authority as if he or she personally were to do the acts. Examples include (1) exercising specific legal rights belonging to the grantee such as signing a contract; (2) performing specific legal duties on behalf of a grantee such as making loan payments; and (3) making specific legal decisions concerning a grantee such as financial investment decisions. */
    Powatt,
    /** **PRIMAUTH**

Primary Author. An entity that is the primary or sole author of information content.  In the healthcare context, there can be only one primary author of health information content in a record entry or document. */
    Primauth,
    /** **PRIRECIP**

Primary Responsible Party. An entity that may, should receive, or has received information or an object to which it was primarily addressed. */
    Prirecip,
    /** **RECIP**

Recipient. An entity that may, should receive, or has received information or an object, which might not have been primarily addressed to it. For example, the staff of a provider, a clearinghouse, or other intermediary. */
    Recip,
    /** **RESPRSN**

Responsible Party. An entity that has legal responsibility for another party. */
    Resprsn,
    /** **REVIEWER**

Reviewer. A person, device, or algorithm that has used approved criteria for filtered data for inclusion into the patient record.  Examples: (1) a medical records clerk who scans a document for inclusion in the medical record, enters header information, or catalogues and classifies the data, or a combination thereof; (2) a gateway that receives data from another computer system and interprets that data or changes its format, or both, before entering it into the patient record. */
    Reviewer,
    /** **SOURCE**

Source. An automated data source that generates a signature along with content. Examples: (1) the signature for an image that is generated by a device for inclusion in the patient record; (2) the signature for an ECG derived by an ECG system for inclusion in the patient record; (3) the data from a biomedical monitoring device or system that is for inclusion in the patient record. */
    Source,
    /** **SPOWATT**

Special Power of Attorney. A person who has been granted the authority to represent or act on another's behalf for a limited set of specific matters in a manner which is a legally binding upon the person giving such authority as if he or she personally were to do the acts. Examples include (1) exercising specific legal rights belonging to the grantee such as drafting a will; (2) performing specific legal duties on behalf of a grantee such as making a reversible mortgage to pay for end of life expenses; and (3) making specific legal decisions concerning a grantee such as managing a trust. */
    Spowatt,
    /** **TRANS**

Transcriber. An entity entering the data into the originating system. This includes the transcriptionist for dictated text transcribed into electronic form. */
    Trans,
    /** **VALID**

Validator. A person who validates a health information document for inclusion in the patient record. For example, a medical student or resident is credentialed to perform history or physical examinations and to write progress notes. The attending physician signs the history and physical examination to validate the entry for inclusion in the patient's medical record. */
    Valid,
    /** **VERF**

Verifier. A person who asserts the correctness and appropriateness of an act or the recording of the act, and is accountable for the assertion that the act or the recording of the act complies with jurisdictional or organizational policy. For example, a physician is required to countersign a verbal order that has previously been recorded in the medical record by a registered nurse who has carried out the verbal order. */
    Verf,
    /** **WIT**

Witness. A person witnessing the signature of another party. A witness is not knowledgeable about the content being signed, much less approves of anything stated in the content. For example, an advanced directive witness or a witness that a party to a contract signed that certain demographic or financial information is truthful. */
    Wit,
    /** **delegator**

Delegator. A party that delegates a right or authority to another party. */
    Delegator,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSignerTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AFFL" => Ok(Self::Affl),
            "AGNT" => Ok(Self::Agnt),
            "AMENDER" => Ok(Self::Amender),
            "ASSIGNED" => Ok(Self::Assigned),
            "AUT" => Ok(Self::Aut),
            "AUTHN" => Ok(Self::Authn),
            "CIT" => Ok(Self::Cit),
            "CLAIMANT" => Ok(Self::Claimant),
            "COAUTH" => Ok(Self::Coauth),
            "CONSENTER" => Ok(Self::Consenter),
            "CONSWIT" => Ok(Self::Conswit),
            "CONT" => Ok(Self::Cont),
            "COPART" => Ok(Self::Copart),
            "COVPTY" => Ok(Self::Covpty),
            "DELEGATEE" => Ok(Self::Delegatee),
            "DEPEND" => Ok(Self::Depend),
            "DPOWATT" => Ok(Self::Dpowatt),
            "EMGCON" => Ok(Self::Emgcon),
            "EVTWIT" => Ok(Self::Evtwit),
            "EXCEST" => Ok(Self::Excest),
            "GRANTEE" => Ok(Self::Grantee),
            "GRANTOR" => Ok(Self::Grantor),
            "GUADLTM" => Ok(Self::Guadltm),
            "GUAR" => Ok(Self::Guar),
            "GUARD" => Ok(Self::Guard),
            "HPOWATT" => Ok(Self::Hpowatt),
            "HPROV" => Ok(Self::Hprov),
            "INF" => Ok(Self::Inf),
            "INSBJ" => Ok(Self::Insbj),
            "INTPRT" => Ok(Self::Intprt),
            "LEGAUTHN" => Ok(Self::Legauthn),
            "NMDINS" => Ok(Self::Nmdins),
            "NOK" => Ok(Self::Nok),
            "NOTARY" => Ok(Self::Notary),
            "PAT" => Ok(Self::Pat),
            "POWATT" => Ok(Self::Powatt),
            "PRIMAUTH" => Ok(Self::Primauth),
            "PRIRECIP" => Ok(Self::Prirecip),
            "RECIP" => Ok(Self::Recip),
            "RESPRSN" => Ok(Self::Resprsn),
            "REVIEWER" => Ok(Self::Reviewer),
            "SOURCE" => Ok(Self::Source),
            "SPOWATT" => Ok(Self::Spowatt),
            "TRANS" => Ok(Self::Trans),
            "VALID" => Ok(Self::Valid),
            "VERF" => Ok(Self::Verf),
            "WIT" => Ok(Self::Wit),
            "delegator" => Ok(Self::Delegator),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSignerTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Affl => "AFFL",
            Self::Agnt => "AGNT",
            Self::Amender => "AMENDER",
            Self::Assigned => "ASSIGNED",
            Self::Aut => "AUT",
            Self::Authn => "AUTHN",
            Self::Cit => "CIT",
            Self::Claimant => "CLAIMANT",
            Self::Coauth => "COAUTH",
            Self::Consenter => "CONSENTER",
            Self::Conswit => "CONSWIT",
            Self::Cont => "CONT",
            Self::Copart => "COPART",
            Self::Covpty => "COVPTY",
            Self::Delegatee => "DELEGATEE",
            Self::Depend => "DEPEND",
            Self::Dpowatt => "DPOWATT",
            Self::Emgcon => "EMGCON",
            Self::Evtwit => "EVTWIT",
            Self::Excest => "EXCEST",
            Self::Grantee => "GRANTEE",
            Self::Grantor => "GRANTOR",
            Self::Guadltm => "GUADLTM",
            Self::Guar => "GUAR",
            Self::Guard => "GUARD",
            Self::Hpowatt => "HPOWATT",
            Self::Hprov => "HPROV",
            Self::Inf => "INF",
            Self::Insbj => "INSBJ",
            Self::Intprt => "INTPRT",
            Self::Legauthn => "LEGAUTHN",
            Self::Nmdins => "NMDINS",
            Self::Nok => "NOK",
            Self::Notary => "NOTARY",
            Self::Pat => "PAT",
            Self::Powatt => "POWATT",
            Self::Primauth => "PRIMAUTH",
            Self::Prirecip => "PRIRECIP",
            Self::Recip => "RECIP",
            Self::Resprsn => "RESPRSN",
            Self::Reviewer => "REVIEWER",
            Self::Source => "SOURCE",
            Self::Spowatt => "SPOWATT",
            Self::Trans => "TRANS",
            Self::Valid => "VALID",
            Self::Verf => "VERF",
            Self::Wit => "WIT",
            Self::Delegator => "delegator",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractSignerTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractSignerTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractSignerTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSignerTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractSignerTypeCodes> for Coding {
    fn from(code: ContractSignerTypeCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-signer-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractSignerTypeCodes> for CodeableConcept {
    fn from(code: ContractSignerTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractStatus](http://hl7.org/fhir/contract-status)**. This CodeSystem contains FHIR-defined contract status types. Each definition includes usage notes explaining the precedence order in contract lifecycle - i.e., while only some stages are required, the order in which they may occur is deterministic; and a map to comparable FHIR and v.3 status codes. It follows guidance about use of status codes in FHIR at http://build.fhir.org/sc.html.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractStatus {
    /** **amended**

Amended. Contract is augmented with additional information to correct errors in a predecessor or to updated values in a predecessor. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: revised; replaced. */
    Amended,
    /** **appended**

Appended. Contract is augmented with additional information that was missing from a predecessor Contract. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: updated, replaced. */
    Appended,
    /** **cancelled**

Cancelled. Contract is terminated due to failure of the Grantor and/or the Grantee to fulfil one or more contract provisions. Usage: Abnormal contract termination. Precedence Order = 10. Comparable FHIR and v.3 status codes: stopped; failed; aborted. */
    Cancelled,
    /** **disputed**

Disputed. Contract is pended to rectify failure of the Grantor or the Grantee to fulfil contract provision(s). E.g., Grantee complaint about Grantor's failure to comply with contract provisions. Usage: Contract pended. Precedence Order = 7. Comparable FHIR and v.3 status codes: on hold; pended; suspended. */
    Disputed,
    /** **entered-in-error**

Entered in Error. Contract was created in error. No Precedence Order.  Status may be applied to a Contract with any status. */
    EnteredInError,
    /** **executable**

Executable. Contract execution pending; may be executed when either the Grantor or the Grantee accepts the contract provisions by signing. I.e., where either the Grantor or the Grantee has signed, but not both. E.g., when an insurance applicant signs the insurers application, which references the policy. Usage: Optional first step of contract execution activity.  May be skipped and contracting activity moves directly to executed state. Precedence Order = 3. Comparable FHIR and v.3 status codes: draft; preliminary; planned; intended; active. */
    Executable,
    /** **executed**

Executed. Contract is activated for period stipulated when both the Grantor and Grantee have signed it. Usage: Required state for normal completion of contracting activity.  Precedence Order = 6. Comparable FHIR and v.3 status codes: accepted; completed. */
    Executed,
    /** **negotiable**

Negotiable. Contract execution is suspended while either or both the Grantor and Grantee propose and consider new or revised contract provisions. I.e., where the party which has not signed proposes changes to the terms.  E .g., a life insurer declines to agree to the signed application because the life insurer has evidence that the applicant, who asserted to being younger or a non-smoker to get a lower premium rate - but offers instead to agree to a higher premium based on the applicants actual age or smoking status. Usage: Optional contract activity between executable and executed state. Precedence Order = 4. Comparable FHIR and v.3 status codes: in progress; review; held. */
    Negotiable,
    /** **offered**

Offered. Contract is a proposal by either the Grantor or the Grantee. Aka - A Contract hard copy or electronic 'template', 'form' or 'application'. E.g., health insurance application; consent directive form. Usage: Beginning of contract negotiation, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 2. Comparable FHIR and v.3 status codes: requested; new. */
    Offered,
    /** **policy**

Policy. Contract template is available as the basis for an application or offer by the Grantor or Grantee. E.g., health insurance policy; consent directive policy.  Usage: Required initial contract activity, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 1. Comparable FHIR and v.3 status codes: proposed; intended. */
    Policy,
    /** **rejected**

Rejected.  Execution of the Contract is not completed because either or both the Grantor and Grantee decline to accept some or all of the contract provisions. Usage: Optional contract activity between executable and abnormal termination. Precedence Order = 5. Comparable FHIR and v.3 status codes:  stopped; cancelled. */
    Rejected,
    /** **renewed**

Renewed. Beginning of a successor Contract at the termination of predecessor Contract lifecycle. Usage: Follows termination of a preceding Contract that has reached its expiry date. Precedence Order = 13. Comparable FHIR and v.3 status codes: superseded. */
    Renewed,
    /** **resolved**

Resolved. Contract is reactivated after being pended because of faulty execution. *E.g., competency of the signer(s), or where the policy is substantially different from and did not accompany the application/form so that the applicant could not compare them. Aka - ''reactivated''. Usage: Optional stage where a pended contract is reactivated. Precedence Order = 8. Comparable FHIR and v.3 status codes: reactivated. */
    Resolved,
    /** **revoked**

Revoked. A Contract that is rescinded.  May be required prior to replacing with an updated Contract. Comparable FHIR and v.3 status codes: nullified. */
    Revoked,
    /** **terminated**

Terminated. Contract reaches its expiry date. It might or might not be renewed or renegotiated. Usage: Normal end of contract period. Precedence Order = 12. Comparable FHIR and v.3 status codes: Obsoleted. */
    Terminated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "disputed" => Ok(Self::Disputed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "executable" => Ok(Self::Executable),
            "executed" => Ok(Self::Executed),
            "negotiable" => Ok(Self::Negotiable),
            "offered" => Ok(Self::Offered),
            "policy" => Ok(Self::Policy),
            "rejected" => Ok(Self::Rejected),
            "renewed" => Ok(Self::Renewed),
            "resolved" => Ok(Self::Resolved),
            "revoked" => Ok(Self::Revoked),
            "terminated" => Ok(Self::Terminated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Disputed => "disputed",
            Self::EnteredInError => "entered-in-error",
            Self::Executable => "executable",
            Self::Executed => "executed",
            Self::Negotiable => "negotiable",
            Self::Offered => "offered",
            Self::Policy => "policy",
            Self::Rejected => "rejected",
            Self::Renewed => "renewed",
            Self::Resolved => "resolved",
            Self::Revoked => "revoked",
            Self::Terminated => "terminated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractStatus> for Coding {
    fn from(code: ContractStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractStatus> for CodeableConcept {
    fn from(code: ContractStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractSubtypeCodes](http://hl7.org/fhir/contract-subtype)**. This value set includes sample Contract Subtype codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractSubtypeCodes {
    /** **disclosure-ca**

Disclosure-CA. Canadian health information disclosure policy. */
    DisclosureCa,
    /** **disclosure-us**

Disclosure-US. United States health information disclosure policy. */
    DisclosureUs,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSubtypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "disclosure-ca" => Ok(Self::DisclosureCa),
            "disclosure-us" => Ok(Self::DisclosureUs),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSubtypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::DisclosureCa => "disclosure-ca",
            Self::DisclosureUs => "disclosure-us",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractSubtypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractSubtypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractSubtypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSubtypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractSubtypeCodes> for Coding {
    fn from(code: ContractSubtypeCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-subtype".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractSubtypeCodes> for CodeableConcept {
    fn from(code: ContractSubtypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractTermSubtypeCodes](http://hl7.org/fhir/contract-term-subtype)**. This value set includes sample Contract Term SubType codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractTermSubtypeCodes {
    /** **condition**

Condition. Terms that go to the very root of a contract. */
    Condition,
    /** **innominate**

Innominate. Breach of which might or might not go to the root of the contract depending upon the nature of the breach */
    Innominate,
    /** **warranty**

Warranty. Less imperative than a condition, so the contract will survive a breach */
    Warranty,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractTermSubtypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "condition" => Ok(Self::Condition),
            "innominate" => Ok(Self::Innominate),
            "warranty" => Ok(Self::Warranty),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractTermSubtypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Condition => "condition",
            Self::Innominate => "innominate",
            Self::Warranty => "warranty",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractTermSubtypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractTermSubtypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractTermSubtypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractTermSubtypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractTermSubtypeCodes> for Coding {
    fn from(code: ContractTermSubtypeCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-term-subtype".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractTermSubtypeCodes> for CodeableConcept {
    fn from(code: ContractTermSubtypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractTermTypeCodes](http://hl7.org/fhir/contract-term-type)**. This value set includes sample Contract Term Type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractTermTypeCodes {
    /** **statutory**

Statutory. Based on specialized statutes that deal with particular subjects. */
    Statutory,
    /** **subject-to**

Subject To. Execution of the term in the contract is conditional on the execution of other actions. */
    SubjectTo,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractTermTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "statutory" => Ok(Self::Statutory),
            "subject-to" => Ok(Self::SubjectTo),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractTermTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Statutory => "statutory",
            Self::SubjectTo => "subject-to",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractTermTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractTermTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractTermTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractTermTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractTermTypeCodes> for Coding {
    fn from(code: ContractTermTypeCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-term-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractTermTypeCodes> for CodeableConcept {
    fn from(code: ContractTermTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContractTypeCodes](http://hl7.org/fhir/contract-type)**. This value set includes sample Contract Type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ContractTypeCodes {
    /** **consent**

Consent. Consent Directive. */
    Consent,
    /** **disclosure**

Disclosure. Information disclosure policy. */
    Disclosure,
    /** **healthinsurance**

Health Insurance. Health Insurance policy. */
    Healthinsurance,
    /** **privacy**

Privacy. Privacy policy. */
    Privacy,
    /** **supply**

Supply Contract. Contract to supply goods or services. */
    Supply,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "consent" => Ok(Self::Consent),
            "disclosure" => Ok(Self::Disclosure),
            "healthinsurance" => Ok(Self::Healthinsurance),
            "privacy" => Ok(Self::Privacy),
            "supply" => Ok(Self::Supply),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consent => "consent",
            Self::Disclosure => "disclosure",
            Self::Healthinsurance => "healthinsurance",
            Self::Privacy => "privacy",
            Self::Supply => "supply",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ContractTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContractTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContractTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractTypeCodes> for Coding {
    fn from(code: ContractTypeCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/contract-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContractTypeCodes> for CodeableConcept {
    fn from(code: ContractTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContributorRole](http://hl7.org/fhir/ValueSet/contributor-role)**. Used to code the format of the display string.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContributorRole {
    /** **author**

Author/Creator. An entity primarily responsible for making the resource, often called author or creator */
    Author,
    /** **editor**

Editor. Entity that revises or has authority to control the content */
    Editor,
    /** **endorser**

Endorser. Entity that supports, approves, or advocates for the content */
    Endorser,
    /** **funder**

Funder. Entity that supplies financial support */
    Funder,
    /** **informant**

Informant. Entity that supplies information */
    Informant,
    /** **publisher**

Publisher. Entity that makes the content available for public use */
    Publisher,
    /** **reviewer**

Reviewer. Entity that examines the content, formally or informally, and suggests revisions or comments */
    Reviewer,
}
impl ::core::str::FromStr for ContributorRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "author" => Ok(Self::Author),
            "editor" => Ok(Self::Editor),
            "endorser" => Ok(Self::Endorser),
            "funder" => Ok(Self::Funder),
            "informant" => Ok(Self::Informant),
            "publisher" => Ok(Self::Publisher),
            "reviewer" => Ok(Self::Reviewer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Author => "author",
            Self::Editor => "editor",
            Self::Endorser => "endorser",
            Self::Funder => "funder",
            Self::Informant => "informant",
            Self::Publisher => "publisher",
            Self::Reviewer => "reviewer",
        }
    }
}
impl ::std::fmt::Debug for ContributorRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContributorRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContributorRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorRole> for Coding {
    fn from(code: ContributorRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/contributor-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContributorRole> for CodeableConcept {
    fn from(code: ContributorRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContributorSummarySource](http://hl7.org/fhir/ValueSet/contributor-summary-source)**. Used to code the producer or rule for creating the display string.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContributorSummarySource {
    /** **article-copy**

Copied from article. Data copied by human from article text. */
    ArticleCopy,
    /** **citation-manager**

Reported by citation manager. Data copied by machine from citation manager data. */
    CitationManager,
    /** **custom**

custom format. Custom format (may be described in text note). */
    Custom,
    /** **publisher-data**

Publisher provided. Data copied by machine from publisher data. */
    PublisherData,
}
impl ::core::str::FromStr for ContributorSummarySource {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "article-copy" => Ok(Self::ArticleCopy),
            "citation-manager" => Ok(Self::CitationManager),
            "custom" => Ok(Self::Custom),
            "publisher-data" => Ok(Self::PublisherData),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorSummarySource {
    fn as_ref(&self) -> &str {
        match self {
            Self::ArticleCopy => "article-copy",
            Self::CitationManager => "citation-manager",
            Self::Custom => "custom",
            Self::PublisherData => "publisher-data",
        }
    }
}
impl ::std::fmt::Debug for ContributorSummarySource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContributorSummarySource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContributorSummarySource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorSummarySource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorSummarySource> for Coding {
    fn from(code: ContributorSummarySource) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/contributor-summary-source".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContributorSummarySource> for CodeableConcept {
    fn from(code: ContributorSummarySource) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContributorSummaryStyle](http://hl7.org/fhir/ValueSet/contributor-summary-style)**. Used to code the format of the display string.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContributorSummaryStyle {
    /** **a1full**

First author (full name) et al. Example: Jennifer Laskowski et al. */
    A1Full,
    /** **a1init**

First author (last name first initials) et al. Example: Laskowski J et al. */
    A1Init,
    /** **a3full**

First 3 authors (full name) et al. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, et al. */
    A3Full,
    /** **a3init**

First 3 authors (last name first initials) et al. Example:  Laskowski J, Renner B, Pickering MC, et al. */
    A3Init,
    /** **a6full**

First 6 authors (full name) et al. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, et al. */
    A6Full,
    /** **a6init**

First 6 authors (last name first initials) et al. Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, et al. */
    A6Init,
    /** **aallfull**

All authors (full name). Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, Joshua M. Thurman. */
    Aallfull,
    /** **aallfullwithampersand**

All authors (full name) with an ampersand before last author. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, & Joshua M. Thurman. */
    Aallfullwithampersand,
    /** **aallfullwithand**

All authors (full name) with and before last author. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, and Joshua M. Thurman. */
    Aallfullwithand,
    /** **aallinit**

All authors (last name first initials). Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, Thurman JM. */
    Aallinit,
    /** **aallinitwithampersand**

All authors (last name first initials) with an ampersand before last author. Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, & Thurman JM. */
    Aallinitwithampersand,
    /** **aallinitwithand**

All authors (last name first initials) with and before last author. Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, and Thurman JM. */
    Aallinitwithand,
    /** **contr-full-by-contr**

Contributorship statement listed by contribution with full names. Project design by Jennnifer Laskowski (JL), Experiment design by JL and Joshua M. Thurman (JMT), technical advice and study design contribution by Matthew C. Pickering, experiments performed by JL, data collection and analysis by JL, PET imaging and associated analyses by Natalie J. Serkova and Peter M. Smith-Jones, conceptual and technical guidance by Eric T. Clambey (ETC) and Raphael A. Nemenoff (RAN), manuscript writing by JL and JMT, manuscript revised critically by JL, Brandon Renner, ETC, and RAN. */
    ContrFullByContr,
    /** **contr-full-by-person**

Contributorship statement listed by person with full names. Jennnifer Laskowski designed project; developed and performed experiments; collected and analyzed data; wrote and revised manuscript. Brandon Renner performed critical review of manuscript. Matthew C. Pickering provided technical advice and contributed to study design. Natalie J. Serkova and Peter M. Smith-Jones performed PET imaging and associated analyses. Eric T. Clambey and Raphael A. Nemenoff provided conceptual and technical guidance and critical review of manuscript. Joshua M. Thurman contributed to experimental design and wrote manuscript. */
    ContrFullByPerson,
    /** **contr-init-by-contr**

Contributorship statement listed by contribution with initials. Project design by JL, Experiment design by JL and JMT, technical advice and study design contribution by MCP, experiments performed by JL, data collection and analysis by JL, PET imaging and associated analyses by NJS and PMS-J, conceptual and technical guidance by ETC and RAN, manuscript writing by JL and JMT, manuscript revised critically by JL, BR, ETC, and RAN. */
    ContrInitByContr,
    /** **contr-init-by-person**

Contributorship statement listed by person with initials. J.L. designed project; developed and performed experiments; collected and analyzed data; wrote and revised manuscript. B.R. performed critical review of manuscript. M.C.P. provided technical advice and contributed to study design. N.J.S and P.M.S.-J. performed PET imaging and associated analyses. E.T.C. and R.A.N provided conceptual and technical guidance and critical review of manuscript. J.M.T contributed to experimental design and wrote manuscript. */
    ContrInitByPerson,
}
impl ::core::str::FromStr for ContributorSummaryStyle {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a1full" => Ok(Self::A1Full),
            "a1init" => Ok(Self::A1Init),
            "a3full" => Ok(Self::A3Full),
            "a3init" => Ok(Self::A3Init),
            "a6full" => Ok(Self::A6Full),
            "a6init" => Ok(Self::A6Init),
            "aallfull" => Ok(Self::Aallfull),
            "aallfullwithampersand" => Ok(Self::Aallfullwithampersand),
            "aallfullwithand" => Ok(Self::Aallfullwithand),
            "aallinit" => Ok(Self::Aallinit),
            "aallinitwithampersand" => Ok(Self::Aallinitwithampersand),
            "aallinitwithand" => Ok(Self::Aallinitwithand),
            "contr-full-by-contr" => Ok(Self::ContrFullByContr),
            "contr-full-by-person" => Ok(Self::ContrFullByPerson),
            "contr-init-by-contr" => Ok(Self::ContrInitByContr),
            "contr-init-by-person" => Ok(Self::ContrInitByPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorSummaryStyle {
    fn as_ref(&self) -> &str {
        match self {
            Self::A1Full => "a1full",
            Self::A1Init => "a1init",
            Self::A3Full => "a3full",
            Self::A3Init => "a3init",
            Self::A6Full => "a6full",
            Self::A6Init => "a6init",
            Self::Aallfull => "aallfull",
            Self::Aallfullwithampersand => "aallfullwithampersand",
            Self::Aallfullwithand => "aallfullwithand",
            Self::Aallinit => "aallinit",
            Self::Aallinitwithampersand => "aallinitwithampersand",
            Self::Aallinitwithand => "aallinitwithand",
            Self::ContrFullByContr => "contr-full-by-contr",
            Self::ContrFullByPerson => "contr-full-by-person",
            Self::ContrInitByContr => "contr-init-by-contr",
            Self::ContrInitByPerson => "contr-init-by-person",
        }
    }
}
impl ::std::fmt::Debug for ContributorSummaryStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContributorSummaryStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContributorSummaryStyle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorSummaryStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorSummaryStyle> for Coding {
    fn from(code: ContributorSummaryStyle) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/contributor-summary-style".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContributorSummaryStyle> for CodeableConcept {
    fn from(code: ContributorSummaryStyle) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContributorSummaryType](http://hl7.org/fhir/ValueSet/contributor-summary-type)**. Used to code author list statement, contributorship statement, and such.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContributorSummaryType {
    /** **acknowledgement-list**

Acknowledgment list. Display of the list of acknowledged parties as a complete string. */
    AcknowledgementList,
    /** **acknowledgment-statement**

Acknowledgment statement. Statement of acknowledgment of contributions beyond those compiled for formal contributorship statements. */
    AcknowledgmentStatement,
    /** **author-string**

Author string. Display of the author list as a complete string. */
    AuthorString,
    /** **competing-interests-statement**

Competing interests statement. Statement of completing interests related to the creation of the cited artifact. Also called conflicts of interest or declaration of interests. */
    CompetingInterestsStatement,
    /** **contributorship-list**

Contributorship list. Display of the list of contributors as a complete string. */
    ContributorshipList,
    /** **contributorship-statement**

Contributorship statement. Compiled summary of contributions. */
    ContributorshipStatement,
    /** **funding-statement**

Funding statement. Statement of financial support for the creation of the cited artifact. */
    FundingStatement,
}
impl ::core::str::FromStr for ContributorSummaryType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acknowledgement-list" => Ok(Self::AcknowledgementList),
            "acknowledgment-statement" => Ok(Self::AcknowledgmentStatement),
            "author-string" => Ok(Self::AuthorString),
            "competing-interests-statement" => Ok(Self::CompetingInterestsStatement),
            "contributorship-list" => Ok(Self::ContributorshipList),
            "contributorship-statement" => Ok(Self::ContributorshipStatement),
            "funding-statement" => Ok(Self::FundingStatement),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorSummaryType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AcknowledgementList => "acknowledgement-list",
            Self::AcknowledgmentStatement => "acknowledgment-statement",
            Self::AuthorString => "author-string",
            Self::CompetingInterestsStatement => "competing-interests-statement",
            Self::ContributorshipList => "contributorship-list",
            Self::ContributorshipStatement => "contributorship-statement",
            Self::FundingStatement => "funding-statement",
        }
    }
}
impl ::std::fmt::Debug for ContributorSummaryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContributorSummaryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContributorSummaryType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorSummaryType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorSummaryType> for Coding {
    fn from(code: ContributorSummaryType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/contributor-summary-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContributorSummaryType> for CodeableConcept {
    fn from(code: ContributorSummaryType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ContributorType](http://hl7.org/fhir/ValueSet/contributor-type)**. The type of contributor.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ContributorType {
    /** **author**

Author. An author of the content of the module. */
    Author,
    /** **editor**

Editor. An editor of the content of the module. */
    Editor,
    /** **endorser**

Endorser. An endorser of the content of the module. */
    Endorser,
    /** **reviewer**

Reviewer. A reviewer of the content of the module. */
    Reviewer,
}
impl ::core::str::FromStr for ContributorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "author" => Ok(Self::Author),
            "editor" => Ok(Self::Editor),
            "endorser" => Ok(Self::Endorser),
            "reviewer" => Ok(Self::Reviewer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Author => "author",
            Self::Editor => "editor",
            Self::Endorser => "endorser",
            Self::Reviewer => "reviewer",
        }
    }
}
impl ::std::fmt::Debug for ContributorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ContributorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ContributorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorType> for Coding {
    fn from(code: ContributorType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/contributor-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ContributorType> for CodeableConcept {
    fn from(code: ContributorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CoverageClassCodes](http://terminology.hl7.org/CodeSystem/coverage-class)**. This value set includes Coverage Class codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum CoverageClassCodes {
    /** **class**

Class. A class of benefits. */
    Class,
    /** **group**

Group. An employee group */
    Group,
    /** **plan**

Plan. A specific suite of benefits. */
    Plan,
    /** **rxbin**

RX BIN. Pharmacy benefit manager's Business Identification Number. */
    Rxbin,
    /** **rxgroup**

RX Group. A Pharmacy Benefit Manager specified Group number. */
    Rxgroup,
    /** **rxid**

RX Id. A Pharmacy Benefit Manager specified Member ID. */
    Rxid,
    /** **rxpcn**

RX PCN. A Pharmacy Benefit Manager specified Processor Control Number. */
    Rxpcn,
    /** **sequence**

Sequence. A sequence number associated with a short-term continuance of the coverage. */
    Sequence,
    /** **subclass**

SubClass. A subset of a class of benefits. */
    Subclass,
    /** **subgroup**

SubGroup. A sub-group of an employee group */
    Subgroup,
    /** **subplan**

SubPlan. A subset of a specific suite of benefits. */
    Subplan,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CoverageClassCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "class" => Ok(Self::Class),
            "group" => Ok(Self::Group),
            "plan" => Ok(Self::Plan),
            "rxbin" => Ok(Self::Rxbin),
            "rxgroup" => Ok(Self::Rxgroup),
            "rxid" => Ok(Self::Rxid),
            "rxpcn" => Ok(Self::Rxpcn),
            "sequence" => Ok(Self::Sequence),
            "subclass" => Ok(Self::Subclass),
            "subgroup" => Ok(Self::Subgroup),
            "subplan" => Ok(Self::Subplan),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CoverageClassCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Class => "class",
            Self::Group => "group",
            Self::Plan => "plan",
            Self::Rxbin => "rxbin",
            Self::Rxgroup => "rxgroup",
            Self::Rxid => "rxid",
            Self::Rxpcn => "rxpcn",
            Self::Sequence => "sequence",
            Self::Subclass => "subclass",
            Self::Subgroup => "subgroup",
            Self::Subplan => "subplan",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for CoverageClassCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CoverageClassCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CoverageClassCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CoverageClassCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CoverageClassCodes> for Coding {
    fn from(code: CoverageClassCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/coverage-class".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CoverageClassCodes> for CodeableConcept {
    fn from(code: CoverageClassCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CoverageCoPayTypeCodes](http://terminology.hl7.org/CodeSystem/coverage-copay-type)**. This codeset includes Coverage Copayment Type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum CoverageCoPayTypeCodes {
    /** **copay**

Copay Amount. A standard fixed currency amount applied to all classes or service or product not otherwise specified. */
    Copay,
    /** **copaypct**

Copay Percentage. A standard percentage applied to all classes or service or product not otherwise specified. */
    Copaypct,
    /** **deductible**

Deductible. The accumulated amount of patient payment before the coverage begins to pay for services. */
    Deductible,
    /** **emergency**

Emergency. An episode in an emergency department. */
    Emergency,
    /** **gpvisit**

GP Office Visit. An office visit for a general practitioner of a discipline. */
    Gpvisit,
    /** **inpthosp**

Inpatient Hospital. An episode of an Inpatient hospital stay. */
    Inpthosp,
    /** **maxoutofpocket**

Maximum out of pocket. The maximum amout of payment for services which a patient, or family, is expected to incur - typically annually. */
    Maxoutofpocket,
    /** **spvisit**

Specialist Office Visit. An office visit for a specialist practitioner of a discipline */
    Spvisit,
    /** **televisit**

Tele-visit. A visit held where the patient is remote relative to the practitioner, e.g. by phone, computer or video conference. */
    Televisit,
    /** **urgentcare**

Urgent Care. A visit to an urgent care facility - typically a community care clinic. */
    Urgentcare,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CoverageCoPayTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "copay" => Ok(Self::Copay),
            "copaypct" => Ok(Self::Copaypct),
            "deductible" => Ok(Self::Deductible),
            "emergency" => Ok(Self::Emergency),
            "gpvisit" => Ok(Self::Gpvisit),
            "inpthosp" => Ok(Self::Inpthosp),
            "maxoutofpocket" => Ok(Self::Maxoutofpocket),
            "spvisit" => Ok(Self::Spvisit),
            "televisit" => Ok(Self::Televisit),
            "urgentcare" => Ok(Self::Urgentcare),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CoverageCoPayTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Copay => "copay",
            Self::Copaypct => "copaypct",
            Self::Deductible => "deductible",
            Self::Emergency => "emergency",
            Self::Gpvisit => "gpvisit",
            Self::Inpthosp => "inpthosp",
            Self::Maxoutofpocket => "maxoutofpocket",
            Self::Spvisit => "spvisit",
            Self::Televisit => "televisit",
            Self::Urgentcare => "urgentcare",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for CoverageCoPayTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CoverageCoPayTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CoverageCoPayTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CoverageCoPayTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CoverageCoPayTypeCodes> for Coding {
    fn from(code: CoverageCoPayTypeCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/coverage-copay-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CoverageCoPayTypeCodes> for CodeableConcept {
    fn from(code: CoverageCoPayTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CoverageEligibilityResponseAuthSupportCodes](http://terminology.hl7.org/CodeSystem/coverageeligibilityresponse-ex-auth-support)**. This value set includes CoverageEligibilityResponse Auth Support codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum CoverageEligibilityResponseAuthSupportCodes {
    /** **accidentreport**

Accident Report. A formal accident report as would be filed with police or a simlar official body. */
    Accidentreport,
    /** **diagnosticimageorder**

Diagnostic Image Order. A request or authorization for diagnostic imaging. */
    Diagnosticimageorder,
    /** **diagnosticimagereport**

Diagnostic Image Report. A report on diagnostic image(s). */
    Diagnosticimagereport,
    /** **laborder**

Lab Order. A request or authorization for laboratory diagnostic tests. */
    Laborder,
    /** **labreport**

Lab Report. A report on laboratory diagnostic test(s). */
    Labreport,
    /** **model**

Model. A physical model of the affected area. */
    Model,
    /** **picture**

Picture. A photograph of the affected area. */
    Picture,
    /** **professionalreport**

Professional Report. A report from a licensed professional regarding the siutation, condition or proposed treatment. */
    Professionalreport,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CoverageEligibilityResponseAuthSupportCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accidentreport" => Ok(Self::Accidentreport),
            "diagnosticimageorder" => Ok(Self::Diagnosticimageorder),
            "diagnosticimagereport" => Ok(Self::Diagnosticimagereport),
            "laborder" => Ok(Self::Laborder),
            "labreport" => Ok(Self::Labreport),
            "model" => Ok(Self::Model),
            "picture" => Ok(Self::Picture),
            "professionalreport" => Ok(Self::Professionalreport),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CoverageEligibilityResponseAuthSupportCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accidentreport => "accidentreport",
            Self::Diagnosticimageorder => "diagnosticimageorder",
            Self::Diagnosticimagereport => "diagnosticimagereport",
            Self::Laborder => "laborder",
            Self::Labreport => "labreport",
            Self::Model => "model",
            Self::Picture => "picture",
            Self::Professionalreport => "professionalreport",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for CoverageEligibilityResponseAuthSupportCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CoverageEligibilityResponseAuthSupportCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CoverageEligibilityResponseAuthSupportCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CoverageEligibilityResponseAuthSupportCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CoverageEligibilityResponseAuthSupportCodes> for Coding {
    fn from(code: CoverageEligibilityResponseAuthSupportCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/coverageeligibilityresponse-ex-auth-support"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CoverageEligibilityResponseAuthSupportCodes> for CodeableConcept {
    fn from(code: CoverageEligibilityResponseAuthSupportCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[CriteriaNotExistsBehavior](http://hl7.org/fhir/ValueSet/subscriptiontopic-cr-behavior)**. Behavior a server can exhibit when a criteria state does not exist (e.g., state prior to a create or after a delete).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum CriteriaNotExistsBehavior {
    /** **test-fails**

test fails. The requested conditional statement will fail if a matching state does not exist (e.g., previous state during create). */
    TestFails,
    /** **test-passes**

test passes. The requested conditional statement will pass if a matching state does not exist (e.g., previous state during create). */
    TestPasses,
}
impl ::core::str::FromStr for CriteriaNotExistsBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "test-fails" => Ok(Self::TestFails),
            "test-passes" => Ok(Self::TestPasses),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CriteriaNotExistsBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::TestFails => "test-fails",
            Self::TestPasses => "test-passes",
        }
    }
}
impl ::std::fmt::Debug for CriteriaNotExistsBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for CriteriaNotExistsBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for CriteriaNotExistsBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CriteriaNotExistsBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CriteriaNotExistsBehavior> for Coding {
    fn from(code: CriteriaNotExistsBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/subscriptiontopic-cr-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<CriteriaNotExistsBehavior> for CodeableConcept {
    fn from(code: CriteriaNotExistsBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DataAbsentReason](http://hl7.org/fhir/ValueSet/data-absent-reason)**. Used to specify why the normally expected content of the data element is missing.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DataAbsentReason {
    /** **as-text**

As Text. The content of the data is represented in the resource narrative. */
    AsText,
    /** **asked-declined**

Asked But Declined. The source was asked but declined to answer. */
    AskedDeclined,
    /** **asked-unknown**

Asked But Unknown. The source was asked but does not know the value. */
    AskedUnknown,
    /** **error**

Error. Some system or workflow process error means that the information is not available. */
    Error,
    /** **masked**

Masked. The information is not available due to security, privacy or related reasons. */
    Masked,
    /** **negative-infinity**

Negative Infinity (NINF). The numeric value is excessively low and unrepresentable due to a floating point processing error. */
    NegativeInfinity,
    /** **not-a-number**

Not a Number (NaN). The numeric value is undefined or unrepresentable due to a floating point processing error. */
    NotANumber,
    /** **not-applicable**

Not Applicable. There is no proper value for this element (e.g. last menstrual period for a male). */
    NotApplicable,
    /** **not-asked**

Not Asked. The workflow didn't lead to this value being known. */
    NotAsked,
    /** **not-performed**

Not Performed. The value is not available because the observation procedure (test, etc.) was not performed. */
    NotPerformed,
    /** **not-permitted**

Not Permitted. The value is not permitted in this context (e.g. due to profiles, or the base data types). */
    NotPermitted,
    /** **positive-infinity**

Positive Infinity (PINF). The numeric value is excessively high and unrepresentable due to a floating point processing error. */
    PositiveInfinity,
    /** **temp-unknown**

Temporarily Unknown. There is reason to expect (from the workflow) that the value may become known. */
    TempUnknown,
    /** **unknown**

Unknown. The value is expected to exist but is not known. */
    Unknown,
    /** **unsupported**

Unsupported. The source system wasn't capable of supporting this element. */
    Unsupported,
}
impl ::core::str::FromStr for DataAbsentReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "as-text" => Ok(Self::AsText),
            "asked-declined" => Ok(Self::AskedDeclined),
            "asked-unknown" => Ok(Self::AskedUnknown),
            "error" => Ok(Self::Error),
            "masked" => Ok(Self::Masked),
            "negative-infinity" => Ok(Self::NegativeInfinity),
            "not-a-number" => Ok(Self::NotANumber),
            "not-applicable" => Ok(Self::NotApplicable),
            "not-asked" => Ok(Self::NotAsked),
            "not-performed" => Ok(Self::NotPerformed),
            "not-permitted" => Ok(Self::NotPermitted),
            "positive-infinity" => Ok(Self::PositiveInfinity),
            "temp-unknown" => Ok(Self::TempUnknown),
            "unknown" => Ok(Self::Unknown),
            "unsupported" => Ok(Self::Unsupported),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DataAbsentReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::AsText => "as-text",
            Self::AskedDeclined => "asked-declined",
            Self::AskedUnknown => "asked-unknown",
            Self::Error => "error",
            Self::Masked => "masked",
            Self::NegativeInfinity => "negative-infinity",
            Self::NotANumber => "not-a-number",
            Self::NotApplicable => "not-applicable",
            Self::NotAsked => "not-asked",
            Self::NotPerformed => "not-performed",
            Self::NotPermitted => "not-permitted",
            Self::PositiveInfinity => "positive-infinity",
            Self::TempUnknown => "temp-unknown",
            Self::Unknown => "unknown",
            Self::Unsupported => "unsupported",
        }
    }
}
impl ::std::fmt::Debug for DataAbsentReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DataAbsentReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DataAbsentReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DataAbsentReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DataAbsentReason> for Coding {
    fn from(code: DataAbsentReason) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/data-absent-reason".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DataAbsentReason> for CodeableConcept {
    fn from(code: DataAbsentReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DataType](http://hl7.org/fhir/data-types)**. A version specific list of the data types defined by the FHIR specification for use as an element  type (any of the FHIR defined data types).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum DataType {
    /** **Address**

Address. An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world. */
    Address,
    /** **Age**

Age. A duration of time during which an organism (or a process) has existed. */
    Age,
    /** **Annotation**

Annotation. A  text note which also  contains information about who made the statement and when. */
    Annotation,
    /** **Attachment**

Attachment. For referring to data content defined in other formats. */
    Attachment,
    /** **BackboneElement**

BackboneElement. Base definition for all elements that are defined inside a resource - but not those in a data type. */
    BackboneElement,
    /** **CodeableConcept**

CodeableConcept. A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text. */
    CodeableConcept,
    /** **CodeableReference**

CodeableReference. A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class). */
    CodeableReference,
    /** **Coding**

Coding. A reference to a code defined by a terminology system. */
    Coding,
    /** **ContactDetail**

ContactDetail. Specifies contact information for a person or organization. */
    ContactDetail,
    /** **ContactPoint**

ContactPoint. Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc. */
    ContactPoint,
    /** **Contributor**

Contributor. A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers. */
    Contributor,
    /** **Count**

Count. A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies. */
    Count,
    /** **DataRequirement**

DataRequirement. Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data. */
    DataRequirement,
    /** **Distance**

Distance. A length - a value with a unit that is a physical distance. */
    Distance,
    /** **Dosage**

Dosage. Indicates how the medication is/was taken or should be taken by the patient. */
    Dosage,
    /** **Duration**

Duration. A length of time. */
    Duration,
    /** **Element**

Element. Base definition for all elements in a resource. */
    Element,
    /** **ElementDefinition**

ElementDefinition. Captures constraints on each element within the resource, profile, or extension. */
    ElementDefinition,
    /** **Expression**

Expression. A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used. */
    Expression,
    /** **Extension**

Extension. Optional Extension Element - found in all resources. */
    Extension,
    /** **HumanName**

HumanName. A human's name with the ability to identify parts and usage. */
    HumanName,
    /** **Identifier**

Identifier. An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers. */
    Identifier,
    /** **MarketingStatus**

MarketingStatus. The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available. */
    MarketingStatus,
    /** **Meta**

Meta. The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource. */
    Meta,
    /** **Money**

Money. An amount of economic utility in some recognized currency. */
    Money,
    /** **MoneyQuantity**

MoneyQuantity. */
    MoneyQuantity,
    /** **Narrative**

Narrative. A human-readable summary of the resource conveying the essential clinical and business information for the resource. */
    Narrative,
    /** **ParameterDefinition**

ParameterDefinition. The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse. */
    ParameterDefinition,
    /** **Period**

Period. A time period defined by a start and end date and optionally time. */
    Period,
    /** **Population**

Population. A populatioof people with some set of grouping criteria. */
    Population,
    /** **ProdCharacteristic**

ProdCharacteristic. The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available. */
    ProdCharacteristic,
    /** **ProductShelfLife**

ProductShelfLife. The shelf-life and storage information for a medicinal product item or container can be described using this class. */
    ProductShelfLife,
    /** **Quantity**

Quantity. A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies. */
    Quantity,
    /** **Range**

Range. A set of ordered Quantities defined by a low and high limit. */
    Range,
    /** **Ratio**

Ratio. A relationship of two Quantity values - expressed as a numerator and a denominator. */
    Ratio,
    /** **RatioRange**

RatioRange. A range of ratios expressed as a low and high numerator and a denominator. */
    RatioRange,
    /** **Reference**

Reference. A reference from one resource to another. */
    Reference,
    /** **RelatedArtifact**

RelatedArtifact. Related artifacts such as additional documentation, justification, or bibliographic references. */
    RelatedArtifact,
    /** **SampledData**

SampledData. A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data. */
    SampledData,
    /** **Signature**

Signature. A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities. */
    Signature,
    /** **SimpleQuantity**

SimpleQuantity. */
    SimpleQuantity,
    /** **Timing**

Timing. Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out. */
    Timing,
    /** **TriggerDefinition**

TriggerDefinition. A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element. */
    TriggerDefinition,
    /** **UsageContext**

UsageContext. Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care). */
    UsageContext,
    /** **base64Binary**

base64Binary. A stream of bytes */
    Base64Binary,
    /** **boolean**

boolean. Value of "true" or "false" */
    Boolean,
    /** **canonical**

canonical. A URI that is a reference to a canonical URL on a FHIR resource */
    Canonical,
    /** **code**

code. A string which has at least one character and no leading or trailing whitespace and where there is no whitespace other than single spaces in the contents */
    Code,
    /** **date**

date. A date or partial date (e.g. just year or year + month). There is no time zone. The format is a union of the schema types gYear, gYearMonth and date.  Dates SHALL be valid dates. */
    Date,
    /** **dateTime**

dateTime. A date, date-time or partial date (e.g. just year or year + month).  If hours and minutes are specified, a time zone SHALL be populated. The format is a union of the schema types gYear, gYearMonth, date and dateTime. Seconds must be provided due to schema type constraints but may be zero-filled and may be ignored.                 Dates SHALL be valid dates. */
    DateTime,
    /** **decimal**

decimal. A rational number with implicit precision */
    Decimal,
    /** **id**

id. Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these constraints.)  Ids are case-insensitive. */
    Id,
    /** **instant**

instant. An instant in time - known at least to the second */
    Instant,
    /** **integer**

integer. A whole number */
    Integer,
    /** **markdown**

markdown. A string that may contain Github Flavored Markdown syntax for optional processing by a mark down presentation engine */
    Markdown,
    /** **oid**

oid. An OID represented as a URI */
    Oid,
    /** **positiveInt**

positiveInt. An integer with a value that is positive (e.g. >0) */
    PositiveInt,
    /** **string**

string. A sequence of Unicode characters */
    String,
    /** **time**

time. A time during the day, with no date specified */
    Time,
    /** **unsignedInt**

unsignedInt. An integer with a value that is not negative (e.g. >= 0) */
    UnsignedInt,
    /** **uri**

uri. String of characters used to identify a name or a resource */
    Uri,
    /** **url**

url. A URI that is a literal reference */
    Url,
    /** **uuid**

uuid. A UUID, represented as a URI */
    Uuid,
    /** **xhtml**

XHTML. XHTML format, as defined by W3C, but restricted usage (mainly, no active content) */
    Xhtml,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for DataType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Address" => Ok(Self::Address),
            "Age" => Ok(Self::Age),
            "Annotation" => Ok(Self::Annotation),
            "Attachment" => Ok(Self::Attachment),
            "BackboneElement" => Ok(Self::BackboneElement),
            "CodeableConcept" => Ok(Self::CodeableConcept),
            "CodeableReference" => Ok(Self::CodeableReference),
            "Coding" => Ok(Self::Coding),
            "ContactDetail" => Ok(Self::ContactDetail),
            "ContactPoint" => Ok(Self::ContactPoint),
            "Contributor" => Ok(Self::Contributor),
            "Count" => Ok(Self::Count),
            "DataRequirement" => Ok(Self::DataRequirement),
            "Distance" => Ok(Self::Distance),
            "Dosage" => Ok(Self::Dosage),
            "Duration" => Ok(Self::Duration),
            "Element" => Ok(Self::Element),
            "ElementDefinition" => Ok(Self::ElementDefinition),
            "Expression" => Ok(Self::Expression),
            "Extension" => Ok(Self::Extension),
            "HumanName" => Ok(Self::HumanName),
            "Identifier" => Ok(Self::Identifier),
            "MarketingStatus" => Ok(Self::MarketingStatus),
            "Meta" => Ok(Self::Meta),
            "Money" => Ok(Self::Money),
            "MoneyQuantity" => Ok(Self::MoneyQuantity),
            "Narrative" => Ok(Self::Narrative),
            "ParameterDefinition" => Ok(Self::ParameterDefinition),
            "Period" => Ok(Self::Period),
            "Population" => Ok(Self::Population),
            "ProdCharacteristic" => Ok(Self::ProdCharacteristic),
            "ProductShelfLife" => Ok(Self::ProductShelfLife),
            "Quantity" => Ok(Self::Quantity),
            "Range" => Ok(Self::Range),
            "Ratio" => Ok(Self::Ratio),
            "RatioRange" => Ok(Self::RatioRange),
            "Reference" => Ok(Self::Reference),
            "RelatedArtifact" => Ok(Self::RelatedArtifact),
            "SampledData" => Ok(Self::SampledData),
            "Signature" => Ok(Self::Signature),
            "SimpleQuantity" => Ok(Self::SimpleQuantity),
            "Timing" => Ok(Self::Timing),
            "TriggerDefinition" => Ok(Self::TriggerDefinition),
            "UsageContext" => Ok(Self::UsageContext),
            "base64Binary" => Ok(Self::Base64Binary),
            "boolean" => Ok(Self::Boolean),
            "canonical" => Ok(Self::Canonical),
            "code" => Ok(Self::Code),
            "date" => Ok(Self::Date),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "id" => Ok(Self::Id),
            "instant" => Ok(Self::Instant),
            "integer" => Ok(Self::Integer),
            "markdown" => Ok(Self::Markdown),
            "oid" => Ok(Self::Oid),
            "positiveInt" => Ok(Self::PositiveInt),
            "string" => Ok(Self::String),
            "time" => Ok(Self::Time),
            "unsignedInt" => Ok(Self::UnsignedInt),
            "uri" => Ok(Self::Uri),
            "url" => Ok(Self::Url),
            "uuid" => Ok(Self::Uuid),
            "xhtml" => Ok(Self::Xhtml),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for DataType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Address => "Address",
            Self::Age => "Age",
            Self::Annotation => "Annotation",
            Self::Attachment => "Attachment",
            Self::BackboneElement => "BackboneElement",
            Self::CodeableConcept => "CodeableConcept",
            Self::CodeableReference => "CodeableReference",
            Self::Coding => "Coding",
            Self::ContactDetail => "ContactDetail",
            Self::ContactPoint => "ContactPoint",
            Self::Contributor => "Contributor",
            Self::Count => "Count",
            Self::DataRequirement => "DataRequirement",
            Self::Distance => "Distance",
            Self::Dosage => "Dosage",
            Self::Duration => "Duration",
            Self::Element => "Element",
            Self::ElementDefinition => "ElementDefinition",
            Self::Expression => "Expression",
            Self::Extension => "Extension",
            Self::HumanName => "HumanName",
            Self::Identifier => "Identifier",
            Self::MarketingStatus => "MarketingStatus",
            Self::Meta => "Meta",
            Self::Money => "Money",
            Self::MoneyQuantity => "MoneyQuantity",
            Self::Narrative => "Narrative",
            Self::ParameterDefinition => "ParameterDefinition",
            Self::Period => "Period",
            Self::Population => "Population",
            Self::ProdCharacteristic => "ProdCharacteristic",
            Self::ProductShelfLife => "ProductShelfLife",
            Self::Quantity => "Quantity",
            Self::Range => "Range",
            Self::Ratio => "Ratio",
            Self::RatioRange => "RatioRange",
            Self::Reference => "Reference",
            Self::RelatedArtifact => "RelatedArtifact",
            Self::SampledData => "SampledData",
            Self::Signature => "Signature",
            Self::SimpleQuantity => "SimpleQuantity",
            Self::Timing => "Timing",
            Self::TriggerDefinition => "TriggerDefinition",
            Self::UsageContext => "UsageContext",
            Self::Base64Binary => "base64Binary",
            Self::Boolean => "boolean",
            Self::Canonical => "canonical",
            Self::Code => "code",
            Self::Date => "date",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Id => "id",
            Self::Instant => "instant",
            Self::Integer => "integer",
            Self::Markdown => "markdown",
            Self::Oid => "oid",
            Self::PositiveInt => "positiveInt",
            Self::String => "string",
            Self::Time => "time",
            Self::UnsignedInt => "unsignedInt",
            Self::Uri => "uri",
            Self::Url => "url",
            Self::Uuid => "uuid",
            Self::Xhtml => "xhtml",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for DataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DataType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DataType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DataType> for Coding {
    fn from(code: DataType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/data-types".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DataType> for CodeableConcept {
    fn from(code: DataType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DaysOfWeek](http://hl7.org/fhir/ValueSet/days-of-week)**. The days of the week.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DaysOfWeek {
    /** **fri**

Friday. Friday. */
    Fri,
    /** **mon**

Monday. Monday. */
    Mon,
    /** **sat**

Saturday. Saturday. */
    Sat,
    /** **sun**

Sunday. Sunday. */
    Sun,
    /** **thu**

Thursday. Thursday. */
    Thu,
    /** **tue**

Tuesday. Tuesday. */
    Tue,
    /** **wed**

Wednesday. Wednesday. */
    Wed,
}
impl ::core::str::FromStr for DaysOfWeek {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fri" => Ok(Self::Fri),
            "mon" => Ok(Self::Mon),
            "sat" => Ok(Self::Sat),
            "sun" => Ok(Self::Sun),
            "thu" => Ok(Self::Thu),
            "tue" => Ok(Self::Tue),
            "wed" => Ok(Self::Wed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DaysOfWeek {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fri => "fri",
            Self::Mon => "mon",
            Self::Sat => "sat",
            Self::Sun => "sun",
            Self::Thu => "thu",
            Self::Tue => "tue",
            Self::Wed => "wed",
        }
    }
}
impl ::std::fmt::Debug for DaysOfWeek {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DaysOfWeek {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DaysOfWeek {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DaysOfWeek {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DaysOfWeek> for Coding {
    fn from(code: DaysOfWeek) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/days-of-week".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DaysOfWeek> for CodeableConcept {
    fn from(code: DaysOfWeek) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DefinitionResourceType](http://hl7.org/fhir/ValueSet/definition-resource-types)**. A list of all the definition resource types defined in this version of the FHIR specification.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DefinitionResourceType {
    /** **ActivityDefinition**

ActivityDefinition. This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context. */
    ActivityDefinition,
    /** **EventDefinition**

EventDefinition. The EventDefinition resource provides a reusable description of when a particular event can occur. */
    EventDefinition,
    /** **Measure**

Measure. The Measure resource provides the definition of a quality measure. */
    Measure,
    /** **OperationDefinition**

OperationDefinition. A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction). */
    OperationDefinition,
    /** **PlanDefinition**

PlanDefinition. This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols. */
    PlanDefinition,
    /** **Questionnaire**

Questionnaire. A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection. */
    Questionnaire,
}
impl ::core::str::FromStr for DefinitionResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActivityDefinition" => Ok(Self::ActivityDefinition),
            "EventDefinition" => Ok(Self::EventDefinition),
            "Measure" => Ok(Self::Measure),
            "OperationDefinition" => Ok(Self::OperationDefinition),
            "PlanDefinition" => Ok(Self::PlanDefinition),
            "Questionnaire" => Ok(Self::Questionnaire),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActivityDefinition => "ActivityDefinition",
            Self::EventDefinition => "EventDefinition",
            Self::Measure => "Measure",
            Self::OperationDefinition => "OperationDefinition",
            Self::PlanDefinition => "PlanDefinition",
            Self::Questionnaire => "Questionnaire",
        }
    }
}
impl ::std::fmt::Debug for DefinitionResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DefinitionResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DefinitionResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DefinitionResourceType> for Coding {
    fn from(code: DefinitionResourceType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/definition-resource-types".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DefinitionResourceType> for CodeableConcept {
    fn from(code: DefinitionResourceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DefinitionStatus](http://hl7.org/fhir/ValueSet/definition-status)**. Codes identifying the lifecycle stage of a definition.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DefinitionStatus {
    /** **active**

Active. The definition is considered ready for use. */
    Active,
    /** **draft**

Draft. The definition is in the design stage and is not yet considered to be "ready for use". */
    Draft,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this resource.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply,  but the authoring/source system does not know which. */
    Unknown,
    /** **withdrawn**

Withdrawn. The definition should no longer be used. */
    Withdrawn,
}
impl ::core::str::FromStr for DefinitionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "unknown" => Ok(Self::Unknown),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::Unknown => "unknown",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Debug for DefinitionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DefinitionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DefinitionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DefinitionStatus> for Coding {
    fn from(code: DefinitionStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/definition-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DefinitionStatus> for CodeableConcept {
    fn from(code: DefinitionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DefinitionTopic](http://hl7.org/fhir/ValueSet/definition-topic)**. High-level categorization of the definition, used for searching, sorting, and filtering.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DefinitionTopic {
    /** **assessment**

Assessment. The definition is related to assessment of the patient. */
    Assessment,
    /** **education**

Education. The definition is related to education of the patient. */
    Education,
    /** **treatment**

Treatment. The definition is related to treatment of the patient. */
    Treatment,
}
impl ::core::str::FromStr for DefinitionTopic {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assessment" => Ok(Self::Assessment),
            "education" => Ok(Self::Education),
            "treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionTopic {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assessment => "assessment",
            Self::Education => "education",
            Self::Treatment => "treatment",
        }
    }
}
impl ::std::fmt::Debug for DefinitionTopic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DefinitionTopic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DefinitionTopic {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionTopic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DefinitionTopic> for Coding {
    fn from(code: DefinitionTopic) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/definition-topic".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DefinitionTopic> for CodeableConcept {
    fn from(code: DefinitionTopic) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DefinitionUseCodes](http://hl7.org/fhir/ValueSet/definition-use)**. Structure Definition Use Codes / Keywords\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DefinitionUseCodes {
    /** **archetype**

Domain Analysis Model. This structure captures an analysis of a domain */
    Archetype,
    /** **custom-resource**

Custom Resource. This structure is intended to be treated like a FHIR resource (e.g. on the FHIR API) */
    CustomResource,
    /** **dam**

Domain Analysis Model. This structure captures an analysis of a domain */
    Dam,
    /** **fhir-structure**

FHIR Structure. This structure is defined as part of the base FHIR Specification */
    FhirStructure,
    /** **template**

Template. This structure is a template (n.b: 'template' has many meanings) */
    Template,
    /** **wire-format**

Wire Format. This structure represents and existing structure (e.g. CDA, HL7 v2) */
    WireFormat,
}
impl ::core::str::FromStr for DefinitionUseCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "archetype" => Ok(Self::Archetype),
            "custom-resource" => Ok(Self::CustomResource),
            "dam" => Ok(Self::Dam),
            "fhir-structure" => Ok(Self::FhirStructure),
            "template" => Ok(Self::Template),
            "wire-format" => Ok(Self::WireFormat),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionUseCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Archetype => "archetype",
            Self::CustomResource => "custom-resource",
            Self::Dam => "dam",
            Self::FhirStructure => "fhir-structure",
            Self::Template => "template",
            Self::WireFormat => "wire-format",
        }
    }
}
impl ::std::fmt::Debug for DefinitionUseCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DefinitionUseCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DefinitionUseCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionUseCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DefinitionUseCodes> for Coding {
    fn from(code: DefinitionUseCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/definition-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DefinitionUseCodes> for CodeableConcept {
    fn from(code: DefinitionUseCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DetectedIssueSeverity](http://hl7.org/fhir/ValueSet/detectedissue-severity)**. Indicates the potential degree of impact of the identified issue on the patient.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DetectedIssueSeverity {
    /** **high**

High. Indicates the issue may be life-threatening or has the potential to cause permanent injury. */
    High,
    /** **low**

Low. Indicates the issue may result in some adverse consequences but is unlikely to substantially affect the situation of the subject. */
    Low,
    /** **moderate**

Moderate. Indicates the issue may result in noticeable adverse consequences but is unlikely to be life-threatening or cause permanent injury. */
    Moderate,
}
impl ::core::str::FromStr for DetectedIssueSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DetectedIssueSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
        }
    }
}
impl ::std::fmt::Debug for DetectedIssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DetectedIssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DetectedIssueSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DetectedIssueSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DetectedIssueSeverity> for Coding {
    fn from(code: DetectedIssueSeverity) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/detectedissue-severity".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DetectedIssueSeverity> for CodeableConcept {
    fn from(code: DetectedIssueSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricCalibrationState](http://hl7.org/fhir/ValueSet/metric-calibration-state)**. Describes the state of a metric calibration.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricCalibrationState {
    /** **calibrated**

Calibrated. The metric has been calibrated. */
    Calibrated,
    /** **calibration-required**

Calibration Required. The metric needs to be calibrated. */
    CalibrationRequired,
    /** **not-calibrated**

Not Calibrated. The metric has not been calibrated. */
    NotCalibrated,
    /** **unspecified**

Unspecified. The state of calibration of this metric is unspecified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCalibrationState {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calibrated" => Ok(Self::Calibrated),
            "calibration-required" => Ok(Self::CalibrationRequired),
            "not-calibrated" => Ok(Self::NotCalibrated),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCalibrationState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calibrated => "calibrated",
            Self::CalibrationRequired => "calibration-required",
            Self::NotCalibrated => "not-calibrated",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricCalibrationState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricCalibrationState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCalibrationState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCalibrationState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricCalibrationState> for Coding {
    fn from(code: DeviceMetricCalibrationState) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/metric-calibration-state".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricCalibrationState> for CodeableConcept {
    fn from(code: DeviceMetricCalibrationState) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricCalibrationType](http://hl7.org/fhir/ValueSet/metric-calibration-type)**. Describes the type of a metric calibration.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricCalibrationType {
    /** **gain**

Gain. Gain metric calibration method. */
    Gain,
    /** **offset**

Offset. Offset metric calibration method. */
    Offset,
    /** **two-point**

Two Point. Two-point metric calibration method. */
    TwoPoint,
    /** **unspecified**

Unspecified. Metric calibration method has not been identified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCalibrationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "gain" => Ok(Self::Gain),
            "offset" => Ok(Self::Offset),
            "two-point" => Ok(Self::TwoPoint),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCalibrationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Gain => "gain",
            Self::Offset => "offset",
            Self::TwoPoint => "two-point",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricCalibrationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricCalibrationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCalibrationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCalibrationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricCalibrationType> for Coding {
    fn from(code: DeviceMetricCalibrationType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/metric-calibration-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricCalibrationType> for CodeableConcept {
    fn from(code: DeviceMetricCalibrationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricCategory](http://hl7.org/fhir/ValueSet/metric-category)**. Describes the category of the metric.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricCategory {
    /** **calculation**

Calculation. DeviceObservations generated for this DeviceMetric are calculated. */
    Calculation,
    /** **measurement**

Measurement. DeviceObservations generated for this DeviceMetric are measured. */
    Measurement,
    /** **setting**

Setting. DeviceObservations generated for this DeviceMetric is a setting that will influence the behavior of the Device. */
    Setting,
    /** **unspecified**

Unspecified. The category of this DeviceMetric is unspecified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calculation" => Ok(Self::Calculation),
            "measurement" => Ok(Self::Measurement),
            "setting" => Ok(Self::Setting),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calculation => "calculation",
            Self::Measurement => "measurement",
            Self::Setting => "setting",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricCategory> for Coding {
    fn from(code: DeviceMetricCategory) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/metric-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricCategory> for CodeableConcept {
    fn from(code: DeviceMetricCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricColor](http://hl7.org/fhir/ValueSet/metric-color)**. Describes the typical color of representation.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricColor {
    /** **black**

Color Black. Color for representation - black. */
    Black,
    /** **blue**

Color Blue. Color for representation - blue. */
    Blue,
    /** **cyan**

Color Cyan. Color for representation - cyan. */
    Cyan,
    /** **green**

Color Green. Color for representation - green. */
    Green,
    /** **magenta**

Color Magenta. Color for representation - magenta. */
    Magenta,
    /** **red**

Color Red. Color for representation - red. */
    Red,
    /** **white**

Color White. Color for representation - white. */
    White,
    /** **yellow**

Color Yellow. Color for representation - yellow. */
    Yellow,
}
impl ::core::str::FromStr for DeviceMetricColor {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "black" => Ok(Self::Black),
            "blue" => Ok(Self::Blue),
            "cyan" => Ok(Self::Cyan),
            "green" => Ok(Self::Green),
            "magenta" => Ok(Self::Magenta),
            "red" => Ok(Self::Red),
            "white" => Ok(Self::White),
            "yellow" => Ok(Self::Yellow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricColor {
    fn as_ref(&self) -> &str {
        match self {
            Self::Black => "black",
            Self::Blue => "blue",
            Self::Cyan => "cyan",
            Self::Green => "green",
            Self::Magenta => "magenta",
            Self::Red => "red",
            Self::White => "white",
            Self::Yellow => "yellow",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricColor {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricColor {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricColor> for Coding {
    fn from(code: DeviceMetricColor) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/metric-color".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricColor> for CodeableConcept {
    fn from(code: DeviceMetricColor) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceMetricOperationalStatus](http://hl7.org/fhir/ValueSet/metric-operational-status)**. Describes the operational status of the DeviceMetric.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceMetricOperationalStatus {
    /** **entered-in-error**

Entered In Error. The DeviceMetric was entered in error. */
    EnteredInError,
    /** **off**

Off. The DeviceMetric is not operating. */
    Off,
    /** **on**

On. The DeviceMetric is operating and will generate DeviceObservations. */
    On,
    /** **standby**

Standby. The DeviceMetric is operating, but will not generate any DeviceObservations. */
    Standby,
}
impl ::core::str::FromStr for DeviceMetricOperationalStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "entered-in-error" => Ok(Self::EnteredInError),
            "off" => Ok(Self::Off),
            "on" => Ok(Self::On),
            "standby" => Ok(Self::Standby),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricOperationalStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::EnteredInError => "entered-in-error",
            Self::Off => "off",
            Self::On => "on",
            Self::Standby => "standby",
        }
    }
}
impl ::std::fmt::Debug for DeviceMetricOperationalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceMetricOperationalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceMetricOperationalStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricOperationalStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricOperationalStatus> for Coding {
    fn from(code: DeviceMetricOperationalStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/metric-operational-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceMetricOperationalStatus> for CodeableConcept {
    fn from(code: DeviceMetricOperationalStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceNameType](http://hl7.org/fhir/ValueSet/device-nametype)**. The type of name the device is referred by.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceNameType {
    /** **manufacturer-name**

Manufacturer name. Manufacturer name. */
    ManufacturerName,
    /** **model-name**

Model name. Model name. */
    ModelName,
    /** **other**

other. other. */
    Other,
    /** **patient-reported-name**

Patient Reported name. Patient Reported name. */
    PatientReportedName,
    /** **udi-label-name**

UDI Label name. UDI Label name. */
    UdiLabelName,
    /** **user-friendly-name**

User Friendly name. User Friendly name. */
    UserFriendlyName,
}
impl ::core::str::FromStr for DeviceNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "manufacturer-name" => Ok(Self::ManufacturerName),
            "model-name" => Ok(Self::ModelName),
            "other" => Ok(Self::Other),
            "patient-reported-name" => Ok(Self::PatientReportedName),
            "udi-label-name" => Ok(Self::UdiLabelName),
            "user-friendly-name" => Ok(Self::UserFriendlyName),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ManufacturerName => "manufacturer-name",
            Self::ModelName => "model-name",
            Self::Other => "other",
            Self::PatientReportedName => "patient-reported-name",
            Self::UdiLabelName => "udi-label-name",
            Self::UserFriendlyName => "user-friendly-name",
        }
    }
}
impl ::std::fmt::Debug for DeviceNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceNameType> for Coding {
    fn from(code: DeviceNameType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/device-nametype".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceNameType> for CodeableConcept {
    fn from(code: DeviceNameType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DeviceUseStatementStatus](http://hl7.org/fhir/ValueSet/device-statement-status)**. A coded concept indicating the current status of the Device Usage.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DeviceUseStatementStatus {
    /** **active**

Active. The device is still being used. */
    Active,
    /** **completed**

Completed. The device is no longer being used. */
    Completed,
    /** **entered-in-error**

Entered in Error. The statement was recorded incorrectly. */
    EnteredInError,
    /** **intended**

Intended. The device may be used at some time in the future. */
    Intended,
    /** **on-hold**

On Hold. Actions implied by the statement have been temporarily halted, but are expected to continue later. May also be called "suspended". */
    OnHold,
    /** **stopped**

Stopped. Actions implied by the statement have been permanently halted, before all of them occurred. */
    Stopped,
}
impl ::core::str::FromStr for DeviceUseStatementStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "intended" => Ok(Self::Intended),
            "on-hold" => Ok(Self::OnHold),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceUseStatementStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::Intended => "intended",
            Self::OnHold => "on-hold",
            Self::Stopped => "stopped",
        }
    }
}
impl ::std::fmt::Debug for DeviceUseStatementStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DeviceUseStatementStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DeviceUseStatementStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceUseStatementStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceUseStatementStatus> for Coding {
    fn from(code: DeviceUseStatementStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/device-statement-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DeviceUseStatementStatus> for CodeableConcept {
    fn from(code: DeviceUseStatementStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DiagnosisRole](http://hl7.org/fhir/ValueSet/diagnosis-role)**. This value set defines a set of codes that can be used to express the role of a diagnosis on the Encounter or EpisodeOfCare record.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DiagnosisRole {
    /** **AD**

Admission diagnosis. */
    Ad,
    /** **CC**

Chief complaint. */
    Cc,
    /** **CM**

Comorbidity diagnosis. */
    Cm,
    /** **DD**

Discharge diagnosis. */
    Dd,
    /** **billing**

Billing. */
    Billing,
    /** **post-op**

post-op diagnosis. */
    PostOp,
    /** **pre-op**

pre-op diagnosis. */
    PreOp,
}
impl ::core::str::FromStr for DiagnosisRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AD" => Ok(Self::Ad),
            "CC" => Ok(Self::Cc),
            "CM" => Ok(Self::Cm),
            "DD" => Ok(Self::Dd),
            "billing" => Ok(Self::Billing),
            "post-op" => Ok(Self::PostOp),
            "pre-op" => Ok(Self::PreOp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiagnosisRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ad => "AD",
            Self::Cc => "CC",
            Self::Cm => "CM",
            Self::Dd => "DD",
            Self::Billing => "billing",
            Self::PostOp => "post-op",
            Self::PreOp => "pre-op",
        }
    }
}
impl ::std::fmt::Debug for DiagnosisRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DiagnosisRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DiagnosisRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiagnosisRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DiagnosisRole> for Coding {
    fn from(code: DiagnosisRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/diagnosis-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DiagnosisRole> for CodeableConcept {
    fn from(code: DiagnosisRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DiagnosticReportStatus](http://hl7.org/fhir/ValueSet/diagnostic-report-status)**. The status of the diagnostic report.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DiagnosticReportStatus {
    /** **amended**

Amended. Subsequent to being final, the report has been modified.  This includes any change in the results, diagnosis, narrative text, or other content of a report that has been issued. */
    Amended,
    /** **appended**

Appended. Subsequent to being final, the report has been modified by adding new content. The existing content is unchanged. */
    Appended,
    /** **cancelled**

Cancelled. The report is unavailable because the measurement was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **corrected**

Corrected. Subsequent to being final, the report has been modified  to correct an error in the report or referenced results. */
    Corrected,
    /** **entered-in-error**

Entered in Error. The report has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **final**

Final. The report is complete and verified by an authorized person. */
    Final,
    /** **partial**

Partial. This is a partial (e.g. initial, interim or preliminary) report: data in the report may be incomplete or unverified. */
    Partial,
    /** **preliminary**

Preliminary. Verified early results are available, but not all  results are final. */
    Preliminary,
    /** **registered**

Registered. The existence of the report is registered, but there is nothing yet available. */
    Registered,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for DiagnosticReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "corrected" => Ok(Self::Corrected),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "partial" => Ok(Self::Partial),
            "preliminary" => Ok(Self::Preliminary),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiagnosticReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Corrected => "corrected",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Partial => "partial",
            Self::Preliminary => "preliminary",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for DiagnosticReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DiagnosticReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DiagnosticReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiagnosticReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DiagnosticReportStatus> for Coding {
    fn from(code: DiagnosticReportStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/diagnostic-report-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DiagnosticReportStatus> for CodeableConcept {
    fn from(code: DiagnosticReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[Diet](http://terminology.hl7.org/CodeSystem/diet)**. This codesystem defines a set of codes that can be used to indicate dietary preferences or restrictions a patient may have.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum Diet {
    /** **dairy-free**

Dairy Free. Excludes dairy products. */
    DairyFree,
    /** **gluten-free**

Gluten Free. Excludes ingredients containing gluten. */
    GlutenFree,
    /** **halal**

Halal. Foods that conform to Islamic law. */
    Halal,
    /** **kosher**

Kosher. Foods that conform to Jewish dietary law. */
    Kosher,
    /** **nut-free**

Nut Free. Excludes ingredients containing nuts. */
    NutFree,
    /** **vegan**

Vegan. Food without meat, poultry, seafood, eggs, dairy products and other animal-derived substances. */
    Vegan,
    /** **vegetarian**

Vegetarian. Food without meat, poultry or seafood. */
    Vegetarian,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for Diet {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "dairy-free" => Ok(Self::DairyFree),
            "gluten-free" => Ok(Self::GlutenFree),
            "halal" => Ok(Self::Halal),
            "kosher" => Ok(Self::Kosher),
            "nut-free" => Ok(Self::NutFree),
            "vegan" => Ok(Self::Vegan),
            "vegetarian" => Ok(Self::Vegetarian),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for Diet {
    fn as_ref(&self) -> &str {
        match self {
            Self::DairyFree => "dairy-free",
            Self::GlutenFree => "gluten-free",
            Self::Halal => "halal",
            Self::Kosher => "kosher",
            Self::NutFree => "nut-free",
            Self::Vegan => "vegan",
            Self::Vegetarian => "vegetarian",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for Diet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for Diet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for Diet {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Diet {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<Diet> for Coding {
    fn from(code: Diet) -> Self {
        CodingInner {
            system: Some("http://terminology.hl7.org/CodeSystem/diet".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<Diet> for CodeableConcept {
    fn from(code: Diet) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DigitalMediaType](http://hl7.org/fhir/ValueSet/media-category)**. Codes for high level media types - whether the media is an image, video, or audio.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DigitalMediaType {
    /** **audio**

Audio. The media consists of a sound recording */
    Audio,
    /** **image**

Image. The media consists of one or more unmoving images, including photographs, computer-generated graphs and charts, and scanned documents */
    Image,
    /** **video**

Video. The media consists of a series of frames that capture a moving image */
    Video,
}
impl ::core::str::FromStr for DigitalMediaType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "audio" => Ok(Self::Audio),
            "image" => Ok(Self::Image),
            "video" => Ok(Self::Video),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DigitalMediaType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Audio => "audio",
            Self::Image => "image",
            Self::Video => "video",
        }
    }
}
impl ::std::fmt::Debug for DigitalMediaType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DigitalMediaType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DigitalMediaType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DigitalMediaType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DigitalMediaType> for Coding {
    fn from(code: DigitalMediaType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/media-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DigitalMediaType> for CodeableConcept {
    fn from(code: DigitalMediaType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DischargeDisposition](http://terminology.hl7.org/CodeSystem/discharge-disposition)**. This codesystem defines a set of codes that can be used to where the patient left the hospital.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum DischargeDisposition {
    /** **aadvice**

Left against advice. The patient self discharged against medical advice. */
    Aadvice,
    /** **alt-home**

Alternative home. The patient was discharged and has indicated that they are going to return home afterwards, but not the patient's home - e.g. a family member's home. */
    AltHome,
    /** **exp**

Expired. The patient has deceased during this encounter. */
    Exp,
    /** **home**

Home. The patient was dicharged and has indicated that they are going to return home afterwards. */
    Home,
    /** **hosp**

Hospice. The patient has been discharged into palliative care. */
    Hosp,
    /** **long**

Long-term care. The patient has been discharged into long-term care where is likely to be monitored through an ongoing episode-of-care. */
    Long,
    /** **oth**

Other. The discharge disposition has not otherwise defined. */
    Oth,
    /** **other-hcf**

Other healthcare facility. The patient was transferred to another healthcare facility. */
    OtherHcf,
    /** **psy**

Psychiatric hospital. The patient has been transferred to a psychiatric facility. */
    Psy,
    /** **rehab**

Rehabilitation. The patient was discharged and is to receive post acute care rehabilitation services. */
    Rehab,
    /** **snf**

Skilled nursing facility. The patient has been discharged to a skilled nursing facility for the patient to receive additional care. */
    Snf,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for DischargeDisposition {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aadvice" => Ok(Self::Aadvice),
            "alt-home" => Ok(Self::AltHome),
            "exp" => Ok(Self::Exp),
            "home" => Ok(Self::Home),
            "hosp" => Ok(Self::Hosp),
            "long" => Ok(Self::Long),
            "oth" => Ok(Self::Oth),
            "other-hcf" => Ok(Self::OtherHcf),
            "psy" => Ok(Self::Psy),
            "rehab" => Ok(Self::Rehab),
            "snf" => Ok(Self::Snf),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for DischargeDisposition {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aadvice => "aadvice",
            Self::AltHome => "alt-home",
            Self::Exp => "exp",
            Self::Home => "home",
            Self::Hosp => "hosp",
            Self::Long => "long",
            Self::Oth => "oth",
            Self::OtherHcf => "other-hcf",
            Self::Psy => "psy",
            Self::Rehab => "rehab",
            Self::Snf => "snf",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for DischargeDisposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DischargeDisposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DischargeDisposition {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DischargeDisposition {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DischargeDisposition> for Coding {
    fn from(code: DischargeDisposition) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/discharge-disposition".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DischargeDisposition> for CodeableConcept {
    fn from(code: DischargeDisposition) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DiscriminatorType](http://hl7.org/fhir/ValueSet/discriminator-type)**. How an element value is interpreted when discrimination is evaluated.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DiscriminatorType {
    /** **exists**

Exists. The slices are differentiated by the presence or absence of the nominated element. */
    Exists,
    /** **pattern**

Pattern. The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x]. */
    Pattern,
    /** **profile**

Profile. The slices are differentiated by conformance of the nominated element to a specified profile. Note that if the path specifies .resolve() then the profile is the target profile on the reference. In this case, validation by the possible profiles is required to differentiate the slices. */
    Profile,
    /** **type**

Type. The slices are differentiated by type of the nominated element. */
    Type,
    /** **value**

Value. The slices have different values in the nominated element. */
    Value,
}
impl ::core::str::FromStr for DiscriminatorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exists" => Ok(Self::Exists),
            "pattern" => Ok(Self::Pattern),
            "profile" => Ok(Self::Profile),
            "type" => Ok(Self::Type),
            "value" => Ok(Self::Value),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiscriminatorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exists => "exists",
            Self::Pattern => "pattern",
            Self::Profile => "profile",
            Self::Type => "type",
            Self::Value => "value",
        }
    }
}
impl ::std::fmt::Debug for DiscriminatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DiscriminatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DiscriminatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiscriminatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DiscriminatorType> for Coding {
    fn from(code: DiscriminatorType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/discriminator-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DiscriminatorType> for CodeableConcept {
    fn from(code: DiscriminatorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DocumentMode](http://hl7.org/fhir/ValueSet/document-mode)**. Whether the application produces or consumes documents.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DocumentMode {
    /** **consumer**

Consumer. The application consumes documents of the specified type. */
    Consumer,
    /** **producer**

Producer. The application produces documents of the specified type. */
    Producer,
}
impl ::core::str::FromStr for DocumentMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "consumer" => Ok(Self::Consumer),
            "producer" => Ok(Self::Producer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consumer => "consumer",
            Self::Producer => "producer",
        }
    }
}
impl ::std::fmt::Debug for DocumentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DocumentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DocumentMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DocumentMode> for Coding {
    fn from(code: DocumentMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/document-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DocumentMode> for CodeableConcept {
    fn from(code: DocumentMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DocumentReferenceStatus](http://hl7.org/fhir/ValueSet/document-reference-status)**. The status of the document reference.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DocumentReferenceStatus {
    /** **current**

Current. This is the current reference for this document. */
    Current,
    /** **entered-in-error**

Entered in Error. This reference was created in error. */
    EnteredInError,
    /** **superseded**

Superseded. This reference has been superseded by another reference. */
    Superseded,
}
impl ::core::str::FromStr for DocumentReferenceStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "current" => Ok(Self::Current),
            "entered-in-error" => Ok(Self::EnteredInError),
            "superseded" => Ok(Self::Superseded),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentReferenceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Current => "current",
            Self::EnteredInError => "entered-in-error",
            Self::Superseded => "superseded",
        }
    }
}
impl ::std::fmt::Debug for DocumentReferenceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DocumentReferenceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DocumentReferenceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentReferenceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DocumentReferenceStatus> for Coding {
    fn from(code: DocumentReferenceStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/document-reference-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DocumentReferenceStatus> for CodeableConcept {
    fn from(code: DocumentReferenceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DocumentRelationshipType](http://hl7.org/fhir/ValueSet/document-relationship-type)**. The type of relationship between documents.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DocumentRelationshipType {
    /** **appends**

Appends. This document adds additional information to the target document. */
    Appends,
    /** **replaces**

Replaces. This document logically replaces or supersedes the target document. */
    Replaces,
    /** **signs**

Signs. This document is a signature of the target document. */
    Signs,
    /** **transforms**

Transforms. This document was generated by transforming the target document (e.g. format or language conversion). */
    Transforms,
}
impl ::core::str::FromStr for DocumentRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "appends" => Ok(Self::Appends),
            "replaces" => Ok(Self::Replaces),
            "signs" => Ok(Self::Signs),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Appends => "appends",
            Self::Replaces => "replaces",
            Self::Signs => "signs",
            Self::Transforms => "transforms",
        }
    }
}
impl ::std::fmt::Debug for DocumentRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DocumentRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DocumentRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DocumentRelationshipType> for Coding {
    fn from(code: DocumentRelationshipType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/document-relationship-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DocumentRelationshipType> for CodeableConcept {
    fn from(code: DocumentRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[DoseAndRateType](http://hl7.org/fhir/ValueSet/dose-rate-type)**. The kind of dose or rate specified.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum DoseAndRateType {
    /** **calculated**

Calculated. The dose specified is calculated by the prescriber or the system. */
    Calculated,
    /** **ordered**

Ordered. The dose specified is as ordered by the prescriber. */
    Ordered,
}
impl ::core::str::FromStr for DoseAndRateType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calculated" => Ok(Self::Calculated),
            "ordered" => Ok(Self::Ordered),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DoseAndRateType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calculated => "calculated",
            Self::Ordered => "ordered",
        }
    }
}
impl ::std::fmt::Debug for DoseAndRateType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for DoseAndRateType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for DoseAndRateType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DoseAndRateType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DoseAndRateType> for Coding {
    fn from(code: DoseAndRateType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/dose-rate-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<DoseAndRateType> for CodeableConcept {
    fn from(code: DoseAndRateType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EligibilityRequestPurpose](http://hl7.org/fhir/ValueSet/eligibilityrequest-purpose)**. A code specifying the types of information being requested.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EligibilityRequestPurpose {
    /** **auth-requirements**

Coverage auth-requirements. The prior authorization requirements for the listed, or discovered if specified, converages for the categories of service and/or specifed biling codes are requested. */
    AuthRequirements,
    /** **benefits**

Coverage benefits. The plan benefits and optionally benefits consumed  for the listed, or discovered if specified, converages are requested. */
    Benefits,
    /** **discovery**

Coverage Discovery. The insurer is requested to report on any coverages which they are aware of in addition to any specifed. */
    Discovery,
    /** **validation**

Coverage Validation. A check that the specified coverages are in-force is requested. */
    Validation,
}
impl ::core::str::FromStr for EligibilityRequestPurpose {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "auth-requirements" => Ok(Self::AuthRequirements),
            "benefits" => Ok(Self::Benefits),
            "discovery" => Ok(Self::Discovery),
            "validation" => Ok(Self::Validation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EligibilityRequestPurpose {
    fn as_ref(&self) -> &str {
        match self {
            Self::AuthRequirements => "auth-requirements",
            Self::Benefits => "benefits",
            Self::Discovery => "discovery",
            Self::Validation => "validation",
        }
    }
}
impl ::std::fmt::Debug for EligibilityRequestPurpose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EligibilityRequestPurpose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EligibilityRequestPurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EligibilityRequestPurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EligibilityRequestPurpose> for Coding {
    fn from(code: EligibilityRequestPurpose) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/eligibilityrequest-purpose".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EligibilityRequestPurpose> for CodeableConcept {
    fn from(code: EligibilityRequestPurpose) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EligibilityResponsePurpose](http://hl7.org/fhir/ValueSet/eligibilityresponse-purpose)**. A code specifying the types of information being requested.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EligibilityResponsePurpose {
    /** **auth-requirements**

Coverage auth-requirements. The prior authorization requirements for the listed, or discovered if specified, converages for the categories of service and/or specifed biling codes are requested. */
    AuthRequirements,
    /** **benefits**

Coverage benefits. The plan benefits and optionally benefits consumed  for the listed, or discovered if specified, converages are requested. */
    Benefits,
    /** **discovery**

Coverage Discovery. The insurer is requested to report on any coverages which they are aware of in addition to any specifed. */
    Discovery,
    /** **validation**

Coverage Validation. A check that the specified coverages are in-force is requested. */
    Validation,
}
impl ::core::str::FromStr for EligibilityResponsePurpose {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "auth-requirements" => Ok(Self::AuthRequirements),
            "benefits" => Ok(Self::Benefits),
            "discovery" => Ok(Self::Discovery),
            "validation" => Ok(Self::Validation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EligibilityResponsePurpose {
    fn as_ref(&self) -> &str {
        match self {
            Self::AuthRequirements => "auth-requirements",
            Self::Benefits => "benefits",
            Self::Discovery => "discovery",
            Self::Validation => "validation",
        }
    }
}
impl ::std::fmt::Debug for EligibilityResponsePurpose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EligibilityResponsePurpose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EligibilityResponsePurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EligibilityResponsePurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EligibilityResponsePurpose> for Coding {
    fn from(code: EligibilityResponsePurpose) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/eligibilityresponse-purpose".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EligibilityResponsePurpose> for CodeableConcept {
    fn from(code: EligibilityResponsePurpose) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EnableWhenBehavior](http://hl7.org/fhir/ValueSet/questionnaire-enable-behavior)**. Controls how multiple enableWhen values are interpreted -  whether all or any must be true.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EnableWhenBehavior {
    /** **all**

All. Enable the question when all the enableWhen criteria are satisfied. */
    All,
    /** **any**

Any. Enable the question when any of the enableWhen criteria are satisfied. */
    Any,
}
impl ::core::str::FromStr for EnableWhenBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "any" => Ok(Self::Any),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EnableWhenBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::All => "all",
            Self::Any => "any",
        }
    }
}
impl ::std::fmt::Debug for EnableWhenBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EnableWhenBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EnableWhenBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EnableWhenBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EnableWhenBehavior> for Coding {
    fn from(code: EnableWhenBehavior) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/questionnaire-enable-behavior".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EnableWhenBehavior> for CodeableConcept {
    fn from(code: EnableWhenBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EncounterLocationStatus](http://hl7.org/fhir/ValueSet/encounter-location-status)**. The status of the location.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EncounterLocationStatus {
    /** **active**

Active. The patient is currently at this location, or was between the period specified.

A system may update these records when the patient leaves the location to either reserved, or completed. */
    Active,
    /** **completed**

Completed. The patient was at this location during the period specified.

Not to be used when the patient is currently at the location. */
    Completed,
    /** **planned**

Planned. The patient is planned to be moved to this location at some point in the future. */
    Planned,
    /** **reserved**

Reserved. This location is held empty for this patient. */
    Reserved,
}
impl ::core::str::FromStr for EncounterLocationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "planned" => Ok(Self::Planned),
            "reserved" => Ok(Self::Reserved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterLocationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::Planned => "planned",
            Self::Reserved => "reserved",
        }
    }
}
impl ::std::fmt::Debug for EncounterLocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EncounterLocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EncounterLocationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterLocationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterLocationStatus> for Coding {
    fn from(code: EncounterLocationStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/encounter-location-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EncounterLocationStatus> for CodeableConcept {
    fn from(code: EncounterLocationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EncounterStatus](http://hl7.org/fhir/ValueSet/encounter-status)**. Current state of the encounter.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EncounterStatus {
    /** **arrived**

Arrived. The Patient is present for the encounter, however is not currently meeting with a practitioner. */
    Arrived,
    /** **cancelled**

Cancelled. The Encounter has ended before it has begun. */
    Cancelled,
    /** **entered-in-error**

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **finished**

Finished. The Encounter has ended. */
    Finished,
    /** **in-progress**

In Progress. The Encounter has begun and the patient is present / the practitioner and the patient are meeting. */
    InProgress,
    /** **onleave**

On Leave. The Encounter has begun, but the patient is temporarily on leave. */
    Onleave,
    /** **planned**

Planned. The Encounter has not yet started. */
    Planned,
    /** **triaged**

Triaged. The patient has been assessed for the priority of their treatment based on the severity of their condition. */
    Triaged,
    /** **unknown**

Unknown. The encounter status is unknown. Note that "unknown" is a value of last resort and every attempt should be made to provide a meaningful value other than "unknown". */
    Unknown,
}
impl ::core::str::FromStr for EncounterStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "arrived" => Ok(Self::Arrived),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "finished" => Ok(Self::Finished),
            "in-progress" => Ok(Self::InProgress),
            "onleave" => Ok(Self::Onleave),
            "planned" => Ok(Self::Planned),
            "triaged" => Ok(Self::Triaged),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Arrived => "arrived",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Finished => "finished",
            Self::InProgress => "in-progress",
            Self::Onleave => "onleave",
            Self::Planned => "planned",
            Self::Triaged => "triaged",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for EncounterStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EncounterStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EncounterStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterStatus> for Coding {
    fn from(code: EncounterStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/encounter-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EncounterStatus> for CodeableConcept {
    fn from(code: EncounterStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EncounterType](http://terminology.hl7.org/CodeSystem/encounter-type)**. This example codesystem defines a set of codes that can be used to indicate the type of encounter: a specific code indicating type of service provided.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum EncounterType {
    /** **ADMS**

Annual diabetes mellitus screening. */
    Adms,
    /** **BD/BM-clin**

Bone drilling/bone marrow punction in clinic. */
    BdBmClin,
    /** **CCS60**

Infant colon screening - 60 minutes. */
    Ccs60,
    /** **OKI**

Outpatient Kenacort injection. */
    Oki,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EncounterType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ADMS" => Ok(Self::Adms),
            "BD/BM-clin" => Ok(Self::BdBmClin),
            "CCS60" => Ok(Self::Ccs60),
            "OKI" => Ok(Self::Oki),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EncounterType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adms => "ADMS",
            Self::BdBmClin => "BD/BM-clin",
            Self::Ccs60 => "CCS60",
            Self::Oki => "OKI",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for EncounterType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EncounterType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EncounterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterType> for Coding {
    fn from(code: EncounterType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/encounter-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EncounterType> for CodeableConcept {
    fn from(code: EncounterType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EndpointConnectionType](http://terminology.hl7.org/CodeSystem/endpoint-connection-type)**. This is an example codesystem defined by the FHIR project, that could be used to represent possible connection type profile values.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum EndpointConnectionType {
    /** **dicom-qido-rs**

DICOM QIDO-RS. DICOMweb RESTful Image query - http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html */
    DicomQidoRs,
    /** **dicom-stow-rs**

DICOM STOW-RS. DICOMweb RESTful image sending and storage - http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.6.html */
    DicomStowRs,
    /** **dicom-wado-rs**

DICOM WADO-RS. DICOMweb RESTful Image Retrieve - http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.html */
    DicomWadoRs,
    /** **dicom-wado-uri**

DICOM WADO-URI. DICOMweb Image Retrieve - http://dicom.nema.org/dicom/2013/output/chtml/part18/sect_6.3.html */
    DicomWadoUri,
    /** **direct-project**

Direct Project. Direct Project information - http://wiki.directproject.org/ */
    DirectProject,
    /** **hl7-fhir-msg**

HL7 FHIR Messaging. Use the servers FHIR Messaging interface. Details can be found on the messaging.html page in the FHIR Specification. The FHIR server's base address is specified in the Endpoint.address property. */
    Hl7FhirMsg,
    /** **hl7-fhir-rest**

HL7 FHIR. Interact with the server interface using FHIR's RESTful interface. For details on its version/capabilities you should connect the value in Endpoint.address and retrieve the FHIR CapabilityStatement. */
    Hl7FhirRest,
    /** **hl7v2-mllp**

HL7 v2 MLLP. HL7v2 messages over an LLP TCP connection */
    Hl7V2Mllp,
    /** **ihe-iid**

IHE IID. IHE Invoke Image Display (IID) - http://wiki.ihe.net/index.php/Invoke_Image_Display */
    IheIid,
    /** **ihe-xca**

IHE XCA. IHE Cross Community Access Profile (XCA) - http://wiki.ihe.net/index.php/Cross-Community_Access */
    IheXca,
    /** **ihe-xcpd**

IHE XCPD. IHE Cross Community Patient Discovery Profile (XCPD) - http://wiki.ihe.net/index.php/Cross-Community_Patient_Discovery */
    IheXcpd,
    /** **ihe-xdr**

IHE XDR. IHE Cross-Enterprise Document Reliable Exchange (XDR) - http://wiki.ihe.net/index.php/Cross-enterprise_Document_Reliable_Interchange */
    IheXdr,
    /** **ihe-xds**

IHE XDS. IHE Cross-Enterprise Document Sharing (XDS) - http://wiki.ihe.net/index.php/Cross-Enterprise_Document_Sharing */
    IheXds,
    /** **secure-email**

Secure email. Email delivery using a digital certificate to encrypt the content using the public key, receiver must have the private key to decrypt the content */
    SecureEmail,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EndpointConnectionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "dicom-qido-rs" => Ok(Self::DicomQidoRs),
            "dicom-stow-rs" => Ok(Self::DicomStowRs),
            "dicom-wado-rs" => Ok(Self::DicomWadoRs),
            "dicom-wado-uri" => Ok(Self::DicomWadoUri),
            "direct-project" => Ok(Self::DirectProject),
            "hl7-fhir-msg" => Ok(Self::Hl7FhirMsg),
            "hl7-fhir-rest" => Ok(Self::Hl7FhirRest),
            "hl7v2-mllp" => Ok(Self::Hl7V2Mllp),
            "ihe-iid" => Ok(Self::IheIid),
            "ihe-xca" => Ok(Self::IheXca),
            "ihe-xcpd" => Ok(Self::IheXcpd),
            "ihe-xdr" => Ok(Self::IheXdr),
            "ihe-xds" => Ok(Self::IheXds),
            "secure-email" => Ok(Self::SecureEmail),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EndpointConnectionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DicomQidoRs => "dicom-qido-rs",
            Self::DicomStowRs => "dicom-stow-rs",
            Self::DicomWadoRs => "dicom-wado-rs",
            Self::DicomWadoUri => "dicom-wado-uri",
            Self::DirectProject => "direct-project",
            Self::Hl7FhirMsg => "hl7-fhir-msg",
            Self::Hl7FhirRest => "hl7-fhir-rest",
            Self::Hl7V2Mllp => "hl7v2-mllp",
            Self::IheIid => "ihe-iid",
            Self::IheXca => "ihe-xca",
            Self::IheXcpd => "ihe-xcpd",
            Self::IheXdr => "ihe-xdr",
            Self::IheXds => "ihe-xds",
            Self::SecureEmail => "secure-email",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for EndpointConnectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EndpointConnectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EndpointConnectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EndpointConnectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EndpointConnectionType> for Coding {
    fn from(code: EndpointConnectionType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/endpoint-connection-type"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EndpointConnectionType> for CodeableConcept {
    fn from(code: EndpointConnectionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EndpointPayloadType](http://terminology.hl7.org/CodeSystem/endpoint-payload-type)**. This is an example codesystem defined by the FHIR project, it represents global concepts for no content, or any unrestricted content.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum EndpointPayloadType {
    /** **any**

Any. Any payload type can be used with this endpoint, it is either a payload agnostic infrastructure (such as a storage repository), or some other type of endpoint where payload considerations are internally handled, and not available */
    Any,
    /** **none**

None. This endpoint does not require any content to be sent; simply connecting to the endpoint is enough notification. This can be used as a 'ping' to wakeup a service to retrieve content, which could be to ensure security considerations are correctly handled */
    None,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EndpointPayloadType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "any" => Ok(Self::Any),
            "none" => Ok(Self::None),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EndpointPayloadType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Any => "any",
            Self::None => "none",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for EndpointPayloadType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EndpointPayloadType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EndpointPayloadType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EndpointPayloadType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EndpointPayloadType> for Coding {
    fn from(code: EndpointPayloadType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/endpoint-payload-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EndpointPayloadType> for CodeableConcept {
    fn from(code: EndpointPayloadType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EndpointStatus](http://hl7.org/fhir/ValueSet/endpoint-status)**. The status of the endpoint.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EndpointStatus {
    /** **active**

Active. This endpoint is expected to be active and can be used. */
    Active,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **error**

Error. This endpoint has exceeded connectivity thresholds and is considered in an error state and should no longer be attempted to connect to until corrective action is taken. */
    Error,
    /** **off**

Off. This endpoint is no longer to be used. */
    Off,
    /** **suspended**

Suspended. This endpoint is temporarily unavailable. */
    Suspended,
    /** **test**

Test. This endpoint is not intended for production usage. */
    Test,
}
impl ::core::str::FromStr for EndpointStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "error" => Ok(Self::Error),
            "off" => Ok(Self::Off),
            "suspended" => Ok(Self::Suspended),
            "test" => Ok(Self::Test),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EndpointStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Error => "error",
            Self::Off => "off",
            Self::Suspended => "suspended",
            Self::Test => "test",
        }
    }
}
impl ::std::fmt::Debug for EndpointStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EndpointStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EndpointStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EndpointStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EndpointStatus> for Coding {
    fn from(code: EndpointStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/endpoint-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EndpointStatus> for CodeableConcept {
    fn from(code: EndpointStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EnteralFormulaAdditiveTypeCode](http://terminology.hl7.org/CodeSystem/entformula-additive)**. EnteralFormulaAdditiveType: Codes for the type of modular component such as protein, carbohydrate or fiber to be provided in addition to or mixed with the base formula. This value set is provided as a suggestive example.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum EnteralFormulaAdditiveTypeCode {
    /** **carbohydrate**

Carbohydrate. Modular carbohydrate enteral formula component */
    Carbohydrate,
    /** **fiber**

Fiber. Modular fiber enteral formula component */
    Fiber,
    /** **lipid**

Lipid. Modular lipid enteral formula component */
    Lipid,
    /** **protein**

Protein. Modular protein enteral formula component */
    Protein,
    /** **water**

Water. Added water */
    Water,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EnteralFormulaAdditiveTypeCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "carbohydrate" => Ok(Self::Carbohydrate),
            "fiber" => Ok(Self::Fiber),
            "lipid" => Ok(Self::Lipid),
            "protein" => Ok(Self::Protein),
            "water" => Ok(Self::Water),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EnteralFormulaAdditiveTypeCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Carbohydrate => "carbohydrate",
            Self::Fiber => "fiber",
            Self::Lipid => "lipid",
            Self::Protein => "protein",
            Self::Water => "water",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for EnteralFormulaAdditiveTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EnteralFormulaAdditiveTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EnteralFormulaAdditiveTypeCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EnteralFormulaAdditiveTypeCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EnteralFormulaAdditiveTypeCode> for Coding {
    fn from(code: EnteralFormulaAdditiveTypeCode) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/entformula-additive".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EnteralFormulaAdditiveTypeCode> for CodeableConcept {
    fn from(code: EnteralFormulaAdditiveTypeCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EpisodeOfCareStatus](http://hl7.org/fhir/ValueSet/episode-of-care-status)**. The status of the episode of care.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EpisodeOfCareStatus {
    /** **active**

Active. This episode of care is current. */
    Active,
    /** **cancelled**

Cancelled. The episode of care was cancelled, or withdrawn from service, often selected during the planned stage as the patient may have gone elsewhere, or the circumstances have changed and the organization is unable to provide the care. It indicates that services terminated outside the planned/expected workflow. */
    Cancelled,
    /** **entered-in-error**

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **finished**

Finished. This episode of care is finished and the organization is not expecting to be providing further care to the patient. Can also be known as "closed", "completed" or other similar terms. */
    Finished,
    /** **onhold**

On Hold. This episode of care is on hold; the organization has limited responsibility for the patient (such as while on respite). */
    Onhold,
    /** **planned**

Planned. This episode of care is planned to start at the date specified in the period.start. During this status, an organization may perform assessments to determine if the patient is eligible to receive services, or be organizing to make resources available to provide care services. */
    Planned,
    /** **waitlist**

Waitlist. This episode has been placed on a waitlist, pending the episode being made active (or cancelled). */
    Waitlist,
}
impl ::core::str::FromStr for EpisodeOfCareStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "finished" => Ok(Self::Finished),
            "onhold" => Ok(Self::Onhold),
            "planned" => Ok(Self::Planned),
            "waitlist" => Ok(Self::Waitlist),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EpisodeOfCareStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Finished => "finished",
            Self::Onhold => "onhold",
            Self::Planned => "planned",
            Self::Waitlist => "waitlist",
        }
    }
}
impl ::std::fmt::Debug for EpisodeOfCareStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EpisodeOfCareStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EpisodeOfCareStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EpisodeOfCareStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EpisodeOfCareStatus> for Coding {
    fn from(code: EpisodeOfCareStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/episode-of-care-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EpisodeOfCareStatus> for CodeableConcept {
    fn from(code: EpisodeOfCareStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EpisodeOfCareType](http://terminology.hl7.org/CodeSystem/episodeofcare-type)**. This incomplete example codesystem defines a set of codes that can be used to express the usage type of an EpisodeOfCare record.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum EpisodeOfCareType {
    /** **cacp**

Community-based aged care. */
    Cacp,
    /** **da**

Drug and alcohol rehabilitation. */
    Da,
    /** **diab**

Post coordinated diabetes program. */
    Diab,
    /** **hacc**

Home and Community Care. */
    Hacc,
    /** **pac**

Post Acute Care. */
    Pac,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EpisodeOfCareType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cacp" => Ok(Self::Cacp),
            "da" => Ok(Self::Da),
            "diab" => Ok(Self::Diab),
            "hacc" => Ok(Self::Hacc),
            "pac" => Ok(Self::Pac),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EpisodeOfCareType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cacp => "cacp",
            Self::Da => "da",
            Self::Diab => "diab",
            Self::Hacc => "hacc",
            Self::Pac => "pac",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for EpisodeOfCareType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EpisodeOfCareType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EpisodeOfCareType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EpisodeOfCareType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EpisodeOfCareType> for Coding {
    fn from(code: EpisodeOfCareType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/episodeofcare-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EpisodeOfCareType> for CodeableConcept {
    fn from(code: EpisodeOfCareType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EventCapabilityMode](http://hl7.org/fhir/ValueSet/event-capability-mode)**. The mode of a message capability statement.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EventCapabilityMode {
    /** **receiver**

Receiver. The application receives requests and sends responses. */
    Receiver,
    /** **sender**

Sender. The application sends requests and receives responses. */
    Sender,
}
impl ::core::str::FromStr for EventCapabilityMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "receiver" => Ok(Self::Receiver),
            "sender" => Ok(Self::Sender),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventCapabilityMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Receiver => "receiver",
            Self::Sender => "sender",
        }
    }
}
impl ::std::fmt::Debug for EventCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EventCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EventCapabilityMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventCapabilityMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventCapabilityMode> for Coding {
    fn from(code: EventCapabilityMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/event-capability-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EventCapabilityMode> for CodeableConcept {
    fn from(code: EventCapabilityMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EventResourceType](http://hl7.org/fhir/ValueSet/event-resource-types)**. A list of all the event resource types defined in this version of the FHIR specification.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EventResourceType {
    /** **ChargeItem**

ChargeItem. Item containing charge code(s) associated with the provision of healthcare provider products. */
    ChargeItem,
    /** **ClaimResponse**

ClaimResponse. Remittance resource. */
    ClaimResponse,
    /** **ClinicalImpression**

ClinicalImpression. A clinical assessment performed when planning treatments and management strategies for a patient. */
    ClinicalImpression,
    /** **Communication**

Communication. A record of information transmitted from a sender to a receiver. */
    Communication,
    /** **Composition**

Composition. A set of resources composed into a single coherent clinical statement with clinical attestation. */
    Composition,
    /** **Condition**

Condition. Detailed information about conditions, problems or diagnoses. */
    Condition,
    /** **Consent**

Consent. A healthcare consumer's policy choices to permits or denies recipients or roles to perform actions for specific purposes and periods of time. */
    Consent,
    /** **Coverage**

Coverage. Insurance or medical plan or a payment agreement. */
    Coverage,
    /** **DeviceUseStatement**

DeviceUseStatement. Record of use of a device. */
    DeviceUseStatement,
    /** **DiagnosticReport**

DiagnosticReport. A Diagnostic report - a combination of request information, atomic results, images, interpretation, as well as formatted reports. */
    DiagnosticReport,
    /** **DocumentManifest**

DocumentManifest. A list that defines a set of documents. */
    DocumentManifest,
    /** **DocumentReference**

DocumentReference. A reference to a document. */
    DocumentReference,
    /** **Encounter**

Encounter. An interaction during which services are provided to the patient. */
    Encounter,
    /** **EnrollmentResponse**

EnrollmentResponse. EnrollmentResponse resource. */
    EnrollmentResponse,
    /** **EpisodeOfCare**

EpisodeOfCare. An association of a Patient with an Organization and  Healthcare Provider(s) for a period of time that the Organization assumes some level of responsibility. */
    EpisodeOfCare,
    /** **ExplanationOfBenefit**

ExplanationOfBenefit. Explanation of Benefit resource. */
    ExplanationOfBenefit,
    /** **FamilyMemberHistory**

FamilyMemberHistory. Information about patient's relatives, relevant for patient. */
    FamilyMemberHistory,
    /** **GuidanceResponse**

GuidanceResponse. The formal response to a guidance request. */
    GuidanceResponse,
    /** **ImagingStudy**

ImagingStudy. A set of images produced in single study (one or more series of references images). */
    ImagingStudy,
    /** **Immunization**

Immunization. Immunization event information. */
    Immunization,
    /** **MeasureReport**

MeasureReport. Results of a measure evaluation. */
    MeasureReport,
    /** **Media**

Media. A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference. */
    Media,
    /** **MedicationAdministration**

MedicationAdministration. Administration of medication to a patient. */
    MedicationAdministration,
    /** **MedicationDispense**

MedicationDispense. Dispensing a medication to a named patient. */
    MedicationDispense,
    /** **MedicationStatement**

MedicationStatement. Record of medication being taken by a patient. */
    MedicationStatement,
    /** **Observation**

Observation. Measurements and simple assertions. */
    Observation,
    /** **PaymentNotice**

PaymentNotice. PaymentNotice request. */
    PaymentNotice,
    /** **PaymentReconciliation**

PaymentReconciliation. PaymentReconciliation resource. */
    PaymentReconciliation,
    /** **Procedure**

Procedure. An action that is being or was performed on a patient. */
    Procedure,
    /** **ProcessResponse**

ProcessResponse. ProcessResponse resource. */
    ProcessResponse,
    /** **QuestionnaireResponse**

QuestionnaireResponse. A structured set of questions and their answers. */
    QuestionnaireResponse,
    /** **RiskAssessment**

RiskAssessment. Potential outcomes for a subject with likelihood. */
    RiskAssessment,
    /** **SupplyDelivery**

SupplyDelivery. Delivery of bulk Supplies. */
    SupplyDelivery,
    /** **Task**

Task. A task to be performed. */
    Task,
}
impl ::core::str::FromStr for EventResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ChargeItem" => Ok(Self::ChargeItem),
            "ClaimResponse" => Ok(Self::ClaimResponse),
            "ClinicalImpression" => Ok(Self::ClinicalImpression),
            "Communication" => Ok(Self::Communication),
            "Composition" => Ok(Self::Composition),
            "Condition" => Ok(Self::Condition),
            "Consent" => Ok(Self::Consent),
            "Coverage" => Ok(Self::Coverage),
            "DeviceUseStatement" => Ok(Self::DeviceUseStatement),
            "DiagnosticReport" => Ok(Self::DiagnosticReport),
            "DocumentManifest" => Ok(Self::DocumentManifest),
            "DocumentReference" => Ok(Self::DocumentReference),
            "Encounter" => Ok(Self::Encounter),
            "EnrollmentResponse" => Ok(Self::EnrollmentResponse),
            "EpisodeOfCare" => Ok(Self::EpisodeOfCare),
            "ExplanationOfBenefit" => Ok(Self::ExplanationOfBenefit),
            "FamilyMemberHistory" => Ok(Self::FamilyMemberHistory),
            "GuidanceResponse" => Ok(Self::GuidanceResponse),
            "ImagingStudy" => Ok(Self::ImagingStudy),
            "Immunization" => Ok(Self::Immunization),
            "MeasureReport" => Ok(Self::MeasureReport),
            "Media" => Ok(Self::Media),
            "MedicationAdministration" => Ok(Self::MedicationAdministration),
            "MedicationDispense" => Ok(Self::MedicationDispense),
            "MedicationStatement" => Ok(Self::MedicationStatement),
            "Observation" => Ok(Self::Observation),
            "PaymentNotice" => Ok(Self::PaymentNotice),
            "PaymentReconciliation" => Ok(Self::PaymentReconciliation),
            "Procedure" => Ok(Self::Procedure),
            "ProcessResponse" => Ok(Self::ProcessResponse),
            "QuestionnaireResponse" => Ok(Self::QuestionnaireResponse),
            "RiskAssessment" => Ok(Self::RiskAssessment),
            "SupplyDelivery" => Ok(Self::SupplyDelivery),
            "Task" => Ok(Self::Task),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ChargeItem => "ChargeItem",
            Self::ClaimResponse => "ClaimResponse",
            Self::ClinicalImpression => "ClinicalImpression",
            Self::Communication => "Communication",
            Self::Composition => "Composition",
            Self::Condition => "Condition",
            Self::Consent => "Consent",
            Self::Coverage => "Coverage",
            Self::DeviceUseStatement => "DeviceUseStatement",
            Self::DiagnosticReport => "DiagnosticReport",
            Self::DocumentManifest => "DocumentManifest",
            Self::DocumentReference => "DocumentReference",
            Self::Encounter => "Encounter",
            Self::EnrollmentResponse => "EnrollmentResponse",
            Self::EpisodeOfCare => "EpisodeOfCare",
            Self::ExplanationOfBenefit => "ExplanationOfBenefit",
            Self::FamilyMemberHistory => "FamilyMemberHistory",
            Self::GuidanceResponse => "GuidanceResponse",
            Self::ImagingStudy => "ImagingStudy",
            Self::Immunization => "Immunization",
            Self::MeasureReport => "MeasureReport",
            Self::Media => "Media",
            Self::MedicationAdministration => "MedicationAdministration",
            Self::MedicationDispense => "MedicationDispense",
            Self::MedicationStatement => "MedicationStatement",
            Self::Observation => "Observation",
            Self::PaymentNotice => "PaymentNotice",
            Self::PaymentReconciliation => "PaymentReconciliation",
            Self::Procedure => "Procedure",
            Self::ProcessResponse => "ProcessResponse",
            Self::QuestionnaireResponse => "QuestionnaireResponse",
            Self::RiskAssessment => "RiskAssessment",
            Self::SupplyDelivery => "SupplyDelivery",
            Self::Task => "Task",
        }
    }
}
impl ::std::fmt::Debug for EventResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EventResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EventResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventResourceType> for Coding {
    fn from(code: EventResourceType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/event-resource-types".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EventResourceType> for CodeableConcept {
    fn from(code: EventResourceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EventStatus](http://hl7.org/fhir/ValueSet/event-status)**. Codes identifying the lifecycle stage of an event.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EventStatus {
    /** **completed**

Completed. The event has now concluded. */
    Completed,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "stopped" rather than "entered-in-error".). */
    EnteredInError,
    /** **in-progress**

In Progress. The event is currently occurring. */
    InProgress,
    /** **not-done**

Not Done. The event was terminated prior to any activity beyond preparation.  I.e. The 'main' activity has not yet begun.  The boundary between preparatory and the 'main' activity is context-specific. */
    NotDone,
    /** **on-hold**

On Hold. The event has been temporarily stopped but is expected to resume in the future. */
    OnHold,
    /** **preparation**

Preparation. The core event has not started yet, but some staging activities have begun (e.g. surgical suite preparation).  Preparation stages may be tracked for billing purposes. */
    Preparation,
    /** **stopped**

Stopped. The event was terminated prior to the full completion of the intended activity but after at least some of the 'main' activity (beyond preparation) has occurred. */
    Stopped,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this event.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply,  but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for EventStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "not-done" => Ok(Self::NotDone),
            "on-hold" => Ok(Self::OnHold),
            "preparation" => Ok(Self::Preparation),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::NotDone => "not-done",
            Self::OnHold => "on-hold",
            Self::Preparation => "preparation",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for EventStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EventStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EventStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventStatus> for Coding {
    fn from(code: EventStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/event-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EventStatus> for CodeableConcept {
    fn from(code: EventStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EventTiming](http://hl7.org/fhir/event-timing)**. Real world event relating to the schedule.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum EventTiming {
    /** **AFT**

Afternoon. Event occurs during the afternoon. The exact time is unspecified and established by institution convention or patient interpretation. */
    Aft,
    /** **AFT.early**

Early Afternoon. Event occurs during the early afternoon. The exact time is unspecified and established by institution convention or patient interpretation. */
    AftEarly,
    /** **AFT.late**

Late Afternoon. Event occurs during the late afternoon. The exact time is unspecified and established by institution convention or patient interpretation. */
    AftLate,
    /** **EVE**

Evening. Event occurs during the evening. The exact time is unspecified and established by institution convention or patient interpretation. */
    Eve,
    /** **EVE.early**

Early Evening. Event occurs during the early evening. The exact time is unspecified and established by institution convention or patient interpretation. */
    EveEarly,
    /** **EVE.late**

Late Evening. Event occurs during the late evening. The exact time is unspecified and established by institution convention or patient interpretation. */
    EveLate,
    /** **MORN**

Morning. Event occurs during the morning. The exact time is unspecified and established by institution convention or patient interpretation. */
    Morn,
    /** **MORN.early**

Early Morning. Event occurs during the early morning. The exact time is unspecified and established by institution convention or patient interpretation. */
    MornEarly,
    /** **MORN.late**

Late Morning. Event occurs during the late morning. The exact time is unspecified and established by institution convention or patient interpretation. */
    MornLate,
    /** **NIGHT**

Night. Event occurs during the night. The exact time is unspecified and established by institution convention or patient interpretation. */
    Night,
    /** **NOON**

Noon. Event occurs around 12:00pm. The exact time is unspecified and established by institution convention or patient interpretation. */
    Noon,
    /** **PHS**

After Sleep. Event occurs [offset] after subject goes to sleep. The exact time is unspecified and established by institution convention or patient interpretation. */
    Phs,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EventTiming {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AFT" => Ok(Self::Aft),
            "AFT.early" => Ok(Self::AftEarly),
            "AFT.late" => Ok(Self::AftLate),
            "EVE" => Ok(Self::Eve),
            "EVE.early" => Ok(Self::EveEarly),
            "EVE.late" => Ok(Self::EveLate),
            "MORN" => Ok(Self::Morn),
            "MORN.early" => Ok(Self::MornEarly),
            "MORN.late" => Ok(Self::MornLate),
            "NIGHT" => Ok(Self::Night),
            "NOON" => Ok(Self::Noon),
            "PHS" => Ok(Self::Phs),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EventTiming {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aft => "AFT",
            Self::AftEarly => "AFT.early",
            Self::AftLate => "AFT.late",
            Self::Eve => "EVE",
            Self::EveEarly => "EVE.early",
            Self::EveLate => "EVE.late",
            Self::Morn => "MORN",
            Self::MornEarly => "MORN.early",
            Self::MornLate => "MORN.late",
            Self::Night => "NIGHT",
            Self::Noon => "NOON",
            Self::Phs => "PHS",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for EventTiming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EventTiming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EventTiming {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventTiming {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventTiming> for Coding {
    fn from(code: EventTiming) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/event-timing".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EventTiming> for CodeableConcept {
    fn from(code: EventTiming) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EvidenceCertaintyRating](http://hl7.org/fhir/ValueSet/certainty-rating)**. The assessment of quality, confidence, or certainty.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EvidenceCertaintyRating {
    /** **absent**

absent. possible reason for increasing quality rating was checked and found to be absent. */
    Absent,
    /** **downcode1**

reduce rating: -1. reduce quality rating by 1. */
    Downcode1,
    /** **downcode2**

reduce rating: -2. reduce quality rating by 2. */
    Downcode2,
    /** **downcode3**

reduce rating: -3. reduce quality rating by 3. */
    Downcode3,
    /** **extremely-serious-concern**

extremely serious concern. extremely serious concern. */
    ExtremelySeriousConcern,
    /** **high**

High quality. High quality evidence. */
    High,
    /** **low**

Low quality. Low quality evidence. */
    Low,
    /** **moderate**

Moderate quality. Moderate quality evidence. */
    Moderate,
    /** **no-change**

no change to rating. no change to quality rating. */
    NoChange,
    /** **no-concern**

no serious concern. no serious concern. */
    NoConcern,
    /** **present**

present. possible reason for increasing quality rating was checked and found to be present. */
    Present,
    /** **serious-concern**

serious concern. serious concern. */
    SeriousConcern,
    /** **upcode1**

increase rating: +1. increase quality rating by 1. */
    Upcode1,
    /** **upcode2**

increase rating: +2. increase quality rating by 2. */
    Upcode2,
    /** **very-low**

Very low quality. Very low quality evidence. */
    VeryLow,
    /** **very-serious-concern**

very serious concern. very serious concern. */
    VerySeriousConcern,
}
impl ::core::str::FromStr for EvidenceCertaintyRating {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "absent" => Ok(Self::Absent),
            "downcode1" => Ok(Self::Downcode1),
            "downcode2" => Ok(Self::Downcode2),
            "downcode3" => Ok(Self::Downcode3),
            "extremely-serious-concern" => Ok(Self::ExtremelySeriousConcern),
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            "no-change" => Ok(Self::NoChange),
            "no-concern" => Ok(Self::NoConcern),
            "present" => Ok(Self::Present),
            "serious-concern" => Ok(Self::SeriousConcern),
            "upcode1" => Ok(Self::Upcode1),
            "upcode2" => Ok(Self::Upcode2),
            "very-low" => Ok(Self::VeryLow),
            "very-serious-concern" => Ok(Self::VerySeriousConcern),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceCertaintyRating {
    fn as_ref(&self) -> &str {
        match self {
            Self::Absent => "absent",
            Self::Downcode1 => "downcode1",
            Self::Downcode2 => "downcode2",
            Self::Downcode3 => "downcode3",
            Self::ExtremelySeriousConcern => "extremely-serious-concern",
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
            Self::NoChange => "no-change",
            Self::NoConcern => "no-concern",
            Self::Present => "present",
            Self::SeriousConcern => "serious-concern",
            Self::Upcode1 => "upcode1",
            Self::Upcode2 => "upcode2",
            Self::VeryLow => "very-low",
            Self::VerySeriousConcern => "very-serious-concern",
        }
    }
}
impl ::std::fmt::Debug for EvidenceCertaintyRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EvidenceCertaintyRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EvidenceCertaintyRating {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceCertaintyRating {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceCertaintyRating> for Coding {
    fn from(code: EvidenceCertaintyRating) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/certainty-rating".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EvidenceCertaintyRating> for CodeableConcept {
    fn from(code: EvidenceCertaintyRating) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EvidenceCertaintyType](http://hl7.org/fhir/ValueSet/certainty-type)**. The aspect of quality, confidence, or certainty.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EvidenceCertaintyType {
    /** **DoseResponseGradient**

Dose response gradient. higher certainty due to dose response relationship. */
    DoseResponseGradient,
    /** **Imprecision**

Imprecision. fuzzy or wide variability. */
    Imprecision,
    /** **Inconsistency**

Inconsistency. concerns that findings are not similar enough to support certainty. */
    Inconsistency,
    /** **Indirectness**

Indirectness. concerns reducing external validity. */
    Indirectness,
    /** **LargeEffect**

Large effect. higher certainty due to large effect size. */
    LargeEffect,
    /** **Overall**

Overall certainty. Overall certainty of evidence (quality of evidence). */
    Overall,
    /** **PlausibleConfounding**

Plausible confounding. higher certainty due to risk of bias in opposite direction. */
    PlausibleConfounding,
    /** **PublicationBias**

Publication bias. likelihood that what is published misrepresents what is available to publish. */
    PublicationBias,
    /** **RiskOfBias**

Risk of bias. methodologic concerns reducing internal validity. */
    RiskOfBias,
}
impl ::core::str::FromStr for EvidenceCertaintyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "DoseResponseGradient" => Ok(Self::DoseResponseGradient),
            "Imprecision" => Ok(Self::Imprecision),
            "Inconsistency" => Ok(Self::Inconsistency),
            "Indirectness" => Ok(Self::Indirectness),
            "LargeEffect" => Ok(Self::LargeEffect),
            "Overall" => Ok(Self::Overall),
            "PlausibleConfounding" => Ok(Self::PlausibleConfounding),
            "PublicationBias" => Ok(Self::PublicationBias),
            "RiskOfBias" => Ok(Self::RiskOfBias),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceCertaintyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DoseResponseGradient => "DoseResponseGradient",
            Self::Imprecision => "Imprecision",
            Self::Inconsistency => "Inconsistency",
            Self::Indirectness => "Indirectness",
            Self::LargeEffect => "LargeEffect",
            Self::Overall => "Overall",
            Self::PlausibleConfounding => "PlausibleConfounding",
            Self::PublicationBias => "PublicationBias",
            Self::RiskOfBias => "RiskOfBias",
        }
    }
}
impl ::std::fmt::Debug for EvidenceCertaintyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EvidenceCertaintyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EvidenceCertaintyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceCertaintyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceCertaintyType> for Coding {
    fn from(code: EvidenceCertaintyType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/certainty-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EvidenceCertaintyType> for CodeableConcept {
    fn from(code: EvidenceCertaintyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EvidenceClassifier](http://hl7.org/fhir/ValueSet/evidence-classifier-code)**. Commonly used classifiers for evidence sets.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EvidenceClassifier {
    /** **AllocConcealNotStated**

Allocation concealment not stated. Allocation concealment not stated. */
    AllocConcealNotStated,
    /** **BaselineImbalance**

Baseline imbalances. Differences between groups at start of trial may confound or bias the findings. */
    BaselineImbalance,
    /** **COVID19HumanResearch**

COVID-19 human data in population, exposure, or outcome. contains human COVID-19 disease in the research data as any variable (population, exposure or outcome). */
    Covid19HumanResearch,
    /** **COVID19Relevant**

COVID-19 relevant (but not specific) article. Not about COVID-19 but relevant to COVID-19 management or understanding. */
    Covid19Relevant,
    /** **COVID19Specific**

COVID-19 specific article. About COVID-19. */
    Covid19Specific,
    /** **Diagnosis**

Article about diagnosis. about methods to distinguish having or not having a condition. */
    Diagnosis,
    /** **EarlyTrialTermination**

Early trial termination. Early trial termination. */
    EarlyTrialTermination,
    /** **Guideline**

Article includes guideline. for clinical practice guidelines. */
    Guideline,
    /** **NoBlinding**

No blinding. No blinding. */
    NoBlinding,
    /** **NoITT**

No intention-to-treat analysis. No intention-to-treat analysis. */
    NoITT,
    /** **NotAssessed**

Not rated, not assessed. Neither rated as yes nor rated as no. */
    NotAssessed,
    /** **NotResearchNotGuideline**

Article is neither research nor guideline. for things that are not research reports, research protocols or guidelines. */
    NotResearchNotGuideline,
    /** **OriginalResearch**

Article includes original research. such as randomized trial, observational study. */
    OriginalResearch,
    /** **PreliminaryAnalysis**

Preliminary analysis. Preliminary analysis. */
    PreliminaryAnalysis,
    /** **Preprint**

Preprint (not final publication). Results presented in preprint (pre-final publication) form. */
    Preprint,
    /** **PreventionAndControl**

Article about prevention and control. about preventive care and interventions. */
    PreventionAndControl,
    /** **PrognosisPrediction**

Article about prognosis or prediction. about predicting risk for something or risk factors for it. */
    PrognosisPrediction,
    /** **RatedAsCaseControl**

classified as case-control study. classified as case-control study. */
    RatedAsCaseControl,
    /** **RatedAsComparativeCohort**

classified as comparative cohort study (observational). classified as comparative cohort study (observational). */
    RatedAsComparativeCohort,
    /** **RatedAsControlledTrial**

classified as nonrandomized controlled trial (experimental). classified as nonrandomized controlled trial (experimental). */
    RatedAsControlledTrial,
    /** **RatedAsMixedMethods**

classified as mixed-methods study. classified as mixed-methods study. */
    RatedAsMixedMethods,
    /** **RatedAsNo**

Rated as no, negative, absent, or exclude. Rated as no, negative, absent, or exclude. */
    RatedAsNo,
    /** **RatedAsOther**

classified as other concept (not elsewhere classified). classified as other concept (not elsewhere classified). */
    RatedAsOther,
    /** **RatedAsRCT**

classified as randomized controlled trial. classified as randomized controlled trial. */
    RatedAsRCT,
    /** **RatedAsUncontrolledSeries**

classified as uncontrolled cohort (case series). classified as uncontrolled cohort (case series). */
    RatedAsUncontrolledSeries,
    /** **RatedAsYes**

Rated as yes, affirmative, positive, present, or include. */
    RatedAsYes,
    /** **ResearchProtocol**

Article provides protocol without results. for research protocols. */
    ResearchProtocol,
    /** **ResearchSynthesis**

Article includes synthesis of research. such as systematic review, meta-analysis, rapid review. */
    ResearchSynthesis,
    /** **RiskOfBias**

Risk of bias assessment. Risk of bias assessment. */
    RiskOfBias,
    /** **SubgroupAnalysis**

Subgroup analysis. Subgroup analysis. */
    SubgroupAnalysis,
    /** **Treatment**

Article about treatment. about therapeutic interventions. */
    Treatment,
}
impl ::core::str::FromStr for EvidenceClassifier {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AllocConcealNotStated" => Ok(Self::AllocConcealNotStated),
            "BaselineImbalance" => Ok(Self::BaselineImbalance),
            "COVID19HumanResearch" => Ok(Self::Covid19HumanResearch),
            "COVID19Relevant" => Ok(Self::Covid19Relevant),
            "COVID19Specific" => Ok(Self::Covid19Specific),
            "Diagnosis" => Ok(Self::Diagnosis),
            "EarlyTrialTermination" => Ok(Self::EarlyTrialTermination),
            "Guideline" => Ok(Self::Guideline),
            "NoBlinding" => Ok(Self::NoBlinding),
            "NoITT" => Ok(Self::NoITT),
            "NotAssessed" => Ok(Self::NotAssessed),
            "NotResearchNotGuideline" => Ok(Self::NotResearchNotGuideline),
            "OriginalResearch" => Ok(Self::OriginalResearch),
            "PreliminaryAnalysis" => Ok(Self::PreliminaryAnalysis),
            "Preprint" => Ok(Self::Preprint),
            "PreventionAndControl" => Ok(Self::PreventionAndControl),
            "PrognosisPrediction" => Ok(Self::PrognosisPrediction),
            "RatedAsCaseControl" => Ok(Self::RatedAsCaseControl),
            "RatedAsComparativeCohort" => Ok(Self::RatedAsComparativeCohort),
            "RatedAsControlledTrial" => Ok(Self::RatedAsControlledTrial),
            "RatedAsMixedMethods" => Ok(Self::RatedAsMixedMethods),
            "RatedAsNo" => Ok(Self::RatedAsNo),
            "RatedAsOther" => Ok(Self::RatedAsOther),
            "RatedAsRCT" => Ok(Self::RatedAsRCT),
            "RatedAsUncontrolledSeries" => Ok(Self::RatedAsUncontrolledSeries),
            "RatedAsYes" => Ok(Self::RatedAsYes),
            "ResearchProtocol" => Ok(Self::ResearchProtocol),
            "ResearchSynthesis" => Ok(Self::ResearchSynthesis),
            "RiskOfBias" => Ok(Self::RiskOfBias),
            "SubgroupAnalysis" => Ok(Self::SubgroupAnalysis),
            "Treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceClassifier {
    fn as_ref(&self) -> &str {
        match self {
            Self::AllocConcealNotStated => "AllocConcealNotStated",
            Self::BaselineImbalance => "BaselineImbalance",
            Self::Covid19HumanResearch => "COVID19HumanResearch",
            Self::Covid19Relevant => "COVID19Relevant",
            Self::Covid19Specific => "COVID19Specific",
            Self::Diagnosis => "Diagnosis",
            Self::EarlyTrialTermination => "EarlyTrialTermination",
            Self::Guideline => "Guideline",
            Self::NoBlinding => "NoBlinding",
            Self::NoITT => "NoITT",
            Self::NotAssessed => "NotAssessed",
            Self::NotResearchNotGuideline => "NotResearchNotGuideline",
            Self::OriginalResearch => "OriginalResearch",
            Self::PreliminaryAnalysis => "PreliminaryAnalysis",
            Self::Preprint => "Preprint",
            Self::PreventionAndControl => "PreventionAndControl",
            Self::PrognosisPrediction => "PrognosisPrediction",
            Self::RatedAsCaseControl => "RatedAsCaseControl",
            Self::RatedAsComparativeCohort => "RatedAsComparativeCohort",
            Self::RatedAsControlledTrial => "RatedAsControlledTrial",
            Self::RatedAsMixedMethods => "RatedAsMixedMethods",
            Self::RatedAsNo => "RatedAsNo",
            Self::RatedAsOther => "RatedAsOther",
            Self::RatedAsRCT => "RatedAsRCT",
            Self::RatedAsUncontrolledSeries => "RatedAsUncontrolledSeries",
            Self::RatedAsYes => "RatedAsYes",
            Self::ResearchProtocol => "ResearchProtocol",
            Self::ResearchSynthesis => "ResearchSynthesis",
            Self::RiskOfBias => "RiskOfBias",
            Self::SubgroupAnalysis => "SubgroupAnalysis",
            Self::Treatment => "Treatment",
        }
    }
}
impl ::std::fmt::Debug for EvidenceClassifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EvidenceClassifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EvidenceClassifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceClassifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceClassifier> for Coding {
    fn from(code: EvidenceClassifier) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/evidence-classifier-code".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EvidenceClassifier> for CodeableConcept {
    fn from(code: EvidenceClassifier) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EvidenceDirectness](http://hl7.org/fhir/ValueSet/directness)**. The quality of how direct the match is.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EvidenceDirectness {
    /** **exact**

Exact match between observed and intended variable. Exact matching quality between observed and intended variable, so no concern for indirectness in evidence interpretation. */
    Exact,
    /** **high**

High quality match between observed and intended variable. High matching quality between observed and intended variable, so little concern for indirectness in evidence interpretation. */
    High,
    /** **low**

Low quality match between observed and intended variable. Low matching quality between observed and intended variable, so very serious concern for indirectness in evidence interpretation. */
    Low,
    /** **moderate**

Moderate quality match between observed and intended variable. Moderate matching quality between observed and intended variable, so serious concern for indirectness in evidence interpretation. */
    Moderate,
}
impl ::core::str::FromStr for EvidenceDirectness {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exact" => Ok(Self::Exact),
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceDirectness {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exact => "exact",
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
        }
    }
}
impl ::std::fmt::Debug for EvidenceDirectness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EvidenceDirectness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EvidenceDirectness {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceDirectness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceDirectness> for Coding {
    fn from(code: EvidenceDirectness) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/directness".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EvidenceDirectness> for CodeableConcept {
    fn from(code: EvidenceDirectness) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EvidenceReportType](http://hl7.org/fhir/ValueSet/evidence-report-type)**. The kind of report, such as grouping of classifiers, search results, or human-compiled expression.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EvidenceReportType {
    /** **classification**

Classification. The report is primarily a listing of classifiers about the report subject. */
    Classification,
    /** **resources-compiled**

Resource Compilation. The report is a composition containing one or more FHIR resources in the content. */
    ResourcesCompiled,
    /** **search-results**

Search Results. The report is a composition of results generated in response to a search query. */
    SearchResults,
    /** **text-structured**

Structured Text. The report is a structured representation of text. */
    TextStructured,
}
impl ::core::str::FromStr for EvidenceReportType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "classification" => Ok(Self::Classification),
            "resources-compiled" => Ok(Self::ResourcesCompiled),
            "search-results" => Ok(Self::SearchResults),
            "text-structured" => Ok(Self::TextStructured),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceReportType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Classification => "classification",
            Self::ResourcesCompiled => "resources-compiled",
            Self::SearchResults => "search-results",
            Self::TextStructured => "text-structured",
        }
    }
}
impl ::std::fmt::Debug for EvidenceReportType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EvidenceReportType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EvidenceReportType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceReportType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceReportType> for Coding {
    fn from(code: EvidenceReportType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/evidence-report-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EvidenceReportType> for CodeableConcept {
    fn from(code: EvidenceReportType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EvidenceVariableHandling](http://hl7.org/fhir/ValueSet/variable-handling)**. The handling of the variable in statistical analysis for exposures or outcomes (E.g. Dichotomous, Continuous, Descriptive).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EvidenceVariableHandling {
    /** **continuous**

continuous variable. A continuous variable is one for which, within the limits the variable ranges, any value is possible (from STATO http://purl.obolibrary.org/obo/STATO_0000251). */
    Continuous,
    /** **dichotomous**

dichotomous variable. A dichotomous variable is a categorical variable which is defined to have only 2 categories or possible values (from STATO http://purl.obolibrary.org/obo/STATO_0000090). */
    Dichotomous,
    /** **ordinal**

ordinal variable. An ordinal variable is a categorical variable where the discrete possible values are ordered or correspond to an implicit ranking (from STATO http://purl.obolibrary.org/obo/STATO_0000228). */
    Ordinal,
    /** **polychotomous**

polychotomous variable. A polychotomous variable is a categorical variable which is defined to have minimally 2 categories or possible values. (from STATO  http://purl.obolibrary.org/obo/STATO_0000087).  Suggestion to limit code use to situations when neither dichotomous nor ordinal variables apply. */
    Polychotomous,
}
impl ::core::str::FromStr for EvidenceVariableHandling {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "continuous" => Ok(Self::Continuous),
            "dichotomous" => Ok(Self::Dichotomous),
            "ordinal" => Ok(Self::Ordinal),
            "polychotomous" => Ok(Self::Polychotomous),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceVariableHandling {
    fn as_ref(&self) -> &str {
        match self {
            Self::Continuous => "continuous",
            Self::Dichotomous => "dichotomous",
            Self::Ordinal => "ordinal",
            Self::Polychotomous => "polychotomous",
        }
    }
}
impl ::std::fmt::Debug for EvidenceVariableHandling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EvidenceVariableHandling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EvidenceVariableHandling {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceVariableHandling {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceVariableHandling> for Coding {
    fn from(code: EvidenceVariableHandling) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/variable-handling".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EvidenceVariableHandling> for CodeableConcept {
    fn from(code: EvidenceVariableHandling) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EvidenceVariableRole](http://hl7.org/fhir/ValueSet/variable-role)**. The role that the assertion variable plays.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EvidenceVariableRole {
    /** **confounder**

confounder. variable represents a confounder. */
    Confounder,
    /** **exposure**

exposure. variable represents an exposure. */
    Exposure,
    /** **measuredVariable**

measured variable. variable represents a measured variable. */
    MeasuredVariable,
    /** **population**

population. variable represents a population. */
    Population,
    /** **referenceExposure**

reference exposure. variable represents a reference exposure. */
    ReferenceExposure,
    /** **subpopulation**

subpopulation. variable represents a subpopulation. */
    Subpopulation,
}
impl ::core::str::FromStr for EvidenceVariableRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confounder" => Ok(Self::Confounder),
            "exposure" => Ok(Self::Exposure),
            "measuredVariable" => Ok(Self::MeasuredVariable),
            "population" => Ok(Self::Population),
            "referenceExposure" => Ok(Self::ReferenceExposure),
            "subpopulation" => Ok(Self::Subpopulation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceVariableRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confounder => "confounder",
            Self::Exposure => "exposure",
            Self::MeasuredVariable => "measuredVariable",
            Self::Population => "population",
            Self::ReferenceExposure => "referenceExposure",
            Self::Subpopulation => "subpopulation",
        }
    }
}
impl ::std::fmt::Debug for EvidenceVariableRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EvidenceVariableRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EvidenceVariableRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceVariableRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceVariableRole> for Coding {
    fn from(code: EvidenceVariableRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/variable-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EvidenceVariableRole> for CodeableConcept {
    fn from(code: EvidenceVariableRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[EvidenceVariableType](http://hl7.org/fhir/ValueSet/variable-type)**. The possible types of variables for exposures or outcomes (E.g. Dichotomous, Continuous, Descriptive).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum EvidenceVariableType {
    /** **continuous**

Continuous. The variable is a continuous result such as a quantity. */
    Continuous,
    /** **descriptive**

Descriptive. The variable is described narratively rather than quantitatively. */
    Descriptive,
    /** **dichotomous**

Dichotomous. The variable is dichotomous, such as present or absent. */
    Dichotomous,
}
impl ::core::str::FromStr for EvidenceVariableType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "continuous" => Ok(Self::Continuous),
            "descriptive" => Ok(Self::Descriptive),
            "dichotomous" => Ok(Self::Dichotomous),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceVariableType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Continuous => "continuous",
            Self::Descriptive => "descriptive",
            Self::Dichotomous => "dichotomous",
        }
    }
}
impl ::std::fmt::Debug for EvidenceVariableType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for EvidenceVariableType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for EvidenceVariableType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceVariableType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceVariableType> for Coding {
    fn from(code: EvidenceVariableType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/variable-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<EvidenceVariableType> for CodeableConcept {
    fn from(code: EvidenceVariableType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleClaimSubTypeCodes](http://terminology.hl7.org/CodeSystem/ex-claimsubtype)**. This value set includes sample Claim SubType codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleClaimSubTypeCodes {
    /** **emergency**

Emergency Claim. A claim for emergency services. */
    Emergency,
    /** **ortho**

Orthodontic Claim. A claim for Orthodontic Services. */
    Ortho,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleClaimSubTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "emergency" => Ok(Self::Emergency),
            "ortho" => Ok(Self::Ortho),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleClaimSubTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Emergency => "emergency",
            Self::Ortho => "ortho",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleClaimSubTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleClaimSubTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleClaimSubTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleClaimSubTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleClaimSubTypeCodes> for Coding {
    fn from(code: ExampleClaimSubTypeCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-claimsubtype".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleClaimSubTypeCodes> for CodeableConcept {
    fn from(code: ExampleClaimSubTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleCoverageFinancialExceptionsCode](http://terminology.hl7.org/CodeSystem/ex-coverage-financial-exception)**. This codeset includes Example Coverage Financial Exceptions Code.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleCoverageFinancialExceptionsCode {
    /** **foster**

Foster child. Children in the foster care have all copays and deductibles waived. */
    Foster,
    /** **retired**

Retired. Retired persons have all copays and deductibles reduced. */
    Retired,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleCoverageFinancialExceptionsCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "foster" => Ok(Self::Foster),
            "retired" => Ok(Self::Retired),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleCoverageFinancialExceptionsCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Foster => "foster",
            Self::Retired => "retired",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleCoverageFinancialExceptionsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleCoverageFinancialExceptionsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleCoverageFinancialExceptionsCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleCoverageFinancialExceptionsCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleCoverageFinancialExceptionsCode> for Coding {
    fn from(code: ExampleCoverageFinancialExceptionsCode) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-coverage-financial-exception"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleCoverageFinancialExceptionsCode> for CodeableConcept {
    fn from(code: ExampleCoverageFinancialExceptionsCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleDiagnosisOnAdmissionCodes](http://terminology.hl7.org/CodeSystem/ex-diagnosis-on-admission)**. This value set includes example Diagnosis on admission codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleDiagnosisOnAdmissionCodes {
    /** **n**

No. Diagnosis was not present at time of inpatient admission. */
    N,
    /** **u**

Unknown. Documentation insufficient to determine if condition was present at the time of inpatient admission. */
    U,
    /** **w**

Undetermined. Clinically undetermined. Provider unable to clinically determine whether the condition was present at the time of inpatient admission. */
    W,
    /** **y**

Yes. Diagnosis was present at time of inpatient admission. */
    Y,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleDiagnosisOnAdmissionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "n" => Ok(Self::N),
            "u" => Ok(Self::U),
            "w" => Ok(Self::W),
            "y" => Ok(Self::Y),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleDiagnosisOnAdmissionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N => "n",
            Self::U => "u",
            Self::W => "w",
            Self::Y => "y",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleDiagnosisOnAdmissionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleDiagnosisOnAdmissionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleDiagnosisOnAdmissionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleDiagnosisOnAdmissionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleDiagnosisOnAdmissionCodes> for Coding {
    fn from(code: ExampleDiagnosisOnAdmissionCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-diagnosis-on-admission"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleDiagnosisOnAdmissionCodes> for CodeableConcept {
    fn from(code: ExampleDiagnosisOnAdmissionCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleDiagnosisRelatedGroupCodes](http://terminology.hl7.org/CodeSystem/ex-diagnosisrelatedgroup)**. This value set includes sample Diagnosis Related Group codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleDiagnosisRelatedGroupCodes {
    /** **100**

Normal Vaginal Delivery. Normal Vaginal Delivery. */
    N100,
    /** **101**

Appendectomy - uncomplicated. Appendectomy without rupture or other complications. */
    N101,
    /** **300**

Tooth abscess. Emergency department treatment of a tooth abscess. */
    N300,
    /** **400**

Head trauma - concussion. Head trauma - concussion. */
    N400,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleDiagnosisRelatedGroupCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100" => Ok(Self::N100),
            "101" => Ok(Self::N101),
            "300" => Ok(Self::N300),
            "400" => Ok(Self::N400),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleDiagnosisRelatedGroupCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100 => "100",
            Self::N101 => "101",
            Self::N300 => "300",
            Self::N400 => "400",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleDiagnosisRelatedGroupCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleDiagnosisRelatedGroupCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleDiagnosisRelatedGroupCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleDiagnosisRelatedGroupCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleDiagnosisRelatedGroupCodes> for Coding {
    fn from(code: ExampleDiagnosisRelatedGroupCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-diagnosisrelatedgroup"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleDiagnosisRelatedGroupCodes> for CodeableConcept {
    fn from(code: ExampleDiagnosisRelatedGroupCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleDiagnosisTypeCodes](http://terminology.hl7.org/CodeSystem/ex-diagnosistype)**. This value set includes example Diagnosis Type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleDiagnosisTypeCodes {
    /** **admitting**

Admitting Diagnosis. The diagnosis given as the reason why the patient was admitted to the hospital. */
    Admitting,
    /** **clinical**

Clinical Diagnosis. A diagnosis made on the basis of medical signs and patient-reported symptoms, rather than diagnostic tests. */
    Clinical,
    /** **differential**

Differential Diagnosis. One of a set of the possible diagnoses that could be connected to the signs, symptoms, and lab findings. */
    Differential,
    /** **discharge**

Discharge Diagnosis. The diagnosis given when the patient is discharged from the hospital. */
    Discharge,
    /** **laboratory**

Laboratory Diagnosis. A diagnosis based significantly on laboratory reports or test results, rather than the physical examination of the patient. */
    Laboratory,
    /** **nursing**

Nursing Diagnosis. A diagnosis which identifies people's responses to situations in their lives, such as a readiness to change or a willingness to accept assistance. */
    Nursing,
    /** **prenatal**

Prenatal Diagnosis. A diagnosis determined prior to birth. */
    Prenatal,
    /** **principal**

Principal Diagnosis. The single medical diagnosis that is most relevant to the patient's chief complaint or need for treatment. */
    Principal,
    /** **radiology**

Radiology Diagnosis. A diagnosis based primarily on the results from medical imaging studies. */
    Radiology,
    /** **remote**

Remote Diagnosis. A diagnosis determined using telemedicine techniques. */
    Remote,
    /** **retrospective**

Retrospective Diagnosis. The labeling of an illness in a specific historical event using modern knowledge, methods and disease classifications. */
    Retrospective,
    /** **self**

Self Diagnosis. A diagnosis determined by the patient. */
    _Self,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleDiagnosisTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "admitting" => Ok(Self::Admitting),
            "clinical" => Ok(Self::Clinical),
            "differential" => Ok(Self::Differential),
            "discharge" => Ok(Self::Discharge),
            "laboratory" => Ok(Self::Laboratory),
            "nursing" => Ok(Self::Nursing),
            "prenatal" => Ok(Self::Prenatal),
            "principal" => Ok(Self::Principal),
            "radiology" => Ok(Self::Radiology),
            "remote" => Ok(Self::Remote),
            "retrospective" => Ok(Self::Retrospective),
            "self" => Ok(Self::_Self),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleDiagnosisTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Admitting => "admitting",
            Self::Clinical => "clinical",
            Self::Differential => "differential",
            Self::Discharge => "discharge",
            Self::Laboratory => "laboratory",
            Self::Nursing => "nursing",
            Self::Prenatal => "prenatal",
            Self::Principal => "principal",
            Self::Radiology => "radiology",
            Self::Remote => "remote",
            Self::Retrospective => "retrospective",
            Self::_Self => "self",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleDiagnosisTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleDiagnosisTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleDiagnosisTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleDiagnosisTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleDiagnosisTypeCodes> for Coding {
    fn from(code: ExampleDiagnosisTypeCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-diagnosistype".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleDiagnosisTypeCodes> for CodeableConcept {
    fn from(code: ExampleDiagnosisTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleMessageReasonCodes](http://terminology.hl7.org/CodeSystem/message-reasons-encounter)**. Example Message Reasons. These are the set of codes that might be used an updating an encounter using admin-update.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleMessageReasonCodes {
    /** **absent**

Absent. The patient has temporarily left the institution. */
    Absent,
    /** **admit**

Admit. The patient has been admitted. */
    Admit,
    /** **discharge**

Discharge. The patient has been discharged. */
    Discharge,
    /** **edit**

Edit. Encounter details have been updated (e.g. to correct a coding error). */
    Edit,
    /** **moved**

Moved. The patient has been moved to a new location. */
    Moved,
    /** **return**

Returned. The patient has returned from a temporary absence. */
    Return,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleMessageReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "absent" => Ok(Self::Absent),
            "admit" => Ok(Self::Admit),
            "discharge" => Ok(Self::Discharge),
            "edit" => Ok(Self::Edit),
            "moved" => Ok(Self::Moved),
            "return" => Ok(Self::Return),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleMessageReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Absent => "absent",
            Self::Admit => "admit",
            Self::Discharge => "discharge",
            Self::Edit => "edit",
            Self::Moved => "moved",
            Self::Return => "return",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleMessageReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleMessageReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleMessageReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleMessageReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleMessageReasonCodes> for Coding {
    fn from(code: ExampleMessageReasonCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/message-reasons-encounter"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleMessageReasonCodes> for CodeableConcept {
    fn from(code: ExampleMessageReasonCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleProcedureTypeCodes](http://terminology.hl7.org/CodeSystem/ex-procedure-type)**. This value set includes example Procedure Type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleProcedureTypeCodes {
    /** **primary**

Primary procedure. The first procedure in a series required to produce and overall patient outcome. */
    Primary,
    /** **secondary**

Secondary procedure. The second procedure in a series required to produce and overall patient outcome. */
    Secondary,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleProcedureTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "primary" => Ok(Self::Primary),
            "secondary" => Ok(Self::Secondary),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleProcedureTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Primary => "primary",
            Self::Secondary => "secondary",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleProcedureTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleProcedureTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleProcedureTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleProcedureTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleProcedureTypeCodes> for Coding {
    fn from(code: ExampleProcedureTypeCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-procedure-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleProcedureTypeCodes> for CodeableConcept {
    fn from(code: ExampleProcedureTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleProgramCodes](http://terminology.hl7.org/CodeSystem/ex-programcode)**. This value set includes sample Program reason codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleProgramCodes {
    /** **as**

Child Asthma. Child Asthma Program */
    As,
    /** **auscr**

Autism Screening. Autism Screening Program. */
    Auscr,
    /** **hd**

Hemodialysis. Hemodialysis Program. */
    Hd,
    /** **none**

None. No program code applies. */
    None,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleProgramCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "as" => Ok(Self::As),
            "auscr" => Ok(Self::Auscr),
            "hd" => Ok(Self::Hd),
            "none" => Ok(Self::None),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleProgramCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::As => "as",
            Self::Auscr => "auscr",
            Self::Hd => "hd",
            Self::None => "none",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleProgramCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleProgramCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleProgramCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleProgramCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleProgramCodes> for Coding {
    fn from(code: ExampleProgramCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-programcode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleProgramCodes> for CodeableConcept {
    fn from(code: ExampleProgramCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleProviderQualificationCodes](http://terminology.hl7.org/CodeSystem/ex-providerqualification)**. This value set includes sample Provider Qualification codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleProviderQualificationCodes {
    /** **311405**

Dentist. Dentist General Practitioner (DDS, DDM). */
    N311405,
    /** **604210**

Optometrist. Optometrist. */
    N604210,
    /** **604215**

Ophthalmologist. Ophthalmologist. */
    N604215,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleProviderQualificationCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "311405" => Ok(Self::N311405),
            "604210" => Ok(Self::N604210),
            "604215" => Ok(Self::N604215),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleProviderQualificationCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N311405 => "311405",
            Self::N604210 => "604210",
            Self::N604215 => "604215",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleProviderQualificationCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleProviderQualificationCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleProviderQualificationCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleProviderQualificationCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleProviderQualificationCodes> for Coding {
    fn from(code: ExampleProviderQualificationCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-providerqualification"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleProviderQualificationCodes> for CodeableConcept {
    fn from(code: ExampleProviderQualificationCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleRelatedClaimRelationshipCodes](http://terminology.hl7.org/CodeSystem/ex-relatedclaimrelationship)**. This value set includes sample Related Claim Relationship codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleRelatedClaimRelationshipCodes {
    /** **associated**

Associated Claim. A claim for a different suite of services which is related the suite claimed here. */
    Associated,
    /** **prior**

Prior Claim. A prior claim instance for the same intended suite of services. */
    Prior,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleRelatedClaimRelationshipCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "associated" => Ok(Self::Associated),
            "prior" => Ok(Self::Prior),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleRelatedClaimRelationshipCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Associated => "associated",
            Self::Prior => "prior",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleRelatedClaimRelationshipCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleRelatedClaimRelationshipCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleRelatedClaimRelationshipCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleRelatedClaimRelationshipCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleRelatedClaimRelationshipCodes> for Coding {
    fn from(code: ExampleRelatedClaimRelationshipCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-relatedclaimrelationship"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleRelatedClaimRelationshipCodes> for CodeableConcept {
    fn from(code: ExampleRelatedClaimRelationshipCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleRevenueCenterCodes](http://terminology.hl7.org/CodeSystem/ex-revenue-center)**. This value set includes sample Revenue Center codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleRevenueCenterCodes {
    /** **0010**

Vision Clinic. Vision Clinic */
    N0010,
    /** **0370**

Anaesthesia. Anaesthesia. */
    N0370,
    /** **0420**

Physical Therapy. Physical Therapy. */
    N0420,
    /** **0421**

Physical Therapy -. Physical Therapy - visit charge. */
    N0421,
    /** **0440**

Speech-Language Pathology. Speech-Language Pathology. */
    N0440,
    /** **0441**

Speech-Language Pathology - Visit. Speech-Language Pathology- visit charge */
    N0441,
    /** **0450**

Emergency Room. Emergency Room */
    N0450,
    /** **0451**

Emergency Room - EM/EMTALA. Emergency Room - EM/EMTALA */
    N0451,
    /** **0452**

Emergency Room - beyond EMTALA. Emergency Room - beyond EMTALA */
    N0452,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleRevenueCenterCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0010" => Ok(Self::N0010),
            "0370" => Ok(Self::N0370),
            "0420" => Ok(Self::N0420),
            "0421" => Ok(Self::N0421),
            "0440" => Ok(Self::N0440),
            "0441" => Ok(Self::N0441),
            "0450" => Ok(Self::N0450),
            "0451" => Ok(Self::N0451),
            "0452" => Ok(Self::N0452),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleRevenueCenterCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0010 => "0010",
            Self::N0370 => "0370",
            Self::N0420 => "0420",
            Self::N0421 => "0421",
            Self::N0440 => "0440",
            Self::N0441 => "0441",
            Self::N0450 => "0450",
            Self::N0451 => "0451",
            Self::N0452 => "0452",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleRevenueCenterCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleRevenueCenterCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleRevenueCenterCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleRevenueCenterCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleRevenueCenterCodes> for Coding {
    fn from(code: ExampleRevenueCenterCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-revenue-center".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleRevenueCenterCodes> for CodeableConcept {
    fn from(code: ExampleRevenueCenterCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleScenarioActorType](http://hl7.org/fhir/ValueSet/examplescenario-actor-type)**. The type of actor - system or human.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ExampleScenarioActorType {
    /** **entity**

System. A system. */
    Entity,
    /** **person**

Person. A person. */
    Person,
}
impl ::core::str::FromStr for ExampleScenarioActorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "entity" => Ok(Self::Entity),
            "person" => Ok(Self::Person),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExampleScenarioActorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Entity => "entity",
            Self::Person => "person",
        }
    }
}
impl ::std::fmt::Debug for ExampleScenarioActorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleScenarioActorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleScenarioActorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleScenarioActorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleScenarioActorType> for Coding {
    fn from(code: ExampleScenarioActorType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/examplescenario-actor-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleScenarioActorType> for CodeableConcept {
    fn from(code: ExampleScenarioActorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleServicePlaceCodes](http://terminology.hl7.org/CodeSystem/ex-serviceplace)**. This value set includes a smattering of Service Place codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleServicePlaceCodes {
    /** **01**

Pharmacy. A facility or location where drugs and other medically related items and services are sold, dispensed, or otherwise provided directly to patients. */
    N01,
    /** **03**

School. A facility whose primary purpose is education. */
    N03,
    /** **04**

Homeless Shelter. A facility or location whose primary purpose is to provide temporary housing to homeless individuals (e.g., emergency shelters, individual or family shelters). */
    N04,
    /** **05**

Indian Health Service Free-standing Facility. A facility or location, owned and operated by the Indian Health Service, which provides diagnostic, therapeutic (surgical and nonsurgical), and rehabilitation services to American Indians and Alaska Natives who do not require hospitalization. */
    N05,
    /** **06**

Indian Health Service Provider-based Facility. A facility or location, owned and operated by the Indian Health Service, which provides diagnostic, therapeutic (surgical and nonsurgical), and rehabilitation services rendered by, or under the supervision of, physicians to American Indians and Alaska Natives admitted as inpatients or outpatients. */
    N06,
    /** **07**

Tribal 638 Free-Standing Facility. A facility or location owned and operated by a federally recognized American Indian or Alaska Native tribe or tribal organization under a 638 agreement, which provides diagnostic, therapeutic (surgical and nonsurgical), and rehabilitation services to tribal members who do not require hospitalization. */
    N07,
    /** **08**

Tribal 638 Provider-Based Facility. A facility or location owned and operated by a federally recognized American Indian or Alaska Native tribe or tribal organization under a 638 agreement, which provides diagnostic, therapeutic (surgical and nonsurgical), and rehabilitation services to tribal members admitted as inpatients or outpatients. */
    N08,
    /** **09**

Prison/Correctional Facility. A prison, jail, reformatory, work farm, detention center, or any other similar facility maintained by either Federal, State or local authorities for the purpose of confinement or rehabilitation of adult or juvenile criminal offenders. */
    N09,
    /** **11**

Office. Location, other than a hospital, skilled nursing facility (SNF), military treatment facility, community health center, State or local public health clinic, or intermediate care facility (ICF), where the health professional routinely provides health examinations, diagnosis, and treatment of illness or injury on an ambulatory basis. */
    N11,
    /** **12**

Home. Location, other than a hospital or other facility, where the patient receives care in a private residence. */
    N12,
    /** **13**

Assisted Living Fa. Congregate residential facility with self-contained living units providing assessment of each resident's needs and on-site support 24 hours a day, 7 days a week, with the capacity to deliver or arrange for services including some health care and other services. */
    N13,
    /** **14**

Group Home. A residence, with shared living areas, where clients receive supervision and other services such as social and/or behavioral services, custodial service, and minimal services (e.g., medication administration). */
    N14,
    /** **15**

Mobile Unit. A facility/unit that moves from place-to-place equipped to provide preventive, screening, diagnostic, and/or treatment services. */
    N15,
    /** **19**

Off Campus-Outpatient Hospital. portion of an off-campus hospital provider-based department which provides diagnostic, therapeutic (both surgical and nonsurgical), and rehabilitation services to sick or injured persons who do not require hospitalization or institutionalization. */
    N19,
    /** **20**

Urgent Care Facility. Location, distinct from a hospital emergency room, an office, or a clinic, whose purpose is to diagnose and treat illness or injury for unscheduled, ambulatory patients seeking immediate medical attention. */
    N20,
    /** **21**

Inpatient Hospital. A facility, other than psychiatric, which primarily provides diagnostic, therapeutic (both surgical and nonsurgical), and rehabilitation services by, or under, the supervision of physicians to patients admitted for a variety of medical conditions. */
    N21,
    /** **41**

Ambulance—Land. A land vehicle specifically designed, equipped and staffed for lifesaving and transporting the sick or injured. */
    N41,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleServicePlaceCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "01" => Ok(Self::N01),
            "03" => Ok(Self::N03),
            "04" => Ok(Self::N04),
            "05" => Ok(Self::N05),
            "06" => Ok(Self::N06),
            "07" => Ok(Self::N07),
            "08" => Ok(Self::N08),
            "09" => Ok(Self::N09),
            "11" => Ok(Self::N11),
            "12" => Ok(Self::N12),
            "13" => Ok(Self::N13),
            "14" => Ok(Self::N14),
            "15" => Ok(Self::N15),
            "19" => Ok(Self::N19),
            "20" => Ok(Self::N20),
            "21" => Ok(Self::N21),
            "41" => Ok(Self::N41),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleServicePlaceCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N01 => "01",
            Self::N03 => "03",
            Self::N04 => "04",
            Self::N05 => "05",
            Self::N06 => "06",
            Self::N07 => "07",
            Self::N08 => "08",
            Self::N09 => "09",
            Self::N11 => "11",
            Self::N12 => "12",
            Self::N13 => "13",
            Self::N14 => "14",
            Self::N15 => "15",
            Self::N19 => "19",
            Self::N20 => "20",
            Self::N21 => "21",
            Self::N41 => "41",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleServicePlaceCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleServicePlaceCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleServicePlaceCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleServicePlaceCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleServicePlaceCodes> for Coding {
    fn from(code: ExampleServicePlaceCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-serviceplace".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleServicePlaceCodes> for CodeableConcept {
    fn from(code: ExampleServicePlaceCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleUseCodesForList](http://terminology.hl7.org/CodeSystem/list-example-use-codes)**. Example use codes for the List resource - typical kinds of use.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleUseCodesForList {
    /** **adverserxns**

Adverse Reactions. A list of part adverse reactions. */
    Adverserxns,
    /** **alerts**

Alerts. A list of alerts for the patient. */
    Alerts,
    /** **allergies**

Allergies. A list of Allergies for the patient. */
    Allergies,
    /** **medications**

Medication List. A list of medication statements for the patient. */
    Medications,
    /** **plans**

Care Plans. A set of care plans that apply in a particular context of care. */
    Plans,
    /** **problems**

Problem List. A list of problems that the patient is known of have (or have had in the past). */
    Problems,
    /** **protocols**

Protocols. A set of protocols to be followed. */
    Protocols,
    /** **waiting**

Waiting List. A list of items waiting for an event (perhaps a surgical patient waiting list). */
    Waiting,
    /** **worklist**

Worklist. A list of items that constitute a set of work to be performed (typically this code would be specialized for more specific uses, such as a ward round list). */
    Worklist,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleUseCodesForList {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "adverserxns" => Ok(Self::Adverserxns),
            "alerts" => Ok(Self::Alerts),
            "allergies" => Ok(Self::Allergies),
            "medications" => Ok(Self::Medications),
            "plans" => Ok(Self::Plans),
            "problems" => Ok(Self::Problems),
            "protocols" => Ok(Self::Protocols),
            "waiting" => Ok(Self::Waiting),
            "worklist" => Ok(Self::Worklist),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleUseCodesForList {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adverserxns => "adverserxns",
            Self::Alerts => "alerts",
            Self::Allergies => "allergies",
            Self::Medications => "medications",
            Self::Plans => "plans",
            Self::Problems => "problems",
            Self::Protocols => "protocols",
            Self::Waiting => "waiting",
            Self::Worklist => "worklist",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleUseCodesForList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleUseCodesForList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleUseCodesForList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleUseCodesForList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleUseCodesForList> for Coding {
    fn from(code: ExampleUseCodesForList) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/list-example-use-codes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleUseCodesForList> for CodeableConcept {
    fn from(code: ExampleUseCodesForList) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExampleVisionPrescriptionProductCodes](http://terminology.hl7.org/CodeSystem/ex-visionprescriptionproduct)**. This value set includes a smattering of Prescription Product codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExampleVisionPrescriptionProductCodes {
    /** **contact**

Contact Lens. A lens to be fitted for wearing directly on an eye. */
    Contact,
    /** **lens**

Lens. A lens to be fitted to a frame to comprise a pair of glasses. */
    Lens,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleVisionPrescriptionProductCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contact" => Ok(Self::Contact),
            "lens" => Ok(Self::Lens),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleVisionPrescriptionProductCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contact => "contact",
            Self::Lens => "lens",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExampleVisionPrescriptionProductCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExampleVisionPrescriptionProductCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExampleVisionPrescriptionProductCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleVisionPrescriptionProductCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleVisionPrescriptionProductCodes> for Coding {
    fn from(code: ExampleVisionPrescriptionProductCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-visionprescriptionproduct"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExampleVisionPrescriptionProductCodes> for CodeableConcept {
    fn from(code: ExampleVisionPrescriptionProductCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExceptionCodes](http://terminology.hl7.org/CodeSystem/claim-exception)**. This value set includes sample Exception codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExceptionCodes {
    /** **disabled**

Disabled. Disabled */
    Disabled,
    /** **student**

Student (Fulltime). Fulltime Student */
    Student,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExceptionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "disabled" => Ok(Self::Disabled),
            "student" => Ok(Self::Student),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExceptionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Disabled => "disabled",
            Self::Student => "student",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExceptionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExceptionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExceptionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExceptionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExceptionCodes> for Coding {
    fn from(code: ExceptionCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/claim-exception".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExceptionCodes> for CodeableConcept {
    fn from(code: ExceptionCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExplanationOfBenefitStatus](http://hl7.org/fhir/ValueSet/explanationofbenefit-status)**. A code specifying the state of the resource instance.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ExplanationOfBenefitStatus {
    /** **active**

Active. The resource instance is currently in-force. */
    Active,
    /** **cancelled**

Cancelled. The resource instance is withdrawn, rescinded or reversed. */
    Cancelled,
    /** **draft**

Draft. A new resource instance the contents of which is not complete. */
    Draft,
    /** **entered-in-error**

Entered In Error. The resource instance was entered in error. */
    EnteredInError,
}
impl ::core::str::FromStr for ExplanationOfBenefitStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExplanationOfBenefitStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
        }
    }
}
impl ::std::fmt::Debug for ExplanationOfBenefitStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExplanationOfBenefitStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExplanationOfBenefitStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExplanationOfBenefitStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExplanationOfBenefitStatus> for Coding {
    fn from(code: ExplanationOfBenefitStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/explanationofbenefit-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExplanationOfBenefitStatus> for CodeableConcept {
    fn from(code: ExplanationOfBenefitStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExpressionLanguage](http://hl7.org/fhir/ValueSet/expression-language)**. The media type of the expression language.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ExpressionLanguage {
    /** **application/x-fhir-query**

FHIR Query. FHIR's RESTful query syntax - typically independent of base URL. */
    ApplicationXFhirQuery,
    /** **text/cql**

CQL. Clinical Quality Language. */
    TextCql,
    /** **text/cql-expression**

CQL Expression. A Clinical Quality Language expression. */
    TextCqlExpression,
    /** **text/cql-identifier**

CQL Identifier. A valid Clinical Quality Language identifier. */
    TextCqlIdentifier,
    /** **text/fhirpath**

FHIRPath. FHIRPath. */
    TextFhirpath,
}
impl ::core::str::FromStr for ExpressionLanguage {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "application/x-fhir-query" => Ok(Self::ApplicationXFhirQuery),
            "text/cql" => Ok(Self::TextCql),
            "text/cql-expression" => Ok(Self::TextCqlExpression),
            "text/cql-identifier" => Ok(Self::TextCqlIdentifier),
            "text/fhirpath" => Ok(Self::TextFhirpath),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExpressionLanguage {
    fn as_ref(&self) -> &str {
        match self {
            Self::ApplicationXFhirQuery => "application/x-fhir-query",
            Self::TextCql => "text/cql",
            Self::TextCqlExpression => "text/cql-expression",
            Self::TextCqlIdentifier => "text/cql-identifier",
            Self::TextFhirpath => "text/fhirpath",
        }
    }
}
impl ::std::fmt::Debug for ExpressionLanguage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExpressionLanguage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExpressionLanguage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExpressionLanguage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExpressionLanguage> for Coding {
    fn from(code: ExpressionLanguage) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/expression-language".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExpressionLanguage> for CodeableConcept {
    fn from(code: ExpressionLanguage) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExtensionContextType](http://hl7.org/fhir/ValueSet/extension-context-type)**. How an extension context is interpreted.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ExtensionContextType {
    /** **element**

Element ID. The context is any element that has an ElementDefinition.id that matches that found in the expression. This includes ElementDefinition Ids that have slicing identifiers. The full path for the element is [url]#[elementid]. If there is no #, the Element id is one defined in the base specification. */
    Element,
    /** **extension**

Extension URL. The context is a particular extension from a particular StructureDefinition, and the expression is just a uri that identifies the extension. */
    Extension,
    /** **fhirpath**

FHIRPath. The context is all elements that match the FHIRPath query found in the expression. */
    Fhirpath,
}
impl ::core::str::FromStr for ExtensionContextType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "element" => Ok(Self::Element),
            "extension" => Ok(Self::Extension),
            "fhirpath" => Ok(Self::Fhirpath),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExtensionContextType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Element => "element",
            Self::Extension => "extension",
            Self::Fhirpath => "fhirpath",
        }
    }
}
impl ::std::fmt::Debug for ExtensionContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExtensionContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExtensionContextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExtensionContextType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExtensionContextType> for Coding {
    fn from(code: ExtensionContextType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/extension-context-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExtensionContextType> for CodeableConcept {
    fn from(code: ExtensionContextType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ExtraActivityType](http://hl7.org/fhir/extra-activity-type)**. This value set includes coded concepts not well covered in any of the included valuesets.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ExtraActivityType {
    /** **aggregate**

aggregate. Activity resulting in a structured collection of preexisting content that does not necessarily result in an integral object with semantic context making it more than the sum of component parts, from which components could be disaggregated without loss of semantic context, e.g., the assembly of multiple stand-alone documents. */
    Aggregate,
    /** **compose**

compose. Activity resulting in the structured compilation of new and preexisting content for the purposes of forming an integral object with  semantic context making it more than the sum of component parts, which would be lost if decomposed. For example, the composition of a document that includes in whole or part other documents along with new content that result in a new document that has unique semantic meaning. */
    Compose,
    /** **label**

label. The means used to associate a set of security attributes with a specific information object as part of the data structure for that object. [ISO-10181-3 Access Control] */
    Label,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExtraActivityType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aggregate" => Ok(Self::Aggregate),
            "compose" => Ok(Self::Compose),
            "label" => Ok(Self::Label),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExtraActivityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aggregate => "aggregate",
            Self::Compose => "compose",
            Self::Label => "label",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ExtraActivityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ExtraActivityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ExtraActivityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExtraActivityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExtraActivityType> for Coding {
    fn from(code: ExtraActivityType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/extra-activity-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ExtraActivityType> for CodeableConcept {
    fn from(code: ExtraActivityType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FHIRDeviceStatus](http://hl7.org/fhir/ValueSet/device-status)**. The availability status of the device.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FHIRDeviceStatus {
    /** **active**

Active. The device is available for use.  Note: For *implanted devices*  this means that the device is implanted in the patient. */
    Active,
    /** **entered-in-error**

Entered in Error. The device was entered in error and voided. */
    EnteredInError,
    /** **inactive**

Inactive. The device is no longer available for use (e.g. lost, expired, damaged).  Note: For *implanted devices*  this means that the device has been removed from the patient. */
    Inactive,
    /** **unknown**

Unknown. The status of the device has not been determined. */
    Unknown,
}
impl ::core::str::FromStr for FHIRDeviceStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FHIRDeviceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for FHIRDeviceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FHIRDeviceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FHIRDeviceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FHIRDeviceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FHIRDeviceStatus> for Coding {
    fn from(code: FHIRDeviceStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/device-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FHIRDeviceStatus> for CodeableConcept {
    fn from(code: FHIRDeviceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FHIRDeviceStatusReason](http://hl7.org/fhir/ValueSet/device-status-reason)**. The availability status reason of the device.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FHIRDeviceStatusReason {
    /** **hw-discon**

Hardware Disconnected. The device hardware is disconnected. */
    HwDiscon,
    /** **not-ready**

Not Ready. The device is not ready. */
    NotReady,
    /** **off**

Off. The device is off. */
    Off,
    /** **offline**

Offline. The device is offline. */
    Offline,
    /** **online**

Online. The device is off. */
    Online,
    /** **paused**

Paused. The device is paused. */
    Paused,
    /** **standby**

Standby. The device is ready but not actively operating. */
    Standby,
    /** **transduc-discon**

Transducer Disconnected. The device transducer is disconnected. */
    TransducDiscon,
}
impl ::core::str::FromStr for FHIRDeviceStatusReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "hw-discon" => Ok(Self::HwDiscon),
            "not-ready" => Ok(Self::NotReady),
            "off" => Ok(Self::Off),
            "offline" => Ok(Self::Offline),
            "online" => Ok(Self::Online),
            "paused" => Ok(Self::Paused),
            "standby" => Ok(Self::Standby),
            "transduc-discon" => Ok(Self::TransducDiscon),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FHIRDeviceStatusReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::HwDiscon => "hw-discon",
            Self::NotReady => "not-ready",
            Self::Off => "off",
            Self::Offline => "offline",
            Self::Online => "online",
            Self::Paused => "paused",
            Self::Standby => "standby",
            Self::TransducDiscon => "transduc-discon",
        }
    }
}
impl ::std::fmt::Debug for FHIRDeviceStatusReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FHIRDeviceStatusReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FHIRDeviceStatusReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FHIRDeviceStatusReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FHIRDeviceStatusReason> for Coding {
    fn from(code: FHIRDeviceStatusReason) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/device-status-reason".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FHIRDeviceStatusReason> for CodeableConcept {
    fn from(code: FHIRDeviceStatusReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FHIRPathTypes](http://hl7.org/fhir/ValueSet/fhirpath-types)**. All FHIRPath data types\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FHIRPathTypes {
    /** **http://hl7.org/fhirpath/System.Boolean**

Boolean. */
    HttpHl7OrgFhirpathSystemBoolean,
    /** **http://hl7.org/fhirpath/System.Date**

Date. */
    HttpHl7OrgFhirpathSystemDate,
    /** **http://hl7.org/fhirpath/System.DateTime**

DateTime. */
    HttpHl7OrgFhirpathSystemDateTime,
    /** **http://hl7.org/fhirpath/System.Decimal**

Decimal. */
    HttpHl7OrgFhirpathSystemDecimal,
    /** **http://hl7.org/fhirpath/System.Integer**

Integer. */
    HttpHl7OrgFhirpathSystemInteger,
    /** **http://hl7.org/fhirpath/System.String**

String. */
    HttpHl7OrgFhirpathSystemString,
    /** **http://hl7.org/fhirpath/System.Time**

Time. */
    HttpHl7OrgFhirpathSystemTime,
}
impl ::core::str::FromStr for FHIRPathTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "http://hl7.org/fhirpath/System.Boolean" => {
                Ok(Self::HttpHl7OrgFhirpathSystemBoolean)
            }
            "http://hl7.org/fhirpath/System.Date" => {
                Ok(Self::HttpHl7OrgFhirpathSystemDate)
            }
            "http://hl7.org/fhirpath/System.DateTime" => {
                Ok(Self::HttpHl7OrgFhirpathSystemDateTime)
            }
            "http://hl7.org/fhirpath/System.Decimal" => {
                Ok(Self::HttpHl7OrgFhirpathSystemDecimal)
            }
            "http://hl7.org/fhirpath/System.Integer" => {
                Ok(Self::HttpHl7OrgFhirpathSystemInteger)
            }
            "http://hl7.org/fhirpath/System.String" => {
                Ok(Self::HttpHl7OrgFhirpathSystemString)
            }
            "http://hl7.org/fhirpath/System.Time" => {
                Ok(Self::HttpHl7OrgFhirpathSystemTime)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FHIRPathTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::HttpHl7OrgFhirpathSystemBoolean => {
                "http://hl7.org/fhirpath/System.Boolean"
            }
            Self::HttpHl7OrgFhirpathSystemDate => "http://hl7.org/fhirpath/System.Date",
            Self::HttpHl7OrgFhirpathSystemDateTime => {
                "http://hl7.org/fhirpath/System.DateTime"
            }
            Self::HttpHl7OrgFhirpathSystemDecimal => {
                "http://hl7.org/fhirpath/System.Decimal"
            }
            Self::HttpHl7OrgFhirpathSystemInteger => {
                "http://hl7.org/fhirpath/System.Integer"
            }
            Self::HttpHl7OrgFhirpathSystemString => {
                "http://hl7.org/fhirpath/System.String"
            }
            Self::HttpHl7OrgFhirpathSystemTime => "http://hl7.org/fhirpath/System.Time",
        }
    }
}
impl ::std::fmt::Debug for FHIRPathTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FHIRPathTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FHIRPathTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FHIRPathTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FHIRPathTypes> for Coding {
    fn from(code: FHIRPathTypes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/fhirpath-types".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FHIRPathTypes> for CodeableConcept {
    fn from(code: FHIRPathTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FHIRSubstanceStatus](http://hl7.org/fhir/ValueSet/substance-status)**. A code to indicate if the substance is actively used.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FHIRSubstanceStatus {
    /** **active**

Active. The substance is considered for use or reference. */
    Active,
    /** **entered-in-error**

Entered in Error. The substance was entered in error. */
    EnteredInError,
    /** **inactive**

Inactive. The substance is considered for reference, but not for use. */
    Inactive,
}
impl ::core::str::FromStr for FHIRSubstanceStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FHIRSubstanceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Debug for FHIRSubstanceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FHIRSubstanceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FHIRSubstanceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FHIRSubstanceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FHIRSubstanceStatus> for Coding {
    fn from(code: FHIRSubstanceStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/substance-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FHIRSubstanceStatus> for CodeableConcept {
    fn from(code: FHIRSubstanceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FHIRVersion](http://hl7.org/fhir/ValueSet/FHIR-version)**. All published FHIR Versions.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FHIRVersion {
    /** **0.0.80**

0.0.80. DSTU 1 Official version. */
    N0080,
    /** **0.0.81**

0.0.81. DSTU 1 Official version Technical Errata #1. */
    N0081,
    /** **0.0.82**

0.0.82. DSTU 1 Official version Technical Errata #2. */
    N0082,
    /** **0.01**

0.01. Oldest archived version of FHIR. */
    N001,
    /** **0.05**

0.05. 1st Draft for Comment (Sept 2012 Ballot). */
    N005,
    /** **0.06**

0.06. 2nd Draft for Comment (January 2013 Ballot). */
    N006,
    /** **0.11**

0.11. DSTU 1 Ballot version. */
    N011,
    /** **0.4.0**

0.4.0. Draft For Comment (January 2015 Ballot). */
    N040,
    /** **0.5.0**

0.5.0. DSTU 2 Ballot version (May 2015 Ballot). */
    N050,
    /** **1.0.0**

1.0.0. DSTU 2 QA Preview + CQIF Ballot (Sep 2015). */
    N100,
    /** **1.0.1**

1.0.1. DSTU 2 (Official version). */
    N101,
    /** **1.0.2**

1.0.2. DSTU 2 (Official version) with 1 technical errata. */
    N102,
    /** **1.1.0**

1.1.0. GAO Ballot + draft changes to main FHIR standard. */
    N110,
    /** **1.4.0**

1.4.0. CQF on FHIR Ballot + Connectathon 12 (Montreal). */
    N140,
    /** **1.6.0**

1.6.0. FHIR STU3 Ballot + Connectathon 13 (Baltimore). */
    N160,
    /** **1.8.0**

1.8.0. FHIR STU3 Candidate + Connectathon 14 (San Antonio). */
    N180,
    /** **3.0.0**

3.0.0. FHIR Release 3 (STU). */
    N300,
    /** **3.0.1**

3.0.1. FHIR Release 3 (STU) with 1 technical errata. */
    N301,
    /** **3.0.2**

3.0.2. FHIR Release 3 (STU) with 2 technical errata. */
    N302,
    /** **3.3.0**

3.3.0. R4 Ballot #1. */
    N330,
    /** **3.5.0**

3.5.0. R4 Ballot #2. */
    N350,
    /** **4.0.0**

4.0.0. FHIR Release 4 (Normative + STU). */
    N400,
    /** **4.0.1**

4.0.1. FHIR Release 4 Technical Correction. */
    N401,
    /** **4.1.0**

4.1.0. FHIR Release 4B Ballot #1. */
    N410,
    /** **4.3.0**

4.3.0. FHIR Release 4B. */
    N430,
    /** **4.3.0-cibuild**

4.3.0-cibuild. FHIR Release 4B CI-Build. */
    N430Cibuild,
    /** **4.3.0-snapshot1**

4.3.0-snapshot1. FHIR Release 4B Snapshot #1. */
    N430Snapshot1,
}
impl ::core::str::FromStr for FHIRVersion {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0.0.80" => Ok(Self::N0080),
            "0.0.81" => Ok(Self::N0081),
            "0.0.82" => Ok(Self::N0082),
            "0.01" => Ok(Self::N001),
            "0.05" => Ok(Self::N005),
            "0.06" => Ok(Self::N006),
            "0.11" => Ok(Self::N011),
            "0.4.0" => Ok(Self::N040),
            "0.5.0" => Ok(Self::N050),
            "1.0.0" => Ok(Self::N100),
            "1.0.1" => Ok(Self::N101),
            "1.0.2" => Ok(Self::N102),
            "1.1.0" => Ok(Self::N110),
            "1.4.0" => Ok(Self::N140),
            "1.6.0" => Ok(Self::N160),
            "1.8.0" => Ok(Self::N180),
            "3.0.0" => Ok(Self::N300),
            "3.0.1" => Ok(Self::N301),
            "3.0.2" => Ok(Self::N302),
            "3.3.0" => Ok(Self::N330),
            "3.5.0" => Ok(Self::N350),
            "4.0.0" => Ok(Self::N400),
            "4.0.1" => Ok(Self::N401),
            "4.1.0" => Ok(Self::N410),
            "4.3.0" => Ok(Self::N430),
            "4.3.0-cibuild" => Ok(Self::N430Cibuild),
            "4.3.0-snapshot1" => Ok(Self::N430Snapshot1),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FHIRVersion {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0080 => "0.0.80",
            Self::N0081 => "0.0.81",
            Self::N0082 => "0.0.82",
            Self::N001 => "0.01",
            Self::N005 => "0.05",
            Self::N006 => "0.06",
            Self::N011 => "0.11",
            Self::N040 => "0.4.0",
            Self::N050 => "0.5.0",
            Self::N100 => "1.0.0",
            Self::N101 => "1.0.1",
            Self::N102 => "1.0.2",
            Self::N110 => "1.1.0",
            Self::N140 => "1.4.0",
            Self::N160 => "1.6.0",
            Self::N180 => "1.8.0",
            Self::N300 => "3.0.0",
            Self::N301 => "3.0.1",
            Self::N302 => "3.0.2",
            Self::N330 => "3.3.0",
            Self::N350 => "3.5.0",
            Self::N400 => "4.0.0",
            Self::N401 => "4.0.1",
            Self::N410 => "4.1.0",
            Self::N430 => "4.3.0",
            Self::N430Cibuild => "4.3.0-cibuild",
            Self::N430Snapshot1 => "4.3.0-snapshot1",
        }
    }
}
impl ::std::fmt::Debug for FHIRVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FHIRVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FHIRVersion {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FHIRVersion {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FHIRVersion> for Coding {
    fn from(code: FHIRVersion) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/FHIR-version".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FHIRVersion> for CodeableConcept {
    fn from(code: FHIRVersion) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FamilyHistoryAbsentReason](http://hl7.org/fhir/ValueSet/history-absent-reason)**. Codes describing the reason why a family member's history is not available.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FamilyHistoryAbsentReason {
    /** **deferred**

Deferred. Patient does not have the information now, but can provide the information at a later date. */
    Deferred,
    /** **subject-unknown**

Subject Unknown. Patient does not know the subject, e.g. the biological parent of an adopted patient. */
    SubjectUnknown,
    /** **unable-to-obtain**

Unable To Obtain. Information cannot be obtained; e.g. unconscious patient. */
    UnableToObtain,
    /** **withheld**

Information Withheld. The patient withheld or refused to share the information. */
    Withheld,
}
impl ::core::str::FromStr for FamilyHistoryAbsentReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deferred" => Ok(Self::Deferred),
            "subject-unknown" => Ok(Self::SubjectUnknown),
            "unable-to-obtain" => Ok(Self::UnableToObtain),
            "withheld" => Ok(Self::Withheld),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FamilyHistoryAbsentReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deferred => "deferred",
            Self::SubjectUnknown => "subject-unknown",
            Self::UnableToObtain => "unable-to-obtain",
            Self::Withheld => "withheld",
        }
    }
}
impl ::std::fmt::Debug for FamilyHistoryAbsentReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FamilyHistoryAbsentReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FamilyHistoryAbsentReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FamilyHistoryAbsentReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FamilyHistoryAbsentReason> for Coding {
    fn from(code: FamilyHistoryAbsentReason) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/history-absent-reason".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FamilyHistoryAbsentReason> for CodeableConcept {
    fn from(code: FamilyHistoryAbsentReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FamilyHistoryStatus](http://hl7.org/fhir/ValueSet/history-status)**. A code that identifies the status of the family history record.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FamilyHistoryStatus {
    /** **completed**

Completed. All available related health information is captured as of the date (and possibly time) when the family member history was taken. */
    Completed,
    /** **entered-in-error**

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **health-unknown**

Health Unknown. Health information for this family member is unavailable/unknown. */
    HealthUnknown,
    /** **partial**

Partial. Some health information is known and captured, but not complete - see notes for details. */
    Partial,
}
impl ::core::str::FromStr for FamilyHistoryStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "health-unknown" => Ok(Self::HealthUnknown),
            "partial" => Ok(Self::Partial),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FamilyHistoryStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::HealthUnknown => "health-unknown",
            Self::Partial => "partial",
        }
    }
}
impl ::std::fmt::Debug for FamilyHistoryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FamilyHistoryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FamilyHistoryStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FamilyHistoryStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FamilyHistoryStatus> for Coding {
    fn from(code: FamilyHistoryStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/history-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FamilyHistoryStatus> for CodeableConcept {
    fn from(code: FamilyHistoryStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FeedingDeviceCodes](http://hl7.org/fhir/feeding-device)**. Materials used or needed to feed the patient. These values are provided as a suggestive example.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum FeedingDeviceCodes {
    /** **angled-utensil**

Angled utensils. Angled utensils definition: */
    AngledUtensil,
    /** **autofeeding-device**

Automated feeding devices. Automated feeding devices definition: */
    AutofeedingDevice,
    /** **bigcut-nipple**

Enlarged, cross-cut nipple. Enlarged, cross-cut nipple definition: */
    BigcutNipple,
    /** **foam-handle**

Foam handle utensils. Foam handle utensils definition: */
    FoamHandle,
    /** **glass-lid**

Glass with lid/sippy cup. Glass with lid/sippy cup definition: */
    GlassLid,
    /** **haberman-bottle**

Haberman bottle. Haberman bottle definition: */
    HabermanBottle,
    /** **handhold-cup**

Double handhold on glass/cup. Double handhold on glass/cup definition: */
    HandholdCup,
    /** **midflo-nipple**

Middle flow nipple. Middle flow nipple definition: */
    MidfloNipple,
    /** **nose-cup**

Nose cup. Nose cup definition: */
    NoseCup,
    /** **ortho-nipple**

Orthodontic nipple. Orthodontic nipple definition: */
    OrthoNipple,
    /** **preemie-nipple**

Preemie nipple. Preemie nipple definition: */
    PreemieNipple,
    /** **provale-cup**

Provale Cup. Provale Cup definition: */
    ProvaleCup,
    /** **rocker-knife**

Rocker knife. Rocker knife definition: */
    RockerKnife,
    /** **rubber-mat**

Rubber matting under tray. Rubber matting under tray definition: */
    RubberMat,
    /** **scoop-plate**

Scoop plate. Scoop plate definition: */
    ScoopPlate,
    /** **sippy-no-valve**

Sippy cup without valve. Sippy cup without valve definition: */
    SippyNoValve,
    /** **sippy-valve**

Sippy cup with valve. Sippy cup with valve definition: */
    SippyValve,
    /** **sloflo-nipple**

Slow flow nipple. Slow flow nipple definition: */
    SlofloNipple,
    /** **spout-cup**

Spout cup. Spout cup definition: */
    SpoutCup,
    /** **standard-nipple**

Standard nipple. Standard nipple definition: */
    StandardNipple,
    /** **straw**

Straw. Straw definition: */
    Straw,
    /** **utensil-holder**

Hand wrap utensil holder. Hand wrap utensil holder definition: */
    UtensilHolder,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for FeedingDeviceCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "angled-utensil" => Ok(Self::AngledUtensil),
            "autofeeding-device" => Ok(Self::AutofeedingDevice),
            "bigcut-nipple" => Ok(Self::BigcutNipple),
            "foam-handle" => Ok(Self::FoamHandle),
            "glass-lid" => Ok(Self::GlassLid),
            "haberman-bottle" => Ok(Self::HabermanBottle),
            "handhold-cup" => Ok(Self::HandholdCup),
            "midflo-nipple" => Ok(Self::MidfloNipple),
            "nose-cup" => Ok(Self::NoseCup),
            "ortho-nipple" => Ok(Self::OrthoNipple),
            "preemie-nipple" => Ok(Self::PreemieNipple),
            "provale-cup" => Ok(Self::ProvaleCup),
            "rocker-knife" => Ok(Self::RockerKnife),
            "rubber-mat" => Ok(Self::RubberMat),
            "scoop-plate" => Ok(Self::ScoopPlate),
            "sippy-no-valve" => Ok(Self::SippyNoValve),
            "sippy-valve" => Ok(Self::SippyValve),
            "sloflo-nipple" => Ok(Self::SlofloNipple),
            "spout-cup" => Ok(Self::SpoutCup),
            "standard-nipple" => Ok(Self::StandardNipple),
            "straw" => Ok(Self::Straw),
            "utensil-holder" => Ok(Self::UtensilHolder),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for FeedingDeviceCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::AngledUtensil => "angled-utensil",
            Self::AutofeedingDevice => "autofeeding-device",
            Self::BigcutNipple => "bigcut-nipple",
            Self::FoamHandle => "foam-handle",
            Self::GlassLid => "glass-lid",
            Self::HabermanBottle => "haberman-bottle",
            Self::HandholdCup => "handhold-cup",
            Self::MidfloNipple => "midflo-nipple",
            Self::NoseCup => "nose-cup",
            Self::OrthoNipple => "ortho-nipple",
            Self::PreemieNipple => "preemie-nipple",
            Self::ProvaleCup => "provale-cup",
            Self::RockerKnife => "rocker-knife",
            Self::RubberMat => "rubber-mat",
            Self::ScoopPlate => "scoop-plate",
            Self::SippyNoValve => "sippy-no-valve",
            Self::SippyValve => "sippy-valve",
            Self::SlofloNipple => "sloflo-nipple",
            Self::SpoutCup => "spout-cup",
            Self::StandardNipple => "standard-nipple",
            Self::Straw => "straw",
            Self::UtensilHolder => "utensil-holder",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for FeedingDeviceCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FeedingDeviceCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FeedingDeviceCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FeedingDeviceCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FeedingDeviceCodes> for Coding {
    fn from(code: FeedingDeviceCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/feeding-device".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FeedingDeviceCodes> for CodeableConcept {
    fn from(code: FeedingDeviceCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FilterOperator](http://hl7.org/fhir/ValueSet/filter-operator)**. The kind of operation to perform as a part of a property based filter.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FilterOperator {
    /** **=**

Equals. The specified property of the code equals the provided value. */
    Equal,
    /** **descendent-of**

Descendent Of (by subsumption). Includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, excluding the provided concept itself i.e. include descendant codes only). */
    DescendentOf,
    /** **exists**

Exists. The specified property of the code has at least one value (if the specified value is true; if the specified value is false, then matches when the specified property of the code has no values). */
    Exists,
    /** **generalizes**

Generalizes (by Subsumption). Includes all concept ids that have a transitive is-a relationship from the concept Id provided as the value, including the provided concept itself (i.e. include ancestor codes and self). */
    Generalizes,
    /** **in**

In Set. The specified property of the code is in the set of codes or concepts specified in the provided value (comma separated list). */
    In,
    /** **is-a**

Is A (by subsumption). Includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, including the provided concept itself (include descendant codes and self). */
    IsA,
    /** **is-not-a**

Not (Is A) (by subsumption). The specified property of the code does not have an is-a relationship with the provided value. */
    IsNotA,
    /** **not-in**

Not in Set. The specified property of the code is not in the set of codes or concepts specified in the provided value (comma separated list). */
    NotIn,
    /** **regex**

Regular Expression. The specified property of the code  matches the regex specified in the provided value. */
    Regex,
}
impl ::core::str::FromStr for FilterOperator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "=" => Ok(Self::Equal),
            "descendent-of" => Ok(Self::DescendentOf),
            "exists" => Ok(Self::Exists),
            "generalizes" => Ok(Self::Generalizes),
            "in" => Ok(Self::In),
            "is-a" => Ok(Self::IsA),
            "is-not-a" => Ok(Self::IsNotA),
            "not-in" => Ok(Self::NotIn),
            "regex" => Ok(Self::Regex),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FilterOperator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equal => "=",
            Self::DescendentOf => "descendent-of",
            Self::Exists => "exists",
            Self::Generalizes => "generalizes",
            Self::In => "in",
            Self::IsA => "is-a",
            Self::IsNotA => "is-not-a",
            Self::NotIn => "not-in",
            Self::Regex => "regex",
        }
    }
}
impl ::std::fmt::Debug for FilterOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FilterOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FilterOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FilterOperator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FilterOperator> for Coding {
    fn from(code: FilterOperator) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/filter-operator".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FilterOperator> for CodeableConcept {
    fn from(code: FilterOperator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FinancialResourceStatusCodes](http://hl7.org/fhir/fm-status)**. This value set includes Status codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum FinancialResourceStatusCodes {
    /** **active**

Active. The instance is currently in-force. */
    Active,
    /** **cancelled**

Cancelled. The instance is withdrawn, rescinded or reversed. */
    Cancelled,
    /** **draft**

Draft. A new instance the contents of which is not complete. */
    Draft,
    /** **entered-in-error**

Entered in Error. The instance was entered in error. */
    EnteredInError,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for FinancialResourceStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for FinancialResourceStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for FinancialResourceStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FinancialResourceStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FinancialResourceStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FinancialResourceStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FinancialResourceStatusCodes> for Coding {
    fn from(code: FinancialResourceStatusCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/fm-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FinancialResourceStatusCodes> for CodeableConcept {
    fn from(code: FinancialResourceStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FlagCategory](http://hl7.org/fhir/ValueSet/flag-category)**. Example list of detail codes for flagged issues. (Not complete or necessarily appropriate.)\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FlagCategory {
    /** **admin**

Administrative. Flags related to administrative and financial processes. */
    Admin,
    /** **advance-directive**

Advance Directive. Flags related to subject's advance directives. */
    AdvanceDirective,
    /** **behavioral**

Behavioral. Flags related to behavior. */
    Behavioral,
    /** **clinical**

Clinical. Flags related to the subject's clinical data. */
    Clinical,
    /** **contact**

Subject Contact. Flags related to coming into contact with the patient. */
    Contact,
    /** **diet**

Diet. Flags related to the subject's dietary needs. */
    Diet,
    /** **drug**

Drug. Flags related to the subject's medications. */
    Drug,
    /** **lab**

Lab. Flags related to performing laboratory tests and related processes (e.g. phlebotomy). */
    Lab,
    /** **research**

Research. Flags related to research. */
    Research,
    /** **safety**

Safety. Flags related to safety precautions. */
    Safety,
}
impl ::core::str::FromStr for FlagCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "admin" => Ok(Self::Admin),
            "advance-directive" => Ok(Self::AdvanceDirective),
            "behavioral" => Ok(Self::Behavioral),
            "clinical" => Ok(Self::Clinical),
            "contact" => Ok(Self::Contact),
            "diet" => Ok(Self::Diet),
            "drug" => Ok(Self::Drug),
            "lab" => Ok(Self::Lab),
            "research" => Ok(Self::Research),
            "safety" => Ok(Self::Safety),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FlagCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Admin => "admin",
            Self::AdvanceDirective => "advance-directive",
            Self::Behavioral => "behavioral",
            Self::Clinical => "clinical",
            Self::Contact => "contact",
            Self::Diet => "diet",
            Self::Drug => "drug",
            Self::Lab => "lab",
            Self::Research => "research",
            Self::Safety => "safety",
        }
    }
}
impl ::std::fmt::Debug for FlagCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FlagCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FlagCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FlagCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FlagCategory> for Coding {
    fn from(code: FlagCategory) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/flag-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FlagCategory> for CodeableConcept {
    fn from(code: FlagCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FlagPriorityCodes](http://hl7.org/fhir/flag-priority-code)**. This value set is provided as an exemplar. The value set is driven by IHE Table B.8-4: Abnormal Flags, Alert Priority.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum FlagPriorityCodes {
    /** **PH**

High priority. High priority. */
    Ph,
    /** **PL**

Low priority. Low priority. */
    Pl,
    /** **PM**

Medium priority. Medium priority. */
    Pm,
    /** **PN**

No alarm. No alarm. */
    Pn,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for FlagPriorityCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "PH" => Ok(Self::Ph),
            "PL" => Ok(Self::Pl),
            "PM" => Ok(Self::Pm),
            "PN" => Ok(Self::Pn),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for FlagPriorityCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ph => "PH",
            Self::Pl => "PL",
            Self::Pm => "PM",
            Self::Pn => "PN",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for FlagPriorityCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FlagPriorityCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FlagPriorityCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FlagPriorityCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FlagPriorityCodes> for Coding {
    fn from(code: FlagPriorityCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/flag-priority-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FlagPriorityCodes> for CodeableConcept {
    fn from(code: FlagPriorityCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FlagStatus](http://hl7.org/fhir/ValueSet/flag-status)**. Indicates whether this flag is active and needs to be displayed to a user, or whether it is no longer needed or was entered in error.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FlagStatus {
    /** **active**

Active. A current flag that should be displayed to a user. A system may use the category to determine which user roles should view the flag. */
    Active,
    /** **entered-in-error**

Entered in Error. The flag was added in error and should no longer be displayed. */
    EnteredInError,
    /** **inactive**

Inactive. The flag no longer needs to be displayed. */
    Inactive,
}
impl ::core::str::FromStr for FlagStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FlagStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Debug for FlagStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FlagStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FlagStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FlagStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FlagStatus> for Coding {
    fn from(code: FlagStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/flag-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FlagStatus> for CodeableConcept {
    fn from(code: FlagStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[FocusCharacteristicCode](http://hl7.org/fhir/ValueSet/focus-characteristic-code)**. Evidence focus characteristic code.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum FocusCharacteristicCode {
    /** **citation**

Citation. Used to reference a specific article. */
    Citation,
    /** **clinical-outcomes-observed**

Observed outcomes are clinical outcomes. Used to denote a focus on clinical outcomes, ie evidence variable in role of outcome (measured variable) as observed is considered a "clinical outcome" (patient-important outcome such as mortality, symptoms, function or quality of life). */
    ClinicalOutcomesObserved,
    /** **comparator**

Comparator. The comparator (intervention or control state) of interest. */
    Comparator,
    /** **exposure**

Exposure. The exposure of interest, such as an intervention. */
    Exposure,
    /** **medication-exposures**

Medication exposures. Any medication exposures. A subset of exposures or interventions that are medications. */
    MedicationExposures,
    /** **outcome**

Outcome. the outcome of interest. */
    Outcome,
    /** **population**

Population. The population of interest. */
    Population,
    /** **study-type**

Study type. Type of research study, such as randomized trial or case-control study. */
    StudyType,
}
impl ::core::str::FromStr for FocusCharacteristicCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "citation" => Ok(Self::Citation),
            "clinical-outcomes-observed" => Ok(Self::ClinicalOutcomesObserved),
            "comparator" => Ok(Self::Comparator),
            "exposure" => Ok(Self::Exposure),
            "medication-exposures" => Ok(Self::MedicationExposures),
            "outcome" => Ok(Self::Outcome),
            "population" => Ok(Self::Population),
            "study-type" => Ok(Self::StudyType),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FocusCharacteristicCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Citation => "citation",
            Self::ClinicalOutcomesObserved => "clinical-outcomes-observed",
            Self::Comparator => "comparator",
            Self::Exposure => "exposure",
            Self::MedicationExposures => "medication-exposures",
            Self::Outcome => "outcome",
            Self::Population => "population",
            Self::StudyType => "study-type",
        }
    }
}
impl ::std::fmt::Debug for FocusCharacteristicCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for FocusCharacteristicCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for FocusCharacteristicCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FocusCharacteristicCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FocusCharacteristicCode> for Coding {
    fn from(code: FocusCharacteristicCode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/focus-characteristic-code".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<FocusCharacteristicCode> for CodeableConcept {
    fn from(code: FocusCharacteristicCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GenderIdentity](http://hl7.org/fhir/gender-identity)**. This example code System defines a set of codes that can be used to indicate a patient's gender identity.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum GenderIdentity {
    /** **female**

female. the patient identifies as female */
    Female,
    /** **male**

male. the patient identifies as male */
    Male,
    /** **non-binary**

non-binary. the patient identifies with neither/both female and male */
    NonBinary,
    /** **non-disclose**

does not wish to disclose. the patient does not wish to disclose his gender identity */
    NonDisclose,
    /** **other**

other. other gender identity */
    Other,
    /** **transgender-female**

transgender female. the patient identifies as transgender male-to-female */
    TransgenderFemale,
    /** **transgender-male**

transgender male. the patient identifies as transgender female-to-male */
    TransgenderMale,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for GenderIdentity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "female" => Ok(Self::Female),
            "male" => Ok(Self::Male),
            "non-binary" => Ok(Self::NonBinary),
            "non-disclose" => Ok(Self::NonDisclose),
            "other" => Ok(Self::Other),
            "transgender-female" => Ok(Self::TransgenderFemale),
            "transgender-male" => Ok(Self::TransgenderMale),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for GenderIdentity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Female => "female",
            Self::Male => "male",
            Self::NonBinary => "non-binary",
            Self::NonDisclose => "non-disclose",
            Self::Other => "other",
            Self::TransgenderFemale => "transgender-female",
            Self::TransgenderMale => "transgender-male",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for GenderIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GenderIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GenderIdentity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenderIdentity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GenderIdentity> for Coding {
    fn from(code: GenderIdentity) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/gender-identity".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GenderIdentity> for CodeableConcept {
    fn from(code: GenderIdentity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GenderStatus](http://hl7.org/fhir/animal-genderstatus)**. This example value set defines a set of codes that can be used to indicate the current state of the animal's reproductive organs.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum GenderStatus {
    /** **intact**

Intact. The animal's reproductive organs are intact. */
    Intact,
    /** **neutered**

Neutered. The animal has been sterilized, castrated or otherwise made infertile. */
    Neutered,
    /** **unknown**

Unknown. Unable to determine whether the animal has been neutered. */
    Unknown,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for GenderStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "intact" => Ok(Self::Intact),
            "neutered" => Ok(Self::Neutered),
            "unknown" => Ok(Self::Unknown),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for GenderStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Intact => "intact",
            Self::Neutered => "neutered",
            Self::Unknown => "unknown",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for GenderStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GenderStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GenderStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenderStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GenderStatus> for Coding {
    fn from(code: GenderStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/animal-genderstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GenderStatus> for CodeableConcept {
    fn from(code: GenderStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GeneticObservationSecondaryFindings](http://hl7.org/fhir/ValueSet/secondary-finding)**. Codes to denote a guideline or policy statement.when a genetic test result is being shared as a secondary finding.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GeneticObservationSecondaryFindings {
    /** **acmg-version1**

ACMG Version 1. First release (2013): ACMG Recommendations for Reporting of Incidental Findings in Clinical Exome and Genome Sequencing.  https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3727274/ */
    AcmgVersion1,
    /** **acmg-version2**

ACMG Version 2. Second release (2016): Recommendations for reporting of secondary findings in clinical exome and genome sequencing, 2016 update (ACMG SF v2.0): a policy statement of the American College of Medical Genetics and Genomics. https://www.ncbi.nlm.nih.gov/pubmed/27854360 */
    AcmgVersion2,
}
impl ::core::str::FromStr for GeneticObservationSecondaryFindings {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acmg-version1" => Ok(Self::AcmgVersion1),
            "acmg-version2" => Ok(Self::AcmgVersion2),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GeneticObservationSecondaryFindings {
    fn as_ref(&self) -> &str {
        match self {
            Self::AcmgVersion1 => "acmg-version1",
            Self::AcmgVersion2 => "acmg-version2",
        }
    }
}
impl ::std::fmt::Debug for GeneticObservationSecondaryFindings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GeneticObservationSecondaryFindings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GeneticObservationSecondaryFindings {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GeneticObservationSecondaryFindings {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GeneticObservationSecondaryFindings> for Coding {
    fn from(code: GeneticObservationSecondaryFindings) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/secondary-finding".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GeneticObservationSecondaryFindings> for CodeableConcept {
    fn from(code: GeneticObservationSecondaryFindings) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalAchievementStatus](http://hl7.org/fhir/ValueSet/goal-achievement)**. Describes the progression, or lack thereof, towards the goal against the target.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GoalAchievementStatus {
    /** **achieved**

Achieved. The goal has been met. */
    Achieved,
    /** **improving**

Improving. The goal is being sought, and is progressing. */
    Improving,
    /** **in-progress**

In Progress. The goal is being sought but has not yet been reached. (Also applies if the goal was reached in the past but there has been regression and the goal is again being sought). */
    InProgress,
    /** **no-change**

No Change. The goal is being sought, but the trend is flat. */
    NoChange,
    /** **no-progress**

No Progress. The goal has not been met and little to no progress towards target. */
    NoProgress,
    /** **not-achieved**

Not Achieved. The goal has not been met and there might or might not have been progress towards target. */
    NotAchieved,
    /** **not-attainable**

Not Attainable. The goal is not possible to be met. */
    NotAttainable,
    /** **sustaining**

Sustaining. The goal has been met, but ongoing activity is needed to sustain the goal objective. */
    Sustaining,
    /** **worsening**

Worsening. The goal is being sought, but is regressing. */
    Worsening,
}
impl ::core::str::FromStr for GoalAchievementStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "achieved" => Ok(Self::Achieved),
            "improving" => Ok(Self::Improving),
            "in-progress" => Ok(Self::InProgress),
            "no-change" => Ok(Self::NoChange),
            "no-progress" => Ok(Self::NoProgress),
            "not-achieved" => Ok(Self::NotAchieved),
            "not-attainable" => Ok(Self::NotAttainable),
            "sustaining" => Ok(Self::Sustaining),
            "worsening" => Ok(Self::Worsening),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalAchievementStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Achieved => "achieved",
            Self::Improving => "improving",
            Self::InProgress => "in-progress",
            Self::NoChange => "no-change",
            Self::NoProgress => "no-progress",
            Self::NotAchieved => "not-achieved",
            Self::NotAttainable => "not-attainable",
            Self::Sustaining => "sustaining",
            Self::Worsening => "worsening",
        }
    }
}
impl ::std::fmt::Debug for GoalAchievementStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalAchievementStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalAchievementStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalAchievementStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalAchievementStatus> for Coding {
    fn from(code: GoalAchievementStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/goal-achievement".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalAchievementStatus> for CodeableConcept {
    fn from(code: GoalAchievementStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalCategory](http://terminology.hl7.org/CodeSystem/goal-category)**. Example codes for grouping goals to use for filtering or presentation.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum GoalCategory {
    /** **behavioral**

Behavioral. Goals related to the manner in which the subject acts. */
    Behavioral,
    /** **dietary**

Dietary. Goals related to the consumption of food and/or beverages. */
    Dietary,
    /** **nursing**

Nursing. Goals related to the practice of nursing or established by nurses. */
    Nursing,
    /** **physiotherapy**

Physiotherapy. Goals related to the mobility and/or motor capability of the subject. */
    Physiotherapy,
    /** **safety**

Safety. Goals related to the personal protection of the subject. */
    Safety,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for GoalCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "behavioral" => Ok(Self::Behavioral),
            "dietary" => Ok(Self::Dietary),
            "nursing" => Ok(Self::Nursing),
            "physiotherapy" => Ok(Self::Physiotherapy),
            "safety" => Ok(Self::Safety),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for GoalCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Behavioral => "behavioral",
            Self::Dietary => "dietary",
            Self::Nursing => "nursing",
            Self::Physiotherapy => "physiotherapy",
            Self::Safety => "safety",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for GoalCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalCategory> for Coding {
    fn from(code: GoalCategory) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/goal-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalCategory> for CodeableConcept {
    fn from(code: GoalCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalLifecycleStatus](http://hl7.org/fhir/ValueSet/goal-status)**. Codes that reflect the current state of a goal and whether the goal is still being targeted.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GoalLifecycleStatus {
    /** **accepted**

Accepted. A proposed goal was accepted or acknowledged. */
    Accepted,
    /** **active**

Active. The goal is being sought actively. */
    Active,
    /** **cancelled**

Cancelled. The goal has been abandoned. */
    Cancelled,
    /** **completed**

Completed. The goal is no longer being sought. */
    Completed,
    /** **entered-in-error**

Entered in Error. The goal was entered in error and voided. */
    EnteredInError,
    /** **on-hold**

On Hold. The goal remains a long term objective but is no longer being actively pursued for a temporary period of time. */
    OnHold,
    /** **planned**

Planned. A goal is planned for this patient. */
    Planned,
    /** **proposed**

Proposed. A goal is proposed for this patient. */
    Proposed,
    /** **rejected**

Rejected. A proposed goal was rejected. */
    Rejected,
}
impl ::core::str::FromStr for GoalLifecycleStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "on-hold" => Ok(Self::OnHold),
            "planned" => Ok(Self::Planned),
            "proposed" => Ok(Self::Proposed),
            "rejected" => Ok(Self::Rejected),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalLifecycleStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::OnHold => "on-hold",
            Self::Planned => "planned",
            Self::Proposed => "proposed",
            Self::Rejected => "rejected",
        }
    }
}
impl ::std::fmt::Debug for GoalLifecycleStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalLifecycleStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalLifecycleStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalLifecycleStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalLifecycleStatus> for Coding {
    fn from(code: GoalLifecycleStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/goal-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalLifecycleStatus> for CodeableConcept {
    fn from(code: GoalLifecycleStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GoalPriority](http://hl7.org/fhir/ValueSet/goal-priority)**. Indicates the level of importance associated with reaching or sustaining a goal.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GoalPriority {
    /** **high-priority**

High Priority. Indicates that the goal is of considerable importance and should be a primary focus of care delivery. */
    HighPriority,
    /** **low-priority**

Low Priority. The goal is desirable but is not sufficiently important to devote significant resources to.  Achievement of the goal may be sought when incidental to achieving other goals. */
    LowPriority,
    /** **medium-priority**

Medium Priority. Indicates that the goal has a reasonable degree of importance and that concrete action should be taken towards the goal.  Attainment is not as critical as high-priority goals. */
    MediumPriority,
}
impl ::core::str::FromStr for GoalPriority {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high-priority" => Ok(Self::HighPriority),
            "low-priority" => Ok(Self::LowPriority),
            "medium-priority" => Ok(Self::MediumPriority),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalPriority {
    fn as_ref(&self) -> &str {
        match self {
            Self::HighPriority => "high-priority",
            Self::LowPriority => "low-priority",
            Self::MediumPriority => "medium-priority",
        }
    }
}
impl ::std::fmt::Debug for GoalPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GoalPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GoalPriority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalPriority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalPriority> for Coding {
    fn from(code: GoalPriority) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/goal-priority".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GoalPriority> for CodeableConcept {
    fn from(code: GoalPriority) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GraphCompartmentRule](http://hl7.org/fhir/ValueSet/graph-compartment-rule)**. How a compartment must be linked.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GraphCompartmentRule {
    /** **custom**

Custom. The compartment rule is defined in the accompanying FHIRPath expression. */
    Custom,
    /** **different**

Different. The compartment must be different. */
    Different,
    /** **identical**

Identical. The compartment must be identical (the same literal reference). */
    Identical,
    /** **matching**

Matching. The compartment must be the same - the record must be about the same patient, but the reference may be different. */
    Matching,
}
impl ::core::str::FromStr for GraphCompartmentRule {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "custom" => Ok(Self::Custom),
            "different" => Ok(Self::Different),
            "identical" => Ok(Self::Identical),
            "matching" => Ok(Self::Matching),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GraphCompartmentRule {
    fn as_ref(&self) -> &str {
        match self {
            Self::Custom => "custom",
            Self::Different => "different",
            Self::Identical => "identical",
            Self::Matching => "matching",
        }
    }
}
impl ::std::fmt::Debug for GraphCompartmentRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GraphCompartmentRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GraphCompartmentRule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GraphCompartmentRule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GraphCompartmentRule> for Coding {
    fn from(code: GraphCompartmentRule) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/graph-compartment-rule".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GraphCompartmentRule> for CodeableConcept {
    fn from(code: GraphCompartmentRule) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GraphCompartmentUse](http://hl7.org/fhir/ValueSet/graph-compartment-use)**. Defines how a compartment rule is used.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GraphCompartmentUse {
    /** **condition**

Condition. This compartment rule is a condition for whether the rule applies. */
    Condition,
    /** **requirement**

Requirement. This compartment rule is enforced on any relationships that meet the conditions. */
    Requirement,
}
impl ::core::str::FromStr for GraphCompartmentUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "condition" => Ok(Self::Condition),
            "requirement" => Ok(Self::Requirement),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GraphCompartmentUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Condition => "condition",
            Self::Requirement => "requirement",
        }
    }
}
impl ::std::fmt::Debug for GraphCompartmentUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GraphCompartmentUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GraphCompartmentUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GraphCompartmentUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GraphCompartmentUse> for Coding {
    fn from(code: GraphCompartmentUse) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/graph-compartment-use".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GraphCompartmentUse> for CodeableConcept {
    fn from(code: GraphCompartmentUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GroupMeasure](http://hl7.org/fhir/ValueSet/group-measure)**. Possible group measure aggregates (E.g. Mean, Median).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GroupMeasure {
    /** **mean**

Mean. Aggregated using Mean of participant values. */
    Mean,
    /** **mean-of-mean**

Mean of Study Means. Aggregated using Mean of study mean values. */
    MeanOfMean,
    /** **mean-of-median**

Mean of Study Medins. Aggregated using Mean of study median values. */
    MeanOfMedian,
    /** **median**

Median. Aggregated using Median of participant values. */
    Median,
    /** **median-of-mean**

Median of Study Means. Aggregated using Median of study mean values. */
    MedianOfMean,
    /** **median-of-median**

Median of Study Medians. Aggregated using Median of study median values. */
    MedianOfMedian,
}
impl ::core::str::FromStr for GroupMeasure {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mean" => Ok(Self::Mean),
            "mean-of-mean" => Ok(Self::MeanOfMean),
            "mean-of-median" => Ok(Self::MeanOfMedian),
            "median" => Ok(Self::Median),
            "median-of-mean" => Ok(Self::MedianOfMean),
            "median-of-median" => Ok(Self::MedianOfMedian),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GroupMeasure {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mean => "mean",
            Self::MeanOfMean => "mean-of-mean",
            Self::MeanOfMedian => "mean-of-median",
            Self::Median => "median",
            Self::MedianOfMean => "median-of-mean",
            Self::MedianOfMedian => "median-of-median",
        }
    }
}
impl ::std::fmt::Debug for GroupMeasure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GroupMeasure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GroupMeasure {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GroupMeasure {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GroupMeasure> for Coding {
    fn from(code: GroupMeasure) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/group-measure".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GroupMeasure> for CodeableConcept {
    fn from(code: GroupMeasure) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GroupType](http://hl7.org/fhir/ValueSet/group-type)**. Types of resources that are part of group.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GroupType {
    /** **animal**

Animal. Group contains "animal" Patient resources. */
    Animal,
    /** **device**

Device. Group contains Device resources. */
    Device,
    /** **medication**

Medication. Group contains Medication resources. */
    Medication,
    /** **person**

Person. Group contains "person" Patient resources. */
    Person,
    /** **practitioner**

Practitioner. Group contains healthcare practitioner resources (Practitioner or PractitionerRole). */
    Practitioner,
    /** **substance**

Substance. Group contains Substance resources. */
    Substance,
}
impl ::core::str::FromStr for GroupType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "animal" => Ok(Self::Animal),
            "device" => Ok(Self::Device),
            "medication" => Ok(Self::Medication),
            "person" => Ok(Self::Person),
            "practitioner" => Ok(Self::Practitioner),
            "substance" => Ok(Self::Substance),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GroupType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "animal",
            Self::Device => "device",
            Self::Medication => "medication",
            Self::Person => "person",
            Self::Practitioner => "practitioner",
            Self::Substance => "substance",
        }
    }
}
impl ::std::fmt::Debug for GroupType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GroupType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GroupType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GroupType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GroupType> for Coding {
    fn from(code: GroupType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/group-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GroupType> for CodeableConcept {
    fn from(code: GroupType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GuidanceResponseStatus](http://hl7.org/fhir/ValueSet/guidance-response-status)**. The status of a guidance response.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GuidanceResponseStatus {
    /** **data-requested**

Data Requested. The request was processed successfully, but more data may result in a more complete evaluation. */
    DataRequested,
    /** **data-required**

Data Required. The request was processed, but more data is required to complete the evaluation. */
    DataRequired,
    /** **entered-in-error**

Entered In Error. The response was entered in error. */
    EnteredInError,
    /** **failure**

Failure. The request was not processed successfully. */
    Failure,
    /** **in-progress**

In Progress. The request is currently being processed. */
    InProgress,
    /** **success**

Success. The request was processed successfully. */
    Success,
}
impl ::core::str::FromStr for GuidanceResponseStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-requested" => Ok(Self::DataRequested),
            "data-required" => Ok(Self::DataRequired),
            "entered-in-error" => Ok(Self::EnteredInError),
            "failure" => Ok(Self::Failure),
            "in-progress" => Ok(Self::InProgress),
            "success" => Ok(Self::Success),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuidanceResponseStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataRequested => "data-requested",
            Self::DataRequired => "data-required",
            Self::EnteredInError => "entered-in-error",
            Self::Failure => "failure",
            Self::InProgress => "in-progress",
            Self::Success => "success",
        }
    }
}
impl ::std::fmt::Debug for GuidanceResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GuidanceResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GuidanceResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuidanceResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuidanceResponseStatus> for Coding {
    fn from(code: GuidanceResponseStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/guidance-response-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GuidanceResponseStatus> for CodeableConcept {
    fn from(code: GuidanceResponseStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GuidePageGeneration](http://hl7.org/fhir/ValueSet/guide-page-generation)**. A code that indicates how the page is generated.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GuidePageGeneration {
    /** **generated**

Generated. Page will be generated by the publication process - no source to bring across. */
    Generated,
    /** **html**

HTML. Page is proper xhtml with no templating.  Will be brought across unchanged for standard post-processing. */
    Html,
    /** **markdown**

Markdown. Page is markdown with templating.  Will use the template to create a file that imports the markdown file prior to post-processing. */
    Markdown,
    /** **xml**

XML. Page is xml with templating.  Will use the template to create a file that imports the source file and run the nominated XSLT transform (see parameters) if present prior to post-processing. */
    Xml,
}
impl ::core::str::FromStr for GuidePageGeneration {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "generated" => Ok(Self::Generated),
            "html" => Ok(Self::Html),
            "markdown" => Ok(Self::Markdown),
            "xml" => Ok(Self::Xml),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuidePageGeneration {
    fn as_ref(&self) -> &str {
        match self {
            Self::Generated => "generated",
            Self::Html => "html",
            Self::Markdown => "markdown",
            Self::Xml => "xml",
        }
    }
}
impl ::std::fmt::Debug for GuidePageGeneration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GuidePageGeneration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GuidePageGeneration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuidePageGeneration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuidePageGeneration> for Coding {
    fn from(code: GuidePageGeneration) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/guide-page-generation".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GuidePageGeneration> for CodeableConcept {
    fn from(code: GuidePageGeneration) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[GuideParameterCode](http://hl7.org/fhir/ValueSet/guide-parameter-code)**. Code of parameter that is input to the guide.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum GuideParameterCode {
    /** **apply**

Apply Metadata Value. If the value of this string 0..* parameter is one of the metadata fields then all conformance resources will have any specified [Resource].[field] overwritten with the ImplementationGuide.[field], where field is one of: version, date, status, publisher, contact, copyright, experimental, jurisdiction, useContext. */
    Apply,
    /** **expansion-parameter**

Expansion Profile. The value of this string 0..* parameter is a parameter (name=value) when expanding value sets for this implementation guide. This is particularly used to specify the versions of published terminologies such as SNOMED CT. */
    ExpansionParameter,
    /** **generate-json**

Generate JSON. The value of this boolean 0..1 parameter specifies whether the IG publisher creates examples in JSON format. If not present, the Publication Tool decides whether to generate JSON. */
    GenerateJson,
    /** **generate-turtle**

Generate Turtle. The value of this boolean 0..1 parameter specifies whether the IG publisher creates examples in Turtle format. If not present, the Publication Tool decides whether to generate Turtle. */
    GenerateTurtle,
    /** **generate-xml**

Generate XML. The value of this boolean 0..1 parameter specifies whether the IG publisher creates examples in XML format. If not present, the Publication Tool decides whether to generate XML. */
    GenerateXml,
    /** **html-template**

HTML Template. The value of this string singleton parameter is the name of the file to use as the builder template for each generated page (see templating). */
    HtmlTemplate,
    /** **path-pages**

Pages Path. The value of this string 0..1 parameter is a subfolder of the build context's location that contains files that are part of the html content processed by the builder. */
    PathPages,
    /** **path-resource**

Resource Path. The value of this string 0..* parameter is a subfolder of the build context's location that is to be scanned to load resources. Scope is (if present) a particular resource type. */
    PathResource,
    /** **path-tx-cache**

Terminology Cache Path. The value of this string 0..1 parameter is a subfolder of the build context's location that is used as the terminology cache. If this is not present, the terminology cache is on the local system, not under version control. */
    PathTxCache,
    /** **rule-broken-links**

Broken Links Rule. The value of this string 0..1 parameter is either "warning" or "error" (default = "error"). If the value is "warning" then IG build tools allow the IG to be considered successfully build even when there is no internal broken links. */
    RuleBrokenLinks,
}
impl ::core::str::FromStr for GuideParameterCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "apply" => Ok(Self::Apply),
            "expansion-parameter" => Ok(Self::ExpansionParameter),
            "generate-json" => Ok(Self::GenerateJson),
            "generate-turtle" => Ok(Self::GenerateTurtle),
            "generate-xml" => Ok(Self::GenerateXml),
            "html-template" => Ok(Self::HtmlTemplate),
            "path-pages" => Ok(Self::PathPages),
            "path-resource" => Ok(Self::PathResource),
            "path-tx-cache" => Ok(Self::PathTxCache),
            "rule-broken-links" => Ok(Self::RuleBrokenLinks),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuideParameterCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Apply => "apply",
            Self::ExpansionParameter => "expansion-parameter",
            Self::GenerateJson => "generate-json",
            Self::GenerateTurtle => "generate-turtle",
            Self::GenerateXml => "generate-xml",
            Self::HtmlTemplate => "html-template",
            Self::PathPages => "path-pages",
            Self::PathResource => "path-resource",
            Self::PathTxCache => "path-tx-cache",
            Self::RuleBrokenLinks => "rule-broken-links",
        }
    }
}
impl ::std::fmt::Debug for GuideParameterCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for GuideParameterCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for GuideParameterCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuideParameterCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuideParameterCode> for Coding {
    fn from(code: GuideParameterCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/guide-parameter-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<GuideParameterCode> for CodeableConcept {
    fn from(code: GuideParameterCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[HTTPVerb](http://hl7.org/fhir/ValueSet/http-verb)**. HTTP verbs (in the HTTP command line). See [HTTP rfc](https://tools.ietf.org/html/rfc7231) for details.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum HTTPVerb {
    /** **DELETE**

DELETE. HTTP DELETE Command. */
    Delete,
    /** **GET**

GET. HTTP GET Command. */
    Get,
    /** **HEAD**

HEAD. HTTP HEAD Command. */
    Head,
    /** **PATCH**

PATCH. HTTP PATCH Command. */
    Patch,
    /** **POST**

POST. HTTP POST Command. */
    Post,
    /** **PUT**

PUT. HTTP PUT Command. */
    Put,
}
impl ::core::str::FromStr for HTTPVerb {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "DELETE" => Ok(Self::Delete),
            "GET" => Ok(Self::Get),
            "HEAD" => Ok(Self::Head),
            "PATCH" => Ok(Self::Patch),
            "POST" => Ok(Self::Post),
            "PUT" => Ok(Self::Put),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for HTTPVerb {
    fn as_ref(&self) -> &str {
        match self {
            Self::Delete => "DELETE",
            Self::Get => "GET",
            Self::Head => "HEAD",
            Self::Patch => "PATCH",
            Self::Post => "POST",
            Self::Put => "PUT",
        }
    }
}
impl ::std::fmt::Debug for HTTPVerb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for HTTPVerb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for HTTPVerb {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for HTTPVerb {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<HTTPVerb> for Coding {
    fn from(code: HTTPVerb) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/http-verb".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<HTTPVerb> for CodeableConcept {
    fn from(code: HTTPVerb) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[HandlingConditionSet](http://hl7.org/fhir/ValueSet/handling-condition)**. Set of handling instructions prior testing of the specimen.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum HandlingConditionSet {
    /** **frozen**

frozen. frozen temperature. */
    Frozen,
    /** **refrigerated**

refrigerated. refrigerated temperature. */
    Refrigerated,
    /** **room**

room temperature. room temperature. */
    Room,
}
impl ::core::str::FromStr for HandlingConditionSet {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "frozen" => Ok(Self::Frozen),
            "refrigerated" => Ok(Self::Refrigerated),
            "room" => Ok(Self::Room),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for HandlingConditionSet {
    fn as_ref(&self) -> &str {
        match self {
            Self::Frozen => "frozen",
            Self::Refrigerated => "refrigerated",
            Self::Room => "room",
        }
    }
}
impl ::std::fmt::Debug for HandlingConditionSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for HandlingConditionSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for HandlingConditionSet {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for HandlingConditionSet {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<HandlingConditionSet> for Coding {
    fn from(code: HandlingConditionSet) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/handling-condition".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<HandlingConditionSet> for CodeableConcept {
    fn from(code: HandlingConditionSet) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[HumanNameAssemblyOrder](http://terminology.hl7.org/CodeSystem/name-assembly-order)**. A code that represents the preferred display order of the components of a human name.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum HumanNameAssemblyOrder {
    /** **NL1**

Own Name. */
    Nl1,
    /** **NL2**

Partner Name. */
    Nl2,
    /** **NL3**

Partner Name followed by Maiden Name. */
    Nl3,
    /** **NL4**

Own Name followed by Partner Name. */
    Nl4,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for HumanNameAssemblyOrder {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "NL1" => Ok(Self::Nl1),
            "NL2" => Ok(Self::Nl2),
            "NL3" => Ok(Self::Nl3),
            "NL4" => Ok(Self::Nl4),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for HumanNameAssemblyOrder {
    fn as_ref(&self) -> &str {
        match self {
            Self::Nl1 => "NL1",
            Self::Nl2 => "NL2",
            Self::Nl3 => "NL3",
            Self::Nl4 => "NL4",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for HumanNameAssemblyOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for HumanNameAssemblyOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for HumanNameAssemblyOrder {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for HumanNameAssemblyOrder {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<HumanNameAssemblyOrder> for Coding {
    fn from(code: HumanNameAssemblyOrder) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/name-assembly-order".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<HumanNameAssemblyOrder> for CodeableConcept {
    fn from(code: HumanNameAssemblyOrder) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IdentifierUse](http://hl7.org/fhir/ValueSet/identifier-use)**. Identifies the purpose for this identifier, if known .\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IdentifierUse {
    /** **official**

Official. The identifier considered to be most trusted for the identification of this item. Sometimes also known as "primary" and "main". The determination of "official" is subjective and implementation guides often provide additional guidelines for use. */
    Official,
    /** **old**

Old. The identifier id no longer considered valid, but may be relevant for search purposes.  E.g. Changes to identifier schemes, account merges, etc. */
    Old,
    /** **secondary**

Secondary. An identifier that was assigned in secondary use - it serves to identify the object in a relative context, but cannot be consistently assigned to the same object again in a different context. */
    Secondary,
    /** **temp**

Temp. A temporary identifier. */
    Temp,
    /** **usual**

Usual. The identifier recommended for display and use in real-world interactions. */
    Usual,
}
impl ::core::str::FromStr for IdentifierUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "official" => Ok(Self::Official),
            "old" => Ok(Self::Old),
            "secondary" => Ok(Self::Secondary),
            "temp" => Ok(Self::Temp),
            "usual" => Ok(Self::Usual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IdentifierUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Official => "official",
            Self::Old => "old",
            Self::Secondary => "secondary",
            Self::Temp => "temp",
            Self::Usual => "usual",
        }
    }
}
impl ::std::fmt::Debug for IdentifierUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IdentifierUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IdentifierUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IdentifierUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IdentifierUse> for Coding {
    fn from(code: IdentifierUse) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/identifier-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IdentifierUse> for CodeableConcept {
    fn from(code: IdentifierUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IdentityAssuranceLevel](http://hl7.org/fhir/ValueSet/identity-assuranceLevel)**. The level of confidence that this link represents the same actual person, based on NIST Authentication Levels.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IdentityAssuranceLevel {
    /** **level1**

Level 1. Little or no confidence in the asserted identity's accuracy. */
    Level1,
    /** **level2**

Level 2. Some confidence in the asserted identity's accuracy. */
    Level2,
    /** **level3**

Level 3. High confidence in the asserted identity's accuracy. */
    Level3,
    /** **level4**

Level 4. Very high confidence in the asserted identity's accuracy. */
    Level4,
}
impl ::core::str::FromStr for IdentityAssuranceLevel {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "level1" => Ok(Self::Level1),
            "level2" => Ok(Self::Level2),
            "level3" => Ok(Self::Level3),
            "level4" => Ok(Self::Level4),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IdentityAssuranceLevel {
    fn as_ref(&self) -> &str {
        match self {
            Self::Level1 => "level1",
            Self::Level2 => "level2",
            Self::Level3 => "level3",
            Self::Level4 => "level4",
        }
    }
}
impl ::std::fmt::Debug for IdentityAssuranceLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IdentityAssuranceLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IdentityAssuranceLevel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IdentityAssuranceLevel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IdentityAssuranceLevel> for Coding {
    fn from(code: IdentityAssuranceLevel) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/identity-assuranceLevel".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IdentityAssuranceLevel> for CodeableConcept {
    fn from(code: IdentityAssuranceLevel) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ImagingStudyStatus](http://hl7.org/fhir/ValueSet/imagingstudy-status)**. The status of the ImagingStudy.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ImagingStudyStatus {
    /** **available**

Available. At least one instance has been associated with this imaging study. */
    Available,
    /** **cancelled**

Cancelled. The imaging study is unavailable because the imaging study was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **entered-in-error**

Entered in Error. The imaging study has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **registered**

Registered. The existence of the imaging study is registered, but there is nothing yet available. */
    Registered,
    /** **unknown**

Unknown. The system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for ImagingStudyStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ImagingStudyStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for ImagingStudyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ImagingStudyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ImagingStudyStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImagingStudyStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImagingStudyStatus> for Coding {
    fn from(code: ImagingStudyStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/imagingstudy-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ImagingStudyStatus> for CodeableConcept {
    fn from(code: ImagingStudyStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ImmunizationEvaluationDoseStatusCodes](http://terminology.hl7.org/CodeSystem/immunization-evaluation-dose-status)**. This code system supports describing the validity of a dose relative to a particular recommended schedule.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ImmunizationEvaluationDoseStatusCodes {
    /** **notvalid**

Not valid. The dose does not count toward fulfilling a path to immunity for a patient. */
    Notvalid,
    /** **valid**

Valid. The dose counts toward fulfilling a path to immunity for a patient, providing protection against the target disease. */
    Valid,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEvaluationDoseStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "notvalid" => Ok(Self::Notvalid),
            "valid" => Ok(Self::Valid),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEvaluationDoseStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Notvalid => "notvalid",
            Self::Valid => "valid",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ImmunizationEvaluationDoseStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ImmunizationEvaluationDoseStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ImmunizationEvaluationDoseStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEvaluationDoseStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImmunizationEvaluationDoseStatusCodes> for Coding {
    fn from(code: ImmunizationEvaluationDoseStatusCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/immunization-evaluation-dose-status"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ImmunizationEvaluationDoseStatusCodes> for CodeableConcept {
    fn from(code: ImmunizationEvaluationDoseStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ImmunizationEvaluationDoseStatusReasonCodes](http://terminology.hl7.org/CodeSystem/immunization-evaluation-dose-status-reason)**. This code system supports describing the reason why an administered dose has been assigned a particular status. Often, this reason describes why a dose is considered invalid.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ImmunizationEvaluationDoseStatusReasonCodes {
    /** **advstorage**

Adverse storage condition. The product was stored in a manner inconsistent with manufacturer guidelines potentially reducing the effectiveness of the product. */
    Advstorage,
    /** **coldchbrk**

Cold chain break. The product was stored at a temperature inconsistent with manufacturer guidelines potentially reducing the effectiveness of the product. */
    Coldchbrk,
    /** **explot**

Expired lot. The product was administered after the expiration date associated with lot of vaccine. */
    Explot,
    /** **outsidesched**

Administered outside recommended schedule. The product was administered at a time inconsistent with the documented schedule. */
    Outsidesched,
    /** **prodrecall**

Product recall. The product administered has been recalled by the manufacturer. */
    Prodrecall,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEvaluationDoseStatusReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "advstorage" => Ok(Self::Advstorage),
            "coldchbrk" => Ok(Self::Coldchbrk),
            "explot" => Ok(Self::Explot),
            "outsidesched" => Ok(Self::Outsidesched),
            "prodrecall" => Ok(Self::Prodrecall),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEvaluationDoseStatusReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Advstorage => "advstorage",
            Self::Coldchbrk => "coldchbrk",
            Self::Explot => "explot",
            Self::Outsidesched => "outsidesched",
            Self::Prodrecall => "prodrecall",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ImmunizationEvaluationDoseStatusReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ImmunizationEvaluationDoseStatusReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ImmunizationEvaluationDoseStatusReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEvaluationDoseStatusReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImmunizationEvaluationDoseStatusReasonCodes> for Coding {
    fn from(code: ImmunizationEvaluationDoseStatusReasonCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/immunization-evaluation-dose-status-reason"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ImmunizationEvaluationDoseStatusReasonCodes> for CodeableConcept {
    fn from(code: ImmunizationEvaluationDoseStatusReasonCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ImmunizationEventFundingSource](http://terminology.hl7.org/CodeSystem/immunization-funding-source)**. This code system supports describing the source of the vaccine actually administered. This may be different than the patient eligbility (e.g. the patient may be eligibile for a publically purchased vaccine but due to inventory issues, vaccine purchased with private funds was actually administered).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ImmunizationEventFundingSource {
    /** **private**

Private. The vaccine was purchased with private funds. */
    Private,
    /** **public**

Public. The vaccine was purchased with public funds. */
    Public,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEventFundingSource {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "private" => Ok(Self::Private),
            "public" => Ok(Self::Public),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEventFundingSource {
    fn as_ref(&self) -> &str {
        match self {
            Self::Private => "private",
            Self::Public => "public",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ImmunizationEventFundingSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ImmunizationEventFundingSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ImmunizationEventFundingSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEventFundingSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImmunizationEventFundingSource> for Coding {
    fn from(code: ImmunizationEventFundingSource) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/immunization-funding-source"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ImmunizationEventFundingSource> for CodeableConcept {
    fn from(code: ImmunizationEventFundingSource) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ImmunizationEventOrigin](http://terminology.hl7.org/CodeSystem/immunization-origin)**. This code system supports describing the source of the data when the report of the immunization event is not based on information from the person, entity or organization who administered the vaccine.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ImmunizationEventOrigin {
    /** **jurisdiction**

Jurisdictional IIS. The data for the immunization event originated with an immunization information system (IIS) or registry operating within the jurisdiction. */
    Jurisdiction,
    /** **provider**

Other Provider. The data for the immunization event originated with another provider. */
    Provider,
    /** **recall**

Parent/Guardian/Patient Recall. The data for the immunization event originated from the recollection of the patient or parent/guardian of the patient. */
    Recall,
    /** **record**

Written Record. The data for the immunization event originated with a written record for the patient. */
    Record,
    /** **school**

School Record. The data for the immunization event originated with a school record for the patient. */
    School,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEventOrigin {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "jurisdiction" => Ok(Self::Jurisdiction),
            "provider" => Ok(Self::Provider),
            "recall" => Ok(Self::Recall),
            "record" => Ok(Self::Record),
            "school" => Ok(Self::School),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEventOrigin {
    fn as_ref(&self) -> &str {
        match self {
            Self::Jurisdiction => "jurisdiction",
            Self::Provider => "provider",
            Self::Recall => "recall",
            Self::Record => "record",
            Self::School => "school",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ImmunizationEventOrigin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ImmunizationEventOrigin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ImmunizationEventOrigin {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEventOrigin {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImmunizationEventOrigin> for Coding {
    fn from(code: ImmunizationEventOrigin) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/immunization-origin".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ImmunizationEventOrigin> for CodeableConcept {
    fn from(code: ImmunizationEventOrigin) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ImmunizationEventProgramEligibility](http://terminology.hl7.org/CodeSystem/immunization-program-eligibility)**. This code system supports describing the source of the patient's eligibility for a vaccination program.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ImmunizationEventProgramEligibility {
    /** **ineligible**

Not Eligible. The patient is not eligible for the funding program. */
    Ineligible,
    /** **uninsured**

Uninsured. The patient is eligible for the funding program because they are uninsured. */
    Uninsured,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEventProgramEligibility {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ineligible" => Ok(Self::Ineligible),
            "uninsured" => Ok(Self::Uninsured),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEventProgramEligibility {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ineligible => "ineligible",
            Self::Uninsured => "uninsured",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ImmunizationEventProgramEligibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ImmunizationEventProgramEligibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ImmunizationEventProgramEligibility {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEventProgramEligibility {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImmunizationEventProgramEligibility> for Coding {
    fn from(code: ImmunizationEventProgramEligibility) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/immunization-program-eligibility"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ImmunizationEventProgramEligibility> for CodeableConcept {
    fn from(code: ImmunizationEventProgramEligibility) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ImmunizationEventSubpotentReason](http://terminology.hl7.org/CodeSystem/immunization-subpotent-reason)**. This code system supports describing the reason why a dose is considered to be subpotent.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ImmunizationEventSubpotentReason {
    /** **coldchainbreak**

Cold Chain Break. The vaccine experienced a cold chain break. */
    Coldchainbreak,
    /** **partial**

Partial Dose. The full volume of the dose was not administered to the patient. */
    Partial,
    /** **recall**

Manufacturer Recall. The vaccine was recalled by the manufacturer. */
    Recall,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEventSubpotentReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "coldchainbreak" => Ok(Self::Coldchainbreak),
            "partial" => Ok(Self::Partial),
            "recall" => Ok(Self::Recall),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEventSubpotentReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::Coldchainbreak => "coldchainbreak",
            Self::Partial => "partial",
            Self::Recall => "recall",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ImmunizationEventSubpotentReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ImmunizationEventSubpotentReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ImmunizationEventSubpotentReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEventSubpotentReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImmunizationEventSubpotentReason> for Coding {
    fn from(code: ImmunizationEventSubpotentReason) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/immunization-subpotent-reason"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ImmunizationEventSubpotentReason> for CodeableConcept {
    fn from(code: ImmunizationEventSubpotentReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ImmunizationRecommendationStatusCodes](http://terminology.hl7.org/CodeSystem/immunization-recommendation-status)**. The value set to instantiate this attribute should be drawn from a terminologically robust code system that consists of or contains concepts to support describing the status of the patient relative to a recommended dose. This value set is provided as a suggestive example.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ImmunizationRecommendationStatusCodes {
    /** **complete**

Complete. The patient is fully protected and no further doses are recommended. */
    Complete,
    /** **contraindicated**

Contraindicated. The patient is contraindicated for futher doses. */
    Contraindicated,
    /** **due**

Due. The patient is due for their next vaccination. */
    Due,
    /** **immune**

Immune. The patient is immune to the target disease and further immunization against the disease is not likely to provide benefit. */
    Immune,
    /** **overdue**

Overdue. The patient is considered overdue for their next vaccination. */
    Overdue,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationRecommendationStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "contraindicated" => Ok(Self::Contraindicated),
            "due" => Ok(Self::Due),
            "immune" => Ok(Self::Immune),
            "overdue" => Ok(Self::Overdue),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationRecommendationStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Contraindicated => "contraindicated",
            Self::Due => "due",
            Self::Immune => "immune",
            Self::Overdue => "overdue",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ImmunizationRecommendationStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ImmunizationRecommendationStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ImmunizationRecommendationStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationRecommendationStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImmunizationRecommendationStatusCodes> for Coding {
    fn from(code: ImmunizationRecommendationStatusCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/immunization-recommendation-status"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ImmunizationRecommendationStatusCodes> for CodeableConcept {
    fn from(code: ImmunizationRecommendationStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[Indicator](http://hl7.org/fhir/ValueSet/cdshooks-indicator)**. This value set captures the set of indicator codes defined by the CDS Hooks specification.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum Indicator {
    /** **critical**

The response is critical and indicates the workflow should not be allowed to proceed. */
    Critical,
    /** **info**

The response is informational. */
    Info,
    /** **warning**

The response is a warning. */
    Warning,
}
impl ::core::str::FromStr for Indicator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "critical" => Ok(Self::Critical),
            "info" => Ok(Self::Info),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Indicator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Critical => "critical",
            Self::Info => "info",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Debug for Indicator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for Indicator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for Indicator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Indicator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<Indicator> for Coding {
    fn from(code: Indicator) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/cdshooks-indicator".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<Indicator> for CodeableConcept {
    fn from(code: Indicator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IngredientFunction](http://hl7.org/fhir/ValueSet/ingredient-function)**. A classification of the ingredient identifying its precise purpose(s) in the drug product (beyond e.g. active/inactive).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IngredientFunction {
    /** **AlkalizingAgent**

Alkalizing Agent. */
    AlkalizingAgent,
    /** **Antioxidant**

Antioxidant. */
    Antioxidant,
}
impl ::core::str::FromStr for IngredientFunction {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AlkalizingAgent" => Ok(Self::AlkalizingAgent),
            "Antioxidant" => Ok(Self::Antioxidant),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IngredientFunction {
    fn as_ref(&self) -> &str {
        match self {
            Self::AlkalizingAgent => "AlkalizingAgent",
            Self::Antioxidant => "Antioxidant",
        }
    }
}
impl ::std::fmt::Debug for IngredientFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IngredientFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IngredientFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IngredientFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IngredientFunction> for Coding {
    fn from(code: IngredientFunction) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/ingredient-function".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IngredientFunction> for CodeableConcept {
    fn from(code: IngredientFunction) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IngredientManufacturerRole](http://hl7.org/fhir/ValueSet/ingredient-manufacturer-role)**. The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IngredientManufacturerRole {
    /** **actual**

Manufacturer actually makes this particular ingredient. */
    Actual,
    /** **allowed**

Manufacturer is specifically allowed for this ingredient. */
    Allowed,
    /** **possible**

Manufacturer is known to make this ingredient in general. */
    Possible,
}
impl ::core::str::FromStr for IngredientManufacturerRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "actual" => Ok(Self::Actual),
            "allowed" => Ok(Self::Allowed),
            "possible" => Ok(Self::Possible),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IngredientManufacturerRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Actual => "actual",
            Self::Allowed => "allowed",
            Self::Possible => "possible",
        }
    }
}
impl ::std::fmt::Debug for IngredientManufacturerRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IngredientManufacturerRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IngredientManufacturerRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IngredientManufacturerRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IngredientManufacturerRole> for Coding {
    fn from(code: IngredientManufacturerRole) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/ingredient-manufacturer-role".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IngredientManufacturerRole> for CodeableConcept {
    fn from(code: IngredientManufacturerRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IngredientRole](http://hl7.org/fhir/ValueSet/ingredient-role)**. A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IngredientRole {
    /** **100000072072**

Active. */
    N100000072072,
    /** **100000072073**

Adjuvant. */
    N100000072073,
    /** **100000072082**

Excipient. */
    N100000072082,
    /** **100000136065**

Starting material for excipient. */
    N100000136065,
    /** **100000136066**

Solvent / Diluent. */
    N100000136066,
    /** **100000136178**

Raw materials used in the manufacture of the product. */
    N100000136178,
    /** **100000136179**

Starting material for active substance. */
    N100000136179,
    /** **100000136561**

Overage. */
    N100000136561,
    /** **200000003427**

bioenhancer. */
    N200000003427,
}
impl ::core::str::FromStr for IngredientRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000072072" => Ok(Self::N100000072072),
            "100000072073" => Ok(Self::N100000072073),
            "100000072082" => Ok(Self::N100000072082),
            "100000136065" => Ok(Self::N100000136065),
            "100000136066" => Ok(Self::N100000136066),
            "100000136178" => Ok(Self::N100000136178),
            "100000136179" => Ok(Self::N100000136179),
            "100000136561" => Ok(Self::N100000136561),
            "200000003427" => Ok(Self::N200000003427),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IngredientRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000072072 => "100000072072",
            Self::N100000072073 => "100000072073",
            Self::N100000072082 => "100000072082",
            Self::N100000136065 => "100000136065",
            Self::N100000136066 => "100000136066",
            Self::N100000136178 => "100000136178",
            Self::N100000136179 => "100000136179",
            Self::N100000136561 => "100000136561",
            Self::N200000003427 => "200000003427",
        }
    }
}
impl ::std::fmt::Debug for IngredientRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IngredientRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IngredientRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IngredientRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IngredientRole> for Coding {
    fn from(code: IngredientRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/ingredient-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IngredientRole> for CodeableConcept {
    fn from(code: IngredientRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[InteractionIncidence](http://hl7.org/fhir/ValueSet/interaction-incidence)**. A categorisation for a frequency of occurence of an undesirable effect.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum InteractionIncidence {
    /** **Observed**

Observed. */
    Observed,
    /** **Theoretical**

Theoretical. */
    Theoretical,
}
impl ::core::str::FromStr for InteractionIncidence {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Observed" => Ok(Self::Observed),
            "Theoretical" => Ok(Self::Theoretical),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InteractionIncidence {
    fn as_ref(&self) -> &str {
        match self {
            Self::Observed => "Observed",
            Self::Theoretical => "Theoretical",
        }
    }
}
impl ::std::fmt::Debug for InteractionIncidence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for InteractionIncidence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for InteractionIncidence {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InteractionIncidence {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InteractionIncidence> for Coding {
    fn from(code: InteractionIncidence) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/interaction-incidence".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<InteractionIncidence> for CodeableConcept {
    fn from(code: InteractionIncidence) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[InteractionType](http://hl7.org/fhir/ValueSet/interaction-type)**. A categorisation for an interaction between two substances.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum InteractionType {
    /** **drug-drug**

drug to drug interaction. */
    DrugDrug,
    /** **drug-food**

drug to food interaction. */
    DrugFood,
    /** **drug-test**

drug to laboratory test interaction. */
    DrugTest,
    /** **other**

other interaction. */
    Other,
}
impl ::core::str::FromStr for InteractionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "drug-drug" => Ok(Self::DrugDrug),
            "drug-food" => Ok(Self::DrugFood),
            "drug-test" => Ok(Self::DrugTest),
            "other" => Ok(Self::Other),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InteractionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DrugDrug => "drug-drug",
            Self::DrugFood => "drug-food",
            Self::DrugTest => "drug-test",
            Self::Other => "other",
        }
    }
}
impl ::std::fmt::Debug for InteractionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for InteractionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for InteractionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InteractionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InteractionType> for Coding {
    fn from(code: InteractionType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/interaction-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<InteractionType> for CodeableConcept {
    fn from(code: InteractionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[InvoicePriceComponentType](http://hl7.org/fhir/ValueSet/invoice-priceComponentType)**. Codes indicating the kind of the price component.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum InvoicePriceComponentType {
    /** **base**

base price. the amount is the base price used for calculating the total price before applying surcharges, discount or taxes. */
    Base,
    /** **deduction**

deduction. the amount is a deduction applied on the base price. */
    Deduction,
    /** **discount**

discount. the amount is a discount applied on the base price. */
    Discount,
    /** **informational**

informational. the amount is of informational character, it has not been applied in the calculation of the total price. */
    Informational,
    /** **surcharge**

surcharge. the amount is a surcharge applied on the base price. */
    Surcharge,
    /** **tax**

tax. the amount is the tax component of the total price. */
    Tax,
}
impl ::core::str::FromStr for InvoicePriceComponentType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "base" => Ok(Self::Base),
            "deduction" => Ok(Self::Deduction),
            "discount" => Ok(Self::Discount),
            "informational" => Ok(Self::Informational),
            "surcharge" => Ok(Self::Surcharge),
            "tax" => Ok(Self::Tax),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InvoicePriceComponentType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Base => "base",
            Self::Deduction => "deduction",
            Self::Discount => "discount",
            Self::Informational => "informational",
            Self::Surcharge => "surcharge",
            Self::Tax => "tax",
        }
    }
}
impl ::std::fmt::Debug for InvoicePriceComponentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for InvoicePriceComponentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for InvoicePriceComponentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InvoicePriceComponentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InvoicePriceComponentType> for Coding {
    fn from(code: InvoicePriceComponentType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/invoice-priceComponentType".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<InvoicePriceComponentType> for CodeableConcept {
    fn from(code: InvoicePriceComponentType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[InvoiceStatus](http://hl7.org/fhir/ValueSet/invoice-status)**. Codes identifying the lifecycle stage of an Invoice.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum InvoiceStatus {
    /** **balanced**

balanced. the invoice has been balaced / completely paid. */
    Balanced,
    /** **cancelled**

cancelled. the invoice was cancelled. */
    Cancelled,
    /** **draft**

draft. the invoice has been prepared but not yet finalized. */
    Draft,
    /** **entered-in-error**

entered in error. the invoice was determined as entered in error before it was issued. */
    EnteredInError,
    /** **issued**

issued. the invoice has been finalized and sent to the recipient. */
    Issued,
}
impl ::core::str::FromStr for InvoiceStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "balanced" => Ok(Self::Balanced),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "issued" => Ok(Self::Issued),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InvoiceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Balanced => "balanced",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Issued => "issued",
        }
    }
}
impl ::std::fmt::Debug for InvoiceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for InvoiceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for InvoiceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InvoiceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InvoiceStatus> for Coding {
    fn from(code: InvoiceStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/invoice-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<InvoiceStatus> for CodeableConcept {
    fn from(code: InvoiceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IssueSeverity](http://hl7.org/fhir/ValueSet/issue-severity)**. How the issue affects the success of the action.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IssueSeverity {
    /** **error**

Error. The issue is sufficiently important to cause the action to fail. */
    Error,
    /** **fatal**

Fatal. The issue caused the action to fail and no further checking could be performed. */
    Fatal,
    /** **information**

Information. The issue has no relation to the degree of success of the action. */
    Information,
    /** **warning**

Warning. The issue is not important enough to cause the action to fail but may cause it to be performed suboptimally or in a way that is not as desired. */
    Warning,
}
impl ::core::str::FromStr for IssueSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "fatal" => Ok(Self::Fatal),
            "information" => Ok(Self::Information),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IssueSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Fatal => "fatal",
            Self::Information => "information",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Debug for IssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IssueSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IssueSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IssueSeverity> for Coding {
    fn from(code: IssueSeverity) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/issue-severity".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IssueSeverity> for CodeableConcept {
    fn from(code: IssueSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[IssueType](http://hl7.org/fhir/ValueSet/issue-type)**. A code that describes the type of issue.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum IssueType {
    /** **business-rule**

Business Rule Violation. The content/operation failed to pass some business rule and so could not proceed. */
    BusinessRule,
    /** **code-invalid**

Invalid Code. The code or system could not be understood, or it was not valid in the context of a particular ValueSet.code. */
    CodeInvalid,
    /** **conflict**

Edit Version Conflict. Content could not be accepted because of an edit conflict (i.e. version aware updates). (In a pure RESTful environment, this would be an HTTP 409 error, but this code may be used where the conflict is discovered further into the application architecture.). */
    Conflict,
    /** **deleted**

Deleted. The reference pointed to content (usually a resource) that has been deleted. */
    Deleted,
    /** **duplicate**

Duplicate. An attempt was made to create a duplicate record. */
    Duplicate,
    /** **exception**

Exception. An unexpected internal error has occurred. */
    Exception,
    /** **expired**

Session Expired. User session expired; a login may be required. */
    Expired,
    /** **extension**

Unacceptable Extension. An extension was found that was not acceptable, could not be resolved, or a modifierExtension was not recognized. */
    Extension,
    /** **forbidden**

Forbidden. The user does not have the rights to perform this action. */
    Forbidden,
    /** **incomplete**

Incomplete Results. Not all data sources typically accessed could be reached or responded in time, so the returned information might not be complete (applies to search interactions and some operations). */
    Incomplete,
    /** **informational**

Informational Note. A message unrelated to the processing success of the completed operation (examples of the latter include things like reminders of password expiry, system maintenance times, etc.). */
    Informational,
    /** **invalid**

Invalid Content. Content invalid against the specification or a profile. */
    Invalid,
    /** **invariant**

Validation rule failed. A content validation rule failed - e.g. a schematron rule. */
    Invariant,
    /** **lock-error**

Lock Error. A resource/record locking failure (usually in an underlying database). */
    LockError,
    /** **login**

Login Required. The client needs to initiate an authentication process. */
    Login,
    /** **multiple-matches**

Multiple Matches. Multiple matching records were found when the operation required only one match. */
    MultipleMatches,
    /** **no-store**

No Store Available. The persistent store is unavailable; e.g. the database is down for maintenance or similar action, and the interaction or operation cannot be processed. */
    NoStore,
    /** **not-found**

Not Found. The reference provided was not found. In a pure RESTful environment, this would be an HTTP 404 error, but this code may be used where the content is not found further into the application architecture. */
    NotFound,
    /** **not-supported**

Content not supported. The interaction, operation, resource or profile is not supported. */
    NotSupported,
    /** **processing**

Processing Failure. Processing issues. These are expected to be final e.g. there is no point resubmitting the same content unchanged. */
    Processing,
    /** **required**

Required element missing. A required element is missing. */
    Required,
    /** **security**

Security Problem. An authentication/authorization/permissions issue of some kind. */
    Security,
    /** **structure**

Structural Issue. A structural issue in the content such as wrong namespace, unable to parse the content completely, invalid syntax, etc. */
    Structure,
    /** **suppressed**

Information  Suppressed. Some information was not or might not have been returned due to business rules, consent or privacy rules, or access permission constraints.  This information may be accessible through alternate processes. */
    Suppressed,
    /** **throttled**

Throttled. The system is not prepared to handle this request due to load management. */
    Throttled,
    /** **timeout**

Timeout. An internal timeout has occurred. */
    Timeout,
    /** **too-costly**

Operation Too Costly. The operation was stopped to protect server resources; e.g. a request for a value set expansion on all of SNOMED CT. */
    TooCostly,
    /** **too-long**

Content Too Long. Provided content is too long (typically, this is a denial of service protection type of error). */
    TooLong,
    /** **transient**

Transient Issue. Transient processing issues. The system receiving the message may be able to resubmit the same content once an underlying issue is resolved. */
    Transient,
    /** **unknown**

Unknown User. The user or system was not able to be authenticated (either there is no process, or the proferred token is unacceptable). */
    Unknown,
    /** **value**

Element value invalid. An element or header value is invalid. */
    Value,
}
impl ::core::str::FromStr for IssueType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "business-rule" => Ok(Self::BusinessRule),
            "code-invalid" => Ok(Self::CodeInvalid),
            "conflict" => Ok(Self::Conflict),
            "deleted" => Ok(Self::Deleted),
            "duplicate" => Ok(Self::Duplicate),
            "exception" => Ok(Self::Exception),
            "expired" => Ok(Self::Expired),
            "extension" => Ok(Self::Extension),
            "forbidden" => Ok(Self::Forbidden),
            "incomplete" => Ok(Self::Incomplete),
            "informational" => Ok(Self::Informational),
            "invalid" => Ok(Self::Invalid),
            "invariant" => Ok(Self::Invariant),
            "lock-error" => Ok(Self::LockError),
            "login" => Ok(Self::Login),
            "multiple-matches" => Ok(Self::MultipleMatches),
            "no-store" => Ok(Self::NoStore),
            "not-found" => Ok(Self::NotFound),
            "not-supported" => Ok(Self::NotSupported),
            "processing" => Ok(Self::Processing),
            "required" => Ok(Self::Required),
            "security" => Ok(Self::Security),
            "structure" => Ok(Self::Structure),
            "suppressed" => Ok(Self::Suppressed),
            "throttled" => Ok(Self::Throttled),
            "timeout" => Ok(Self::Timeout),
            "too-costly" => Ok(Self::TooCostly),
            "too-long" => Ok(Self::TooLong),
            "transient" => Ok(Self::Transient),
            "unknown" => Ok(Self::Unknown),
            "value" => Ok(Self::Value),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IssueType {
    fn as_ref(&self) -> &str {
        match self {
            Self::BusinessRule => "business-rule",
            Self::CodeInvalid => "code-invalid",
            Self::Conflict => "conflict",
            Self::Deleted => "deleted",
            Self::Duplicate => "duplicate",
            Self::Exception => "exception",
            Self::Expired => "expired",
            Self::Extension => "extension",
            Self::Forbidden => "forbidden",
            Self::Incomplete => "incomplete",
            Self::Informational => "informational",
            Self::Invalid => "invalid",
            Self::Invariant => "invariant",
            Self::LockError => "lock-error",
            Self::Login => "login",
            Self::MultipleMatches => "multiple-matches",
            Self::NoStore => "no-store",
            Self::NotFound => "not-found",
            Self::NotSupported => "not-supported",
            Self::Processing => "processing",
            Self::Required => "required",
            Self::Security => "security",
            Self::Structure => "structure",
            Self::Suppressed => "suppressed",
            Self::Throttled => "throttled",
            Self::Timeout => "timeout",
            Self::TooCostly => "too-costly",
            Self::TooLong => "too-long",
            Self::Transient => "transient",
            Self::Unknown => "unknown",
            Self::Value => "value",
        }
    }
}
impl ::std::fmt::Debug for IssueType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for IssueType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for IssueType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IssueType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IssueType> for Coding {
    fn from(code: IssueType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/issue-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<IssueType> for CodeableConcept {
    fn from(code: IssueType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[KnowledgeResourceType](http://hl7.org/fhir/ValueSet/knowledge-resource-types)**. A list of all the knowledge resource types defined in this version of the FHIR specification.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum KnowledgeResourceType {
    /** **ActivityDefinition**

ActivityDefinition. The definition of a specific activity to be taken, independent of any particular patient or context. */
    ActivityDefinition,
    /** **CodeSystem**

CodeSystem. A set of codes drawn from one or more code systems. */
    CodeSystem,
    /** **ConceptMap**

ConceptMap. A map from one set of concepts to one or more other concepts. */
    ConceptMap,
    /** **Library**

Library. Represents a library of quality improvement components. */
    Library,
    /** **Measure**

Measure. A quality measure definition. */
    Measure,
    /** **PlanDefinition**

PlanDefinition. The definition of a plan for a series of actions, independent of any specific patient or context. */
    PlanDefinition,
    /** **StructureDefinition**

StructureDefinition. Structural Definition. */
    StructureDefinition,
    /** **StructureMap**

StructureMap. A Map of relationships between 2 structures that can be used to transform data. */
    StructureMap,
    /** **ValueSet**

ValueSet. A set of codes drawn from one or more code systems. */
    ValueSet,
}
impl ::core::str::FromStr for KnowledgeResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActivityDefinition" => Ok(Self::ActivityDefinition),
            "CodeSystem" => Ok(Self::CodeSystem),
            "ConceptMap" => Ok(Self::ConceptMap),
            "Library" => Ok(Self::Library),
            "Measure" => Ok(Self::Measure),
            "PlanDefinition" => Ok(Self::PlanDefinition),
            "StructureDefinition" => Ok(Self::StructureDefinition),
            "StructureMap" => Ok(Self::StructureMap),
            "ValueSet" => Ok(Self::ValueSet),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for KnowledgeResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActivityDefinition => "ActivityDefinition",
            Self::CodeSystem => "CodeSystem",
            Self::ConceptMap => "ConceptMap",
            Self::Library => "Library",
            Self::Measure => "Measure",
            Self::PlanDefinition => "PlanDefinition",
            Self::StructureDefinition => "StructureDefinition",
            Self::StructureMap => "StructureMap",
            Self::ValueSet => "ValueSet",
        }
    }
}
impl ::std::fmt::Debug for KnowledgeResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for KnowledgeResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for KnowledgeResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for KnowledgeResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<KnowledgeResourceType> for Coding {
    fn from(code: KnowledgeResourceType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/knowledge-resource-types".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<KnowledgeResourceType> for CodeableConcept {
    fn from(code: KnowledgeResourceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LanguagePreferenceType](http://hl7.org/fhir/language-preference-type)**. This code system defines a defines the set of codes for describing the type or mode of the patient's preferred language.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum LanguagePreferenceType {
    /** **verbal**

verbal. The patient prefers to verbally communicate with the associated language. */
    Verbal,
    /** **written**

written. The patient prefers to communicate in writing with the associated language. */
    Written,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for LanguagePreferenceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "verbal" => Ok(Self::Verbal),
            "written" => Ok(Self::Written),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for LanguagePreferenceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Verbal => "verbal",
            Self::Written => "written",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for LanguagePreferenceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LanguagePreferenceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LanguagePreferenceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LanguagePreferenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LanguagePreferenceType> for Coding {
    fn from(code: LanguagePreferenceType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/language-preference-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LanguagePreferenceType> for CodeableConcept {
    fn from(code: LanguagePreferenceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LegalStatusOfSupply](http://hl7.org/fhir/ValueSet/legal-status-of-supply)**. The prescription supply types appropriate to a medicinal product\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LegalStatusOfSupply {
    /** **100000072076**

Medicinal product not subject to medical prescription. */
    N100000072076,
    /** **100000072077**

Medicinal product on medical prescription for renewable or non-renewable delivery. */
    N100000072077,
    /** **100000072078**

Medicinal product subject to restricted medical prescription. */
    N100000072078,
    /** **100000072079**

Medicinal product on medical prescription for non-renewable delivery. */
    N100000072079,
    /** **100000072084**

Medicinal product subject to medical prescription. */
    N100000072084,
    /** **100000072085**

Medicinal product subject to special medical prescription. */
    N100000072085,
    /** **100000072086**

Medicinal product on medical prescription for renewable delivery. */
    N100000072086,
    /** **100000157313**

Medicinal product subject to special and restricted medical prescription. */
    N100000157313,
}
impl ::core::str::FromStr for LegalStatusOfSupply {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000072076" => Ok(Self::N100000072076),
            "100000072077" => Ok(Self::N100000072077),
            "100000072078" => Ok(Self::N100000072078),
            "100000072079" => Ok(Self::N100000072079),
            "100000072084" => Ok(Self::N100000072084),
            "100000072085" => Ok(Self::N100000072085),
            "100000072086" => Ok(Self::N100000072086),
            "100000157313" => Ok(Self::N100000157313),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LegalStatusOfSupply {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000072076 => "100000072076",
            Self::N100000072077 => "100000072077",
            Self::N100000072078 => "100000072078",
            Self::N100000072079 => "100000072079",
            Self::N100000072084 => "100000072084",
            Self::N100000072085 => "100000072085",
            Self::N100000072086 => "100000072086",
            Self::N100000157313 => "100000157313",
        }
    }
}
impl ::std::fmt::Debug for LegalStatusOfSupply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LegalStatusOfSupply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LegalStatusOfSupply {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LegalStatusOfSupply {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LegalStatusOfSupply> for Coding {
    fn from(code: LegalStatusOfSupply) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/legal-status-of-supply".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LegalStatusOfSupply> for CodeableConcept {
    fn from(code: LegalStatusOfSupply) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LibraryType](http://hl7.org/fhir/ValueSet/library-type)**. The type of knowledge asset this library contains.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LibraryType {
    /** **asset-collection**

Asset Collection. The resource is a collection of knowledge assets. */
    AssetCollection,
    /** **logic-library**

Logic Library. The resource is a shareable library of formalized knowledge. */
    LogicLibrary,
    /** **model-definition**

Model Definition. The resource is a definition of an information model. */
    ModelDefinition,
    /** **module-definition**

Module Definition. The resource defines the dependencies, parameters, and data requirements for a particular module or evaluation context. */
    ModuleDefinition,
}
impl ::core::str::FromStr for LibraryType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "asset-collection" => Ok(Self::AssetCollection),
            "logic-library" => Ok(Self::LogicLibrary),
            "model-definition" => Ok(Self::ModelDefinition),
            "module-definition" => Ok(Self::ModuleDefinition),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LibraryType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AssetCollection => "asset-collection",
            Self::LogicLibrary => "logic-library",
            Self::ModelDefinition => "model-definition",
            Self::ModuleDefinition => "module-definition",
        }
    }
}
impl ::std::fmt::Debug for LibraryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LibraryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LibraryType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LibraryType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LibraryType> for Coding {
    fn from(code: LibraryType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/library-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LibraryType> for CodeableConcept {
    fn from(code: LibraryType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LinkType](http://hl7.org/fhir/ValueSet/link-type)**. The type of link between this patient resource and another patient resource.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LinkType {
    /** **refer**

Refer. The patient resource containing this link is in use and valid but not considered the main source of information about a patient. The link points forward to another patient resource that should be consulted to retrieve additional patient information. */
    Refer,
    /** **replaced-by**

Replaced-by. The patient resource containing this link must no longer be used. The link points forward to another patient resource that must be used in lieu of the patient resource that contains this link. */
    ReplacedBy,
    /** **replaces**

Replaces. The patient resource containing this link is the current active patient record. The link points back to an inactive patient resource that has been merged into this resource, and should be consulted to retrieve additional referenced information. */
    Replaces,
    /** **seealso**

See also. The patient resource containing this link is in use and valid, but points to another patient resource that is known to contain data about the same person. Data in this resource might overlap or contradict information found in the other patient resource. This link does not indicate any relative importance of the resources concerned, and both should be regarded as equally valid. */
    Seealso,
}
impl ::core::str::FromStr for LinkType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "refer" => Ok(Self::Refer),
            "replaced-by" => Ok(Self::ReplacedBy),
            "replaces" => Ok(Self::Replaces),
            "seealso" => Ok(Self::Seealso),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LinkType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Refer => "refer",
            Self::ReplacedBy => "replaced-by",
            Self::Replaces => "replaces",
            Self::Seealso => "seealso",
        }
    }
}
impl ::std::fmt::Debug for LinkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LinkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LinkType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LinkType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LinkType> for Coding {
    fn from(code: LinkType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/link-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LinkType> for CodeableConcept {
    fn from(code: LinkType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LinkageType](http://hl7.org/fhir/ValueSet/linkage-type)**. Used to distinguish different roles a resource can play within a set of linked resources.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LinkageType {
    /** **alternate**

Alternate Record. The resource represents an alternative view of the underlying event/condition/etc.  The resource may still be actively maintained, even though it is not considered to be the source of truth. */
    Alternate,
    /** **historical**

Historical/Obsolete Record. The resource represents an obsolete record of the underlying event/condition/etc.  It is not expected to be actively maintained. */
    Historical,
    /** **source**

Source of Truth. The resource represents the "source of truth" (from the perspective of this Linkage resource) for the underlying event/condition/etc. */
    Source,
}
impl ::core::str::FromStr for LinkageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alternate" => Ok(Self::Alternate),
            "historical" => Ok(Self::Historical),
            "source" => Ok(Self::Source),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LinkageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alternate => "alternate",
            Self::Historical => "historical",
            Self::Source => "source",
        }
    }
}
impl ::std::fmt::Debug for LinkageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LinkageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LinkageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LinkageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LinkageType> for Coding {
    fn from(code: LinkageType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/linkage-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LinkageType> for CodeableConcept {
    fn from(code: LinkageType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ListEmptyReasons](http://terminology.hl7.org/CodeSystem/list-empty-reason)**. General reasons for a list to be empty. Reasons are either related to a summary list (i.e. problem or medication list) or to a workflow related list (i.e. consultation list).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ListEmptyReasons {
    /** **closed**

Closed. This list has now closed or has ceased to be relevant or useful. */
    Closed,
    /** **nilknown**

Nil Known. Clinical judgment that there are no known items for this list after reasonable investigation. Note that this a positive statement by a clinical user, and not a default position asserted by a computer system in the lack of other information. Example uses:  * For allergies: the patient or patient's agent/guardian has asserted that he/she is not aware of any allergies (NKA - nil known allergies)  * For medications: the patient or patient's agent/guardian has asserted that the patient is known to be taking no medications  * For diagnoses, problems and procedures: the patient or patient's agent/guardian has asserted that there is no known event to record. */
    Nilknown,
    /** **notasked**

Not Asked. The investigation to find out whether there are items for this list has not occurred. */
    Notasked,
    /** **notstarted**

Not Started. The work to populate this list has not yet begun. */
    Notstarted,
    /** **unavailable**

Unavailable. Information to populate this list cannot be obtained; e.g. unconscious patient. */
    Unavailable,
    /** **withheld**

Information Withheld. The content of the list was not provided due to privacy or confidentiality concerns. Note that it should not be assumed that this means that the particular information in question was withheld due to its contents - it can also be a policy decision. */
    Withheld,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ListEmptyReasons {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "closed" => Ok(Self::Closed),
            "nilknown" => Ok(Self::Nilknown),
            "notasked" => Ok(Self::Notasked),
            "notstarted" => Ok(Self::Notstarted),
            "unavailable" => Ok(Self::Unavailable),
            "withheld" => Ok(Self::Withheld),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ListEmptyReasons {
    fn as_ref(&self) -> &str {
        match self {
            Self::Closed => "closed",
            Self::Nilknown => "nilknown",
            Self::Notasked => "notasked",
            Self::Notstarted => "notstarted",
            Self::Unavailable => "unavailable",
            Self::Withheld => "withheld",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ListEmptyReasons {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ListEmptyReasons {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ListEmptyReasons {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListEmptyReasons {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ListEmptyReasons> for Coding {
    fn from(code: ListEmptyReasons) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/list-empty-reason".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ListEmptyReasons> for CodeableConcept {
    fn from(code: ListEmptyReasons) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ListMode](http://hl7.org/fhir/ValueSet/list-mode)**. The processing mode that applies to this list.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ListMode {
    /** **changes**

Change List. A point-in-time list that shows what changes have been made or recommended.  E.g. a discharge medication list showing what was added and removed during an encounter. */
    Changes,
    /** **snapshot**

Snapshot List. This list was prepared as a snapshot. It should not be assumed to be current. */
    Snapshot,
    /** **working**

Working List. This list is the master list, maintained in an ongoing fashion with regular updates as the real world list it is tracking changes. */
    Working,
}
impl ::core::str::FromStr for ListMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "changes" => Ok(Self::Changes),
            "snapshot" => Ok(Self::Snapshot),
            "working" => Ok(Self::Working),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Changes => "changes",
            Self::Snapshot => "snapshot",
            Self::Working => "working",
        }
    }
}
impl ::std::fmt::Debug for ListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ListMode> for Coding {
    fn from(code: ListMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/list-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ListMode> for CodeableConcept {
    fn from(code: ListMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ListOrderCodes](http://terminology.hl7.org/CodeSystem/list-order)**. Base values for the order of the items in a list resource.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ListOrderCodes {
    /** **alphabetic**

Sorted Alphabetically. The list is sorted alphabetically by an unspecified property of the items in the list. */
    Alphabetic,
    /** **category**

Sorted by Category. The list is sorted categorically by an unspecified property of the items in the list. */
    Category,
    /** **entry-date**

Sorted by Item Date. The list is sorted by the date the item was added to the list. Note that the date added to the list is not explicit in the list itself. */
    EntryDate,
    /** **event-date**

Sorted by Event Date. The list is sorted by the data of the event. This can be used when the list has items which are dates with past or future events. */
    EventDate,
    /** **patient**

Sorted by Patient. The list is sorted by patient, with items for each patient grouped together. */
    Patient,
    /** **priority**

Sorted by Priority. The list is sorted by priority. The exact method in which priority has been determined is not specified. */
    Priority,
    /** **system**

Sorted by System. The list was sorted by the system. The criteria the user used are not specified; define additional codes to specify a particular order (or use other defined codes). */
    System,
    /** **user**

Sorted by User. The list was sorted by a user. The criteria the user used are not specified. */
    User,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ListOrderCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alphabetic" => Ok(Self::Alphabetic),
            "category" => Ok(Self::Category),
            "entry-date" => Ok(Self::EntryDate),
            "event-date" => Ok(Self::EventDate),
            "patient" => Ok(Self::Patient),
            "priority" => Ok(Self::Priority),
            "system" => Ok(Self::System),
            "user" => Ok(Self::User),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ListOrderCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alphabetic => "alphabetic",
            Self::Category => "category",
            Self::EntryDate => "entry-date",
            Self::EventDate => "event-date",
            Self::Patient => "patient",
            Self::Priority => "priority",
            Self::System => "system",
            Self::User => "user",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ListOrderCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ListOrderCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ListOrderCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListOrderCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ListOrderCodes> for Coding {
    fn from(code: ListOrderCodes) -> Self {
        CodingInner {
            system: Some("http://terminology.hl7.org/CodeSystem/list-order".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ListOrderCodes> for CodeableConcept {
    fn from(code: ListOrderCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ListStatus](http://hl7.org/fhir/ValueSet/list-status)**. The current state of the list.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ListStatus {
    /** **current**

Current. The list is considered to be an active part of the patient's record. */
    Current,
    /** **entered-in-error**

Entered In Error. The list was never accurate.  It is retained for medico-legal purposes only. */
    EnteredInError,
    /** **retired**

Retired. The list is "old" and should no longer be considered accurate or relevant. */
    Retired,
}
impl ::core::str::FromStr for ListStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "current" => Ok(Self::Current),
            "entered-in-error" => Ok(Self::EnteredInError),
            "retired" => Ok(Self::Retired),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ListStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Current => "current",
            Self::EnteredInError => "entered-in-error",
            Self::Retired => "retired",
        }
    }
}
impl ::std::fmt::Debug for ListStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ListStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ListStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ListStatus> for Coding {
    fn from(code: ListStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/list-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ListStatus> for CodeableConcept {
    fn from(code: ListStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LocationMode](http://hl7.org/fhir/ValueSet/location-mode)**. Indicates whether a resource instance represents a specific location or a class of locations.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LocationMode {
    /** **instance**

Instance. The Location resource represents a specific instance of a location (e.g. Operating Theatre 1A). */
    Instance,
    /** **kind**

Kind. The Location represents a class of locations (e.g. Any Operating Theatre) although this class of locations could be constrained within a specific boundary (such as organization, or parent location, address etc.). */
    Kind,
}
impl ::core::str::FromStr for LocationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "instance" => Ok(Self::Instance),
            "kind" => Ok(Self::Kind),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Instance => "instance",
            Self::Kind => "kind",
        }
    }
}
impl ::std::fmt::Debug for LocationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LocationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LocationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LocationMode> for Coding {
    fn from(code: LocationMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/location-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LocationMode> for CodeableConcept {
    fn from(code: LocationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LocationStatus](http://hl7.org/fhir/ValueSet/location-status)**. Indicates whether the location is still in use.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum LocationStatus {
    /** **active**

Active. The location is operational. */
    Active,
    /** **inactive**

Inactive. The location is no longer used. */
    Inactive,
    /** **suspended**

Suspended. The location is temporarily closed. */
    Suspended,
}
impl ::core::str::FromStr for LocationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Suspended => "suspended",
        }
    }
}
impl ::std::fmt::Debug for LocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LocationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LocationStatus> for Coding {
    fn from(code: LocationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/location-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LocationStatus> for CodeableConcept {
    fn from(code: LocationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[LocationType](http://terminology.hl7.org/CodeSystem/location-physical-type)**. This example value set defines a set of codes that can be used to indicate the physical form of the Location.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum LocationType {
    /** **area**

Area. A defined physical boundary of something, such as a flood risk zone, region, postcode */
    Area,
    /** **bd**

Bed. A space that is allocated for sleeping/laying on. This is not the physical bed/trolley that may be moved about, but the space it may occupy. */
    Bd,
    /** **bu**

Building. Any Building or structure. This may contain rooms, corridors, wings, etc. It might not have walls, or a roof, but is considered a defined/allocated space. */
    Bu,
    /** **ca**

Cabinet. A container that can store goods, equipment, medications or other items. */
    Ca,
    /** **co**

Corridor. Any corridor within a Building, that may connect rooms. */
    Co,
    /** **ho**

House. A residential dwelling. Usually used to reference a location that a person/patient may reside. */
    Ho,
    /** **jdn**

Jurisdiction. A wide scope that covers a conceptual domain, such as a Nation (Country wide community or Federal Government - e.g. Ministry of Health),  Province or State (community or Government), Business (throughout the enterprise), Nation with a business scope of an agency (e.g. CDC, FDA etc.) or a Business segment (UK Pharmacy), not just an physical boundary */
    Jdn,
    /** **lvl**

Level. A Level in a multi-level Building/Structure. */
    Lvl,
    /** **rd**

Road. A defined path to travel between 2 points that has a known name. */
    Rd,
    /** **ro**

Room. A space that is allocated as a room, it may have walls/roof etc., but does not require these. */
    Ro,
    /** **si**

Site. A collection of buildings or other locations such as a site or a campus. */
    Si,
    /** **ve**

Vehicle. A means of transportation. */
    Ve,
    /** **wa**

Ward. A Ward is a section of a medical facility that may contain rooms and other types of location. */
    Wa,
    /** **wi**

Wing. A Wing within a Building, this often contains levels, rooms and corridors. */
    Wi,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for LocationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "area" => Ok(Self::Area),
            "bd" => Ok(Self::Bd),
            "bu" => Ok(Self::Bu),
            "ca" => Ok(Self::Ca),
            "co" => Ok(Self::Co),
            "ho" => Ok(Self::Ho),
            "jdn" => Ok(Self::Jdn),
            "lvl" => Ok(Self::Lvl),
            "rd" => Ok(Self::Rd),
            "ro" => Ok(Self::Ro),
            "si" => Ok(Self::Si),
            "ve" => Ok(Self::Ve),
            "wa" => Ok(Self::Wa),
            "wi" => Ok(Self::Wi),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for LocationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Area => "area",
            Self::Bd => "bd",
            Self::Bu => "bu",
            Self::Ca => "ca",
            Self::Co => "co",
            Self::Ho => "ho",
            Self::Jdn => "jdn",
            Self::Lvl => "lvl",
            Self::Rd => "rd",
            Self::Ro => "ro",
            Self::Si => "si",
            Self::Ve => "ve",
            Self::Wa => "wa",
            Self::Wi => "wi",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for LocationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for LocationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for LocationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LocationType> for Coding {
    fn from(code: LocationType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/location-physical-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<LocationType> for CodeableConcept {
    fn from(code: LocationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ManufacturedDoseForm](http://hl7.org/fhir/ValueSet/manufactured-dose-form)**. Dose form for a medication, as manufactured (and before any mixing etc.), not necessarily ready for administration to the patient.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ManufacturedDoseForm {
    /** **100000073362**

Oral suspension. */
    N100000073362,
    /** **100000073363**

Oral gel. */
    N100000073363,
    /** **100000073364**

Powder for oral solution. */
    N100000073364,
    /** **100000073365**

Granules for oral solution. */
    N100000073365,
    /** **100000073367**

Lyophilisate for suspension. */
    N100000073367,
    /** **100000073368**

Powder for syrup. */
    N100000073368,
    /** **100000073369**

Soluble tablet. */
    N100000073369,
    /** **100000073370**

Herbal tea. */
    N100000073370,
    /** **100000073371**

Instant herbal tea. */
    N100000073371,
    /** **100000073372**

Granules. */
    N100000073372,
    /** **100000073373**

Gastro-resistant granules. */
    N100000073373,
    /** **100000073374**

Modified-release granules. */
    N100000073374,
    /** **100000073375**

Capsule, hard. */
    N100000073375,
    /** **100000073376**

Gastro-resistant capsule, hard. */
    N100000073376,
    /** **100000073377**

Chewable capsule, soft. */
    N100000073377,
    /** **100000073378**

Prolonged-release capsule, soft. */
    N100000073378,
    /** **100000073379**

Modified-release capsule, soft. */
    N100000073379,
    /** **100000073380**

Coated tablet. */
    N100000073380,
    /** **100000073642**

Oral drops, solution. */
    N100000073642,
    /** **100000073643**

Oral drops, suspension. */
    N100000073643,
    /** **100000073644**

Oral drops, emulsion. */
    N100000073644,
    /** **100000073645**

Oral liquid. */
    N100000073645,
    /** **100000073646**

Oral solution. */
    N100000073646,
    /** **100000073647**

Oral emulsion. */
    N100000073647,
    /** **100000073648**

Oral paste. */
    N100000073648,
    /** **100000073649**

Powder for oral suspension. */
    N100000073649,
    /** **100000073650**

Granules for oral suspension. */
    N100000073650,
    /** **100000073652**

Syrup. */
    N100000073652,
    /** **100000073653**

Granules for syrup. */
    N100000073653,
    /** **100000073654**

Dispersible tablet. */
    N100000073654,
    /** **100000073655**

Oral powder. */
    N100000073655,
    /** **100000073656**

Effervescent powder. */
    N100000073656,
    /** **100000073657**

Effervescent granules. */
    N100000073657,
    /** **100000073658**

Prolonged-release granules. */
    N100000073658,
    /** **100000073659**

Cachet. */
    N100000073659,
    /** **100000073660**

Capsule, soft. */
    N100000073660,
    /** **100000073661**

Gastro-resistant capsule, soft. */
    N100000073661,
    /** **100000073662**

Prolonged-release capsule, hard. */
    N100000073662,
    /** **100000073663**

Modified-release capsule, hard. */
    N100000073663,
    /** **100000073664**

Tablet. */
    N100000073664,
    /** **100000073665**

Film-coated tablet. */
    N100000073665,
    /** **100000073666**

Orodispersible tablet. */
    N100000073666,
    /** **100000073667**

Gastro-resistant tablet. */
    N100000073667,
    /** **100000073668**

Modified-release tablet. */
    N100000073668,
    /** **100000073669**

Medicated chewing-gum. */
    N100000073669,
    /** **100000073670**

Pillules. */
    N100000073670,
    /** **100000073671**

Pulsatile-release intraruminal device. */
    N100000073671,
    /** **100000073672**

Premix for medicated feeding stuff. */
    N100000073672,
    /** **100000073673**

Gargle. */
    N100000073673,
    /** **100000073674**

Gargle, powder for solution. */
    N100000073674,
    /** **100000073675**

Oromucosal suspension. */
    N100000073675,
    /** **100000073676**

Oromucosal spray. */
    N100000073676,
    /** **100000073677**

Mouthwash. */
    N100000073677,
    /** **100000073678**

Gingival solution. */
    N100000073678,
    /** **100000073679**

Oromucosal paste. */
    N100000073679,
    /** **100000073680**

Gingival gel. */
    N100000073680,
    /** **100000073681**

Effervescent tablet. */
    N100000073681,
    /** **100000073682**

Oral lyophilisate. */
    N100000073682,
    /** **100000073683**

Prolonged-release tablet. */
    N100000073683,
    /** **100000073684**

Chewable tablet. */
    N100000073684,
    /** **100000073685**

Oral gum. */
    N100000073685,
    /** **100000073686**

Continuous-release intraruminal device. */
    N100000073686,
    /** **100000073687**

Lick block. */
    N100000073687,
    /** **100000073688**

Medicated pellets. */
    N100000073688,
    /** **100000073689**

Concentrate for gargle. */
    N100000073689,
    /** **100000073690**

Gargle, tablet for solution. */
    N100000073690,
    /** **100000073691**

Oromucosal solution. */
    N100000073691,
    /** **100000073692**

Oromucosal drops. */
    N100000073692,
    /** **100000073693**

Sublingual spray. */
    N100000073693,
    /** **100000073694**

Mouthwash, tablet for solution. */
    N100000073694,
    /** **100000073695**

Oromucosal gel. */
    N100000073695,
    /** **100000073696**

Oromucosal cream. */
    N100000073696,
    /** **100000073697**

Gingival paste. */
    N100000073697,
    /** **100000073698**

Sublingual tablet. */
    N100000073698,
    /** **100000073699**

Buccal tablet. */
    N100000073699,
    /** **100000073700**

Compressed lozenge. */
    N100000073700,
    /** **100000073701**

Oromucosal capsule. */
    N100000073701,
    /** **100000073702**

Muco-adhesive buccal tablet. */
    N100000073702,
    /** **100000073703**

Lozenge. */
    N100000073703,
    /** **100000073704**

Pastille. */
    N100000073704,
    /** **100000073705**

Dental gel. */
    N100000073705,
    /** **100000073706**

Dental insert. */
    N100000073706,
    /** **100000073707**

Dental powder. */
    N100000073707,
    /** **100000073708**

Dental suspension. */
    N100000073708,
    /** **100000073709**

Toothpaste. */
    N100000073709,
    /** **100000073710**

Periodontal gel. */
    N100000073710,
    /** **100000073711**

Bath additive. */
    N100000073711,
    /** **100000073712**

Cream. */
    N100000073712,
    /** **100000073713**

Ointment. */
    N100000073713,
    /** **100000073714**

Medicated plaster. */
    N100000073714,
    /** **100000073715**

Shampoo. */
    N100000073715,
    /** **100000073716**

Cutaneous spray, suspension. */
    N100000073716,
    /** **100000073717**

Cutaneous liquid. */
    N100000073717,
    /** **100000073718**

Concentrate for cutaneous solution. */
    N100000073718,
    /** **100000073719**

Cutaneous emulsion. */
    N100000073719,
    /** **100000073720**

Cutaneous patch. */
    N100000073720,
    /** **100000073721**

Periodontal powder. */
    N100000073721,
    /** **100000073722**

Dental stick. */
    N100000073722,
    /** **100000073723**

Dental solution. */
    N100000073723,
    /** **100000073724**

Dental emulsion. */
    N100000073724,
    /** **100000073725**

Periodontal insert. */
    N100000073725,
    /** **100000073726**

Gel. */
    N100000073726,
    /** **100000073727**

Cutaneous paste. */
    N100000073727,
    /** **100000073728**

Cutaneous foam. */
    N100000073728,
    /** **100000073729**

Cutaneous spray, solution. */
    N100000073729,
    /** **100000073730**

Cutaneous spray, powder. */
    N100000073730,
    /** **100000073731**

Cutaneous solution. */
    N100000073731,
    /** **100000073732**

Cutaneous suspension. */
    N100000073732,
    /** **100000073733**

Cutaneous powder. */
    N100000073733,
    /** **100000073734**

Solution for iontophoresis. */
    N100000073734,
    /** **100000073735**

Collodion. */
    N100000073735,
    /** **100000073736**

Poultice. */
    N100000073736,
    /** **100000073737**

Cutaneous sponge. */
    N100000073737,
    /** **100000073738**

Collar. */
    N100000073738,
    /** **100000073739**

Ear tag. */
    N100000073739,
    /** **100000073740**

Dip suspension. */
    N100000073740,
    /** **100000073741**

Transdermal patch. */
    N100000073741,
    /** **100000073742**

Medicated nail lacquer. */
    N100000073742,
    /** **100000073743**

Cutaneous stick. */
    N100000073743,
    /** **100000073744**

Impregnated dressing. */
    N100000073744,
    /** **100000073745**

Medicated pendant. */
    N100000073745,
    /** **100000073746**

Dip solution. */
    N100000073746,
    /** **100000073747**

Dip emulsion. */
    N100000073747,
    /** **100000073748**

Concentrate for dip suspension. */
    N100000073748,
    /** **100000073749**

Powder for dip solution. */
    N100000073749,
    /** **100000073750**

Powder for suspension for fish treatment. */
    N100000073750,
    /** **100000073751**

Pour-on suspension. */
    N100000073751,
    /** **100000073752**

Spot-on solution. */
    N100000073752,
    /** **100000073753**

Spot-on emulsion. */
    N100000073753,
    /** **100000073754**

Teat dip suspension. */
    N100000073754,
    /** **100000073755**

Teat spray solution. */
    N100000073755,
    /** **100000073756**

Solution for skin-prick test. */
    N100000073756,
    /** **100000073757**

Plaster for provocation test. */
    N100000073757,
    /** **100000073758**

Eye gel. */
    N100000073758,
    /** **100000073759**

Eye drops, solution. */
    N100000073759,
    /** **100000073760**

Eye drops, suspension. */
    N100000073760,
    /** **100000073761**

Concentrate for dip solution. */
    N100000073761,
    /** **100000073762**

Concentrate for dip emulsion. */
    N100000073762,
    /** **100000073763**

Concentrate for solution for fish treatment. */
    N100000073763,
    /** **100000073764**

Pour-on solution. */
    N100000073764,
    /** **100000073765**

Pour-on emulsion. */
    N100000073765,
    /** **100000073766**

Spot-on suspension. */
    N100000073766,
    /** **100000073767**

Teat dip solution. */
    N100000073767,
    /** **100000073768**

Teat dip emulsion. */
    N100000073768,
    /** **100000073769**

Transdermal system. */
    N100000073769,
    /** **100000073770**

Solution for skin-scratch test. */
    N100000073770,
    /** **100000073771**

Eye cream. */
    N100000073771,
    /** **100000073772**

Eye ointment. */
    N100000073772,
    /** **100000073773**

Eye drops, emulsion. */
    N100000073773,
    /** **100000073775**

Eye drops, solvent for reconstitution. */
    N100000073775,
    /** **100000073776**

Eye lotion. */
    N100000073776,
    /** **100000073777**

Ophthalmic insert. */
    N100000073777,
    /** **100000073778**

Ear cream. */
    N100000073778,
    /** **100000073779**

Ear ointment. */
    N100000073779,
    /** **100000073780**

Ear drops, suspension. */
    N100000073780,
    /** **100000073782**

Eye drops, prolonged-release. */
    N100000073782,
    /** **100000073783**

Eye lotion, solvent for reconstitution. */
    N100000073783,
    /** **100000073784**

Ophthalmic strip. */
    N100000073784,
    /** **100000073785**

Ear gel. */
    N100000073785,
    /** **100000073786**

Ear drops, solution. */
    N100000073786,
    /** **100000073787**

Ear drops, emulsion. */
    N100000073787,
    /** **100000073788**

Ear powder. */
    N100000073788,
    /** **100000073789**

Ear spray, suspension. */
    N100000073789,
    /** **100000073790**

Ear wash, solution. */
    N100000073790,
    /** **100000073791**

Ear tampon. */
    N100000073791,
    /** **100000073792**

Nasal cream. */
    N100000073792,
    /** **100000073793**

Nasal gel. */
    N100000073793,
    /** **100000073794**

Nasal drops, solution. */
    N100000073794,
    /** **100000073795**

Nasal drops, emulsion. */
    N100000073795,
    /** **100000073796**

Nasal spray, solution. */
    N100000073796,
    /** **100000073797**

Nasal spray, emulsion. */
    N100000073797,
    /** **100000073798**

Nasal stick. */
    N100000073798,
    /** **100000073799**

Vaginal gel. */
    N100000073799,
    /** **100000073800**

Vaginal foam. */
    N100000073800,
    /** **100000073802**

Ear spray, solution. */
    N100000073802,
    /** **100000073803**

Ear spray, emulsion. */
    N100000073803,
    /** **100000073804**

Ear wash, emulsion. */
    N100000073804,
    /** **100000073805**

Ear stick. */
    N100000073805,
    /** **100000073806**

Nasal ointment. */
    N100000073806,
    /** **100000073807**

Nasal drops, suspension. */
    N100000073807,
    /** **100000073808**

Nasal powder. */
    N100000073808,
    /** **100000073809**

Nasal spray, suspension. */
    N100000073809,
    /** **100000073810**

Nasal wash. */
    N100000073810,
    /** **100000073811**

Vaginal cream. */
    N100000073811,
    /** **100000073812**

Vaginal ointment. */
    N100000073812,
    /** **100000073813**

Vaginal solution. */
    N100000073813,
    /** **100000073814**

Vaginal emulsion. */
    N100000073814,
    /** **100000073815**

Pessary. */
    N100000073815,
    /** **100000073816**

Vaginal capsule, soft. */
    N100000073816,
    /** **100000073817**

Effervescent vaginal tablet. */
    N100000073817,
    /** **100000073818**

Vaginal delivery system. */
    N100000073818,
    /** **100000073819**

Rectal cream. */
    N100000073819,
    /** **100000073820**

Rectal foam. */
    N100000073820,
    /** **100000073821**

Vaginal suspension. */
    N100000073821,
    /** **100000073822**

Tablet for vaginal solution. */
    N100000073822,
    /** **100000073823**

Vaginal capsule, hard. */
    N100000073823,
    /** **100000073824**

Vaginal tablet. */
    N100000073824,
    /** **100000073825**

Medicated vaginal tampon. */
    N100000073825,
    /** **100000073826**

Vaginal sponge. */
    N100000073826,
    /** **100000073827**

Rectal gel. */
    N100000073827,
    /** **100000073863**

Solution for injection. */
    N100000073863,
}
impl ::core::str::FromStr for ManufacturedDoseForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073362" => Ok(Self::N100000073362),
            "100000073363" => Ok(Self::N100000073363),
            "100000073364" => Ok(Self::N100000073364),
            "100000073365" => Ok(Self::N100000073365),
            "100000073367" => Ok(Self::N100000073367),
            "100000073368" => Ok(Self::N100000073368),
            "100000073369" => Ok(Self::N100000073369),
            "100000073370" => Ok(Self::N100000073370),
            "100000073371" => Ok(Self::N100000073371),
            "100000073372" => Ok(Self::N100000073372),
            "100000073373" => Ok(Self::N100000073373),
            "100000073374" => Ok(Self::N100000073374),
            "100000073375" => Ok(Self::N100000073375),
            "100000073376" => Ok(Self::N100000073376),
            "100000073377" => Ok(Self::N100000073377),
            "100000073378" => Ok(Self::N100000073378),
            "100000073379" => Ok(Self::N100000073379),
            "100000073380" => Ok(Self::N100000073380),
            "100000073642" => Ok(Self::N100000073642),
            "100000073643" => Ok(Self::N100000073643),
            "100000073644" => Ok(Self::N100000073644),
            "100000073645" => Ok(Self::N100000073645),
            "100000073646" => Ok(Self::N100000073646),
            "100000073647" => Ok(Self::N100000073647),
            "100000073648" => Ok(Self::N100000073648),
            "100000073649" => Ok(Self::N100000073649),
            "100000073650" => Ok(Self::N100000073650),
            "100000073652" => Ok(Self::N100000073652),
            "100000073653" => Ok(Self::N100000073653),
            "100000073654" => Ok(Self::N100000073654),
            "100000073655" => Ok(Self::N100000073655),
            "100000073656" => Ok(Self::N100000073656),
            "100000073657" => Ok(Self::N100000073657),
            "100000073658" => Ok(Self::N100000073658),
            "100000073659" => Ok(Self::N100000073659),
            "100000073660" => Ok(Self::N100000073660),
            "100000073661" => Ok(Self::N100000073661),
            "100000073662" => Ok(Self::N100000073662),
            "100000073663" => Ok(Self::N100000073663),
            "100000073664" => Ok(Self::N100000073664),
            "100000073665" => Ok(Self::N100000073665),
            "100000073666" => Ok(Self::N100000073666),
            "100000073667" => Ok(Self::N100000073667),
            "100000073668" => Ok(Self::N100000073668),
            "100000073669" => Ok(Self::N100000073669),
            "100000073670" => Ok(Self::N100000073670),
            "100000073671" => Ok(Self::N100000073671),
            "100000073672" => Ok(Self::N100000073672),
            "100000073673" => Ok(Self::N100000073673),
            "100000073674" => Ok(Self::N100000073674),
            "100000073675" => Ok(Self::N100000073675),
            "100000073676" => Ok(Self::N100000073676),
            "100000073677" => Ok(Self::N100000073677),
            "100000073678" => Ok(Self::N100000073678),
            "100000073679" => Ok(Self::N100000073679),
            "100000073680" => Ok(Self::N100000073680),
            "100000073681" => Ok(Self::N100000073681),
            "100000073682" => Ok(Self::N100000073682),
            "100000073683" => Ok(Self::N100000073683),
            "100000073684" => Ok(Self::N100000073684),
            "100000073685" => Ok(Self::N100000073685),
            "100000073686" => Ok(Self::N100000073686),
            "100000073687" => Ok(Self::N100000073687),
            "100000073688" => Ok(Self::N100000073688),
            "100000073689" => Ok(Self::N100000073689),
            "100000073690" => Ok(Self::N100000073690),
            "100000073691" => Ok(Self::N100000073691),
            "100000073692" => Ok(Self::N100000073692),
            "100000073693" => Ok(Self::N100000073693),
            "100000073694" => Ok(Self::N100000073694),
            "100000073695" => Ok(Self::N100000073695),
            "100000073696" => Ok(Self::N100000073696),
            "100000073697" => Ok(Self::N100000073697),
            "100000073698" => Ok(Self::N100000073698),
            "100000073699" => Ok(Self::N100000073699),
            "100000073700" => Ok(Self::N100000073700),
            "100000073701" => Ok(Self::N100000073701),
            "100000073702" => Ok(Self::N100000073702),
            "100000073703" => Ok(Self::N100000073703),
            "100000073704" => Ok(Self::N100000073704),
            "100000073705" => Ok(Self::N100000073705),
            "100000073706" => Ok(Self::N100000073706),
            "100000073707" => Ok(Self::N100000073707),
            "100000073708" => Ok(Self::N100000073708),
            "100000073709" => Ok(Self::N100000073709),
            "100000073710" => Ok(Self::N100000073710),
            "100000073711" => Ok(Self::N100000073711),
            "100000073712" => Ok(Self::N100000073712),
            "100000073713" => Ok(Self::N100000073713),
            "100000073714" => Ok(Self::N100000073714),
            "100000073715" => Ok(Self::N100000073715),
            "100000073716" => Ok(Self::N100000073716),
            "100000073717" => Ok(Self::N100000073717),
            "100000073718" => Ok(Self::N100000073718),
            "100000073719" => Ok(Self::N100000073719),
            "100000073720" => Ok(Self::N100000073720),
            "100000073721" => Ok(Self::N100000073721),
            "100000073722" => Ok(Self::N100000073722),
            "100000073723" => Ok(Self::N100000073723),
            "100000073724" => Ok(Self::N100000073724),
            "100000073725" => Ok(Self::N100000073725),
            "100000073726" => Ok(Self::N100000073726),
            "100000073727" => Ok(Self::N100000073727),
            "100000073728" => Ok(Self::N100000073728),
            "100000073729" => Ok(Self::N100000073729),
            "100000073730" => Ok(Self::N100000073730),
            "100000073731" => Ok(Self::N100000073731),
            "100000073732" => Ok(Self::N100000073732),
            "100000073733" => Ok(Self::N100000073733),
            "100000073734" => Ok(Self::N100000073734),
            "100000073735" => Ok(Self::N100000073735),
            "100000073736" => Ok(Self::N100000073736),
            "100000073737" => Ok(Self::N100000073737),
            "100000073738" => Ok(Self::N100000073738),
            "100000073739" => Ok(Self::N100000073739),
            "100000073740" => Ok(Self::N100000073740),
            "100000073741" => Ok(Self::N100000073741),
            "100000073742" => Ok(Self::N100000073742),
            "100000073743" => Ok(Self::N100000073743),
            "100000073744" => Ok(Self::N100000073744),
            "100000073745" => Ok(Self::N100000073745),
            "100000073746" => Ok(Self::N100000073746),
            "100000073747" => Ok(Self::N100000073747),
            "100000073748" => Ok(Self::N100000073748),
            "100000073749" => Ok(Self::N100000073749),
            "100000073750" => Ok(Self::N100000073750),
            "100000073751" => Ok(Self::N100000073751),
            "100000073752" => Ok(Self::N100000073752),
            "100000073753" => Ok(Self::N100000073753),
            "100000073754" => Ok(Self::N100000073754),
            "100000073755" => Ok(Self::N100000073755),
            "100000073756" => Ok(Self::N100000073756),
            "100000073757" => Ok(Self::N100000073757),
            "100000073758" => Ok(Self::N100000073758),
            "100000073759" => Ok(Self::N100000073759),
            "100000073760" => Ok(Self::N100000073760),
            "100000073761" => Ok(Self::N100000073761),
            "100000073762" => Ok(Self::N100000073762),
            "100000073763" => Ok(Self::N100000073763),
            "100000073764" => Ok(Self::N100000073764),
            "100000073765" => Ok(Self::N100000073765),
            "100000073766" => Ok(Self::N100000073766),
            "100000073767" => Ok(Self::N100000073767),
            "100000073768" => Ok(Self::N100000073768),
            "100000073769" => Ok(Self::N100000073769),
            "100000073770" => Ok(Self::N100000073770),
            "100000073771" => Ok(Self::N100000073771),
            "100000073772" => Ok(Self::N100000073772),
            "100000073773" => Ok(Self::N100000073773),
            "100000073775" => Ok(Self::N100000073775),
            "100000073776" => Ok(Self::N100000073776),
            "100000073777" => Ok(Self::N100000073777),
            "100000073778" => Ok(Self::N100000073778),
            "100000073779" => Ok(Self::N100000073779),
            "100000073780" => Ok(Self::N100000073780),
            "100000073782" => Ok(Self::N100000073782),
            "100000073783" => Ok(Self::N100000073783),
            "100000073784" => Ok(Self::N100000073784),
            "100000073785" => Ok(Self::N100000073785),
            "100000073786" => Ok(Self::N100000073786),
            "100000073787" => Ok(Self::N100000073787),
            "100000073788" => Ok(Self::N100000073788),
            "100000073789" => Ok(Self::N100000073789),
            "100000073790" => Ok(Self::N100000073790),
            "100000073791" => Ok(Self::N100000073791),
            "100000073792" => Ok(Self::N100000073792),
            "100000073793" => Ok(Self::N100000073793),
            "100000073794" => Ok(Self::N100000073794),
            "100000073795" => Ok(Self::N100000073795),
            "100000073796" => Ok(Self::N100000073796),
            "100000073797" => Ok(Self::N100000073797),
            "100000073798" => Ok(Self::N100000073798),
            "100000073799" => Ok(Self::N100000073799),
            "100000073800" => Ok(Self::N100000073800),
            "100000073802" => Ok(Self::N100000073802),
            "100000073803" => Ok(Self::N100000073803),
            "100000073804" => Ok(Self::N100000073804),
            "100000073805" => Ok(Self::N100000073805),
            "100000073806" => Ok(Self::N100000073806),
            "100000073807" => Ok(Self::N100000073807),
            "100000073808" => Ok(Self::N100000073808),
            "100000073809" => Ok(Self::N100000073809),
            "100000073810" => Ok(Self::N100000073810),
            "100000073811" => Ok(Self::N100000073811),
            "100000073812" => Ok(Self::N100000073812),
            "100000073813" => Ok(Self::N100000073813),
            "100000073814" => Ok(Self::N100000073814),
            "100000073815" => Ok(Self::N100000073815),
            "100000073816" => Ok(Self::N100000073816),
            "100000073817" => Ok(Self::N100000073817),
            "100000073818" => Ok(Self::N100000073818),
            "100000073819" => Ok(Self::N100000073819),
            "100000073820" => Ok(Self::N100000073820),
            "100000073821" => Ok(Self::N100000073821),
            "100000073822" => Ok(Self::N100000073822),
            "100000073823" => Ok(Self::N100000073823),
            "100000073824" => Ok(Self::N100000073824),
            "100000073825" => Ok(Self::N100000073825),
            "100000073826" => Ok(Self::N100000073826),
            "100000073827" => Ok(Self::N100000073827),
            "100000073863" => Ok(Self::N100000073863),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ManufacturedDoseForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073362 => "100000073362",
            Self::N100000073363 => "100000073363",
            Self::N100000073364 => "100000073364",
            Self::N100000073365 => "100000073365",
            Self::N100000073367 => "100000073367",
            Self::N100000073368 => "100000073368",
            Self::N100000073369 => "100000073369",
            Self::N100000073370 => "100000073370",
            Self::N100000073371 => "100000073371",
            Self::N100000073372 => "100000073372",
            Self::N100000073373 => "100000073373",
            Self::N100000073374 => "100000073374",
            Self::N100000073375 => "100000073375",
            Self::N100000073376 => "100000073376",
            Self::N100000073377 => "100000073377",
            Self::N100000073378 => "100000073378",
            Self::N100000073379 => "100000073379",
            Self::N100000073380 => "100000073380",
            Self::N100000073642 => "100000073642",
            Self::N100000073643 => "100000073643",
            Self::N100000073644 => "100000073644",
            Self::N100000073645 => "100000073645",
            Self::N100000073646 => "100000073646",
            Self::N100000073647 => "100000073647",
            Self::N100000073648 => "100000073648",
            Self::N100000073649 => "100000073649",
            Self::N100000073650 => "100000073650",
            Self::N100000073652 => "100000073652",
            Self::N100000073653 => "100000073653",
            Self::N100000073654 => "100000073654",
            Self::N100000073655 => "100000073655",
            Self::N100000073656 => "100000073656",
            Self::N100000073657 => "100000073657",
            Self::N100000073658 => "100000073658",
            Self::N100000073659 => "100000073659",
            Self::N100000073660 => "100000073660",
            Self::N100000073661 => "100000073661",
            Self::N100000073662 => "100000073662",
            Self::N100000073663 => "100000073663",
            Self::N100000073664 => "100000073664",
            Self::N100000073665 => "100000073665",
            Self::N100000073666 => "100000073666",
            Self::N100000073667 => "100000073667",
            Self::N100000073668 => "100000073668",
            Self::N100000073669 => "100000073669",
            Self::N100000073670 => "100000073670",
            Self::N100000073671 => "100000073671",
            Self::N100000073672 => "100000073672",
            Self::N100000073673 => "100000073673",
            Self::N100000073674 => "100000073674",
            Self::N100000073675 => "100000073675",
            Self::N100000073676 => "100000073676",
            Self::N100000073677 => "100000073677",
            Self::N100000073678 => "100000073678",
            Self::N100000073679 => "100000073679",
            Self::N100000073680 => "100000073680",
            Self::N100000073681 => "100000073681",
            Self::N100000073682 => "100000073682",
            Self::N100000073683 => "100000073683",
            Self::N100000073684 => "100000073684",
            Self::N100000073685 => "100000073685",
            Self::N100000073686 => "100000073686",
            Self::N100000073687 => "100000073687",
            Self::N100000073688 => "100000073688",
            Self::N100000073689 => "100000073689",
            Self::N100000073690 => "100000073690",
            Self::N100000073691 => "100000073691",
            Self::N100000073692 => "100000073692",
            Self::N100000073693 => "100000073693",
            Self::N100000073694 => "100000073694",
            Self::N100000073695 => "100000073695",
            Self::N100000073696 => "100000073696",
            Self::N100000073697 => "100000073697",
            Self::N100000073698 => "100000073698",
            Self::N100000073699 => "100000073699",
            Self::N100000073700 => "100000073700",
            Self::N100000073701 => "100000073701",
            Self::N100000073702 => "100000073702",
            Self::N100000073703 => "100000073703",
            Self::N100000073704 => "100000073704",
            Self::N100000073705 => "100000073705",
            Self::N100000073706 => "100000073706",
            Self::N100000073707 => "100000073707",
            Self::N100000073708 => "100000073708",
            Self::N100000073709 => "100000073709",
            Self::N100000073710 => "100000073710",
            Self::N100000073711 => "100000073711",
            Self::N100000073712 => "100000073712",
            Self::N100000073713 => "100000073713",
            Self::N100000073714 => "100000073714",
            Self::N100000073715 => "100000073715",
            Self::N100000073716 => "100000073716",
            Self::N100000073717 => "100000073717",
            Self::N100000073718 => "100000073718",
            Self::N100000073719 => "100000073719",
            Self::N100000073720 => "100000073720",
            Self::N100000073721 => "100000073721",
            Self::N100000073722 => "100000073722",
            Self::N100000073723 => "100000073723",
            Self::N100000073724 => "100000073724",
            Self::N100000073725 => "100000073725",
            Self::N100000073726 => "100000073726",
            Self::N100000073727 => "100000073727",
            Self::N100000073728 => "100000073728",
            Self::N100000073729 => "100000073729",
            Self::N100000073730 => "100000073730",
            Self::N100000073731 => "100000073731",
            Self::N100000073732 => "100000073732",
            Self::N100000073733 => "100000073733",
            Self::N100000073734 => "100000073734",
            Self::N100000073735 => "100000073735",
            Self::N100000073736 => "100000073736",
            Self::N100000073737 => "100000073737",
            Self::N100000073738 => "100000073738",
            Self::N100000073739 => "100000073739",
            Self::N100000073740 => "100000073740",
            Self::N100000073741 => "100000073741",
            Self::N100000073742 => "100000073742",
            Self::N100000073743 => "100000073743",
            Self::N100000073744 => "100000073744",
            Self::N100000073745 => "100000073745",
            Self::N100000073746 => "100000073746",
            Self::N100000073747 => "100000073747",
            Self::N100000073748 => "100000073748",
            Self::N100000073749 => "100000073749",
            Self::N100000073750 => "100000073750",
            Self::N100000073751 => "100000073751",
            Self::N100000073752 => "100000073752",
            Self::N100000073753 => "100000073753",
            Self::N100000073754 => "100000073754",
            Self::N100000073755 => "100000073755",
            Self::N100000073756 => "100000073756",
            Self::N100000073757 => "100000073757",
            Self::N100000073758 => "100000073758",
            Self::N100000073759 => "100000073759",
            Self::N100000073760 => "100000073760",
            Self::N100000073761 => "100000073761",
            Self::N100000073762 => "100000073762",
            Self::N100000073763 => "100000073763",
            Self::N100000073764 => "100000073764",
            Self::N100000073765 => "100000073765",
            Self::N100000073766 => "100000073766",
            Self::N100000073767 => "100000073767",
            Self::N100000073768 => "100000073768",
            Self::N100000073769 => "100000073769",
            Self::N100000073770 => "100000073770",
            Self::N100000073771 => "100000073771",
            Self::N100000073772 => "100000073772",
            Self::N100000073773 => "100000073773",
            Self::N100000073775 => "100000073775",
            Self::N100000073776 => "100000073776",
            Self::N100000073777 => "100000073777",
            Self::N100000073778 => "100000073778",
            Self::N100000073779 => "100000073779",
            Self::N100000073780 => "100000073780",
            Self::N100000073782 => "100000073782",
            Self::N100000073783 => "100000073783",
            Self::N100000073784 => "100000073784",
            Self::N100000073785 => "100000073785",
            Self::N100000073786 => "100000073786",
            Self::N100000073787 => "100000073787",
            Self::N100000073788 => "100000073788",
            Self::N100000073789 => "100000073789",
            Self::N100000073790 => "100000073790",
            Self::N100000073791 => "100000073791",
            Self::N100000073792 => "100000073792",
            Self::N100000073793 => "100000073793",
            Self::N100000073794 => "100000073794",
            Self::N100000073795 => "100000073795",
            Self::N100000073796 => "100000073796",
            Self::N100000073797 => "100000073797",
            Self::N100000073798 => "100000073798",
            Self::N100000073799 => "100000073799",
            Self::N100000073800 => "100000073800",
            Self::N100000073802 => "100000073802",
            Self::N100000073803 => "100000073803",
            Self::N100000073804 => "100000073804",
            Self::N100000073805 => "100000073805",
            Self::N100000073806 => "100000073806",
            Self::N100000073807 => "100000073807",
            Self::N100000073808 => "100000073808",
            Self::N100000073809 => "100000073809",
            Self::N100000073810 => "100000073810",
            Self::N100000073811 => "100000073811",
            Self::N100000073812 => "100000073812",
            Self::N100000073813 => "100000073813",
            Self::N100000073814 => "100000073814",
            Self::N100000073815 => "100000073815",
            Self::N100000073816 => "100000073816",
            Self::N100000073817 => "100000073817",
            Self::N100000073818 => "100000073818",
            Self::N100000073819 => "100000073819",
            Self::N100000073820 => "100000073820",
            Self::N100000073821 => "100000073821",
            Self::N100000073822 => "100000073822",
            Self::N100000073823 => "100000073823",
            Self::N100000073824 => "100000073824",
            Self::N100000073825 => "100000073825",
            Self::N100000073826 => "100000073826",
            Self::N100000073827 => "100000073827",
            Self::N100000073863 => "100000073863",
        }
    }
}
impl ::std::fmt::Debug for ManufacturedDoseForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ManufacturedDoseForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ManufacturedDoseForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ManufacturedDoseForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ManufacturedDoseForm> for Coding {
    fn from(code: ManufacturedDoseForm) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/manufactured-dose-form".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ManufacturedDoseForm> for CodeableConcept {
    fn from(code: ManufacturedDoseForm) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureDataUsage](http://hl7.org/fhir/ValueSet/measure-data-usage)**. The intended usage for supplemental data elements in the measure.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureDataUsage {
    /** **risk-adjustment-factor**

Risk Adjustment Factor. The data is intended to be used to calculate and apply a risk adjustment model for the measure. */
    RiskAdjustmentFactor,
    /** **supplemental-data**

Supplemental Data. The data is intended to be provided as additional information alongside the measure results. */
    SupplementalData,
}
impl ::core::str::FromStr for MeasureDataUsage {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "risk-adjustment-factor" => Ok(Self::RiskAdjustmentFactor),
            "supplemental-data" => Ok(Self::SupplementalData),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureDataUsage {
    fn as_ref(&self) -> &str {
        match self {
            Self::RiskAdjustmentFactor => "risk-adjustment-factor",
            Self::SupplementalData => "supplemental-data",
        }
    }
}
impl ::std::fmt::Debug for MeasureDataUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureDataUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureDataUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureDataUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureDataUsage> for Coding {
    fn from(code: MeasureDataUsage) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-data-usage".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureDataUsage> for CodeableConcept {
    fn from(code: MeasureDataUsage) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureGroupExample](http://hl7.org/fhir/ValueSet/measure-group-example)**. Example Measure Groups for the Measure Resource.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureGroupExample {
    /** **primary-rate**

Primary Rate. Primary Measure Group. */
    PrimaryRate,
    /** **secondary-rate**

Secondary Rate. Secondary Measure Group */
    SecondaryRate,
}
impl ::core::str::FromStr for MeasureGroupExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "primary-rate" => Ok(Self::PrimaryRate),
            "secondary-rate" => Ok(Self::SecondaryRate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureGroupExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::PrimaryRate => "primary-rate",
            Self::SecondaryRate => "secondary-rate",
        }
    }
}
impl ::std::fmt::Debug for MeasureGroupExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureGroupExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureGroupExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureGroupExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureGroupExample> for Coding {
    fn from(code: MeasureGroupExample) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/measure-group-example".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureGroupExample> for CodeableConcept {
    fn from(code: MeasureGroupExample) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureImprovementNotation](http://hl7.org/fhir/ValueSet/measure-improvement-notation)**. Observation values that indicate what change in a measurement value or score is indicative of an improvement in the measured item or scored issue.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureImprovementNotation {
    /** **decrease**

Decreased score indicates improvement. Improvement is indicated as a decrease in the score or measurement (e.g. Lower score indicates better quality). */
    Decrease,
    /** **increase**

Increased score indicates improvement. Improvement is indicated as an increase in the score or measurement (e.g. Higher score indicates better quality). */
    Increase,
}
impl ::core::str::FromStr for MeasureImprovementNotation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "decrease" => Ok(Self::Decrease),
            "increase" => Ok(Self::Increase),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureImprovementNotation {
    fn as_ref(&self) -> &str {
        match self {
            Self::Decrease => "decrease",
            Self::Increase => "increase",
        }
    }
}
impl ::std::fmt::Debug for MeasureImprovementNotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureImprovementNotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureImprovementNotation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureImprovementNotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureImprovementNotation> for Coding {
    fn from(code: MeasureImprovementNotation) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/measure-improvement-notation".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureImprovementNotation> for CodeableConcept {
    fn from(code: MeasureImprovementNotation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasurePopulationType](http://hl7.org/fhir/ValueSet/measure-population)**. The type of population.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasurePopulationType {
    /** **denominator**

Denominator. The lower portion of a fraction used to calculate a rate, proportion, or ratio. The denominator can be the same as the initial population, or a subset of the initial population to further constrain the population for the purpose of the measure. */
    Denominator,
    /** **denominator-exception**

Denominator Exception. Denominator exceptions are conditions that should remove a patient or event from the denominator of a measure only if the numerator criteria are not met. Denominator exception allows for adjustment of the calculated score for those providers with higher risk populations. Denominator exception criteria are only used in proportion measures. */
    DenominatorException,
    /** **denominator-exclusion**

Denominator Exclusion. Denominator exclusion criteria define patients or events that should be removed from the denominator before determining if numerator criteria are met. Denominator exclusions are used in proportion and ratio measures to help narrow the denominator. For example, patients with bilateral lower extremity amputations would be listed as a denominator exclusion for a measure requiring foot exams. */
    DenominatorExclusion,
    /** **initial-population**

Initial Population. The initial population refers to all patients or events to be evaluated by a quality measure involving patients who share a common set of specified characterstics. All patients or events counted (for example, as numerator, as denominator) are drawn from the initial population. */
    InitialPopulation,
    /** **measure-observation**

Measure Observation. Defines the individual observation to be performed for each patient or event in the measure population. Measure observations for each case in the population are aggregated to determine the overall measure score for the population. */
    MeasureObservation,
    /** **measure-population**

Measure Population. Measure population criteria define the patients or events for which the individual observation for the measure should be taken. Measure populations are used for continuous variable measures rather than numerator and denominator criteria. */
    MeasurePopulation,
    /** **measure-population-exclusion**

Measure Population Exclusion. Measure population criteria define the patients or events that should be removed from the measure population before determining the outcome of one or more continuous variables defined for the measure observation. Measure population exclusion criteria are used within continuous variable measures to help narrow the measure population. */
    MeasurePopulationExclusion,
    /** **numerator**

Numerator. The upper portion of a fraction used to calculate a rate, proportion, or ratio. Also called the measure focus, it is the target process, condition, event, or outcome. Numerator criteria are the processes or outcomes expected for each patient, or event defined in the denominator. A numerator statement describes the clinical action that satisfies the conditions of the measure. */
    Numerator,
    /** **numerator-exclusion**

Numerator Exclusion. Numerator exclusion criteria define patients or events to be removed from the numerator. Numerator exclusions are used in proportion and ratio measures to help narrow the numerator (for inverted measures). */
    NumeratorExclusion,
}
impl ::core::str::FromStr for MeasurePopulationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "denominator" => Ok(Self::Denominator),
            "denominator-exception" => Ok(Self::DenominatorException),
            "denominator-exclusion" => Ok(Self::DenominatorExclusion),
            "initial-population" => Ok(Self::InitialPopulation),
            "measure-observation" => Ok(Self::MeasureObservation),
            "measure-population" => Ok(Self::MeasurePopulation),
            "measure-population-exclusion" => Ok(Self::MeasurePopulationExclusion),
            "numerator" => Ok(Self::Numerator),
            "numerator-exclusion" => Ok(Self::NumeratorExclusion),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasurePopulationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Denominator => "denominator",
            Self::DenominatorException => "denominator-exception",
            Self::DenominatorExclusion => "denominator-exclusion",
            Self::InitialPopulation => "initial-population",
            Self::MeasureObservation => "measure-observation",
            Self::MeasurePopulation => "measure-population",
            Self::MeasurePopulationExclusion => "measure-population-exclusion",
            Self::Numerator => "numerator",
            Self::NumeratorExclusion => "numerator-exclusion",
        }
    }
}
impl ::std::fmt::Debug for MeasurePopulationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasurePopulationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasurePopulationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasurePopulationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasurePopulationType> for Coding {
    fn from(code: MeasurePopulationType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-population".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasurePopulationType> for CodeableConcept {
    fn from(code: MeasurePopulationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureReportStatus](http://hl7.org/fhir/ValueSet/measure-report-status)**. The status of the measure report.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureReportStatus {
    /** **complete**

Complete. The report is complete and ready for use. */
    Complete,
    /** **error**

Error. An error occurred attempting to generate the report. */
    Error,
    /** **pending**

Pending. The report is currently being generated. */
    Pending,
}
impl ::core::str::FromStr for MeasureReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "error" => Ok(Self::Error),
            "pending" => Ok(Self::Pending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Error => "error",
            Self::Pending => "pending",
        }
    }
}
impl ::std::fmt::Debug for MeasureReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureReportStatus> for Coding {
    fn from(code: MeasureReportStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/measure-report-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureReportStatus> for CodeableConcept {
    fn from(code: MeasureReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureReportStratifierValueExample](http://hl7.org/fhir/ValueSet/measurereport-stratifier-value-example)**. Example Region Value Measure Groups for the Measure Resource.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureReportStratifierValueExample {
    /** **northeast**

Northeast. Northeast region stratification. */
    Northeast,
    /** **northwest**

Northwest. Northwest region stratification. */
    Northwest,
    /** **southeast**

Southeast. Southeast region stratification. */
    Southeast,
    /** **southwest**

Soutwest. Soutwest region stratification. */
    Southwest,
}
impl ::core::str::FromStr for MeasureReportStratifierValueExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "northeast" => Ok(Self::Northeast),
            "northwest" => Ok(Self::Northwest),
            "southeast" => Ok(Self::Southeast),
            "southwest" => Ok(Self::Southwest),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportStratifierValueExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Northeast => "northeast",
            Self::Northwest => "northwest",
            Self::Southeast => "southeast",
            Self::Southwest => "southwest",
        }
    }
}
impl ::std::fmt::Debug for MeasureReportStratifierValueExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureReportStratifierValueExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureReportStratifierValueExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportStratifierValueExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureReportStratifierValueExample> for Coding {
    fn from(code: MeasureReportStratifierValueExample) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/measurereport-stratifier-value-example"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureReportStratifierValueExample> for CodeableConcept {
    fn from(code: MeasureReportStratifierValueExample) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureReportType](http://hl7.org/fhir/ValueSet/measure-report-type)**. The type of the measure report.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureReportType {
    /** **data-collection**

Data Collection. A data collection report that contains data-of-interest for the measure. */
    DataCollection,
    /** **individual**

Individual. An individual report that provides information on the performance for a given measure with respect to a single subject. */
    Individual,
    /** **subject-list**

Subject List. A subject list report that includes a listing of subjects that satisfied each population criteria in the measure. */
    SubjectList,
    /** **summary**

Summary. A summary report that returns the number of members in each population criteria for the measure. */
    Summary,
}
impl ::core::str::FromStr for MeasureReportType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-collection" => Ok(Self::DataCollection),
            "individual" => Ok(Self::Individual),
            "subject-list" => Ok(Self::SubjectList),
            "summary" => Ok(Self::Summary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataCollection => "data-collection",
            Self::Individual => "individual",
            Self::SubjectList => "subject-list",
            Self::Summary => "summary",
        }
    }
}
impl ::std::fmt::Debug for MeasureReportType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureReportType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureReportType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureReportType> for Coding {
    fn from(code: MeasureReportType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-report-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureReportType> for CodeableConcept {
    fn from(code: MeasureReportType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureScoring](http://hl7.org/fhir/ValueSet/measure-scoring)**. The scoring type of the measure.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureScoring {
    /** **cohort**

Cohort. The measure is a cohort definition. */
    Cohort,
    /** **continuous-variable**

Continuous Variable. The score is defined by a calculation of some quantity. */
    ContinuousVariable,
    /** **proportion**

Proportion. The measure score is defined using a proportion. */
    Proportion,
    /** **ratio**

Ratio. The measure score is defined using a ratio. */
    Ratio,
}
impl ::core::str::FromStr for MeasureScoring {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cohort" => Ok(Self::Cohort),
            "continuous-variable" => Ok(Self::ContinuousVariable),
            "proportion" => Ok(Self::Proportion),
            "ratio" => Ok(Self::Ratio),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureScoring {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cohort => "cohort",
            Self::ContinuousVariable => "continuous-variable",
            Self::Proportion => "proportion",
            Self::Ratio => "ratio",
        }
    }
}
impl ::std::fmt::Debug for MeasureScoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureScoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureScoring {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureScoring {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureScoring> for Coding {
    fn from(code: MeasureScoring) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-scoring".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureScoring> for CodeableConcept {
    fn from(code: MeasureScoring) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureStratifierExample](http://hl7.org/fhir/ValueSet/measure-stratifier-example)**. Identifier subgroups in a population for measuring purposes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureStratifierExample {
    /** **age**

Age. Age Stratification. */
    Age,
    /** **gender**

Gender. Gender Stratification. */
    Gender,
    /** **region**

Region. Region Stratification. */
    Region,
}
impl ::core::str::FromStr for MeasureStratifierExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "age" => Ok(Self::Age),
            "gender" => Ok(Self::Gender),
            "region" => Ok(Self::Region),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureStratifierExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Age => "age",
            Self::Gender => "gender",
            Self::Region => "region",
        }
    }
}
impl ::std::fmt::Debug for MeasureStratifierExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureStratifierExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureStratifierExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureStratifierExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureStratifierExample> for Coding {
    fn from(code: MeasureStratifierExample) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/measure-stratifier-example".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureStratifierExample> for CodeableConcept {
    fn from(code: MeasureStratifierExample) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureSupplementalDataExample](http://hl7.org/fhir/ValueSet/measure-supplemental-data-example)**. Identifier supplemental data in a population for measuring purposes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureSupplementalDataExample {
    /** **age**

Age. Age Supplemental Data. */
    Age,
    /** **ethnicity**

Ethnicity. Ethnicity Supplemental Data . */
    Ethnicity,
    /** **gender**

Gender. Gender Supplemental Data . */
    Gender,
    /** **payer**

Payer. Payer Supplemental Data. */
    Payer,
}
impl ::core::str::FromStr for MeasureSupplementalDataExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "age" => Ok(Self::Age),
            "ethnicity" => Ok(Self::Ethnicity),
            "gender" => Ok(Self::Gender),
            "payer" => Ok(Self::Payer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureSupplementalDataExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Age => "age",
            Self::Ethnicity => "ethnicity",
            Self::Gender => "gender",
            Self::Payer => "payer",
        }
    }
}
impl ::std::fmt::Debug for MeasureSupplementalDataExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureSupplementalDataExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureSupplementalDataExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureSupplementalDataExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureSupplementalDataExample> for Coding {
    fn from(code: MeasureSupplementalDataExample) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/measure-supplemental-data-example"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureSupplementalDataExample> for CodeableConcept {
    fn from(code: MeasureSupplementalDataExample) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MeasureType](http://hl7.org/fhir/ValueSet/measure-type)**. The type of measure (includes codes from 2.16.840.1.113883.1.11.20368).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MeasureType {
    /** **composite**

Composite. A measure that combines multiple component measures in to a single quality measure. */
    Composite,
    /** **outcome**

Outcome. A measure that indicates the result of the performance (or non-performance) of a function or process. */
    Outcome,
    /** **patient-reported-outcome**

Patient Reported Outcome. A measure that focuses on patient-reported information such as patient engagement or patient experience measures. */
    PatientReportedOutcome,
    /** **process**

Process. A measure which focuses on a process which leads to a certain outcome, meaning that a scientific basis exists for believing that the process, when executed well, will increase the probability of achieving a desired outcome. */
    Process,
    /** **structure**

Structure. A measure that focuses on a health care provider's capacity, systems, and processes to provide high-quality care. */
    Structure,
}
impl ::core::str::FromStr for MeasureType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "composite" => Ok(Self::Composite),
            "outcome" => Ok(Self::Outcome),
            "patient-reported-outcome" => Ok(Self::PatientReportedOutcome),
            "process" => Ok(Self::Process),
            "structure" => Ok(Self::Structure),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Composite => "composite",
            Self::Outcome => "outcome",
            Self::PatientReportedOutcome => "patient-reported-outcome",
            Self::Process => "process",
            Self::Structure => "structure",
        }
    }
}
impl ::std::fmt::Debug for MeasureType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MeasureType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MeasureType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureType> for Coding {
    fn from(code: MeasureType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/measure-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MeasureType> for CodeableConcept {
    fn from(code: MeasureType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MediaSubType](http://terminology.hl7.org/CodeSystem/media-modality)**. Detailed information about the type of the image - its kind, purpose, or the kind of equipment used to generate it.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum MediaSubType {
    /** **diagram**

Diagram. A diagram. Often used in diagnostic reports */
    Diagram,
    /** **face**

Face Scan. A face scan used for identification purposes */
    Face,
    /** **fax**

Fax. A digital record of a fax document */
    Fax,
    /** **fingerprint**

Fingerprint. A finger print scan used for identification purposes */
    Fingerprint,
    /** **iris**

Iris Scan. An iris scan used for identification purposes */
    Iris,
    /** **palm**

Palm Scan. A palm scan used for identification purposes */
    Palm,
    /** **retina**

Retina Scan. A retinal image used for identification purposes */
    Retina,
    /** **scan**

Scanned Document. A digital scan of a document. This is reserved for when there is not enough metadata to create a document reference */
    Scan,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for MediaSubType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "diagram" => Ok(Self::Diagram),
            "face" => Ok(Self::Face),
            "fax" => Ok(Self::Fax),
            "fingerprint" => Ok(Self::Fingerprint),
            "iris" => Ok(Self::Iris),
            "palm" => Ok(Self::Palm),
            "retina" => Ok(Self::Retina),
            "scan" => Ok(Self::Scan),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for MediaSubType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Diagram => "diagram",
            Self::Face => "face",
            Self::Fax => "fax",
            Self::Fingerprint => "fingerprint",
            Self::Iris => "iris",
            Self::Palm => "palm",
            Self::Retina => "retina",
            Self::Scan => "scan",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for MediaSubType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MediaSubType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MediaSubType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MediaSubType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MediaSubType> for Coding {
    fn from(code: MediaSubType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/media-modality".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MediaSubType> for CodeableConcept {
    fn from(code: MediaSubType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicinalProductDomain](http://hl7.org/fhir/ValueSet/medicinal-product-domain)**. Applicable domain for this product (e.g. human, veterinary).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicinalProductDomain {
    /** **Human**

Human use. Product intended for use with humans */
    Human,
    /** **HumanAndVeterinary**

Human and Veterinary use. Product intended for use with both humans and animals */
    HumanAndVeterinary,
    /** **Veterinary**

Veterinary use. Product intended for use with animals */
    Veterinary,
}
impl ::core::str::FromStr for MedicinalProductDomain {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Human" => Ok(Self::Human),
            "HumanAndVeterinary" => Ok(Self::HumanAndVeterinary),
            "Veterinary" => Ok(Self::Veterinary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicinalProductDomain {
    fn as_ref(&self) -> &str {
        match self {
            Self::Human => "Human",
            Self::HumanAndVeterinary => "HumanAndVeterinary",
            Self::Veterinary => "Veterinary",
        }
    }
}
impl ::std::fmt::Debug for MedicinalProductDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicinalProductDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicinalProductDomain {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicinalProductDomain {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicinalProductDomain> for Coding {
    fn from(code: MedicinalProductDomain) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-domain".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicinalProductDomain> for CodeableConcept {
    fn from(code: MedicinalProductDomain) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicinalProductPackageType](http://hl7.org/fhir/ValueSet/medicinal-product-package-type)**. Types of medicinal product packs\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicinalProductPackageType {
    /** **100000073490**

Ampoule. */
    N100000073490,
    /** **100000073491**

Applicator. */
    N100000073491,
    /** **100000073492**

Automatic injection device. */
    N100000073492,
    /** **100000073493**

Bag. */
    N100000073493,
    /** **100000073494**

Balling gun. */
    N100000073494,
    /** **100000073495**

Barrel. */
    N100000073495,
    /** **100000073496**

Blister. */
    N100000073496,
    /** **100000073497**

Bottle. */
    N100000073497,
    /** **100000073498**

Box. */
    N100000073498,
    /** **100000073547**

Sachet. */
    N100000073547,
    /** **100000073563**

Vial. */
    N100000073563,
    /** **100000143555**

Pack. */
    N100000143555,
}
impl ::core::str::FromStr for MedicinalProductPackageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073490" => Ok(Self::N100000073490),
            "100000073491" => Ok(Self::N100000073491),
            "100000073492" => Ok(Self::N100000073492),
            "100000073493" => Ok(Self::N100000073493),
            "100000073494" => Ok(Self::N100000073494),
            "100000073495" => Ok(Self::N100000073495),
            "100000073496" => Ok(Self::N100000073496),
            "100000073497" => Ok(Self::N100000073497),
            "100000073498" => Ok(Self::N100000073498),
            "100000073547" => Ok(Self::N100000073547),
            "100000073563" => Ok(Self::N100000073563),
            "100000143555" => Ok(Self::N100000143555),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicinalProductPackageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073490 => "100000073490",
            Self::N100000073491 => "100000073491",
            Self::N100000073492 => "100000073492",
            Self::N100000073493 => "100000073493",
            Self::N100000073494 => "100000073494",
            Self::N100000073495 => "100000073495",
            Self::N100000073496 => "100000073496",
            Self::N100000073497 => "100000073497",
            Self::N100000073498 => "100000073498",
            Self::N100000073547 => "100000073547",
            Self::N100000073563 => "100000073563",
            Self::N100000143555 => "100000143555",
        }
    }
}
impl ::std::fmt::Debug for MedicinalProductPackageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicinalProductPackageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicinalProductPackageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicinalProductPackageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicinalProductPackageType> for Coding {
    fn from(code: MedicinalProductPackageType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-package-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicinalProductPackageType> for CodeableConcept {
    fn from(code: MedicinalProductPackageType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MedicinalProductType](http://hl7.org/fhir/ValueSet/medicinal-product-type)**. Overall defining type of this Medicinal Product.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MedicinalProductType {
    /** **InvestigationalProduct**

Investigational Medicinal Product. An investigational medicinal product. */
    InvestigationalProduct,
    /** **MedicinalProduct**

Medicinal Product. A standard medicinal product. */
    MedicinalProduct,
}
impl ::core::str::FromStr for MedicinalProductType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "InvestigationalProduct" => Ok(Self::InvestigationalProduct),
            "MedicinalProduct" => Ok(Self::MedicinalProduct),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicinalProductType {
    fn as_ref(&self) -> &str {
        match self {
            Self::InvestigationalProduct => "InvestigationalProduct",
            Self::MedicinalProduct => "MedicinalProduct",
        }
    }
}
impl ::std::fmt::Debug for MedicinalProductType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MedicinalProductType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MedicinalProductType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicinalProductType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicinalProductType> for Coding {
    fn from(code: MedicinalProductType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MedicinalProductType> for CodeableConcept {
    fn from(code: MedicinalProductType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MessageEvent](http://hl7.org/fhir/message-events)**. One of the message events defined as part of this version of FHIR.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum MessageEvent {
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for MessageEvent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for MessageEvent {
    fn as_ref(&self) -> &str {
        match self {
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for MessageEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MessageEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MessageEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageEvent> for Coding {
    fn from(code: MessageEvent) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/message-events".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MessageEvent> for CodeableConcept {
    fn from(code: MessageEvent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MessageSignificanceCategory](http://hl7.org/fhir/ValueSet/message-significance-category)**. The impact of the content of a message.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MessageSignificanceCategory {
    /** **consequence**

Consequence. The message represents/requests a change that should not be processed more than once; e.g., making a booking for an appointment. */
    Consequence,
    /** **currency**

Currency. The message represents a response to query for current information. Retrospective processing is wrong and/or wasteful. */
    Currency,
    /** **notification**

Notification. The content is not necessarily intended to be current, and it can be reprocessed, though there may be version issues created by processing old notifications. */
    Notification,
}
impl ::core::str::FromStr for MessageSignificanceCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "consequence" => Ok(Self::Consequence),
            "currency" => Ok(Self::Currency),
            "notification" => Ok(Self::Notification),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageSignificanceCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consequence => "consequence",
            Self::Currency => "currency",
            Self::Notification => "notification",
        }
    }
}
impl ::std::fmt::Debug for MessageSignificanceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MessageSignificanceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MessageSignificanceCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageSignificanceCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageSignificanceCategory> for Coding {
    fn from(code: MessageSignificanceCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/message-significance-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MessageSignificanceCategory> for CodeableConcept {
    fn from(code: MessageSignificanceCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MessageTransport](http://hl7.org/fhir/ValueSet/message-transport)**. The protocol used for message transport.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum MessageTransport {
    /** **ftp**

FTP. The application sends or receives messages using File Transfer Protocol. */
    Ftp,
    /** **http**

HTTP. The application sends or receives messages using HTTP POST (may be over http: or https:). */
    Http,
    /** **mllp**

MLLP. The application sends or receives messages using HL7's Minimal Lower Level Protocol. */
    Mllp,
}
impl ::core::str::FromStr for MessageTransport {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ftp" => Ok(Self::Ftp),
            "http" => Ok(Self::Http),
            "mllp" => Ok(Self::Mllp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageTransport {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ftp => "ftp",
            Self::Http => "http",
            Self::Mllp => "mllp",
        }
    }
}
impl ::std::fmt::Debug for MessageTransport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MessageTransport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MessageTransport {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageTransport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageTransport> for Coding {
    fn from(code: MessageTransport) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/message-transport".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MessageTransport> for CodeableConcept {
    fn from(code: MessageTransport) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[MissingToothReasonCodes](http://terminology.hl7.org/CodeSystem/missingtoothreason)**. This value set includes sample Missing Tooth Reason codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum MissingToothReasonCodes {
    /** **c**

C. Congenital */
    C,
    /** **e**

E. Extraction */
    E,
    /** **o**

O. Other */
    O,
    /** **u**

U. Unknown */
    U,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for MissingToothReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "c" => Ok(Self::C),
            "e" => Ok(Self::E),
            "o" => Ok(Self::O),
            "u" => Ok(Self::U),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for MissingToothReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::C => "c",
            Self::E => "e",
            Self::O => "o",
            Self::U => "u",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for MissingToothReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for MissingToothReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for MissingToothReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MissingToothReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MissingToothReasonCodes> for Coding {
    fn from(code: MissingToothReasonCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/missingtoothreason".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<MissingToothReasonCodes> for CodeableConcept {
    fn from(code: MissingToothReasonCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ModifierTypeCodes](http://terminology.hl7.org/CodeSystem/modifiers)**. This value set includes sample Modifier type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ModifierTypeCodes {
    /** **a**

Repair of prior service or installation. Repair of prior service or installation. */
    A,
    /** **b**

Temporary service or installation. Temporary service or installation. */
    B,
    /** **c**

TMJ treatment. Treatment associated with TMJ. */
    C,
    /** **e**

Implant or associated with an implant. Implant or associated with an implant. */
    E,
    /** **rooh**

Rush or Outside of office hours. A Rush service or service performed outside of normal office hours. */
    Rooh,
    /** **x**

None. None. */
    X,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ModifierTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a" => Ok(Self::A),
            "b" => Ok(Self::B),
            "c" => Ok(Self::C),
            "e" => Ok(Self::E),
            "rooh" => Ok(Self::Rooh),
            "x" => Ok(Self::X),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ModifierTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::A => "a",
            Self::B => "b",
            Self::C => "c",
            Self::E => "e",
            Self::Rooh => "rooh",
            Self::X => "x",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ModifierTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ModifierTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ModifierTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ModifierTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ModifierTypeCodes> for Coding {
    fn from(code: ModifierTypeCodes) -> Self {
        CodingInner {
            system: Some("http://terminology.hl7.org/CodeSystem/modifiers".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ModifierTypeCodes> for CodeableConcept {
    fn from(code: ModifierTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NameUse](http://hl7.org/fhir/ValueSet/name-use)**. The use of a human name.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NameUse {
    /** **anonymous**

Anonymous. Anonymous assigned name, alias, or pseudonym (used to protect a person's identity for privacy reasons). */
    Anonymous,
    /** **maiden**

Name changed for Marriage. A name used prior to changing name because of marriage. This name use is for use by applications that collect and store names that were used prior to a marriage. Marriage naming customs vary greatly around the world, and are constantly changing. This term is not gender specific. The use of this term does not imply any particular history for a person's name. */
    Maiden,
    /** **nickname**

Nickname. A name that is used to address the person in an informal manner, but is not part of their formal or usual name. */
    Nickname,
    /** **official**

Official. The formal name as registered in an official (government) registry, but which name might not be commonly used. May be called "legal name". */
    Official,
    /** **old**

Old. This name is no longer in use (or was never correct, but retained for records). */
    Old,
    /** **temp**

Temp. A temporary name. Name.period can provide more detailed information. This may also be used for temporary names assigned at birth or in emergency situations. */
    Temp,
    /** **usual**

Usual. Known as/conventional/the one you normally use. */
    Usual,
}
impl ::core::str::FromStr for NameUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "anonymous" => Ok(Self::Anonymous),
            "maiden" => Ok(Self::Maiden),
            "nickname" => Ok(Self::Nickname),
            "official" => Ok(Self::Official),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "usual" => Ok(Self::Usual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NameUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Anonymous => "anonymous",
            Self::Maiden => "maiden",
            Self::Nickname => "nickname",
            Self::Official => "official",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Usual => "usual",
        }
    }
}
impl ::std::fmt::Debug for NameUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NameUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NameUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NameUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NameUse> for Coding {
    fn from(code: NameUse) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/name-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NameUse> for CodeableConcept {
    fn from(code: NameUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NamingSystemIdentifierType](http://hl7.org/fhir/ValueSet/namingsystem-identifier-type)**. Identifies the style of unique identifier used to identify a namespace.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NamingSystemIdentifierType {
    /** **oid**

OID. An ISO object identifier; e.g. 1.2.3.4.5. */
    Oid,
    /** **other**

Other. Some other type of unique identifier; e.g. HL7-assigned reserved string such as LN for LOINC. */
    Other,
    /** **uri**

URI. A uniform resource identifier (ideally a URL - uniform resource locator); e.g. http://unitsofmeasure.org. */
    Uri,
    /** **uuid**

UUID. A universally unique identifier of the form a5afddf4-e880-459b-876e-e4591b0acc11. */
    Uuid,
}
impl ::core::str::FromStr for NamingSystemIdentifierType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "oid" => Ok(Self::Oid),
            "other" => Ok(Self::Other),
            "uri" => Ok(Self::Uri),
            "uuid" => Ok(Self::Uuid),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NamingSystemIdentifierType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Oid => "oid",
            Self::Other => "other",
            Self::Uri => "uri",
            Self::Uuid => "uuid",
        }
    }
}
impl ::std::fmt::Debug for NamingSystemIdentifierType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NamingSystemIdentifierType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NamingSystemIdentifierType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NamingSystemIdentifierType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NamingSystemIdentifierType> for Coding {
    fn from(code: NamingSystemIdentifierType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/namingsystem-identifier-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NamingSystemIdentifierType> for CodeableConcept {
    fn from(code: NamingSystemIdentifierType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NamingSystemType](http://hl7.org/fhir/ValueSet/namingsystem-type)**. Identifies the purpose of the naming system.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NamingSystemType {
    /** **codesystem**

Code System. The naming system is used to define concepts and symbols to represent those concepts; e.g. UCUM, LOINC, NDC code, local lab codes, etc. */
    Codesystem,
    /** **identifier**

Identifier. The naming system is used to manage identifiers (e.g. license numbers, order numbers, etc.). */
    Identifier,
    /** **root**

Root. The naming system is used as the root for other identifiers and naming systems. */
    Root,
}
impl ::core::str::FromStr for NamingSystemType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "codesystem" => Ok(Self::Codesystem),
            "identifier" => Ok(Self::Identifier),
            "root" => Ok(Self::Root),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NamingSystemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Codesystem => "codesystem",
            Self::Identifier => "identifier",
            Self::Root => "root",
        }
    }
}
impl ::std::fmt::Debug for NamingSystemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NamingSystemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NamingSystemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NamingSystemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NamingSystemType> for Coding {
    fn from(code: NamingSystemType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/namingsystem-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NamingSystemType> for CodeableConcept {
    fn from(code: NamingSystemType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NarrativeStatus](http://hl7.org/fhir/ValueSet/narrative-status)**. The status of a resource narrative.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NarrativeStatus {
    /** **additional**

Additional. The contents of the narrative may contain additional information not found in the structured data. Note that there is no computable way to determine what the extra information is, other than by human inspection. */
    Additional,
    /** **empty**

Empty. The contents of the narrative are some equivalent of "No human-readable text provided in this case". */
    Empty,
    /** **extensions**

Extensions. The contents of the narrative are entirely generated from the core elements in the content and some of the content is generated from extensions. The narrative SHALL reflect the impact of all modifier extensions. */
    Extensions,
    /** **generated**

Generated. The contents of the narrative are entirely generated from the core elements in the content. */
    Generated,
}
impl ::core::str::FromStr for NarrativeStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "additional" => Ok(Self::Additional),
            "empty" => Ok(Self::Empty),
            "extensions" => Ok(Self::Extensions),
            "generated" => Ok(Self::Generated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NarrativeStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Additional => "additional",
            Self::Empty => "empty",
            Self::Extensions => "extensions",
            Self::Generated => "generated",
        }
    }
}
impl ::std::fmt::Debug for NarrativeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NarrativeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NarrativeStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NarrativeStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NarrativeStatus> for Coding {
    fn from(code: NarrativeStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/narrative-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NarrativeStatus> for CodeableConcept {
    fn from(code: NarrativeStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NetworkTypeCodes](http://terminology.hl7.org/CodeSystem/benefit-network)**. This value set includes a smattering of Network type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum NetworkTypeCodes {
    /** **in**

In Network. Services rendered by a Network provider */
    In,
    /** **out**

Out of Network. Services rendered by a provider who is not in the Network */
    Out,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for NetworkTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for NetworkTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::In => "in",
            Self::Out => "out",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for NetworkTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NetworkTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NetworkTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NetworkTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NetworkTypeCodes> for Coding {
    fn from(code: NetworkTypeCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/benefit-network".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NetworkTypeCodes> for CodeableConcept {
    fn from(code: NetworkTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NoteType](http://hl7.org/fhir/ValueSet/note-type)**. The presentation types of notes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NoteType {
    /** **display**

Display. Display the note. */
    Display,
    /** **print**

Print (Form). Print the note on the form. */
    Print,
    /** **printoper**

Print (Operator). Print the note for the operator. */
    Printoper,
}
impl ::core::str::FromStr for NoteType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "display" => Ok(Self::Display),
            "print" => Ok(Self::Print),
            "printoper" => Ok(Self::Printoper),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NoteType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Display => "display",
            Self::Print => "print",
            Self::Printoper => "printoper",
        }
    }
}
impl ::std::fmt::Debug for NoteType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NoteType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NoteType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NoteType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NoteType> for Coding {
    fn from(code: NoteType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/note-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NoteType> for CodeableConcept {
    fn from(code: NoteType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[NutritionProductStatus](http://hl7.org/fhir/ValueSet/nutritionproduct-status)**. Codes identifying the lifecycle stage of a product.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum NutritionProductStatus {
    /** **active**

Active. The product can be used. */
    Active,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **inactive**

Inactive. The product is not expected or allowed to be used. */
    Inactive,
}
impl ::core::str::FromStr for NutritionProductStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NutritionProductStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Debug for NutritionProductStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for NutritionProductStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for NutritionProductStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NutritionProductStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NutritionProductStatus> for Coding {
    fn from(code: NutritionProductStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/nutritionproduct-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<NutritionProductStatus> for CodeableConcept {
    fn from(code: NutritionProductStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ObservationCategoryCodes](http://hl7.org/fhir/ValueSet/observation-category)**. Observation Category codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ObservationCategoryCodes {
    /** **activity**

Activity. Observations that measure or record any bodily activity that enhances or maintains physical fitness and overall health and wellness.  Not under direct supervision of practitioner such as a physical therapist. (e.g., laps swum, steps, sleep data) */
    Activity,
    /** **exam**

Exam. Observations generated by physical exam findings including direct observations made by a clinician and use of simple instruments and the result of simple maneuvers performed directly on the patient's body. */
    Exam,
    /** **imaging**

Imaging. Observations generated by imaging. The scope includes observations regarding plain x-ray, ultrasound, CT, MRI, angiography, echocardiography, and nuclear medicine. */
    Imaging,
    /** **laboratory**

Laboratory. The results of observations generated by laboratories.  Laboratory results are typically generated by laboratories providing analytic services in areas such as chemistry, hematology, serology, histology, cytology, anatomic pathology (including digital pathology), microbiology, and/or virology. These observations are based on analysis of specimens obtained from the patient and submitted to the laboratory. */
    Laboratory,
    /** **procedure**

Procedure. Observations generated by other procedures.  This category includes observations resulting from interventional and non-interventional procedures excluding laboratory and imaging (e.g., cardiology catheterization, endoscopy, electrodiagnostics, etc.).  Procedure results are typically generated by a clinician to provide more granular information about component observations made during a procedure.  An example would be when a gastroenterologist reports the size of a polyp observed during a colonoscopy. */
    Procedure,
    /** **social-history**

Social History. Social History Observations define the patient's occupational, personal (e.g., lifestyle), social, familial, and environmental history and health risk factors that may impact the patient's health. */
    SocialHistory,
    /** **survey**

Survey. Assessment tool/survey instrument observations (e.g., Apgar Scores, Montreal Cognitive Assessment (MoCA)). */
    Survey,
    /** **therapy**

Therapy. Observations generated by non-interventional treatment protocols (e.g. occupational, physical, radiation, nutritional and medication therapy) */
    Therapy,
    /** **vital-signs**

Vital Signs.  Clinical observations measure the body's basic functions such as blood pressure, heart rate, respiratory rate, height, weight, body mass index, head circumference, pulse oximetry, temperature, and body surface area. */
    VitalSigns,
}
impl ::core::str::FromStr for ObservationCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "activity" => Ok(Self::Activity),
            "exam" => Ok(Self::Exam),
            "imaging" => Ok(Self::Imaging),
            "laboratory" => Ok(Self::Laboratory),
            "procedure" => Ok(Self::Procedure),
            "social-history" => Ok(Self::SocialHistory),
            "survey" => Ok(Self::Survey),
            "therapy" => Ok(Self::Therapy),
            "vital-signs" => Ok(Self::VitalSigns),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Activity => "activity",
            Self::Exam => "exam",
            Self::Imaging => "imaging",
            Self::Laboratory => "laboratory",
            Self::Procedure => "procedure",
            Self::SocialHistory => "social-history",
            Self::Survey => "survey",
            Self::Therapy => "therapy",
            Self::VitalSigns => "vital-signs",
        }
    }
}
impl ::std::fmt::Debug for ObservationCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ObservationCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ObservationCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationCategoryCodes> for Coding {
    fn from(code: ObservationCategoryCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/observation-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ObservationCategoryCodes> for CodeableConcept {
    fn from(code: ObservationCategoryCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ObservationDataType](http://hl7.org/fhir/ValueSet/permitted-data-type)**. Permitted data type for observation value.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ObservationDataType {
    /** **CodeableConcept**

CodeableConcept. A coded concept from a reference terminology and/or text. */
    CodeableConcept,
    /** **Period**

Period. A time range defined by start and end date/time. */
    Period,
    /** **Quantity**

Quantity. A measured amount. */
    Quantity,
    /** **Range**

Range. A set of values bounded by low and high. */
    Range,
    /** **Ratio**

Ratio. A ratio of two Quantity values - a numerator and a denominator. */
    Ratio,
    /** **SampledData**

SampledData. A series of measurements taken by a device. */
    SampledData,
    /** **boolean**

boolean. true or false. */
    Boolean,
    /** **dateTime**

dateTime. A date, date-time or partial date (e.g. just year or year + month) as used in human communication. */
    DateTime,
    /** **integer**

integer. A signed integer. */
    Integer,
    /** **string**

string. A sequence of Unicode characters. */
    String,
    /** **time**

time. A time during the day, in the format hh:mm:ss. */
    Time,
}
impl ::core::str::FromStr for ObservationDataType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CodeableConcept" => Ok(Self::CodeableConcept),
            "Period" => Ok(Self::Period),
            "Quantity" => Ok(Self::Quantity),
            "Range" => Ok(Self::Range),
            "Ratio" => Ok(Self::Ratio),
            "SampledData" => Ok(Self::SampledData),
            "boolean" => Ok(Self::Boolean),
            "dateTime" => Ok(Self::DateTime),
            "integer" => Ok(Self::Integer),
            "string" => Ok(Self::String),
            "time" => Ok(Self::Time),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationDataType {
    fn as_ref(&self) -> &str {
        match self {
            Self::CodeableConcept => "CodeableConcept",
            Self::Period => "Period",
            Self::Quantity => "Quantity",
            Self::Range => "Range",
            Self::Ratio => "Ratio",
            Self::SampledData => "SampledData",
            Self::Boolean => "boolean",
            Self::DateTime => "dateTime",
            Self::Integer => "integer",
            Self::String => "string",
            Self::Time => "time",
        }
    }
}
impl ::std::fmt::Debug for ObservationDataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ObservationDataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ObservationDataType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationDataType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationDataType> for Coding {
    fn from(code: ObservationDataType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/permitted-data-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ObservationDataType> for CodeableConcept {
    fn from(code: ObservationDataType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ObservationRangeCategory](http://hl7.org/fhir/ValueSet/observation-range-category)**. Codes identifying the category of observation range.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ObservationRangeCategory {
    /** **absolute**

absolute range. Absolute Range for Ordinal and Continuous Observations. Results outside this range are not possible. */
    Absolute,
    /** **critical**

critical range. Critical Range for Ordinal and Continuous Observations. */
    Critical,
    /** **reference**

reference range. Reference (Normal) Range for Ordinal and Continuous Observations. */
    Reference,
}
impl ::core::str::FromStr for ObservationRangeCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "absolute" => Ok(Self::Absolute),
            "critical" => Ok(Self::Critical),
            "reference" => Ok(Self::Reference),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationRangeCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Absolute => "absolute",
            Self::Critical => "critical",
            Self::Reference => "reference",
        }
    }
}
impl ::std::fmt::Debug for ObservationRangeCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ObservationRangeCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ObservationRangeCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationRangeCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationRangeCategory> for Coding {
    fn from(code: ObservationRangeCategory) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/observation-range-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ObservationRangeCategory> for CodeableConcept {
    fn from(code: ObservationRangeCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ObservationReferenceRangeMeaningCodes](http://terminology.hl7.org/CodeSystem/referencerange-meaning)**. This value set defines a set of codes that can be used to indicate the meaning/use of a reference range.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ObservationReferenceRangeMeaningCodes {
    /** **endocrine**

Endocrine. Endocrine related states that change the expected value. */
    Endocrine,
    /** **follicular**

Follicular Stage. An expected range in an individual during the follicular stage of the cycle. */
    Follicular,
    /** **luteal**

Luteal. An expected range in an individual during the luteal stage of the cycle. */
    Luteal,
    /** **midcycle**

MidCycle. An expected range in an individual during the midcycle stage of the cycle. */
    Midcycle,
    /** **normal**

Normal Range. Values expected for a normal member of the relevant control population being measured. Typically each results producer such as a laboratory has specific normal ranges and they are usually defined as within two standard deviations from the mean and account for 95.45% of this population. */
    Normal,
    /** **post**

Post Therapeutic Desired Level. The optimal range for best therapeutic outcomes for a specimen taken immediately after administration. */
    Post,
    /** **postmenopausal**

Post-Menopause. An expected range in an individual post-menopause. */
    Postmenopausal,
    /** **pre**

Pre Therapeutic Desired Level. The optimal range for best therapeutic outcomes for a specimen taken immediately before administration. */
    Pre,
    /** **pre-puberty**

Pre-Puberty. An expected range in an individual prior to puberty. */
    PrePuberty,
    /** **recommended**

Recommended Range. The range that is recommended by a relevant professional body. */
    Recommended,
    /** **therapeutic**

Therapeutic Desired Level. The optimal range for best therapeutic outcomes. */
    Therapeutic,
    /** **treatment**

Treatment Range. The range at which treatment would/should be considered. */
    Treatment,
    /** **type**

Type. General types of reference range. */
    Type,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ObservationReferenceRangeMeaningCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "endocrine" => Ok(Self::Endocrine),
            "follicular" => Ok(Self::Follicular),
            "luteal" => Ok(Self::Luteal),
            "midcycle" => Ok(Self::Midcycle),
            "normal" => Ok(Self::Normal),
            "post" => Ok(Self::Post),
            "postmenopausal" => Ok(Self::Postmenopausal),
            "pre" => Ok(Self::Pre),
            "pre-puberty" => Ok(Self::PrePuberty),
            "recommended" => Ok(Self::Recommended),
            "therapeutic" => Ok(Self::Therapeutic),
            "treatment" => Ok(Self::Treatment),
            "type" => Ok(Self::Type),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ObservationReferenceRangeMeaningCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Endocrine => "endocrine",
            Self::Follicular => "follicular",
            Self::Luteal => "luteal",
            Self::Midcycle => "midcycle",
            Self::Normal => "normal",
            Self::Post => "post",
            Self::Postmenopausal => "postmenopausal",
            Self::Pre => "pre",
            Self::PrePuberty => "pre-puberty",
            Self::Recommended => "recommended",
            Self::Therapeutic => "therapeutic",
            Self::Treatment => "treatment",
            Self::Type => "type",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ObservationReferenceRangeMeaningCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ObservationReferenceRangeMeaningCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ObservationReferenceRangeMeaningCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationReferenceRangeMeaningCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationReferenceRangeMeaningCodes> for Coding {
    fn from(code: ObservationReferenceRangeMeaningCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/referencerange-meaning".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ObservationReferenceRangeMeaningCodes> for CodeableConcept {
    fn from(code: ObservationReferenceRangeMeaningCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ObservationStatus](http://hl7.org/fhir/ValueSet/observation-status)**. Codes providing the status of an observation.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ObservationStatus {
    /** **amended**

Amended. Subsequent to being Final, the observation has been modified subsequent.  This includes updates/new information and corrections. */
    Amended,
    /** **cancelled**

Cancelled. The observation is unavailable because the measurement was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **corrected**

Corrected. Subsequent to being Final, the observation has been modified to correct an error in the test result. */
    Corrected,
    /** **entered-in-error**

Entered in Error. The observation has been withdrawn following previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **final**

Final. The observation is complete and there are no further actions needed. Additional information such "released", "signed", etc would be represented using [Provenance](provenance.html) which provides not only the act but also the actors and dates and other related data. These act states would be associated with an observation status of `preliminary` until they are all completed and then a status of `final` would be applied. */
    Final,
    /** **preliminary**

Preliminary. This is an initial or interim observation: data may be incomplete or unverified. */
    Preliminary,
    /** **registered**

Registered. The existence of the observation is registered, but there is no result yet available. */
    Registered,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for ObservationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "cancelled" => Ok(Self::Cancelled),
            "corrected" => Ok(Self::Corrected),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "preliminary" => Ok(Self::Preliminary),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Cancelled => "cancelled",
            Self::Corrected => "corrected",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Preliminary => "preliminary",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for ObservationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ObservationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ObservationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationStatus> for Coding {
    fn from(code: ObservationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/observation-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ObservationStatus> for CodeableConcept {
    fn from(code: ObservationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[OperationKind](http://hl7.org/fhir/ValueSet/operation-kind)**. Whether an operation is a normal operation or a query.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum OperationKind {
    /** **operation**

Operation. This operation is invoked as an operation. */
    Operation,
    /** **query**

Query. This operation is a named query, invoked using the search mechanism. */
    Query,
}
impl ::core::str::FromStr for OperationKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "operation" => Ok(Self::Operation),
            "query" => Ok(Self::Query),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OperationKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Operation => "operation",
            Self::Query => "query",
        }
    }
}
impl ::std::fmt::Debug for OperationKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for OperationKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for OperationKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OperationKind> for Coding {
    fn from(code: OperationKind) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/operation-kind".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<OperationKind> for CodeableConcept {
    fn from(code: OperationKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[OperationParameterUse](http://hl7.org/fhir/ValueSet/operation-parameter-use)**. Whether an operation parameter is an input or an output parameter.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum OperationParameterUse {
    /** **in**

In. This is an input parameter. */
    In,
    /** **out**

Out. This is an output parameter. */
    Out,
}
impl ::core::str::FromStr for OperationParameterUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OperationParameterUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::In => "in",
            Self::Out => "out",
        }
    }
}
impl ::std::fmt::Debug for OperationParameterUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for OperationParameterUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for OperationParameterUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationParameterUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OperationParameterUse> for Coding {
    fn from(code: OperationParameterUse) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/operation-parameter-use".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<OperationParameterUse> for CodeableConcept {
    fn from(code: OperationParameterUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[OralSiteCodes](http://terminology.hl7.org/CodeSystem/ex-tooth)**. This value set includes a smattering of FDI oral site codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum OralSiteCodes {
    /** **0**

Oral cavity. Oral cavity. */
    N0,
    /** **1**

1. Permanent teeth Maxillary right. */
    N1,
    /** **11**

11. Upper Right Tooth 1 from the central axis, permanent dentition. */
    N11,
    /** **12**

12. Upper Right Tooth 2 from the central axis, permanent dentition. */
    N12,
    /** **13**

13. Upper Right Tooth 3 from the central axis, permanent dentition. */
    N13,
    /** **14**

14. Upper Right Tooth 4 from the central axis, permanent dentition. */
    N14,
    /** **15**

15. Upper Right Tooth 5 from the central axis, permanent dentition. */
    N15,
    /** **16**

16. Upper Right Tooth 6 from the central axis, permanent dentition. */
    N16,
    /** **17**

17. Upper Right Tooth 7 from the central axis, permanent dentition. */
    N17,
    /** **18**

18. Upper Right Tooth 8 from the central axis, permanent dentition. */
    N18,
    /** **2**

2. Permanent teeth Maxillary left. */
    N2,
    /** **21**

21. Upper Left Tooth 1 from the central axis, permanent dentition. */
    N21,
    /** **22**

22. Upper Left Tooth 2 from the central axis, permanent dentition. */
    N22,
    /** **23**

23. Upper Left Tooth 3 from the central axis, permanent dentition. */
    N23,
    /** **24**

24. Upper Left Tooth 4 from the central axis, permanent dentition. */
    N24,
    /** **25**

25. Upper Left Tooth 5 from the central axis, permanent dentition. */
    N25,
    /** **26**

26. Upper Left Tooth 6 from the central axis, permanent dentition. */
    N26,
    /** **27**

27. Upper Left Tooth 7 from the central axis, permanent dentition. */
    N27,
    /** **28**

28. Upper Left Tooth 8 from the central axis, permanent dentition. */
    N28,
    /** **3**

3. Permanent teeth Mandibular right. */
    N3,
    /** **31**

31. Lower Left Tooth 1 from the central axis, permanent dentition. */
    N31,
    /** **32**

32. Lower Left Tooth 2 from the central axis, permanent dentition. */
    N32,
    /** **33**

33. Lower Left Tooth 3 from the central axis, permanent dentition. */
    N33,
    /** **34**

34. Lower Left Tooth 4 from the central axis, permanent dentition. */
    N34,
    /** **35**

35. Lower Left Tooth 5 from the central axis, permanent dentition. */
    N35,
    /** **36**

36. Lower Left Tooth 6 from the central axis, permanent dentition. */
    N36,
    /** **37**

37. Lower Left Tooth 7 from the central axis, permanent dentition. */
    N37,
    /** **38**

38. Lower Left Tooth 8 from the central axis, permanent dentition. */
    N38,
    /** **4**

4. Permanent teeth Mandibular left. */
    N4,
    /** **41**

41. Lower Right Tooth 1 from the central axis, permanent dentition. */
    N41,
    /** **42**

42. Lower Right Tooth 2 from the central axis, permanent dentition. */
    N42,
    /** **43**

43. Lower Right Tooth 3 from the central axis, permanent dentition. */
    N43,
    /** **44**

44. Lower Right Tooth 4 from the central axis, permanent dentition. */
    N44,
    /** **45**

45. Lower Right Tooth 5 from the central axis, permanent dentition. */
    N45,
    /** **46**

46. Lower Right Tooth 6 from the central axis, permanent dentition. */
    N46,
    /** **47**

47. Lower Right Tooth 7 from the central axis, permanent dentition. */
    N47,
    /** **48**

48. Lower Right Tooth 8 from the central axis, permanent dentition. */
    N48,
    /** **5**

5. Deciduous teeth Maxillary right. */
    N5,
    /** **6**

6. Deciduous teeth Maxillary left. */
    N6,
    /** **7**

7. Deciduous teeth Mandibular right. */
    N7,
    /** **8**

8. Deciduous teeth Mandibular left. */
    N8,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for OralSiteCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0" => Ok(Self::N0),
            "1" => Ok(Self::N1),
            "11" => Ok(Self::N11),
            "12" => Ok(Self::N12),
            "13" => Ok(Self::N13),
            "14" => Ok(Self::N14),
            "15" => Ok(Self::N15),
            "16" => Ok(Self::N16),
            "17" => Ok(Self::N17),
            "18" => Ok(Self::N18),
            "2" => Ok(Self::N2),
            "21" => Ok(Self::N21),
            "22" => Ok(Self::N22),
            "23" => Ok(Self::N23),
            "24" => Ok(Self::N24),
            "25" => Ok(Self::N25),
            "26" => Ok(Self::N26),
            "27" => Ok(Self::N27),
            "28" => Ok(Self::N28),
            "3" => Ok(Self::N3),
            "31" => Ok(Self::N31),
            "32" => Ok(Self::N32),
            "33" => Ok(Self::N33),
            "34" => Ok(Self::N34),
            "35" => Ok(Self::N35),
            "36" => Ok(Self::N36),
            "37" => Ok(Self::N37),
            "38" => Ok(Self::N38),
            "4" => Ok(Self::N4),
            "41" => Ok(Self::N41),
            "42" => Ok(Self::N42),
            "43" => Ok(Self::N43),
            "44" => Ok(Self::N44),
            "45" => Ok(Self::N45),
            "46" => Ok(Self::N46),
            "47" => Ok(Self::N47),
            "48" => Ok(Self::N48),
            "5" => Ok(Self::N5),
            "6" => Ok(Self::N6),
            "7" => Ok(Self::N7),
            "8" => Ok(Self::N8),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for OralSiteCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0 => "0",
            Self::N1 => "1",
            Self::N11 => "11",
            Self::N12 => "12",
            Self::N13 => "13",
            Self::N14 => "14",
            Self::N15 => "15",
            Self::N16 => "16",
            Self::N17 => "17",
            Self::N18 => "18",
            Self::N2 => "2",
            Self::N21 => "21",
            Self::N22 => "22",
            Self::N23 => "23",
            Self::N24 => "24",
            Self::N25 => "25",
            Self::N26 => "26",
            Self::N27 => "27",
            Self::N28 => "28",
            Self::N3 => "3",
            Self::N31 => "31",
            Self::N32 => "32",
            Self::N33 => "33",
            Self::N34 => "34",
            Self::N35 => "35",
            Self::N36 => "36",
            Self::N37 => "37",
            Self::N38 => "38",
            Self::N4 => "4",
            Self::N41 => "41",
            Self::N42 => "42",
            Self::N43 => "43",
            Self::N44 => "44",
            Self::N45 => "45",
            Self::N46 => "46",
            Self::N47 => "47",
            Self::N48 => "48",
            Self::N5 => "5",
            Self::N6 => "6",
            Self::N7 => "7",
            Self::N8 => "8",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for OralSiteCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for OralSiteCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for OralSiteCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OralSiteCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OralSiteCodes> for Coding {
    fn from(code: OralSiteCodes) -> Self {
        CodingInner {
            system: Some("http://terminology.hl7.org/CodeSystem/ex-tooth".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<OralSiteCodes> for CodeableConcept {
    fn from(code: OralSiteCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[OrganizationAffiliationRole](http://hl7.org/fhir/organization-role)**. This example value set defines a set of codes that can be used to indicate the role of one Organization in relation to its affiliation with another.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum OrganizationAffiliationRole {
    /** **HIE/HIO**

HIE/HIO. An organization that facilitates electronic clinical data exchange between entities */
    HieHio,
    /** **agency**

Agency. An organization such as a public health agency, community/social services provider, etc. */
    Agency,
    /** **diagnostics**

Diagnostics. An organization providing diagnostic testing/laboratory services */
    Diagnostics,
    /** **member**

Member. A type of non-ownership relationship between entities (encompasses partnerships, collaboration, joint ventures, etc.) */
    Member,
    /** **payer**

Payer. An organization providing reimbursement, payment, or related services */
    Payer,
    /** **provider**

Provider. */
    Provider,
    /** **research**

Research. An organization providing research-related services such as conducting research, recruiting research participants, analyzing data, etc. */
    Research,
    /** **supplier**

Supplier. An organization that provides medical supplies (e.g. medical devices, equipment, pharmaceutical products, etc.) */
    Supplier,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for OrganizationAffiliationRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "HIE/HIO" => Ok(Self::HieHio),
            "agency" => Ok(Self::Agency),
            "diagnostics" => Ok(Self::Diagnostics),
            "member" => Ok(Self::Member),
            "payer" => Ok(Self::Payer),
            "provider" => Ok(Self::Provider),
            "research" => Ok(Self::Research),
            "supplier" => Ok(Self::Supplier),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for OrganizationAffiliationRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::HieHio => "HIE/HIO",
            Self::Agency => "agency",
            Self::Diagnostics => "diagnostics",
            Self::Member => "member",
            Self::Payer => "payer",
            Self::Provider => "provider",
            Self::Research => "research",
            Self::Supplier => "supplier",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for OrganizationAffiliationRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for OrganizationAffiliationRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for OrganizationAffiliationRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OrganizationAffiliationRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OrganizationAffiliationRole> for Coding {
    fn from(code: OrganizationAffiliationRole) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/organization-role".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<OrganizationAffiliationRole> for CodeableConcept {
    fn from(code: OrganizationAffiliationRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[OrganizationType](http://terminology.hl7.org/CodeSystem/organization-type)**. This example value set defines a set of codes that can be used to indicate a type of organization.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum OrganizationType {
    /** **bus**

Non-Healthcare Business or Corporation. An organization that is a registered business or corporation but not identified by other types. */
    Bus,
    /** **cg**

Community Group. An un-incorporated community group. */
    Cg,
    /** **crs**

Clinical Research Sponsor. An organization that is identified as a Pharmaceutical/Clinical Research Sponsor. */
    Crs,
    /** **dept**

Hospital Department. A department or ward within a hospital (Generally is not applicable to top level organizations) */
    Dept,
    /** **edu**

Educational Institute. An educational institution that provides education or research facilities. */
    Edu,
    /** **govt**

Government. A political body, often used when including organization records for government bodies such as a Federal Government, State or Local Government. */
    Govt,
    /** **ins**

Insurance Company. A company that provides insurance to its subscribers that may include healthcare related policies. */
    Ins,
    /** **other**

Other. Other type of organization not already specified. */
    Other,
    /** **pay**

Payer. A company, charity, or governmental organization, which processes claims and/or issues payments to providers on behalf of patients or groups of patients. */
    Pay,
    /** **prov**

Healthcare Provider. An organization that provides healthcare services. */
    Prov,
    /** **reli**

Religious Institution. An organization that is identified as a part of a religious institution. */
    Reli,
    /** **team**

Organizational team. An organizational team is usually a grouping of practitioners that perform a specific function within an organization (which could be a top level organization, or a department). */
    Team,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for OrganizationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bus" => Ok(Self::Bus),
            "cg" => Ok(Self::Cg),
            "crs" => Ok(Self::Crs),
            "dept" => Ok(Self::Dept),
            "edu" => Ok(Self::Edu),
            "govt" => Ok(Self::Govt),
            "ins" => Ok(Self::Ins),
            "other" => Ok(Self::Other),
            "pay" => Ok(Self::Pay),
            "prov" => Ok(Self::Prov),
            "reli" => Ok(Self::Reli),
            "team" => Ok(Self::Team),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for OrganizationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bus => "bus",
            Self::Cg => "cg",
            Self::Crs => "crs",
            Self::Dept => "dept",
            Self::Edu => "edu",
            Self::Govt => "govt",
            Self::Ins => "ins",
            Self::Other => "other",
            Self::Pay => "pay",
            Self::Prov => "prov",
            Self::Reli => "reli",
            Self::Team => "team",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for OrganizationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for OrganizationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for OrganizationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OrganizationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OrganizationType> for Coding {
    fn from(code: OrganizationType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/organization-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<OrganizationType> for CodeableConcept {
    fn from(code: OrganizationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PackageCharacteristic](http://hl7.org/fhir/ValueSet/package-characteristic)**. A characteristic of a package.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PackageCharacteristic {
    /** **CalendarPack**

Calendar pack. */
    CalendarPack,
    /** **HospitalPack**

Hospital pack. */
    HospitalPack,
    /** **NursePrescribable**

Nurse prescribable. */
    NursePrescribable,
}
impl ::core::str::FromStr for PackageCharacteristic {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CalendarPack" => Ok(Self::CalendarPack),
            "HospitalPack" => Ok(Self::HospitalPack),
            "NursePrescribable" => Ok(Self::NursePrescribable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackageCharacteristic {
    fn as_ref(&self) -> &str {
        match self {
            Self::CalendarPack => "CalendarPack",
            Self::HospitalPack => "HospitalPack",
            Self::NursePrescribable => "NursePrescribable",
        }
    }
}
impl ::std::fmt::Debug for PackageCharacteristic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PackageCharacteristic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PackageCharacteristic {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackageCharacteristic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PackageCharacteristic> for Coding {
    fn from(code: PackageCharacteristic) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/package-characteristic".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PackageCharacteristic> for CodeableConcept {
    fn from(code: PackageCharacteristic) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PackageMaterial](http://hl7.org/fhir/ValueSet/package-material)**. A material used in the construction of packages and their components.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PackageMaterial {
    /** **200000003200**

Aluminium. */
    N200000003200,
    /** **200000003201**

Cyclic Olefin Copolymer. */
    N200000003201,
    /** **200000003202**

Epoxyphenol. */
    N200000003202,
    /** **200000003203**

Glass. */
    N200000003203,
    /** **200000003204**

Glass type I. */
    N200000003204,
    /** **200000003205**

Glass type II. */
    N200000003205,
    /** **200000003206**

Glass type III. */
    N200000003206,
    /** **200000003207**

Paper. */
    N200000003207,
    /** **200000003208**

Plastic. */
    N200000003208,
    /** **200000003209**

PolyAmide. */
    N200000003209,
    /** **200000003210**

Orientated PolyAmide. */
    N200000003210,
    /** **200000003211**

PolyCarbonate. */
    N200000003211,
    /** **200000003212**

PolyChloroTriFluoroEthylene. */
    N200000003212,
    /** **200000003213**

Polyester. */
    N200000003213,
    /** **200000003214**

PolyEthylene. */
    N200000003214,
    /** **200000003215**

High Density PolyEthylene. */
    N200000003215,
    /** **200000003216**

Low Density PolyEthylene. */
    N200000003216,
    /** **200000003217**

PolyEthylene TerePhthalate. */
    N200000003217,
    /** **200000003218**

Polyolefin. */
    N200000003218,
    /** **200000003219**

PolyPropylene. */
    N200000003219,
    /** **200000003220**

PolyStyrene. */
    N200000003220,
    /** **200000003221**

PolyVinyl Acetate. */
    N200000003221,
    /** **200000003222**

PolyVinyl Chloride. */
    N200000003222,
    /** **200000003223**

Plasticised PolyVinyl Chloride. */
    N200000003223,
    /** **200000003224**

Non-plasticised PolyVinyl Chloride / Unplasticised PolyVinyl Chloride. */
    N200000003224,
    /** **200000003225**

PolyVinylidene Chloride. */
    N200000003225,
    /** **200000003226**

Rubber. */
    N200000003226,
    /** **200000003227**

Silicone oil. */
    N200000003227,
    /** **200000003228**

Silicone elastomer. */
    N200000003228,
    /** **200000003229**

Steel. */
    N200000003229,
    /** **200000003529**

Cardboard. */
    N200000003529,
    /** **200000012514**

PolyAcryloNitrile. */
    N200000012514,
    /** **200000012515**

Ethylene acrylic acid copolymer. */
    N200000012515,
    /** **200000012521**

Ethylene meta-acrylic acid. */
    N200000012521,
    /** **200000012522**

Ethylene-Vinyl Alcohol copolymer. */
    N200000012522,
    /** **200000012523**

PolyVinylidene Fluoride. */
    N200000012523,
    /** **200000012524**

Medium Density PolyEthylene. */
    N200000012524,
    /** **200000012538**

Syndiotactic Polypropylene. */
    N200000012538,
    /** **200000015521**

PolyEthylene copolymer. */
    N200000015521,
    /** **200000023330**

Expanded Polyethylene. */
    N200000023330,
    /** **200000023332**

Cyclic Olefin Polymer. */
    N200000023332,
    /** **200000025255**

Silica gel. */
    N200000025255,
    /** **200000025257**

Linear Low Density PolyEthylene. */
    N200000025257,
}
impl ::core::str::FromStr for PackageMaterial {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "200000003200" => Ok(Self::N200000003200),
            "200000003201" => Ok(Self::N200000003201),
            "200000003202" => Ok(Self::N200000003202),
            "200000003203" => Ok(Self::N200000003203),
            "200000003204" => Ok(Self::N200000003204),
            "200000003205" => Ok(Self::N200000003205),
            "200000003206" => Ok(Self::N200000003206),
            "200000003207" => Ok(Self::N200000003207),
            "200000003208" => Ok(Self::N200000003208),
            "200000003209" => Ok(Self::N200000003209),
            "200000003210" => Ok(Self::N200000003210),
            "200000003211" => Ok(Self::N200000003211),
            "200000003212" => Ok(Self::N200000003212),
            "200000003213" => Ok(Self::N200000003213),
            "200000003214" => Ok(Self::N200000003214),
            "200000003215" => Ok(Self::N200000003215),
            "200000003216" => Ok(Self::N200000003216),
            "200000003217" => Ok(Self::N200000003217),
            "200000003218" => Ok(Self::N200000003218),
            "200000003219" => Ok(Self::N200000003219),
            "200000003220" => Ok(Self::N200000003220),
            "200000003221" => Ok(Self::N200000003221),
            "200000003222" => Ok(Self::N200000003222),
            "200000003223" => Ok(Self::N200000003223),
            "200000003224" => Ok(Self::N200000003224),
            "200000003225" => Ok(Self::N200000003225),
            "200000003226" => Ok(Self::N200000003226),
            "200000003227" => Ok(Self::N200000003227),
            "200000003228" => Ok(Self::N200000003228),
            "200000003229" => Ok(Self::N200000003229),
            "200000003529" => Ok(Self::N200000003529),
            "200000012514" => Ok(Self::N200000012514),
            "200000012515" => Ok(Self::N200000012515),
            "200000012521" => Ok(Self::N200000012521),
            "200000012522" => Ok(Self::N200000012522),
            "200000012523" => Ok(Self::N200000012523),
            "200000012524" => Ok(Self::N200000012524),
            "200000012538" => Ok(Self::N200000012538),
            "200000015521" => Ok(Self::N200000015521),
            "200000023330" => Ok(Self::N200000023330),
            "200000023332" => Ok(Self::N200000023332),
            "200000025255" => Ok(Self::N200000025255),
            "200000025257" => Ok(Self::N200000025257),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackageMaterial {
    fn as_ref(&self) -> &str {
        match self {
            Self::N200000003200 => "200000003200",
            Self::N200000003201 => "200000003201",
            Self::N200000003202 => "200000003202",
            Self::N200000003203 => "200000003203",
            Self::N200000003204 => "200000003204",
            Self::N200000003205 => "200000003205",
            Self::N200000003206 => "200000003206",
            Self::N200000003207 => "200000003207",
            Self::N200000003208 => "200000003208",
            Self::N200000003209 => "200000003209",
            Self::N200000003210 => "200000003210",
            Self::N200000003211 => "200000003211",
            Self::N200000003212 => "200000003212",
            Self::N200000003213 => "200000003213",
            Self::N200000003214 => "200000003214",
            Self::N200000003215 => "200000003215",
            Self::N200000003216 => "200000003216",
            Self::N200000003217 => "200000003217",
            Self::N200000003218 => "200000003218",
            Self::N200000003219 => "200000003219",
            Self::N200000003220 => "200000003220",
            Self::N200000003221 => "200000003221",
            Self::N200000003222 => "200000003222",
            Self::N200000003223 => "200000003223",
            Self::N200000003224 => "200000003224",
            Self::N200000003225 => "200000003225",
            Self::N200000003226 => "200000003226",
            Self::N200000003227 => "200000003227",
            Self::N200000003228 => "200000003228",
            Self::N200000003229 => "200000003229",
            Self::N200000003529 => "200000003529",
            Self::N200000012514 => "200000012514",
            Self::N200000012515 => "200000012515",
            Self::N200000012521 => "200000012521",
            Self::N200000012522 => "200000012522",
            Self::N200000012523 => "200000012523",
            Self::N200000012524 => "200000012524",
            Self::N200000012538 => "200000012538",
            Self::N200000015521 => "200000015521",
            Self::N200000023330 => "200000023330",
            Self::N200000023332 => "200000023332",
            Self::N200000025255 => "200000025255",
            Self::N200000025257 => "200000025257",
        }
    }
}
impl ::std::fmt::Debug for PackageMaterial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PackageMaterial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PackageMaterial {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackageMaterial {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PackageMaterial> for Coding {
    fn from(code: PackageMaterial) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/package-material".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PackageMaterial> for CodeableConcept {
    fn from(code: PackageMaterial) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PackageType](http://hl7.org/fhir/ValueSet/package-type)**. A high level categorisation of a package.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PackageType {
    /** **MedicinalProductPack**

Medicinal product pack. */
    MedicinalProductPack,
    /** **RawMaterialPackage**

Raw material package. */
    RawMaterialPackage,
    /** **Shipping-TransportContainer**

Shipping or transport container. */
    ShippingTransportContainer,
}
impl ::core::str::FromStr for PackageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "MedicinalProductPack" => Ok(Self::MedicinalProductPack),
            "RawMaterialPackage" => Ok(Self::RawMaterialPackage),
            "Shipping-TransportContainer" => Ok(Self::ShippingTransportContainer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MedicinalProductPack => "MedicinalProductPack",
            Self::RawMaterialPackage => "RawMaterialPackage",
            Self::ShippingTransportContainer => "Shipping-TransportContainer",
        }
    }
}
impl ::std::fmt::Debug for PackageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PackageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PackageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PackageType> for Coding {
    fn from(code: PackageType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/package-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PackageType> for CodeableConcept {
    fn from(code: PackageType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PackagingType](http://hl7.org/fhir/ValueSet/packaging-type)**. A type of packaging.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PackagingType {
    /** **100000073490**

Ampoule. */
    N100000073490,
    /** **100000073491**

Applicator. */
    N100000073491,
    /** **100000073492**

Automatic injection device. */
    N100000073492,
    /** **100000073493**

Bag. */
    N100000073493,
    /** **100000073494**

Balling gun. */
    N100000073494,
    /** **100000073495**

Barrel. */
    N100000073495,
    /** **100000073496**

Blister. */
    N100000073496,
    /** **100000073497**

Bottle. */
    N100000073497,
    /** **100000073498**

Box. */
    N100000073498,
    /** **100000073499**

Brush. */
    N100000073499,
    /** **100000073500**

Brush applicator. */
    N100000073500,
    /** **100000073501**

Cannula. */
    N100000073501,
    /** **100000073502**

Cap. */
    N100000073502,
    /** **100000073503**

Cartridge. */
    N100000073503,
    /** **100000073504**

Child-resistant closure. */
    N100000073504,
    /** **100000073505**

Cup. */
    N100000073505,
    /** **100000073506**

Dabbing applicator. */
    N100000073506,
    /** **100000073507**

Dart. */
    N100000073507,
    /** **100000073508**

Dredging applicator. */
    N100000073508,
    /** **100000073509**

Dredging container. */
    N100000073509,
    /** **100000073510**

Drench gun. */
    N100000073510,
    /** **100000073511**

Dropper applicator. */
    N100000073511,
    /** **100000073512**

Dropper container. */
    N100000073512,
    /** **100000073513**

Fixed cryogenic vessel. */
    N100000073513,
    /** **100000073514**

Gas cylinder. */
    N100000073514,
    /** **100000073515**

High pressure transdermal delivery device. */
    N100000073515,
    /** **100000073516**

Implanter. */
    N100000073516,
    /** **100000073517**

Inhaler. */
    N100000073517,
    /** **100000073518**

In-ovo injection device. */
    N100000073518,
    /** **100000073519**

Injection needle. */
    N100000073519,
    /** **100000073520**

Injection syringe. */
    N100000073520,
    /** **100000073521**

Internal graduated calibration chamber. */
    N100000073521,
    /** **100000073522**

Intramammary syringe. */
    N100000073522,
    /** **100000073523**

Jar. */
    N100000073523,
    /** **100000073524**

Measuring device. */
    N100000073524,
    /** **100000073525**

Measuring spoon. */
    N100000073525,
    /** **100000073526**

Metering pump. */
    N100000073526,
    /** **100000073527**

Metering valve. */
    N100000073527,
    /** **100000073528**

Mobile cryogenic vessel. */
    N100000073528,
    /** **100000073529**

Mouthpiece. */
    N100000073529,
    /** **100000073530**

Multidose container. */
    N100000073530,
    /** **100000073531**

Multidose container with airless pump. */
    N100000073531,
    /** **100000073532**

Multipuncturer. */
    N100000073532,
    /** **100000073533**

Nasal applicator. */
    N100000073533,
    /** **100000073534**

Nebuliser. */
    N100000073534,
    /** **100000073535**

Needle applicator. */
    N100000073535,
    /** **100000073536**

Nozzle. */
    N100000073536,
    /** **100000073537**

Oral syringe. */
    N100000073537,
    /** **100000073538**

Pipette. */
    N100000073538,
    /** **100000073539**

Pipette applicator. */
    N100000073539,
    /** **100000073540**

Pouch. */
    N100000073540,
    /** **100000073541**

Pour-on container. */
    N100000073541,
    /** **100000073542**

Pre-filled gastroenteral tube. */
    N100000073542,
    /** **100000073543**

Pre-filled pen. */
    N100000073543,
    /** **100000073544**

Pre-filled syringe. */
    N100000073544,
    /** **100000073545**

Pressurised container. */
    N100000073545,
    /** **100000073546**

Prick test applicator. */
    N100000073546,
    /** **100000073547**

Sachet. */
    N100000073547,
    /** **100000073548**

Scarifier. */
    N100000073548,
    /** **100000073549**

Screw cap. */
    N100000073549,
    /** **100000073550**

Single-dose container. */
    N100000073550,
    /** **100000073551**

Spatula. */
    N100000073551,
    /** **100000073552**

Spot-on applicator. */
    N100000073552,
    /** **100000073553**

Spray container. */
    N100000073553,
    /** **100000073554**

Spray pump. */
    N100000073554,
    /** **100000073555**

Spray valve. */
    N100000073555,
    /** **100000073556**

Stab vaccinator. */
    N100000073556,
    /** **100000073557**

Stopper. */
    N100000073557,
    /** **100000073558**

Straw. */
    N100000073558,
    /** **100000073559**

Strip. */
    N100000073559,
    /** **100000073560**

Tablet container. */
    N100000073560,
    /** **100000073561**

Tube. */
    N100000073561,
    /** **100000073562**

Vaginal sponge applicator. */
    N100000073562,
    /** **100000073563**

Vial. */
    N100000073563,
    /** **100000075664**

Administration system. */
    N100000075664,
    /** **100000116195**

Calendar package. */
    N100000116195,
    /** **100000116196**

Needle-free injector. */
    N100000116196,
    /** **100000116197**

Roll-on container. */
    N100000116197,
    /** **100000125779**

Multidose container with pump. */
    N100000125779,
    /** **100000137702**

Container. */
    N100000137702,
    /** **100000137703**

Oral applicator. */
    N100000137703,
    /** **100000143554**

Multidose container with metering pump. */
    N100000143554,
    /** **100000143555**

Pack. */
    N100000143555,
    /** **100000163233**

disk. */
    N100000163233,
    /** **100000163234**

plunger. */
    N100000163234,
    /** **100000164143**

infusion port. */
    N100000164143,
    /** **100000166980**

Valve. */
    N100000166980,
    /** **100000169899**

Jerrycan. */
    N100000169899,
    /** **100000173982**

Oral applicator. */
    N100000173982,
    /** **100000173983**

Dose dispenser. */
    N100000173983,
    /** **100000174066**

Unit-dose blister. */
    N100000174066,
    /** **100000174067**

Pre-filled injector. */
    N100000174067,
    /** **100000174068**

Pre-filled oral syringe. */
    N100000174068,
    /** **100000174069**

Pre-filled oral applicator. */
    N100000174069,
    /** **100000174070**

Dose-dispenser cartridge. */
    N100000174070,
    /** **200000005068**

Pen. */
    N200000005068,
    /** **200000005585**

Wrapper. */
    N200000005585,
    /** **200000010647**

Lid. */
    N200000010647,
    /** **200000011726**

Capsule for opening. */
    N200000011726,
    /** **200000012539**

Child-resistant sachet. */
    N200000012539,
    /** **200000013191**

Tamper-evident closure. */
    N200000013191,
    /** **200000024874**

Tablet tube. */
    N200000024874,
}
impl ::core::str::FromStr for PackagingType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073490" => Ok(Self::N100000073490),
            "100000073491" => Ok(Self::N100000073491),
            "100000073492" => Ok(Self::N100000073492),
            "100000073493" => Ok(Self::N100000073493),
            "100000073494" => Ok(Self::N100000073494),
            "100000073495" => Ok(Self::N100000073495),
            "100000073496" => Ok(Self::N100000073496),
            "100000073497" => Ok(Self::N100000073497),
            "100000073498" => Ok(Self::N100000073498),
            "100000073499" => Ok(Self::N100000073499),
            "100000073500" => Ok(Self::N100000073500),
            "100000073501" => Ok(Self::N100000073501),
            "100000073502" => Ok(Self::N100000073502),
            "100000073503" => Ok(Self::N100000073503),
            "100000073504" => Ok(Self::N100000073504),
            "100000073505" => Ok(Self::N100000073505),
            "100000073506" => Ok(Self::N100000073506),
            "100000073507" => Ok(Self::N100000073507),
            "100000073508" => Ok(Self::N100000073508),
            "100000073509" => Ok(Self::N100000073509),
            "100000073510" => Ok(Self::N100000073510),
            "100000073511" => Ok(Self::N100000073511),
            "100000073512" => Ok(Self::N100000073512),
            "100000073513" => Ok(Self::N100000073513),
            "100000073514" => Ok(Self::N100000073514),
            "100000073515" => Ok(Self::N100000073515),
            "100000073516" => Ok(Self::N100000073516),
            "100000073517" => Ok(Self::N100000073517),
            "100000073518" => Ok(Self::N100000073518),
            "100000073519" => Ok(Self::N100000073519),
            "100000073520" => Ok(Self::N100000073520),
            "100000073521" => Ok(Self::N100000073521),
            "100000073522" => Ok(Self::N100000073522),
            "100000073523" => Ok(Self::N100000073523),
            "100000073524" => Ok(Self::N100000073524),
            "100000073525" => Ok(Self::N100000073525),
            "100000073526" => Ok(Self::N100000073526),
            "100000073527" => Ok(Self::N100000073527),
            "100000073528" => Ok(Self::N100000073528),
            "100000073529" => Ok(Self::N100000073529),
            "100000073530" => Ok(Self::N100000073530),
            "100000073531" => Ok(Self::N100000073531),
            "100000073532" => Ok(Self::N100000073532),
            "100000073533" => Ok(Self::N100000073533),
            "100000073534" => Ok(Self::N100000073534),
            "100000073535" => Ok(Self::N100000073535),
            "100000073536" => Ok(Self::N100000073536),
            "100000073537" => Ok(Self::N100000073537),
            "100000073538" => Ok(Self::N100000073538),
            "100000073539" => Ok(Self::N100000073539),
            "100000073540" => Ok(Self::N100000073540),
            "100000073541" => Ok(Self::N100000073541),
            "100000073542" => Ok(Self::N100000073542),
            "100000073543" => Ok(Self::N100000073543),
            "100000073544" => Ok(Self::N100000073544),
            "100000073545" => Ok(Self::N100000073545),
            "100000073546" => Ok(Self::N100000073546),
            "100000073547" => Ok(Self::N100000073547),
            "100000073548" => Ok(Self::N100000073548),
            "100000073549" => Ok(Self::N100000073549),
            "100000073550" => Ok(Self::N100000073550),
            "100000073551" => Ok(Self::N100000073551),
            "100000073552" => Ok(Self::N100000073552),
            "100000073553" => Ok(Self::N100000073553),
            "100000073554" => Ok(Self::N100000073554),
            "100000073555" => Ok(Self::N100000073555),
            "100000073556" => Ok(Self::N100000073556),
            "100000073557" => Ok(Self::N100000073557),
            "100000073558" => Ok(Self::N100000073558),
            "100000073559" => Ok(Self::N100000073559),
            "100000073560" => Ok(Self::N100000073560),
            "100000073561" => Ok(Self::N100000073561),
            "100000073562" => Ok(Self::N100000073562),
            "100000073563" => Ok(Self::N100000073563),
            "100000075664" => Ok(Self::N100000075664),
            "100000116195" => Ok(Self::N100000116195),
            "100000116196" => Ok(Self::N100000116196),
            "100000116197" => Ok(Self::N100000116197),
            "100000125779" => Ok(Self::N100000125779),
            "100000137702" => Ok(Self::N100000137702),
            "100000137703" => Ok(Self::N100000137703),
            "100000143554" => Ok(Self::N100000143554),
            "100000143555" => Ok(Self::N100000143555),
            "100000163233" => Ok(Self::N100000163233),
            "100000163234" => Ok(Self::N100000163234),
            "100000164143" => Ok(Self::N100000164143),
            "100000166980" => Ok(Self::N100000166980),
            "100000169899" => Ok(Self::N100000169899),
            "100000173982" => Ok(Self::N100000173982),
            "100000173983" => Ok(Self::N100000173983),
            "100000174066" => Ok(Self::N100000174066),
            "100000174067" => Ok(Self::N100000174067),
            "100000174068" => Ok(Self::N100000174068),
            "100000174069" => Ok(Self::N100000174069),
            "100000174070" => Ok(Self::N100000174070),
            "200000005068" => Ok(Self::N200000005068),
            "200000005585" => Ok(Self::N200000005585),
            "200000010647" => Ok(Self::N200000010647),
            "200000011726" => Ok(Self::N200000011726),
            "200000012539" => Ok(Self::N200000012539),
            "200000013191" => Ok(Self::N200000013191),
            "200000024874" => Ok(Self::N200000024874),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackagingType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073490 => "100000073490",
            Self::N100000073491 => "100000073491",
            Self::N100000073492 => "100000073492",
            Self::N100000073493 => "100000073493",
            Self::N100000073494 => "100000073494",
            Self::N100000073495 => "100000073495",
            Self::N100000073496 => "100000073496",
            Self::N100000073497 => "100000073497",
            Self::N100000073498 => "100000073498",
            Self::N100000073499 => "100000073499",
            Self::N100000073500 => "100000073500",
            Self::N100000073501 => "100000073501",
            Self::N100000073502 => "100000073502",
            Self::N100000073503 => "100000073503",
            Self::N100000073504 => "100000073504",
            Self::N100000073505 => "100000073505",
            Self::N100000073506 => "100000073506",
            Self::N100000073507 => "100000073507",
            Self::N100000073508 => "100000073508",
            Self::N100000073509 => "100000073509",
            Self::N100000073510 => "100000073510",
            Self::N100000073511 => "100000073511",
            Self::N100000073512 => "100000073512",
            Self::N100000073513 => "100000073513",
            Self::N100000073514 => "100000073514",
            Self::N100000073515 => "100000073515",
            Self::N100000073516 => "100000073516",
            Self::N100000073517 => "100000073517",
            Self::N100000073518 => "100000073518",
            Self::N100000073519 => "100000073519",
            Self::N100000073520 => "100000073520",
            Self::N100000073521 => "100000073521",
            Self::N100000073522 => "100000073522",
            Self::N100000073523 => "100000073523",
            Self::N100000073524 => "100000073524",
            Self::N100000073525 => "100000073525",
            Self::N100000073526 => "100000073526",
            Self::N100000073527 => "100000073527",
            Self::N100000073528 => "100000073528",
            Self::N100000073529 => "100000073529",
            Self::N100000073530 => "100000073530",
            Self::N100000073531 => "100000073531",
            Self::N100000073532 => "100000073532",
            Self::N100000073533 => "100000073533",
            Self::N100000073534 => "100000073534",
            Self::N100000073535 => "100000073535",
            Self::N100000073536 => "100000073536",
            Self::N100000073537 => "100000073537",
            Self::N100000073538 => "100000073538",
            Self::N100000073539 => "100000073539",
            Self::N100000073540 => "100000073540",
            Self::N100000073541 => "100000073541",
            Self::N100000073542 => "100000073542",
            Self::N100000073543 => "100000073543",
            Self::N100000073544 => "100000073544",
            Self::N100000073545 => "100000073545",
            Self::N100000073546 => "100000073546",
            Self::N100000073547 => "100000073547",
            Self::N100000073548 => "100000073548",
            Self::N100000073549 => "100000073549",
            Self::N100000073550 => "100000073550",
            Self::N100000073551 => "100000073551",
            Self::N100000073552 => "100000073552",
            Self::N100000073553 => "100000073553",
            Self::N100000073554 => "100000073554",
            Self::N100000073555 => "100000073555",
            Self::N100000073556 => "100000073556",
            Self::N100000073557 => "100000073557",
            Self::N100000073558 => "100000073558",
            Self::N100000073559 => "100000073559",
            Self::N100000073560 => "100000073560",
            Self::N100000073561 => "100000073561",
            Self::N100000073562 => "100000073562",
            Self::N100000073563 => "100000073563",
            Self::N100000075664 => "100000075664",
            Self::N100000116195 => "100000116195",
            Self::N100000116196 => "100000116196",
            Self::N100000116197 => "100000116197",
            Self::N100000125779 => "100000125779",
            Self::N100000137702 => "100000137702",
            Self::N100000137703 => "100000137703",
            Self::N100000143554 => "100000143554",
            Self::N100000143555 => "100000143555",
            Self::N100000163233 => "100000163233",
            Self::N100000163234 => "100000163234",
            Self::N100000164143 => "100000164143",
            Self::N100000166980 => "100000166980",
            Self::N100000169899 => "100000169899",
            Self::N100000173982 => "100000173982",
            Self::N100000173983 => "100000173983",
            Self::N100000174066 => "100000174066",
            Self::N100000174067 => "100000174067",
            Self::N100000174068 => "100000174068",
            Self::N100000174069 => "100000174069",
            Self::N100000174070 => "100000174070",
            Self::N200000005068 => "200000005068",
            Self::N200000005585 => "200000005585",
            Self::N200000010647 => "200000010647",
            Self::N200000011726 => "200000011726",
            Self::N200000012539 => "200000012539",
            Self::N200000013191 => "200000013191",
            Self::N200000024874 => "200000024874",
        }
    }
}
impl ::std::fmt::Debug for PackagingType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PackagingType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PackagingType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackagingType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PackagingType> for Coding {
    fn from(code: PackagingType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/packaging-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PackagingType> for CodeableConcept {
    fn from(code: PackagingType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ParticipantRequired](http://hl7.org/fhir/ValueSet/participantrequired)**. Is the Participant required to attend the appointment.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ParticipantRequired {
    /** **information-only**

Information Only. The participant is excluded from the appointment, and might not be informed of the appointment taking place. (Appointment is about them, not for them - such as 2 doctors discussing results about a patient's test). */
    InformationOnly,
    /** **optional**

Optional. The participant may optionally attend the appointment. */
    Optional,
    /** **required**

Required. The participant is required to attend the appointment. */
    Required,
}
impl ::core::str::FromStr for ParticipantRequired {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "information-only" => Ok(Self::InformationOnly),
            "optional" => Ok(Self::Optional),
            "required" => Ok(Self::Required),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ParticipantRequired {
    fn as_ref(&self) -> &str {
        match self {
            Self::InformationOnly => "information-only",
            Self::Optional => "optional",
            Self::Required => "required",
        }
    }
}
impl ::std::fmt::Debug for ParticipantRequired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ParticipantRequired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ParticipantRequired {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipantRequired {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ParticipantRequired> for Coding {
    fn from(code: ParticipantRequired) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/participantrequired".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ParticipantRequired> for CodeableConcept {
    fn from(code: ParticipantRequired) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ParticipantType](http://terminology.hl7.org/CodeSystem/participant-type)**. This codesystem defines a set of codes that can be used to indicate how an individual participates in an encounter.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ParticipantType {
    /** **emergency**

Emergency. A person to be contacted in case of an emergency during the encounter. */
    Emergency,
    /** **translator**

Translator. A translator who is facilitating communication with the patient during the encounter. */
    Translator,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "emergency" => Ok(Self::Emergency),
            "translator" => Ok(Self::Translator),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Emergency => "emergency",
            Self::Translator => "translator",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ParticipantType> for Coding {
    fn from(code: ParticipantType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/participant-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ParticipantType> for CodeableConcept {
    fn from(code: ParticipantType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ParticipationStatus](http://hl7.org/fhir/ValueSet/participationstatus)**. The Participation status of an appointment.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ParticipationStatus {
    /** **accepted**

Accepted. The participant has accepted the appointment. */
    Accepted,
    /** **declined**

Declined. The participant has declined the appointment and will not participate in the appointment. */
    Declined,
    /** **needs-action**

Needs Action. The participant needs to indicate if they accept the appointment by changing this status to one of the other statuses. */
    NeedsAction,
    /** **tentative**

Tentative. The participant has  tentatively accepted the appointment. This could be automatically created by a system and requires further processing before it can be accepted. There is no commitment that attendance will occur. */
    Tentative,
}
impl ::core::str::FromStr for ParticipationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "declined" => Ok(Self::Declined),
            "needs-action" => Ok(Self::NeedsAction),
            "tentative" => Ok(Self::Tentative),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ParticipationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Declined => "declined",
            Self::NeedsAction => "needs-action",
            Self::Tentative => "tentative",
        }
    }
}
impl ::std::fmt::Debug for ParticipationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ParticipationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ParticipationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ParticipationStatus> for Coding {
    fn from(code: ParticipationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/participationstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ParticipationStatus> for CodeableConcept {
    fn from(code: ParticipationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PatientMedicineChangeTypes](http://hl7.org/fhir/ValueSet/list-item-flag)**. Example Item Flags for the List Resource. In this case, these are the kind of flags that would be used on a medication list at the end of a consultation.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PatientMedicineChangeTypes {
    /** **01**

Unchanged. No change has been made to the status of this medicine item. */
    N01,
    /** **02**

Changed. The medicine item has changed. The change may be described in an extension (not defined yet) */
    N02,
    /** **03**

Cancelled. The prescription for this medicine item was cancelled by an authorized health care provider. The patient may be advised to complete the course of the prescribed medicine. This advice is a clinical decision made based on assessment of the patient's clinical condition. */
    N03,
    /** **04**

Prescribed. A new medicine item has been prescribed */
    N04,
    /** **05**

Ceased. Administration of this medication item that the patient is currently taking is stopped or recommended to be stopped (i.e. instructed to be ceased by a health care provider). This cessation is anticipated to be permanent. The Change Description should describe the reason for cessation. Example uses: the medication in question is considered ineffective or has caused serious adverse effects. This value applies both to the cessation of a medication that is prescribed by another healthcare provider or patient self-administration of OTC medicines. */
    N05,
    /** **06**

Suspended. Administration of this medication item that the patient is currently taking is on hold, or instructed or recommended by a health care provider to be temporarily stopped, or subject to clinical review (i.e. the stop may be temporary or permanent depending on the outcome of clinical review), or temporarily suspended as a pre-requisite to certain surgical or diagnostic procedures. */
    N06,
}
impl ::core::str::FromStr for PatientMedicineChangeTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "01" => Ok(Self::N01),
            "02" => Ok(Self::N02),
            "03" => Ok(Self::N03),
            "04" => Ok(Self::N04),
            "05" => Ok(Self::N05),
            "06" => Ok(Self::N06),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PatientMedicineChangeTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N01 => "01",
            Self::N02 => "02",
            Self::N03 => "03",
            Self::N04 => "04",
            Self::N05 => "05",
            Self::N06 => "06",
        }
    }
}
impl ::std::fmt::Debug for PatientMedicineChangeTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PatientMedicineChangeTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PatientMedicineChangeTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PatientMedicineChangeTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PatientMedicineChangeTypes> for Coding {
    fn from(code: PatientMedicineChangeTypes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/list-item-flag".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PatientMedicineChangeTypes> for CodeableConcept {
    fn from(code: PatientMedicineChangeTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PaymentAdjustmentReasonCodes](http://terminology.hl7.org/CodeSystem/payment-adjustment-reason)**. This value set includes smattering of Payment Adjustment Reason codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum PaymentAdjustmentReasonCodes {
    /** **a001**

Prior Payment Reversal. Prior Payment Reversal */
    A001,
    /** **a002**

Prior Overpayment. Prior Overpayment */
    A002,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PaymentAdjustmentReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a001" => Ok(Self::A001),
            "a002" => Ok(Self::A002),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PaymentAdjustmentReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::A001 => "a001",
            Self::A002 => "a002",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for PaymentAdjustmentReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PaymentAdjustmentReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PaymentAdjustmentReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PaymentAdjustmentReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PaymentAdjustmentReasonCodes> for Coding {
    fn from(code: PaymentAdjustmentReasonCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/payment-adjustment-reason"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PaymentAdjustmentReasonCodes> for CodeableConcept {
    fn from(code: PaymentAdjustmentReasonCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PaymentStatusCodes](http://terminology.hl7.org/CodeSystem/paymentstatus)**. This value set includes a sample set of Payment Status codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum PaymentStatusCodes {
    /** **cleared**

Cleared. The payment has been received by the payee. */
    Cleared,
    /** **paid**

Paid. The payment has been sent physically or electronically. */
    Paid,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PaymentStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cleared" => Ok(Self::Cleared),
            "paid" => Ok(Self::Paid),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PaymentStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cleared => "cleared",
            Self::Paid => "paid",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for PaymentStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PaymentStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PaymentStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PaymentStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PaymentStatusCodes> for Coding {
    fn from(code: PaymentStatusCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/paymentstatus".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PaymentStatusCodes> for CodeableConcept {
    fn from(code: PaymentStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PaymentTypeCodes](http://terminology.hl7.org/CodeSystem/ex-paymenttype)**. This value set includes a smattering of Payment Type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum PaymentTypeCodes {
    /** **complete**

Complete. Complete (final) payment of the benefit under the Claim less any adjustments. */
    Complete,
    /** **partial**

Partial. Partial payment of the benefit under the Claim less any adjustments. */
    Partial,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PaymentTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "partial" => Ok(Self::Partial),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PaymentTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Partial => "partial",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for PaymentTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PaymentTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PaymentTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PaymentTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PaymentTypeCodes> for Coding {
    fn from(code: PaymentTypeCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/ex-paymenttype".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PaymentTypeCodes> for CodeableConcept {
    fn from(code: PaymentTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PediatricUse](http://hl7.org/fhir/ValueSet/medicinal-product-pediatric-use)**. Suitability for age groups, in particular children.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PediatricUse {
    /** **Adolescents**

Adolescents (12 to < 18 years). Adolescents (12 to < 18 years) */
    Adolescents,
    /** **Adults**

Adults (18 to < 65 years). Adults (18 to < 65 years) */
    Adults,
    /** **AdultsAndElderly**

Adult and elderly population (> 18 years). Adult and elderly population (> 18 years) */
    AdultsAndElderly,
    /** **All**

All. All */
    All,
    /** **Children**

Children (2 to < 12 years). Children (2 to < 12 years) */
    Children,
    /** **Elderly**

Elderly (≥ 65 years). Elderly (≥ 65 years) */
    Elderly,
    /** **InUtero**

In utero. In utero */
    InUtero,
    /** **Infants**

Infants and toddlers (28 days – 23 months). Infants and toddlers (28 days – 23 months) */
    Infants,
    /** **Neonate**

Neonate. Neonate */
    Neonate,
    /** **PediatricPopulation**

Pediatric Population (< 18 years). Pediatric Population (< 18 years) */
    PediatricPopulation,
    /** **Prepubertal**

Prepubertal children (2 years to onset of puberty). Prepubertal children (2 years to onset of puberty) */
    Prepubertal,
    /** **PretermNewborn**

Preterm newborn infants (0 – 27 days). Preterm newborn infants (0 – 27 days) */
    PretermNewborn,
    /** **PubertalAndPostpubertal**

Pubertal and postpubertal adolescents (onset of puberty to < 18 years). Pubertal and postpubertal adolescents (onset of puberty to < 18 years) */
    PubertalAndPostpubertal,
    /** **TermNewborn**

Term newborn infants (0 – 27 days). Term newborn infants (0 – 27 days) */
    TermNewborn,
}
impl ::core::str::FromStr for PediatricUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Adolescents" => Ok(Self::Adolescents),
            "Adults" => Ok(Self::Adults),
            "AdultsAndElderly" => Ok(Self::AdultsAndElderly),
            "All" => Ok(Self::All),
            "Children" => Ok(Self::Children),
            "Elderly" => Ok(Self::Elderly),
            "InUtero" => Ok(Self::InUtero),
            "Infants" => Ok(Self::Infants),
            "Neonate" => Ok(Self::Neonate),
            "PediatricPopulation" => Ok(Self::PediatricPopulation),
            "Prepubertal" => Ok(Self::Prepubertal),
            "PretermNewborn" => Ok(Self::PretermNewborn),
            "PubertalAndPostpubertal" => Ok(Self::PubertalAndPostpubertal),
            "TermNewborn" => Ok(Self::TermNewborn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PediatricUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adolescents => "Adolescents",
            Self::Adults => "Adults",
            Self::AdultsAndElderly => "AdultsAndElderly",
            Self::All => "All",
            Self::Children => "Children",
            Self::Elderly => "Elderly",
            Self::InUtero => "InUtero",
            Self::Infants => "Infants",
            Self::Neonate => "Neonate",
            Self::PediatricPopulation => "PediatricPopulation",
            Self::Prepubertal => "Prepubertal",
            Self::PretermNewborn => "PretermNewborn",
            Self::PubertalAndPostpubertal => "PubertalAndPostpubertal",
            Self::TermNewborn => "TermNewborn",
        }
    }
}
impl ::std::fmt::Debug for PediatricUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PediatricUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PediatricUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PediatricUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PediatricUse> for Coding {
    fn from(code: PediatricUse) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-pediatric-use".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PediatricUse> for CodeableConcept {
    fn from(code: PediatricUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PlanDefinitionType](http://hl7.org/fhir/ValueSet/plan-definition-type)**. The type of PlanDefinition.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PlanDefinitionType {
    /** **clinical-protocol**

Clinical Protocol. Defines a desired/typical sequence of clinical activities including preconditions, triggers and temporal relationships. */
    ClinicalProtocol,
    /** **eca-rule**

ECA Rule. A decision support rule of the form [on Event] if Condition then Action. It is intended to be a shareable, computable definition of actions that should be taken whenever some condition is met in response to a particular event or events. */
    EcaRule,
    /** **order-set**

Order Set. A pre-defined and approved group of orders related to a particular clinical condition (e.g. hypertension treatment and monitoring) or stage of care (e.g. hospital admission to Coronary Care Unit). An order set is used as a checklist for the clinician when managing a patient with a specific condition. It is a structured collection of orders relevant to that condition and presented to the clinician in a computerized provider order entry (CPOE) system. */
    OrderSet,
    /** **workflow-definition**

Workflow Definition. Defines the steps for a group of one or more systems in an event flow process along with the step constraints, sequence, pre-conditions and decision points to complete a particular objective. */
    WorkflowDefinition,
}
impl ::core::str::FromStr for PlanDefinitionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "clinical-protocol" => Ok(Self::ClinicalProtocol),
            "eca-rule" => Ok(Self::EcaRule),
            "order-set" => Ok(Self::OrderSet),
            "workflow-definition" => Ok(Self::WorkflowDefinition),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PlanDefinitionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ClinicalProtocol => "clinical-protocol",
            Self::EcaRule => "eca-rule",
            Self::OrderSet => "order-set",
            Self::WorkflowDefinition => "workflow-definition",
        }
    }
}
impl ::std::fmt::Debug for PlanDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PlanDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PlanDefinitionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PlanDefinitionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PlanDefinitionType> for Coding {
    fn from(code: PlanDefinitionType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/plan-definition-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PlanDefinitionType> for CodeableConcept {
    fn from(code: PlanDefinitionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PolicyCodes](http://terminology.hl7.org/CodeSystem/consentpolicycodes)**. FHIR Specific Example codes for Consent Policy\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum PolicyCodes {
    /** **at-elga**

AT ELGA Opt-in Consent. Pursuant to Sec. 2 no. 9 Health Telematics Act 2012, ELGA Health Data ( “ELGA-Gesundheitsdaten”) = Medical documents. Austria opted for an opt-out approach. This means that a person is by default ‘ELGA participant’ unless he/she objects. ELGA participants have the following options: General opt out: No participation in ELGA, Partial opt-out: No participation in a particular ELGA application, e.g. eMedication and Case-specific opt-out: No participation in ELGA only regarding a particular case/treatment. There is the possibility to opt-in again. ELGA participants can also exclude the access of a particular ELGA healthcare provider to a particular piece of or all of their ELGA data. http://ec.europa.eu/health/ehealth/docs/laws_austria_en.pdf */
    AtElga,
    /** **cric**

Common Rule Informed Consent. 45 CFR part 46 §46.116 General requirements for informed consent; and §46.117 Documentation of informed consent. https://www.gpo.gov/fdsys/pkg/FR-2017-01-19/pdf/2017-01058.pdf */
    Cric,
    /** **dch-3927**

Michigan behavior and mental health consent. Michigan DCH-3927 Consent to Share Behavioral Health Information for Care Coordination Purposes, which combines 42 CFR Part 2 and Michigan Mental Health Code, Act 258 of 1974. Form is available at http://www.michigan.gov/documents/mdch/DCH-3927_Consent_to_Share_Health_Information_477005_7.docx */
    Dch3927,
    /** **ga4gh**

Population origins and ancestry research consent. Global Alliance for Genomic Health Data Sharing Consent Form is an example of the GA4GH Population origins and ancestry research consent form. Consenters agree to permitting a specified research project to collect ancestry and genetic information in controlled-access databases, and to allow other researchers to use deidentified information from those databases. http://www.commonaccord.org/index.php?action=doc&file=Wx/org/genomicsandhealth/REWG/Demo/Roberta_Robinson_US */
    Ga4Gh,
    /** **hipaa-auth**

HIPAA Authorization. HIPAA 45 CFR Section 164.508 Uses and disclosures for which an authorization is required. (a) Standard: Authorizations for uses and disclosures. (1) Authorization required: General rule. Except as otherwise permitted or required by this subchapter, a covered entity SHALL not use or disclose protected health information without an authorization that is valid under this section. When a covered entity obtains or receives a valid authorization for its use or disclosure of protected health information, such use or disclosure must be consistent with such authorization. Usage Note: Authorizations governed under this regulation meet the definition of an opt in class of consent directive. */
    HipaaAuth,
    /** **hipaa-npp**

HIPAA Notice of Privacy Practices. 164.520  Notice of privacy practices for protected health information. (1) Right to notice. Except as provided by paragraph (a)(2) or (3) of this section, an individual has a right to adequate notice of the uses and disclosures of protected health information that may be made by the covered entity, and of the individual's rights and the covered entity's legal duties with respect to protected health information. Usage Note: Restrictions governed under this regulation meet the definition of an implied with an opportunity to dissent class of consent directive. */
    HipaaNpp,
    /** **hipaa-research**

HIPAA Research Authorization. HIPAA 45 CFR 164.508 - Uses and disclosures for which an authorization is required. (a) Standard: Authorizations for uses and disclosures. (3) Compound authorizations. An authorization for use or disclosure of protected health information SHALL NOT be combined with any other document to create a compound authorization, except as follows: (i) An authorization for the use or disclosure of protected health information for a research study may be combined with any other type of written permission for the same or another research study. This exception includes combining an authorization for the use or disclosure of protected health information for a research study with another authorization for the same research study, with an authorization for the creation or maintenance of a research database or repository, or with a consent to participate in research. Where a covered health care provider has conditioned the provision of research-related treatment on the provision of one of the authorizations, as permitted under paragraph (b)(4)(i) of this section, any compound authorization created under this paragraph must clearly differentiate between the conditioned and unconditioned components and provide the individual with an opportunity to opt in to the research activities described in the unconditioned authorization. Usage Notes: See HHS http://www.hhs.gov/hipaa/for-professionals/special-topics/research/index.html and OCR http://www.hhs.gov/hipaa/for-professionals/special-topics/research/index.html */
    HipaaResearch,
    /** **hipaa-restrictions**

HIPAA Restrictions. HIPAA 45 CFR 164.510 - Uses and disclosures requiring an opportunity for the individual to agree or to object. A covered entity may use or disclose protected health information, provided that the individual is informed in advance of the use or disclosure and has the opportunity to agree to or prohibit or restrict the use or disclosure, in accordance with the applicable requirements of this section. The covered entity may orally inform the individual of and obtain the individual's oral agreement or objection to a use or disclosure permitted by this section. Usage Note: Restrictions governed under this regulation meet the definition of an opt out with exception class of consent directive. */
    HipaaRestrictions,
    /** **hipaa-self-pay**

HIPAA Self-Pay Restriction. HIPAA 45 CFR 164.522(a) Right To Request a Restriction of Uses and Disclosures. (vi) A covered entity must agree to the request of an individual to restrict disclosure of protected health information about the individual to a health plan if: (A) The disclosure is for the purpose of carrying out payment or health care operations and is not otherwise required by law; and (B) The protected health information pertains solely to a health care item or service for which the individual, or person other than the health plan on behalf of the individual, has paid the covered entity in full. Usage Note: Restrictions governed under this regulation meet the definition of an opt out with exception class of consent directive. Opt out is limited to disclosures to a payer for payment and operations purpose of use. See HL7 HIPAA Self-Pay code in ActPrivacyLaw (2.16.840.1.113883.1.11.20426). */
    HipaaSelfPay,
    /** **illinois-minor-procedure**

Illinois Consent by Minors to Medical Procedures. The consent to the performance of a medical or surgical procedure by a physician licensed to practice medicine and surgery, a licensed advanced practice nurse, or a licensed physician assistant executed by a married person who is a minor, by a parent who is a minor, by a pregnant woman who is a minor, or by any person 18 years of age or older, is not voidable because of such minority, and, for such purpose, a married person who is a minor, a parent who is a minor, a pregnant woman who is a minor, or any person 18 years of age or older, is deemed to have the same legal capacity to act and has the same powers and obligations as has a person of legal age. Consent by Minors to Medical Procedures Act. (410 ILCS 210/0.01) (from Ch. 111, par. 4500) Sec. 0.01. Short title. This Act may be cited as the Consent by Minors to Medical Procedures Act. (Source: P.A. 86-1324.) http://www.ilga.gov/legislation/ilcs/ilcs3.asp?ActID=1539&ChapterID=35 */
    IllinoisMinorProcedure,
    /** **mdhhs-5515**

Michigan MDHHS-5515 Consent to Share Behavioral Health Information for Care Coordination Purposes. On January 1, 2015, the Michigan Department of Health and Human Services (MDHHS) released a standard consent form for the sharing of health information specific to behavioral health and substance use treatment in accordance with Public Act 129 of 2014. In Michigan, while providers are not required to use this new standard form (MDHHS-5515), they are required to accept it. Note: Form is available at http://www.michigan.gov/documents/mdhhs/Consent_to_Share_Behavioral_Health_Information_for_Care_Coordination_Purposes_548835_7.docx For more information see http://www.michigan.gov/documents/mdhhs/Behavioral_Health_Consent_Form_Background_Information_548864_7.pdf */
    Mdhhs5515,
    /** **nci**

NCI Cancer Clinical Trial consent. see http://ctep.cancer.gov/protocolDevelopment/docs/Informed_Consent_Template.docx */
    Nci,
    /** **nih-527**

NIH Authorization for the Release of Medical Information. NIH Authorization for the Release of Medical Information is a patient’s consent for the National Institutes of Health Clinical Center to release medical information to care providers, which can be revoked. Note: Consent Form available @ http://cc.nih.gov/participate/_pdf/NIH-527.pdf */
    Nih527,
    /** **nih-grdr**

NIH Global Rare Disease Patient Registry and Data Repository consent. Global Rare Disease Patient Registry and Data Repository (GRDR) consent is an agreement of a healthcare consumer to permit collection, access, use and disclosure of de-identified rare disease information and collection of bio-specimens, medical information, family history and other related information from patients to permit the registry collection of health and genetic information, and specimens for pseudonymized disclosure for research purpose of use. https://rarediseases.info.nih.gov/files/informed_consent_template.pdf */
    NihGrdr,
    /** **nih-hipaa**

HHS NIH HIPAA Research Authorization. Guidance and template form https://privacyruleandresearch.nih.gov/pdf/authorization.pdf */
    NihHipaa,
    /** **nl-lsp**

NL LSP Permission. LSP (National Exchange Point) requires that providers, hospitals and pharmacy obtain explicit permission [opt-in] from healthcare consumers to submit and retrieve all or only some of a subject of care’s health information collected by the LSP for purpose of treatment, which can be revoked.  Without permission, a provider cannot access LSP information even in an emergency. The LSP provides healthcare consumers with accountings of disclosures. https://www.vzvz.nl/uploaded/FILES/htmlcontent/Formulieren/TOESTEMMINGSFORMULIER.pdf, https://www.ikgeeftoestemming.nl/en, https://www.ikgeeftoestemming.nl/en/registration/find-healthcare-provider */
    NlLsp,
    /** **nyssipp**

New York State Surgical and Invasive Procedure Protocol. The New York State Surgical and Invasive Procedure Protocol (NYSSIPP) applies to all operative and invasive procedures including endoscopy, general surgery or interventional radiology. Other procedures that involve puncture or incision of the skin, or insertion of an instrument or foreign material into the body are within the scope of the protocol. This protocol also applies to those anesthesia procedures either prior to a surgical procedure or independent of a surgical procedure such as spinal facet blocks. Example: Certain 'minor' procedures such as venipuncture, peripheral IV placement, insertion of nasogastric tube and foley catheter insertion are not within the scope of the protocol. From http://www.health.ny.gov/professionals/protocols_and_guidelines/surgical_and_invasive_procedure/nyssipp_faq.htm Note: HHC 100B-1 Form is available at http://www.downstate.edu/emergency_medicine/documents/Consent_CT_with_contrast.pdf */
    Nyssipp,
    /** **squaxin**

Squaxin Indian behavioral health and HIPAA consent. Squaxin Indian HIPAA and 42 CFR Part 2 Consent for Release and Exchange of Confidential Information, which permits consenter to select healthcare record type and types of treatment purposes.  This consent requires disclosers and recipients to comply with 42 C.F.R. Part 2, and HIPAA 45 C.F.R. parts 160 and 164. It includes patient notice of the refrain policy not to disclose without consent, and revocation rights. https://www.ncsacw.samhsa.gov/files/SI_ConsentForReleaseAndExchange.PDF */
    Squaxin,
    /** **ssa-827**

SSA Authorization to Disclose. SA Form SSA-827 (Authorization to Disclose Information to the Social Security Administration (SSA)). Form is available at https://www.socialsecurity.gov/forms/ssa-827-inst-sp.pdf */
    Ssa827,
    /** **va-10-0484**

VA Form 10-0484. VA Form 10-0484 Revocation for Release of Individually-Identifiable Health Information enables a veteran to revoke authorization for the VA to release specified copies of individually-identifiable health information with the non-VA health care provider organizations participating in the eHealth Exchange and partnering with VA. Comment: Opt-in Consent Directive with status = rescinded (aka 'revoked'). Note: Form is available at http://www.va.gov/vaforms/medical/pdf/vha-10-0484-fill.pdf */
    Va100484,
    /** **va-10-0485**

VA Form 10-0485. VA Form 10-0485 Request for and Authorization to Release Protected Health Information to eHealth Exchange enables a veteran to request and authorize a VA health care facility to release protected health information (PHI) for treatment purposes only to the communities that are participating in the eHealth Exchange, VLER Directive, and other Health Information Exchanges with who VA has an agreement. This information may consist of the diagnosis of Sickle Cell Anemia, the treatment of or referral for Drug Abuse, treatment of or referral for Alcohol Abuse or the treatment of or testing for infection with Human Immunodeficiency Virus. This authorization covers the diagnoses that I may have upon signing of the authorization and the diagnoses that I may acquire in the future including those protected by 38 U.S.C. 7332. Comment: Opt-in Consent Directive. Note: Form is available at http://www.va.gov/vaforms/medical/pdf/10-0485-fill.pdf */
    Va100485,
    /** **va-10-10116**

VA Form 10-10-10116. VA Form 10-10116 Revocation of Authorization for Use and Release of Individually Identifiable Health Information for Veterans Health Administration Research. Comment: Opt-in with Restriction Consent Directive with status = 'completed'. Note: Form is available at http://www.northerncalifornia.va.gov/northerncalifornia/services/rnd/docs/vha-10-10116.pdf */
    Va1010116,
    /** **va-10-5345**

VA Form 10-5345. VA Form 10-5345 Request for and Authorization to Release Medical Records or Health Information enables a veteran to request and authorize the VA to release specified copies of protected health information (PHI), such as hospital summary or outpatient treatment notes, which may include information about conditions governed under Title 38 Section 7332 (drug abuse, alcoholism or alcohol abuse, testing for or infection with HIV, and sickle cell anemia). Comment: Opt-in Consent Directive. Note: Form is available at http://www.va.gov/vaforms/medical/pdf/vha-10-5345-fill.pdf */
    Va105345,
    /** **va-10-5345a**

VA Form 10-5345a. VA Form 10-5345a Individuals' Request for a Copy of Their Own Health Information enables a veteran to request and authorize the VA to release specified copies of protected health information (PHI), such as hospital summary or outpatient treatment notes. Note: Form is available at http://www.va.gov/vaforms/medical/pdf/vha-10-5345a-fill.pdf */
    Va105345A,
    /** **va-10-5345a-mhv**

VA Form 10-5345a-MHV. VA Form 10-5345a-MHV Individual's Request for a Copy of their own health information from MyHealtheVet enables a veteran to receive a copy of all available personal health information to be delivered through the veteran's My HealtheVet account. Note: Form is available at http://www.va.gov/vaforms/medical/pdf/vha-10-5345a-MHV-fill.pdf */
    Va105345AMhv,
    /** **va-21-4142**

VA Form 21-4142. VA Form 21-4142 (Authorization and Consent to Release Information to the Department of Veterans Affairs (VA) enables a veteran to authorize the US Veterans Administration [VA] to request veteran's health information from non-VA providers. Aka VA Compensation Application Note: Form is available at http://www.vba.va.gov/pubs/forms/VBA-21-4142-ARE.pdf . For additional information regarding VA Form 21-4142, refer to the following website: www.benefits.va.gov/compensation/consent_privateproviders */
    Va214142,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PolicyCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "at-elga" => Ok(Self::AtElga),
            "cric" => Ok(Self::Cric),
            "dch-3927" => Ok(Self::Dch3927),
            "ga4gh" => Ok(Self::Ga4Gh),
            "hipaa-auth" => Ok(Self::HipaaAuth),
            "hipaa-npp" => Ok(Self::HipaaNpp),
            "hipaa-research" => Ok(Self::HipaaResearch),
            "hipaa-restrictions" => Ok(Self::HipaaRestrictions),
            "hipaa-self-pay" => Ok(Self::HipaaSelfPay),
            "illinois-minor-procedure" => Ok(Self::IllinoisMinorProcedure),
            "mdhhs-5515" => Ok(Self::Mdhhs5515),
            "nci" => Ok(Self::Nci),
            "nih-527" => Ok(Self::Nih527),
            "nih-grdr" => Ok(Self::NihGrdr),
            "nih-hipaa" => Ok(Self::NihHipaa),
            "nl-lsp" => Ok(Self::NlLsp),
            "nyssipp" => Ok(Self::Nyssipp),
            "squaxin" => Ok(Self::Squaxin),
            "ssa-827" => Ok(Self::Ssa827),
            "va-10-0484" => Ok(Self::Va100484),
            "va-10-0485" => Ok(Self::Va100485),
            "va-10-10116" => Ok(Self::Va1010116),
            "va-10-5345" => Ok(Self::Va105345),
            "va-10-5345a" => Ok(Self::Va105345A),
            "va-10-5345a-mhv" => Ok(Self::Va105345AMhv),
            "va-21-4142" => Ok(Self::Va214142),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PolicyCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::AtElga => "at-elga",
            Self::Cric => "cric",
            Self::Dch3927 => "dch-3927",
            Self::Ga4Gh => "ga4gh",
            Self::HipaaAuth => "hipaa-auth",
            Self::HipaaNpp => "hipaa-npp",
            Self::HipaaResearch => "hipaa-research",
            Self::HipaaRestrictions => "hipaa-restrictions",
            Self::HipaaSelfPay => "hipaa-self-pay",
            Self::IllinoisMinorProcedure => "illinois-minor-procedure",
            Self::Mdhhs5515 => "mdhhs-5515",
            Self::Nci => "nci",
            Self::Nih527 => "nih-527",
            Self::NihGrdr => "nih-grdr",
            Self::NihHipaa => "nih-hipaa",
            Self::NlLsp => "nl-lsp",
            Self::Nyssipp => "nyssipp",
            Self::Squaxin => "squaxin",
            Self::Ssa827 => "ssa-827",
            Self::Va100484 => "va-10-0484",
            Self::Va100485 => "va-10-0485",
            Self::Va1010116 => "va-10-10116",
            Self::Va105345 => "va-10-5345",
            Self::Va105345A => "va-10-5345a",
            Self::Va105345AMhv => "va-10-5345a-mhv",
            Self::Va214142 => "va-21-4142",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for PolicyCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PolicyCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PolicyCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PolicyCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PolicyCodes> for Coding {
    fn from(code: PolicyCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/consentpolicycodes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PolicyCodes> for CodeableConcept {
    fn from(code: PolicyCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PriorityCodes](http://terminology.hl7.org/CodeSystem/processpriority)**. This value set includes the financial processing priority codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum PriorityCodes {
    /** **deferred**

Deferred. Later, when possible. */
    Deferred,
    /** **normal**

Normal. With best effort. */
    Normal,
    /** **stat**

Immediate. Immediately in real time. */
    Stat,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PriorityCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deferred" => Ok(Self::Deferred),
            "normal" => Ok(Self::Normal),
            "stat" => Ok(Self::Stat),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PriorityCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deferred => "deferred",
            Self::Normal => "normal",
            Self::Stat => "stat",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for PriorityCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PriorityCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PriorityCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PriorityCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PriorityCodes> for Coding {
    fn from(code: PriorityCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/processpriority".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PriorityCodes> for CodeableConcept {
    fn from(code: PriorityCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProcedureDeviceActionCodes](http://hl7.org/fhir/device-action)**. Example value set for Procedure Device Action code (what happened to a device during a procedure.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ProcedureDeviceActionCodes {
    /** **explanted**

Explanted. The device was explanted from the patient during the procedure. */
    Explanted,
    /** **implanted**

Implanted. The device was implanted in the patient during the procedure. */
    Implanted,
    /** **manipulated**

Manipulated. The device remains in the patient, but its location, settings, or functionality was changed. */
    Manipulated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ProcedureDeviceActionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "explanted" => Ok(Self::Explanted),
            "implanted" => Ok(Self::Implanted),
            "manipulated" => Ok(Self::Manipulated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ProcedureDeviceActionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Explanted => "explanted",
            Self::Implanted => "implanted",
            Self::Manipulated => "manipulated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ProcedureDeviceActionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProcedureDeviceActionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProcedureDeviceActionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProcedureDeviceActionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProcedureDeviceActionCodes> for Coding {
    fn from(code: ProcedureDeviceActionCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/device-action".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProcedureDeviceActionCodes> for CodeableConcept {
    fn from(code: ProcedureDeviceActionCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProcedureProgressStatusCodes](http://hl7.org/fhir/procedure-progress-status-code)**. This value set is provided as an exemplar. The value set to instantiate this attribute should be drawn from a terminologically robust code system that consists of or contains concepts to support the procedure performance process.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ProcedureProgressStatusCodes {
    /** **anesthesia-induced**

Anesthesia Induced. The patient is under anesthesia. */
    AnesthesiaInduced,
    /** **closed-incision**

Closed Incision. The patient has incision(s) closed. */
    ClosedIncision,
    /** **in-operating-room**

In Operating Room. A patient is in the Operating Room. */
    InOperatingRoom,
    /** **in-recovery-room**

In Recovery Room. The patient is in the recovery room. */
    InRecoveryRoom,
    /** **open-incision**

Open Incision. The patient has open incision(s). */
    OpenIncision,
    /** **prepared**

Prepared. The patient is prepared for a procedure. */
    Prepared,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ProcedureProgressStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "anesthesia-induced" => Ok(Self::AnesthesiaInduced),
            "closed-incision" => Ok(Self::ClosedIncision),
            "in-operating-room" => Ok(Self::InOperatingRoom),
            "in-recovery-room" => Ok(Self::InRecoveryRoom),
            "open-incision" => Ok(Self::OpenIncision),
            "prepared" => Ok(Self::Prepared),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ProcedureProgressStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::AnesthesiaInduced => "anesthesia-induced",
            Self::ClosedIncision => "closed-incision",
            Self::InOperatingRoom => "in-operating-room",
            Self::InRecoveryRoom => "in-recovery-room",
            Self::OpenIncision => "open-incision",
            Self::Prepared => "prepared",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ProcedureProgressStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProcedureProgressStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProcedureProgressStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProcedureProgressStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProcedureProgressStatusCodes> for Coding {
    fn from(code: ProcedureProgressStatusCodes) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/procedure-progress-status-code".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProcedureProgressStatusCodes> for CodeableConcept {
    fn from(code: ProcedureProgressStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProductConfidentiality](http://hl7.org/fhir/ValueSet/medicinal-product-confidentiality)**. Confidentiality rating, e.g. commercial sensitivity for a Medicinal Product.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProductConfidentiality {
    /** **CommerciallySensitive**

Commercially Sensitive. Commercially Sensitive */
    CommerciallySensitive,
    /** **NotCommerciallySensitive**

Not Commercially Sensitive. Not Commercially Sensitive */
    NotCommerciallySensitive,
}
impl ::core::str::FromStr for ProductConfidentiality {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CommerciallySensitive" => Ok(Self::CommerciallySensitive),
            "NotCommerciallySensitive" => Ok(Self::NotCommerciallySensitive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductConfidentiality {
    fn as_ref(&self) -> &str {
        match self {
            Self::CommerciallySensitive => "CommerciallySensitive",
            Self::NotCommerciallySensitive => "NotCommerciallySensitive",
        }
    }
}
impl ::std::fmt::Debug for ProductConfidentiality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProductConfidentiality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProductConfidentiality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductConfidentiality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductConfidentiality> for Coding {
    fn from(code: ProductConfidentiality) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-confidentiality"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProductConfidentiality> for CodeableConcept {
    fn from(code: ProductConfidentiality) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProductContactType](http://hl7.org/fhir/ValueSet/medicinal-product-contact-type)**. Contact type for a Medicinal Product.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProductContactType {
    /** **PVEnquiries**

Pharmacovigilance Enquiry Information. Pharmacovigilance Enquiry Information */
    Pvenquiries,
    /** **ProcedureContactAfter**

Person/Company authorised for Communication after procedure. Person/Company authorised for Communication between MAH and Authorities after Authorisation */
    ProcedureContactAfter,
    /** **ProcedureContactDuring**

Person/Company authorised for Communication during procedure. Person/Company authorised for Communication on behalf of the Applicant during the Procedure */
    ProcedureContactDuring,
    /** **ProposedMAH**

Proposed Marketing Authorisation Holder/Person. Proposed Marketing Authorisation Holder/Person */
    ProposedMAH,
    /** **QPPV**

Qualified Person Responsible for Pharmacovigilance. Qualified Person Responsible for Pharmacovigilance */
    Qppv,
}
impl ::core::str::FromStr for ProductContactType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "PVEnquiries" => Ok(Self::Pvenquiries),
            "ProcedureContactAfter" => Ok(Self::ProcedureContactAfter),
            "ProcedureContactDuring" => Ok(Self::ProcedureContactDuring),
            "ProposedMAH" => Ok(Self::ProposedMAH),
            "QPPV" => Ok(Self::Qppv),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductContactType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Pvenquiries => "PVEnquiries",
            Self::ProcedureContactAfter => "ProcedureContactAfter",
            Self::ProcedureContactDuring => "ProcedureContactDuring",
            Self::ProposedMAH => "ProposedMAH",
            Self::Qppv => "QPPV",
        }
    }
}
impl ::std::fmt::Debug for ProductContactType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProductContactType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProductContactType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductContactType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductContactType> for Coding {
    fn from(code: ProductContactType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-contact-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProductContactType> for CodeableConcept {
    fn from(code: ProductContactType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProductCrossReferenceType](http://hl7.org/fhir/ValueSet/medicinal-product-cross-reference-type)**. Relationship to another Medicinal Product.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProductCrossReferenceType {
    /** **ActualProduct**

Link Virtual to Actual Product. Link Virtual to Actual Product */
    ActualProduct,
    /** **BrandedProduct**

Link Generic to Branded Product. Link Generic to Branded Product */
    BrandedProduct,
    /** **GenericProduct**

Link Branded to Generic Product. Link Branded to Generic Product */
    GenericProduct,
    /** **InvestigationalProduct**

Link to Investigational Product. Link to Investigational (Development) Product */
    InvestigationalProduct,
    /** **Parallel**

Link to Parallel Import Product. Link to Parallel Import Product */
    Parallel,
    /** **VirtualProduct**

Link Actual to Virtual Product. Link Actual to Virtual Product */
    VirtualProduct,
}
impl ::core::str::FromStr for ProductCrossReferenceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActualProduct" => Ok(Self::ActualProduct),
            "BrandedProduct" => Ok(Self::BrandedProduct),
            "GenericProduct" => Ok(Self::GenericProduct),
            "InvestigationalProduct" => Ok(Self::InvestigationalProduct),
            "Parallel" => Ok(Self::Parallel),
            "VirtualProduct" => Ok(Self::VirtualProduct),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductCrossReferenceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActualProduct => "ActualProduct",
            Self::BrandedProduct => "BrandedProduct",
            Self::GenericProduct => "GenericProduct",
            Self::InvestigationalProduct => "InvestigationalProduct",
            Self::Parallel => "Parallel",
            Self::VirtualProduct => "VirtualProduct",
        }
    }
}
impl ::std::fmt::Debug for ProductCrossReferenceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProductCrossReferenceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProductCrossReferenceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductCrossReferenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductCrossReferenceType> for Coding {
    fn from(code: ProductCrossReferenceType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-cross-reference-type"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProductCrossReferenceType> for CodeableConcept {
    fn from(code: ProductCrossReferenceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProductIntendedUse](http://hl7.org/fhir/ValueSet/product-intended-use)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProductIntendedUse {
    /** **Alleviation**

Alleviation. */
    Alleviation,
    /** **Diagnosis**

Diagnosis. */
    Diagnosis,
    /** **Monitoring**

Monitoring. */
    Monitoring,
    /** **Prevention**

Prevention. */
    Prevention,
    /** **Treatment**

Treatment. */
    Treatment,
}
impl ::core::str::FromStr for ProductIntendedUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Alleviation" => Ok(Self::Alleviation),
            "Diagnosis" => Ok(Self::Diagnosis),
            "Monitoring" => Ok(Self::Monitoring),
            "Prevention" => Ok(Self::Prevention),
            "Treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductIntendedUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alleviation => "Alleviation",
            Self::Diagnosis => "Diagnosis",
            Self::Monitoring => "Monitoring",
            Self::Prevention => "Prevention",
            Self::Treatment => "Treatment",
        }
    }
}
impl ::std::fmt::Debug for ProductIntendedUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProductIntendedUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProductIntendedUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductIntendedUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductIntendedUse> for Coding {
    fn from(code: ProductIntendedUse) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/product-intended-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProductIntendedUse> for CodeableConcept {
    fn from(code: ProductIntendedUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProductNamePartType](http://hl7.org/fhir/ValueSet/medicinal-product-name-part-type)**. Type of part of a name for a Medicinal Product.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProductNamePartType {
    /** **ContainerPart**

Container or pack part. */
    ContainerPart,
    /** **DelimiterPart**

Delimiter part. */
    DelimiterPart,
    /** **DevicePart**

Device part. */
    DevicePart,
    /** **DoseFormPart**

Pharmaceutical dose form part. */
    DoseFormPart,
    /** **FlavorPart**

Flavor part. */
    FlavorPart,
    /** **FormulationPart**

Formulation part. */
    FormulationPart,
    /** **FullName**

Full name. */
    FullName,
    /** **IntendedUsePart**

Intended use part. */
    IntendedUsePart,
    /** **InventedNamePart**

Invented name part. */
    InventedNamePart,
    /** **LegacyNamePart**

Legacy name. */
    LegacyNamePart,
    /** **PopulationPart**

Target population part. */
    PopulationPart,
    /** **ScientificNamePart**

Scientific name part. */
    ScientificNamePart,
    /** **SpeciesNamePart**

Target species name part. */
    SpeciesNamePart,
    /** **StrengthPart**

Strength part. */
    StrengthPart,
    /** **TimeOrPeriodPart**

Time/Period part. */
    TimeOrPeriodPart,
    /** **TrademarkOrCompanyPart**

Trademark or company name part. */
    TrademarkOrCompanyPart,
}
impl ::core::str::FromStr for ProductNamePartType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ContainerPart" => Ok(Self::ContainerPart),
            "DelimiterPart" => Ok(Self::DelimiterPart),
            "DevicePart" => Ok(Self::DevicePart),
            "DoseFormPart" => Ok(Self::DoseFormPart),
            "FlavorPart" => Ok(Self::FlavorPart),
            "FormulationPart" => Ok(Self::FormulationPart),
            "FullName" => Ok(Self::FullName),
            "IntendedUsePart" => Ok(Self::IntendedUsePart),
            "InventedNamePart" => Ok(Self::InventedNamePart),
            "LegacyNamePart" => Ok(Self::LegacyNamePart),
            "PopulationPart" => Ok(Self::PopulationPart),
            "ScientificNamePart" => Ok(Self::ScientificNamePart),
            "SpeciesNamePart" => Ok(Self::SpeciesNamePart),
            "StrengthPart" => Ok(Self::StrengthPart),
            "TimeOrPeriodPart" => Ok(Self::TimeOrPeriodPart),
            "TrademarkOrCompanyPart" => Ok(Self::TrademarkOrCompanyPart),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductNamePartType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ContainerPart => "ContainerPart",
            Self::DelimiterPart => "DelimiterPart",
            Self::DevicePart => "DevicePart",
            Self::DoseFormPart => "DoseFormPart",
            Self::FlavorPart => "FlavorPart",
            Self::FormulationPart => "FormulationPart",
            Self::FullName => "FullName",
            Self::IntendedUsePart => "IntendedUsePart",
            Self::InventedNamePart => "InventedNamePart",
            Self::LegacyNamePart => "LegacyNamePart",
            Self::PopulationPart => "PopulationPart",
            Self::ScientificNamePart => "ScientificNamePart",
            Self::SpeciesNamePart => "SpeciesNamePart",
            Self::StrengthPart => "StrengthPart",
            Self::TimeOrPeriodPart => "TimeOrPeriodPart",
            Self::TrademarkOrCompanyPart => "TrademarkOrCompanyPart",
        }
    }
}
impl ::std::fmt::Debug for ProductNamePartType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProductNamePartType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProductNamePartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductNamePartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductNamePartType> for Coding {
    fn from(code: ProductNamePartType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-name-part-type"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProductNamePartType> for CodeableConcept {
    fn from(code: ProductNamePartType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProductNameType](http://hl7.org/fhir/ValueSet/medicinal-product-name-type)**. Type of a name for a Medicinal Product.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProductNameType {
    /** **BAN**

British Approved Name. */
    Ban,
    /** **INN**

International Non-Proprietary Name. */
    Inn,
    /** **INNM**

Modified International Non-Proprietary Name. */
    Innm,
    /** **pINN**

Proposed International Non-Proprietary Name. */
    Pinn,
    /** **rINN**

Recommended International Non-Proprietary Name. */
    Rinn,
}
impl ::core::str::FromStr for ProductNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BAN" => Ok(Self::Ban),
            "INN" => Ok(Self::Inn),
            "INNM" => Ok(Self::Innm),
            "pINN" => Ok(Self::Pinn),
            "rINN" => Ok(Self::Rinn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ban => "BAN",
            Self::Inn => "INN",
            Self::Innm => "INNM",
            Self::Pinn => "pINN",
            Self::Rinn => "rINN",
        }
    }
}
impl ::std::fmt::Debug for ProductNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProductNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProductNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductNameType> for Coding {
    fn from(code: ProductNameType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-name-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProductNameType> for CodeableConcept {
    fn from(code: ProductNameType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PropertyRepresentation](http://hl7.org/fhir/ValueSet/property-representation)**. How a property is represented when serialized.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PropertyRepresentation {
    /** **cdaText**

CDA Text Format. Use CDA narrative instead of XHTML. */
    CdaText,
    /** **typeAttr**

Type Attribute. The type of this element is indicated using xsi:type. */
    TypeAttr,
    /** **xhtml**

XHTML. The property is represented using XHTML. */
    Xhtml,
    /** **xmlAttr**

XML Attribute. In XML, this property is represented as an attribute not an element. */
    XmlAttr,
    /** **xmlText**

XML Text. This element is represented using the XML text attribute (primitives only). */
    XmlText,
}
impl ::core::str::FromStr for PropertyRepresentation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cdaText" => Ok(Self::CdaText),
            "typeAttr" => Ok(Self::TypeAttr),
            "xhtml" => Ok(Self::Xhtml),
            "xmlAttr" => Ok(Self::XmlAttr),
            "xmlText" => Ok(Self::XmlText),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PropertyRepresentation {
    fn as_ref(&self) -> &str {
        match self {
            Self::CdaText => "cdaText",
            Self::TypeAttr => "typeAttr",
            Self::Xhtml => "xhtml",
            Self::XmlAttr => "xmlAttr",
            Self::XmlText => "xmlText",
        }
    }
}
impl ::std::fmt::Debug for PropertyRepresentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PropertyRepresentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PropertyRepresentation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PropertyRepresentation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PropertyRepresentation> for Coding {
    fn from(code: PropertyRepresentation) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/property-representation".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PropertyRepresentation> for CodeableConcept {
    fn from(code: PropertyRepresentation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PropertyType](http://hl7.org/fhir/ValueSet/concept-property-type)**. The type of a property value.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PropertyType {
    /** **Coding**

Coding (external reference). The property  value is a code defined in an external code system. This may be used for translations, but is not the intent. */
    Coding,
    /** **boolean**

boolean. The property value is a boolean true | false. */
    Boolean,
    /** **code**

code (internal reference). The property value is a code that identifies a concept defined in the code system. */
    Code,
    /** **dateTime**

dateTime. The property is a date or a date + time. */
    DateTime,
    /** **decimal**

decimal. The property value is a decimal number. */
    Decimal,
    /** **integer**

integer. The property value is a string (often used to assign ranking values to concepts for supporting score assessments). */
    Integer,
    /** **string**

string. The property value is a string. */
    String,
}
impl ::core::str::FromStr for PropertyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Coding" => Ok(Self::Coding),
            "boolean" => Ok(Self::Boolean),
            "code" => Ok(Self::Code),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "integer" => Ok(Self::Integer),
            "string" => Ok(Self::String),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PropertyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Coding => "Coding",
            Self::Boolean => "boolean",
            Self::Code => "code",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Integer => "integer",
            Self::String => "string",
        }
    }
}
impl ::std::fmt::Debug for PropertyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PropertyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PropertyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PropertyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PropertyType> for Coding {
    fn from(code: PropertyType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/concept-property-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PropertyType> for CodeableConcept {
    fn from(code: PropertyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProvenanceEntityRole](http://hl7.org/fhir/ValueSet/provenance-entity-role)**. How an entity was used in an activity.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProvenanceEntityRole {
    /** **derivation**

Derivation. A transformation of an entity into another, an update of an entity resulting in a new one, or the construction of a new entity based on a pre-existing entity. */
    Derivation,
    /** **quotation**

Quotation. The repeat of (some or all of) an entity, such as text or image, by someone who might or might not be its original author. */
    Quotation,
    /** **removal**

Removal. A derivation for which the entity is removed from accessibility usually through the use of the Delete operation. */
    Removal,
    /** **revision**

Revision. A derivation for which the resulting entity is a revised version of some original. */
    Revision,
    /** **source**

Source. A primary source for a topic refers to something produced by some agent with direct experience and knowledge about the topic, at the time of the topic's study, without benefit from hindsight. */
    Source,
}
impl ::core::str::FromStr for ProvenanceEntityRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "derivation" => Ok(Self::Derivation),
            "quotation" => Ok(Self::Quotation),
            "removal" => Ok(Self::Removal),
            "revision" => Ok(Self::Revision),
            "source" => Ok(Self::Source),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProvenanceEntityRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Derivation => "derivation",
            Self::Quotation => "quotation",
            Self::Removal => "removal",
            Self::Revision => "revision",
            Self::Source => "source",
        }
    }
}
impl ::std::fmt::Debug for ProvenanceEntityRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProvenanceEntityRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProvenanceEntityRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProvenanceEntityRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProvenanceEntityRole> for Coding {
    fn from(code: ProvenanceEntityRole) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/provenance-entity-role".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProvenanceEntityRole> for CodeableConcept {
    fn from(code: ProvenanceEntityRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProvenanceParticipantRole](http://hl7.org/fhir/ValueSet/provenance-participant-role)**. The role that a provenance participant played\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProvenanceParticipantRole {
    /** **assembler**

Assembler. A device that operates independently of an author on custodian's algorithms for data extraction of existing information for purpose of generating a new artifact. */
    Assembler,
    /** **attester**

Attester. A verifier who attests to the accuracy of the resource */
    Attester,
    /** **author**

Author. A party that originates the resource and therefore has responsibility for the information given in the resource and ownership of this resource */
    Author,
    /** **composer**

Composer. A device used by an author to record new information, which may also be used by the author to select existing information for aggregation with newly recorded information for the purpose of generating a new artifact. */
    Composer,
    /** **custodian**

Custodian. The entity that is accountable for maintaining a true an accurate copy of the original record */
    Custodian,
    /** **enterer**

Enterer. A person entering the data into the originating system */
    Enterer,
    /** **informant**

Informant. A person who reported information that contributed to the resource */
    Informant,
    /** **legal**

Legal Authenticator. The person authenticated the content and accepted legal responsibility for its content */
    Legal,
    /** **performer**

Performer. A person, animal, organization or device that who actually and principally carries out the activity */
    Performer,
    /** **verifier**

Verifier. A person who verifies the correctness and appropriateness of activity */
    Verifier,
}
impl ::core::str::FromStr for ProvenanceParticipantRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assembler" => Ok(Self::Assembler),
            "attester" => Ok(Self::Attester),
            "author" => Ok(Self::Author),
            "composer" => Ok(Self::Composer),
            "custodian" => Ok(Self::Custodian),
            "enterer" => Ok(Self::Enterer),
            "informant" => Ok(Self::Informant),
            "legal" => Ok(Self::Legal),
            "performer" => Ok(Self::Performer),
            "verifier" => Ok(Self::Verifier),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProvenanceParticipantRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assembler => "assembler",
            Self::Attester => "attester",
            Self::Author => "author",
            Self::Composer => "composer",
            Self::Custodian => "custodian",
            Self::Enterer => "enterer",
            Self::Informant => "informant",
            Self::Legal => "legal",
            Self::Performer => "performer",
            Self::Verifier => "verifier",
        }
    }
}
impl ::std::fmt::Debug for ProvenanceParticipantRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProvenanceParticipantRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProvenanceParticipantRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProvenanceParticipantRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProvenanceParticipantRole> for Coding {
    fn from(code: ProvenanceParticipantRole) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/provenance-participant-role".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProvenanceParticipantRole> for CodeableConcept {
    fn from(code: ProvenanceParticipantRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ProvenanceParticipantType](http://hl7.org/fhir/ValueSet/provenance-participant-type)**. The type of participation that a provenance agent (participant) played\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ProvenanceParticipantType {
    /** **assembler**

Assembler. A device that operates independently of an author on custodian's algorithms for data extraction of existing information for purpose of generating a new artifact. */
    Assembler,
    /** **attester**

Attester. A verifier who attests to the accuracy of the resource */
    Attester,
    /** **author**

Author. A party that originates the resource and therefore has responsibility for the information given in the resource and ownership of this resource */
    Author,
    /** **composer**

Composer. A device used by an author to record new information, which may also be used by the author to select existing information for aggregation with newly recorded information for the purpose of generating a new artifact. */
    Composer,
    /** **custodian**

Custodian. The entity that is accountable for maintaining a true an accurate copy of the original record */
    Custodian,
    /** **enterer**

Enterer. A person entering the data into the originating system */
    Enterer,
    /** **informant**

Informant. A person who reported information that contributed to the resource */
    Informant,
    /** **legal**

Legal Authenticator. The person authenticated the content and accepted legal responsibility for its content */
    Legal,
    /** **performer**

Performer. A person, animal, organization or device that who actually and principally carries out the activity */
    Performer,
    /** **verifier**

Verifier. A person who verifies the correctness and appropriateness of activity */
    Verifier,
}
impl ::core::str::FromStr for ProvenanceParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assembler" => Ok(Self::Assembler),
            "attester" => Ok(Self::Attester),
            "author" => Ok(Self::Author),
            "composer" => Ok(Self::Composer),
            "custodian" => Ok(Self::Custodian),
            "enterer" => Ok(Self::Enterer),
            "informant" => Ok(Self::Informant),
            "legal" => Ok(Self::Legal),
            "performer" => Ok(Self::Performer),
            "verifier" => Ok(Self::Verifier),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProvenanceParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assembler => "assembler",
            Self::Attester => "attester",
            Self::Author => "author",
            Self::Composer => "composer",
            Self::Custodian => "custodian",
            Self::Enterer => "enterer",
            Self::Informant => "informant",
            Self::Legal => "legal",
            Self::Performer => "performer",
            Self::Verifier => "verifier",
        }
    }
}
impl ::std::fmt::Debug for ProvenanceParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ProvenanceParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ProvenanceParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProvenanceParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProvenanceParticipantType> for Coding {
    fn from(code: ProvenanceParticipantType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/provenance-participant-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ProvenanceParticipantType> for CodeableConcept {
    fn from(code: ProvenanceParticipantType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PublicationStatus](http://hl7.org/fhir/ValueSet/publication-status)**. The lifecycle status of an artifact.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PublicationStatus {
    /** **active**

Active. This resource is ready for normal use. */
    Active,
    /** **draft**

Draft. This resource is still under development and is not yet considered to be ready for normal use. */
    Draft,
    /** **retired**

Retired. This resource has been withdrawn or superseded and should no longer be used. */
    Retired,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this resource.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for PublicationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "retired" => Ok(Self::Retired),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PublicationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::Retired => "retired",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for PublicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PublicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PublicationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PublicationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PublicationStatus> for Coding {
    fn from(code: PublicationStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/publication-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PublicationStatus> for CodeableConcept {
    fn from(code: PublicationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[PublishedInType](http://hl7.org/fhir/ValueSet/published-in-type)**. The type of publication such as book, database, or journal.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum PublishedInType {
    /** **D001877**

Book. Non-periodical written or printed works consisting of sheets of pages fastened or bound together within covers. */
    D001877,
    /** **D019991**

Database. A structured file of information or a set of logically related data stored and retrieved using computer-based means. */
    D019991,
    /** **D020492**

Periodical. Publication intended to be issued on an ongoing basis, generally more frequently than annually, containing separate articles, stories, or writings. */
    D020492,
    /** **D064886**

Dataset. Works consisting of organized collections of data, which have been stored permanently in a formalized manner suitable for communication, interpretation, or processing. */
    D064886,
}
impl ::core::str::FromStr for PublishedInType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "D001877" => Ok(Self::D001877),
            "D019991" => Ok(Self::D019991),
            "D020492" => Ok(Self::D020492),
            "D064886" => Ok(Self::D064886),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PublishedInType {
    fn as_ref(&self) -> &str {
        match self {
            Self::D001877 => "D001877",
            Self::D019991 => "D019991",
            Self::D020492 => "D020492",
            Self::D064886 => "D064886",
        }
    }
}
impl ::std::fmt::Debug for PublishedInType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for PublishedInType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for PublishedInType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PublishedInType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PublishedInType> for Coding {
    fn from(code: PublishedInType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/published-in-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<PublishedInType> for CodeableConcept {
    fn from(code: PublishedInType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QualityOfEvidenceRating](http://hl7.org/fhir/ValueSet/evidence-quality)**. A rating system that describes the quality of evidence such as the GRADE, DynaMed, or Oxford CEBM systems.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QualityOfEvidenceRating {
    /** **high**

High quality. High quality evidence. */
    High,
    /** **low**

Low quality. Low quality evidence. */
    Low,
    /** **moderate**

Moderate quality. Moderate quality evidence. */
    Moderate,
    /** **very-low**

Very low quality. Very low quality evidence. */
    VeryLow,
}
impl ::core::str::FromStr for QualityOfEvidenceRating {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            "very-low" => Ok(Self::VeryLow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QualityOfEvidenceRating {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
            Self::VeryLow => "very-low",
        }
    }
}
impl ::std::fmt::Debug for QualityOfEvidenceRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QualityOfEvidenceRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QualityOfEvidenceRating {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QualityOfEvidenceRating {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QualityOfEvidenceRating> for Coding {
    fn from(code: QualityOfEvidenceRating) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/evidence-quality".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QualityOfEvidenceRating> for CodeableConcept {
    fn from(code: QualityOfEvidenceRating) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuantityComparator](http://hl7.org/fhir/ValueSet/quantity-comparator)**. How the Quantity should be understood and represented.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuantityComparator {
    /** **<**

Less than. The actual value is less than the given value. */
    Less,
    /** **<=**

Less or Equal to. The actual value is less than or equal to the given value. */
    LessOrEqual,
    /** **>**

Greater than. The actual value is greater than the given value. */
    Greater,
    /** **>=**

Greater or Equal to. The actual value is greater than or equal to the given value. */
    GreaterOrEqual,
}
impl ::core::str::FromStr for QuantityComparator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "<" => Ok(Self::Less),
            "<=" => Ok(Self::LessOrEqual),
            ">" => Ok(Self::Greater),
            ">=" => Ok(Self::GreaterOrEqual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuantityComparator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Less => "<",
            Self::LessOrEqual => "<=",
            Self::Greater => ">",
            Self::GreaterOrEqual => ">=",
        }
    }
}
impl ::std::fmt::Debug for QuantityComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuantityComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuantityComparator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuantityComparator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuantityComparator> for Coding {
    fn from(code: QuantityComparator) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/quantity-comparator".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuantityComparator> for CodeableConcept {
    fn from(code: QuantityComparator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuestionnaireItemOperator](http://hl7.org/fhir/ValueSet/questionnaire-enable-operator)**. The criteria by which a question is enabled.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuestionnaireItemOperator {
    /** **!=**

Not Equals. True if whether at least no answer has a value that is equal to the enableWhen answer. */
    NotEqual,
    /** **<**

Less Than. True if whether at least no answer has a value that is less than the enableWhen answer. */
    Less,
    /** **<=**

Less or Equals. True if whether at least no answer has a value that is less or equal to the enableWhen answer. */
    LessOrEqual,
    /** **=**

Equals. True if whether at least one answer has a value that is equal to the enableWhen answer. */
    Equal,
    /** **>**

Greater Than. True if whether at least no answer has a value that is greater than the enableWhen answer. */
    Greater,
    /** **>=**

Greater or Equals. True if whether at least no answer has a value that is greater or equal to the enableWhen answer. */
    GreaterOrEqual,
    /** **exists**

Exists. True if whether an answer exists is equal to the enableWhen answer (which must be a boolean). */
    Exists,
}
impl ::core::str::FromStr for QuestionnaireItemOperator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "!=" => Ok(Self::NotEqual),
            "<" => Ok(Self::Less),
            "<=" => Ok(Self::LessOrEqual),
            "=" => Ok(Self::Equal),
            ">" => Ok(Self::Greater),
            ">=" => Ok(Self::GreaterOrEqual),
            "exists" => Ok(Self::Exists),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemOperator {
    fn as_ref(&self) -> &str {
        match self {
            Self::NotEqual => "!=",
            Self::Less => "<",
            Self::LessOrEqual => "<=",
            Self::Equal => "=",
            Self::Greater => ">",
            Self::GreaterOrEqual => ">=",
            Self::Exists => "exists",
        }
    }
}
impl ::std::fmt::Debug for QuestionnaireItemOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuestionnaireItemOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemOperator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireItemOperator> for Coding {
    fn from(code: QuestionnaireItemOperator) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/questionnaire-enable-operator".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuestionnaireItemOperator> for CodeableConcept {
    fn from(code: QuestionnaireItemOperator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuestionnaireItemType](http://hl7.org/fhir/ValueSet/item-type)**. Distinguishes groups from questions and display text and indicates data type for questions.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuestionnaireItemType {
    /** **attachment**

Attachment. Question with binary content such as an image, PDF, etc. as an answer (valueAttachment). */
    Attachment,
    /** **boolean**

Boolean. Question with a yes/no answer (valueBoolean). */
    Boolean,
    /** **choice**

Choice. Question with a Coding drawn from a list of possible answers (specified in either the answerOption property, or via the valueset referenced in the answerValueSet property) as an answer (valueCoding). */
    Choice,
    /** **date**

Date. Question with a date answer (valueDate). */
    Date,
    /** **dateTime**

Date Time. Question with a date and time answer (valueDateTime). */
    DateTime,
    /** **decimal**

Decimal. Question with is a real number answer (valueDecimal). */
    Decimal,
    /** **display**

Display. Text for display that will not capture an answer or have child items. */
    Display,
    /** **group**

Group. An item with no direct answer but should have at least one child item. */
    Group,
    /** **integer**

Integer. Question with an integer answer (valueInteger). */
    Integer,
    /** **open-choice**

Open Choice. Answer is a Coding drawn from a list of possible answers (as with the choice type) or a free-text entry in a string (valueCoding or valueString). */
    OpenChoice,
    /** **quantity**

Quantity. Question with a combination of a numeric value and unit, potentially with a comparator (<, >, etc.) as an answer. (valueQuantity) There is an extension 'http://hl7.org/fhir/StructureDefinition/questionnaire-unit' that can be used to define what unit should be captured (or the unit that has a ucum conversion from the provided unit). */
    Quantity,
    /** **question**

Question. An item that defines a specific answer to be captured, and which may have child items. (the answer provided in the QuestionnaireResponse should be of the defined datatype). */
    Question,
    /** **reference**

Reference. Question with a reference to another resource (practitioner, organization, etc.) as an answer (valueReference). */
    Reference,
    /** **string**

String. Question with a short (few words to short sentence) free-text entry answer (valueString). */
    String,
    /** **text**

Text. Question with a long (potentially multi-paragraph) free-text entry answer (valueString). */
    Text,
    /** **time**

Time. Question with a time (hour:minute:second) answer independent of date. (valueTime). */
    Time,
    /** **url**

Url. Question with a URL (website, FTP site, etc.) answer (valueUri). */
    Url,
}
impl ::core::str::FromStr for QuestionnaireItemType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "attachment" => Ok(Self::Attachment),
            "boolean" => Ok(Self::Boolean),
            "choice" => Ok(Self::Choice),
            "date" => Ok(Self::Date),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "display" => Ok(Self::Display),
            "group" => Ok(Self::Group),
            "integer" => Ok(Self::Integer),
            "open-choice" => Ok(Self::OpenChoice),
            "quantity" => Ok(Self::Quantity),
            "question" => Ok(Self::Question),
            "reference" => Ok(Self::Reference),
            "string" => Ok(Self::String),
            "text" => Ok(Self::Text),
            "time" => Ok(Self::Time),
            "url" => Ok(Self::Url),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attachment => "attachment",
            Self::Boolean => "boolean",
            Self::Choice => "choice",
            Self::Date => "date",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Display => "display",
            Self::Group => "group",
            Self::Integer => "integer",
            Self::OpenChoice => "open-choice",
            Self::Quantity => "quantity",
            Self::Question => "question",
            Self::Reference => "reference",
            Self::String => "string",
            Self::Text => "text",
            Self::Time => "time",
            Self::Url => "url",
        }
    }
}
impl ::std::fmt::Debug for QuestionnaireItemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuestionnaireItemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireItemType> for Coding {
    fn from(code: QuestionnaireItemType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/item-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuestionnaireItemType> for CodeableConcept {
    fn from(code: QuestionnaireItemType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuestionnaireItemUIControlCodes](http://hl7.org/fhir/ValueSet/questionnaire-item-control)**. Starter set of user interface control/display mechanisms that might be used when rendering an item in a questionnaire.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuestionnaireItemUIControlCodes {
    /** **atable**

Answer Table. This table has one row - for the question.  Permitted answers are columns.  Used for choice questions. */
    Atable,
    /** **autocomplete**

Auto-complete. A control which provides a list of potential matches based on text entered into a control.  Used for large choice sets where text-matching is an appropriate discovery mechanism. */
    Autocomplete,
    /** **check-box**

Check-box. A control where choices are listed with a box beside them.  The box can be toggled to select or de-select a given choice.  Multiple selections may be possible. */
    CheckBox,
    /** **drop-down**

Drop down. A control where an item (or multiple items) can be selected from a list that is only displayed when the user is editing the field. */
    DropDown,
    /** **flyover**

Fly-over. Text is temporarily visible over top of an item if the mouse is positioned over top of the text for the containing item */
    Flyover,
    /** **footer**

Footer. The group is to be continuously visible at the bottom of the questionnaire */
    Footer,
    /** **group**

UI controls relevant to organizing groups of questions */
    Group,
    /** **gtable**

Group Table. Questions within the group are columns in the table with each group repetition as a row.  Used for single-answer questions. */
    Gtable,
    /** **header**

Header. The group is to be continuously visible at the top of the questionnaire */
    Header,
    /** **help**

Help-Button. Text is displayed in a dialog box or similar control if invoked by pushing a button or some other UI-appropriate action to request 'help' for a question, group or the questionnaire as a whole (depending what the text is nested within) */
    Help,
    /** **htable**

Horizontal Answer Table. Questions within the group are columns in the table with possible answers as rows.  Used for 'choice' questions. */
    Htable,
    /** **inline**

In-line. Text is displayed as a paragraph in a sequential position between sibling items (default behavior) */
    Inline,
    /** **list**

List. Questions within the group should be listed sequentially */
    List,
    /** **lookup**

Lookup. A control where editing an item spawns a separate dialog box or screen permitting a user to navigate, filter or otherwise discover an appropriate match.  Useful for large choice sets where text matching is not an appropriate discovery mechanism.  Such screens must generally be tuned for the specific choice list structure. */
    Lookup,
    /** **lower**

Lower-bound. Text is displayed to the left of the set of answer choices or a scaling control for the parent question item to indicate the meaning of the 'lower' bound.  E.g. 'Strongly disagree' */
    Lower,
    /** **prompt**

Prompt. Text is displayed immediately below or within the answer-entry area of the containing question item (typically as a guide for what to enter) */
    Prompt,
    /** **question**

UI controls relevant to capturing question data */
    Question,
    /** **radio-button**

Radio Button. A control where choices are listed with a button beside them.  The button can be toggled to select or de-select a given choice.  Selecting one item deselects all others. */
    RadioButton,
    /** **slider**

Slider. A control where an axis is displayed between the high and low values and the control can be visually manipulated to select a value anywhere on the axis. */
    Slider,
    /** **spinner**

Spinner. A control where a list of numeric or other ordered values can be scrolled through via arrows. */
    Spinner,
    /** **table**

Vertical Answer Table. Questions within the group are rows in the table with possible answers as columns.  Used for 'choice' questions. */
    Table,
    /** **text**

UI controls relevant to rendering questionnaire text items */
    Text,
    /** **text-box**

Text Box. A control where a user can type in their answer freely. */
    TextBox,
    /** **unit**

Unit. Text is displayed adjacent (horizontally or vertically) to the answer space for the parent question, typically to indicate a unit of measure */
    Unit,
    /** **upper**

Upper-bound. Text is displayed to the right of the set of answer choices or a scaling control for the parent question item to indicate the meaning of the 'upper' bound.  E.g. 'Strongly agree' */
    Upper,
}
impl ::core::str::FromStr for QuestionnaireItemUIControlCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "atable" => Ok(Self::Atable),
            "autocomplete" => Ok(Self::Autocomplete),
            "check-box" => Ok(Self::CheckBox),
            "drop-down" => Ok(Self::DropDown),
            "flyover" => Ok(Self::Flyover),
            "footer" => Ok(Self::Footer),
            "group" => Ok(Self::Group),
            "gtable" => Ok(Self::Gtable),
            "header" => Ok(Self::Header),
            "help" => Ok(Self::Help),
            "htable" => Ok(Self::Htable),
            "inline" => Ok(Self::Inline),
            "list" => Ok(Self::List),
            "lookup" => Ok(Self::Lookup),
            "lower" => Ok(Self::Lower),
            "prompt" => Ok(Self::Prompt),
            "question" => Ok(Self::Question),
            "radio-button" => Ok(Self::RadioButton),
            "slider" => Ok(Self::Slider),
            "spinner" => Ok(Self::Spinner),
            "table" => Ok(Self::Table),
            "text" => Ok(Self::Text),
            "text-box" => Ok(Self::TextBox),
            "unit" => Ok(Self::Unit),
            "upper" => Ok(Self::Upper),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemUIControlCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Atable => "atable",
            Self::Autocomplete => "autocomplete",
            Self::CheckBox => "check-box",
            Self::DropDown => "drop-down",
            Self::Flyover => "flyover",
            Self::Footer => "footer",
            Self::Group => "group",
            Self::Gtable => "gtable",
            Self::Header => "header",
            Self::Help => "help",
            Self::Htable => "htable",
            Self::Inline => "inline",
            Self::List => "list",
            Self::Lookup => "lookup",
            Self::Lower => "lower",
            Self::Prompt => "prompt",
            Self::Question => "question",
            Self::RadioButton => "radio-button",
            Self::Slider => "slider",
            Self::Spinner => "spinner",
            Self::Table => "table",
            Self::Text => "text",
            Self::TextBox => "text-box",
            Self::Unit => "unit",
            Self::Upper => "upper",
        }
    }
}
impl ::std::fmt::Debug for QuestionnaireItemUIControlCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuestionnaireItemUIControlCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemUIControlCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemUIControlCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireItemUIControlCodes> for Coding {
    fn from(code: QuestionnaireItemUIControlCodes) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/questionnaire-item-control".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuestionnaireItemUIControlCodes> for CodeableConcept {
    fn from(code: QuestionnaireItemUIControlCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuestionnaireResponseStatus](http://hl7.org/fhir/ValueSet/questionnaire-answers-status)**. Lifecycle status of the questionnaire response.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuestionnaireResponseStatus {
    /** **amended**

Amended. This QuestionnaireResponse has been filled out with answers, then marked as complete, yet changes or additions have been made to it afterwards. */
    Amended,
    /** **completed**

Completed. This QuestionnaireResponse has been filled out with answers and the current content is regarded as definitive. */
    Completed,
    /** **entered-in-error**

Entered in Error. This QuestionnaireResponse was entered in error and voided. */
    EnteredInError,
    /** **in-progress**

In Progress. This QuestionnaireResponse has been partially filled out with answers but changes or additions are still expected to be made to it. */
    InProgress,
    /** **stopped**

Stopped. This QuestionnaireResponse has been partially filled out with answers but has been abandoned. It is unknown whether changes or additions are expected to be made to it. */
    Stopped,
}
impl ::core::str::FromStr for QuestionnaireResponseStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireResponseStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Stopped => "stopped",
        }
    }
}
impl ::std::fmt::Debug for QuestionnaireResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuestionnaireResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuestionnaireResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireResponseStatus> for Coding {
    fn from(code: QuestionnaireResponseStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/questionnaire-answers-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuestionnaireResponseStatus> for CodeableConcept {
    fn from(code: QuestionnaireResponseStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[QuestionnaireTextCategories](http://hl7.org/fhir/ValueSet/questionnaire-display-category)**. Codes defining the purpose of a Questionnaire item of type 'text'.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum QuestionnaireTextCategories {
    /** **help**

Help. The text provides additional guidance on populating the containing item.  Help text isn't necessarily expected to be rendered as part of the form, but may instead be made available through fly-over, pop-up button, link to a "help" page, etc. */
    Help,
    /** **instructions**

Instructions. The text provides guidance on how to populate or use a portion of the questionnaire (or the questionnaire as a whole). */
    Instructions,
    /** **security**

Security. The text provides guidance on how the information should be or will be handled from a security/confidentiality/access control perspective when completed */
    Security,
}
impl ::core::str::FromStr for QuestionnaireTextCategories {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "help" => Ok(Self::Help),
            "instructions" => Ok(Self::Instructions),
            "security" => Ok(Self::Security),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireTextCategories {
    fn as_ref(&self) -> &str {
        match self {
            Self::Help => "help",
            Self::Instructions => "instructions",
            Self::Security => "security",
        }
    }
}
impl ::std::fmt::Debug for QuestionnaireTextCategories {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for QuestionnaireTextCategories {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for QuestionnaireTextCategories {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireTextCategories {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireTextCategories> for Coding {
    fn from(code: QuestionnaireTextCategories) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/questionnaire-display-category".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<QuestionnaireTextCategories> for CodeableConcept {
    fn from(code: QuestionnaireTextCategories) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReasonMedicationGivenCodes](http://terminology.hl7.org/CodeSystem/reason-medication-given)**. This value set is provided as an example. The value set to instantiate this attribute should be drawn from a robust terminology code system that consists of or contains concepts to support the medication process.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ReasonMedicationGivenCodes {
    /** **a**

None. No reason known. */
    A,
    /** **b**

Given as Ordered. The administration was following an ordered protocol. */
    B,
    /** **c**

Emergency. The administration was needed to treat an emergency. */
    C,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ReasonMedicationGivenCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a" => Ok(Self::A),
            "b" => Ok(Self::B),
            "c" => Ok(Self::C),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ReasonMedicationGivenCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::A => "a",
            Self::B => "b",
            Self::C => "c",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ReasonMedicationGivenCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReasonMedicationGivenCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReasonMedicationGivenCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReasonMedicationGivenCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReasonMedicationGivenCodes> for Coding {
    fn from(code: ReasonMedicationGivenCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/reason-medication-given"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReasonMedicationGivenCodes> for CodeableConcept {
    fn from(code: ReasonMedicationGivenCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReasonMedicationNotGivenCodes](http://hl7.org/fhir/reason-medication-not-given)**. This value set is provided as an example. The value set to instantiate this attribute should be drawn from a robust terminology code system that consists of or contains concepts to support the medication process.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ReasonMedicationNotGivenCodes {
    /** **a**

None. No reason known. */
    A,
    /** **b**

Away. The patient was not available when the dose was scheduled. */
    B,
    /** **c**

Asleep. The patient was asleep when the dose was scheduled. */
    C,
    /** **d**

Vomit. The patient was given the medication and immediately vomited it back. */
    D,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ReasonMedicationNotGivenCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a" => Ok(Self::A),
            "b" => Ok(Self::B),
            "c" => Ok(Self::C),
            "d" => Ok(Self::D),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ReasonMedicationNotGivenCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::A => "a",
            Self::B => "b",
            Self::C => "c",
            Self::D => "d",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ReasonMedicationNotGivenCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReasonMedicationNotGivenCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReasonMedicationNotGivenCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReasonMedicationNotGivenCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReasonMedicationNotGivenCodes> for Coding {
    fn from(code: ReasonMedicationNotGivenCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/reason-medication-not-given".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReasonMedicationNotGivenCodes> for CodeableConcept {
    fn from(code: ReasonMedicationNotGivenCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReferenceHandlingPolicy](http://hl7.org/fhir/ValueSet/reference-handling-policy)**. A set of flags that defines how references are supported.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ReferenceHandlingPolicy {
    /** **enforced**

Reference Integrity Enforced. The server enforces that references have integrity - e.g. it ensures that references can always be resolved. This is typically the case for clinical record systems, but often not the case for middleware/proxy systems. */
    Enforced,
    /** **literal**

Literal References. The server supports and populates Literal references (i.e. using Reference.reference) where they are known (this code does not guarantee that all references are literal; see 'enforced'). */
    Literal,
    /** **local**

Local References Only. The server does not support references that point to other servers. */
    Local,
    /** **logical**

Logical References. The server allows logical references (i.e. using Reference.identifier). */
    Logical,
    /** **resolves**

Resolves References. The server will attempt to resolve logical references to literal references - i.e. converting Reference.identifier to Reference.reference (if resolution fails, the server may still accept resources; see logical). */
    Resolves,
}
impl ::core::str::FromStr for ReferenceHandlingPolicy {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "enforced" => Ok(Self::Enforced),
            "literal" => Ok(Self::Literal),
            "local" => Ok(Self::Local),
            "logical" => Ok(Self::Logical),
            "resolves" => Ok(Self::Resolves),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferenceHandlingPolicy {
    fn as_ref(&self) -> &str {
        match self {
            Self::Enforced => "enforced",
            Self::Literal => "literal",
            Self::Local => "local",
            Self::Logical => "logical",
            Self::Resolves => "resolves",
        }
    }
}
impl ::std::fmt::Debug for ReferenceHandlingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReferenceHandlingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReferenceHandlingPolicy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferenceHandlingPolicy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReferenceHandlingPolicy> for Coding {
    fn from(code: ReferenceHandlingPolicy) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/reference-handling-policy".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReferenceHandlingPolicy> for CodeableConcept {
    fn from(code: ReferenceHandlingPolicy) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReferenceVersionRules](http://hl7.org/fhir/ValueSet/reference-version-rules)**. Whether a reference needs to be version specific or version independent, or whether either can be used.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ReferenceVersionRules {
    /** **either**

Either Specific or independent. The reference may be either version independent or version specific. */
    Either,
    /** **independent**

Version independent. The reference must be version independent. */
    Independent,
    /** **specific**

Version Specific. The reference must be version specific. */
    Specific,
}
impl ::core::str::FromStr for ReferenceVersionRules {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "either" => Ok(Self::Either),
            "independent" => Ok(Self::Independent),
            "specific" => Ok(Self::Specific),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferenceVersionRules {
    fn as_ref(&self) -> &str {
        match self {
            Self::Either => "either",
            Self::Independent => "independent",
            Self::Specific => "specific",
        }
    }
}
impl ::std::fmt::Debug for ReferenceVersionRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReferenceVersionRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReferenceVersionRules {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferenceVersionRules {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReferenceVersionRules> for Coding {
    fn from(code: ReferenceVersionRules) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/reference-version-rules".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReferenceVersionRules> for CodeableConcept {
    fn from(code: ReferenceVersionRules) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReferralMethod](http://hl7.org/fhir/ValueSet/service-referral-method)**. The methods of referral can be used when referring to a specific HealthCareService resource.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ReferralMethod {
    /** **elec**

Secure Messaging. Referrals may be accepted via a secure messaging system. To determine the types of secure messaging systems supported, refer to the identifiers collection. Callers will need to understand the specific identifier system used to know that they are able to transmit messages. */
    Elec,
    /** **fax**

Fax. Referrals may be accepted by fax. */
    Fax,
    /** **mail**

Mail. Referrals may be accepted via regular postage (or hand delivered). */
    Mail,
    /** **phone**

Phone. Referrals may be accepted over the phone from a practitioner. */
    Phone,
    /** **semail**

Secure Email. Referrals may be accepted via a secure email. To send please encrypt with the services public key. */
    Semail,
}
impl ::core::str::FromStr for ReferralMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "elec" => Ok(Self::Elec),
            "fax" => Ok(Self::Fax),
            "mail" => Ok(Self::Mail),
            "phone" => Ok(Self::Phone),
            "semail" => Ok(Self::Semail),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferralMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Elec => "elec",
            Self::Fax => "fax",
            Self::Mail => "mail",
            Self::Phone => "phone",
            Self::Semail => "semail",
        }
    }
}
impl ::std::fmt::Debug for ReferralMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReferralMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReferralMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferralMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReferralMethod> for Coding {
    fn from(code: ReferralMethod) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/service-referral-method".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReferralMethod> for CodeableConcept {
    fn from(code: ReferralMethod) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RegulatedAuthorizationBasis](http://hl7.org/fhir/ValueSet/regulated-authorization-basis)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RegulatedAuthorizationBasis {
    /** **Bibliographical**

Bibliographical application (stand-alone). */
    Bibliographical,
    /** **Full**

Full application. */
    Full,
    /** **KnownHumanBlood**

Known human blood/plasma derived ancillary medicinal substance. */
    KnownHumanBlood,
    /** **KnownSubstance**

Known active substance. */
    KnownSubstance,
    /** **NewSubstance**

New active substance. */
    NewSubstance,
    /** **ParallelTrade**

Parallel traded products. */
    ParallelTrade,
    /** **SimilarBiological**

Similar biological application. */
    SimilarBiological,
    /** **TemporaryUse**

Authorisations for temporary use. */
    TemporaryUse,
    /** **TraditionalUse**

Traditional use registration for herbal medicinal product application. */
    TraditionalUse,
    /** **Well-establishedUse**

Well-established use application. */
    WellEstablishedUse,
}
impl ::core::str::FromStr for RegulatedAuthorizationBasis {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Bibliographical" => Ok(Self::Bibliographical),
            "Full" => Ok(Self::Full),
            "KnownHumanBlood" => Ok(Self::KnownHumanBlood),
            "KnownSubstance" => Ok(Self::KnownSubstance),
            "NewSubstance" => Ok(Self::NewSubstance),
            "ParallelTrade" => Ok(Self::ParallelTrade),
            "SimilarBiological" => Ok(Self::SimilarBiological),
            "TemporaryUse" => Ok(Self::TemporaryUse),
            "TraditionalUse" => Ok(Self::TraditionalUse),
            "Well-establishedUse" => Ok(Self::WellEstablishedUse),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RegulatedAuthorizationBasis {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bibliographical => "Bibliographical",
            Self::Full => "Full",
            Self::KnownHumanBlood => "KnownHumanBlood",
            Self::KnownSubstance => "KnownSubstance",
            Self::NewSubstance => "NewSubstance",
            Self::ParallelTrade => "ParallelTrade",
            Self::SimilarBiological => "SimilarBiological",
            Self::TemporaryUse => "TemporaryUse",
            Self::TraditionalUse => "TraditionalUse",
            Self::WellEstablishedUse => "Well-establishedUse",
        }
    }
}
impl ::std::fmt::Debug for RegulatedAuthorizationBasis {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RegulatedAuthorizationBasis {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RegulatedAuthorizationBasis {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RegulatedAuthorizationBasis {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RegulatedAuthorizationBasis> for Coding {
    fn from(code: RegulatedAuthorizationBasis) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/regulated-authorization-basis".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RegulatedAuthorizationBasis> for CodeableConcept {
    fn from(code: RegulatedAuthorizationBasis) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RegulatedAuthorizationCaseType](http://hl7.org/fhir/ValueSet/regulated-authorization-case-type)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RegulatedAuthorizationCaseType {
    /** **100000155699**

Specific Obligation. */
    N100000155699,
    /** **AnnualReassessment**

Annual Reassessment. */
    AnnualReassessment,
    /** **FLU**

FLU STRAIN UPDATE. */
    Flu,
    /** **Follow-up**

Follow-up Measure. */
    FollowUp,
    /** **InitialMAA**

Initial Marketing Authorisation Application. */
    InitialMAA,
    /** **LiftingSuspension**

Lifting of a Suspension. */
    LiftingSuspension,
    /** **LineExtension**

Line Extension. */
    LineExtension,
    /** **Orphan**

Orphan Designation Application. */
    Orphan,
    /** **PANDEMIC**

PANDEMIC UPDATE. */
    Pandemic,
    /** **PSUR**

Periodic Safety Update Report. */
    Psur,
    /** **PaediatricSubmission**

Paediatric Submission. */
    PaediatricSubmission,
    /** **RMP**

Risk Management Plan. */
    Rmp,
    /** **Reformatting**

Reformatting. */
    Reformatting,
    /** **Renewal**

Renewal. */
    Renewal,
    /** **RepeatUse**

Repeat Use Procedure. */
    RepeatUse,
    /** **ReviewSuspension**

Review of a Suspension of MA. */
    ReviewSuspension,
    /** **SignalDetection**

Signal detection. */
    SignalDetection,
    /** **SupplementalInformation**

Supplemental Information. */
    SupplementalInformation,
    /** **TransferMA**

Transfer of a marketing authorisation. */
    TransferMA,
    /** **UrgentSafetyRestriction**

Urgent Safety Restriction. */
    UrgentSafetyRestriction,
    /** **Variation**

Variation. */
    Variation,
    /** **Withdrawal**

Withdrawal. */
    Withdrawal,
}
impl ::core::str::FromStr for RegulatedAuthorizationCaseType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000155699" => Ok(Self::N100000155699),
            "AnnualReassessment" => Ok(Self::AnnualReassessment),
            "FLU" => Ok(Self::Flu),
            "Follow-up" => Ok(Self::FollowUp),
            "InitialMAA" => Ok(Self::InitialMAA),
            "LiftingSuspension" => Ok(Self::LiftingSuspension),
            "LineExtension" => Ok(Self::LineExtension),
            "Orphan" => Ok(Self::Orphan),
            "PANDEMIC" => Ok(Self::Pandemic),
            "PSUR" => Ok(Self::Psur),
            "PaediatricSubmission" => Ok(Self::PaediatricSubmission),
            "RMP" => Ok(Self::Rmp),
            "Reformatting" => Ok(Self::Reformatting),
            "Renewal" => Ok(Self::Renewal),
            "RepeatUse" => Ok(Self::RepeatUse),
            "ReviewSuspension" => Ok(Self::ReviewSuspension),
            "SignalDetection" => Ok(Self::SignalDetection),
            "SupplementalInformation" => Ok(Self::SupplementalInformation),
            "TransferMA" => Ok(Self::TransferMA),
            "UrgentSafetyRestriction" => Ok(Self::UrgentSafetyRestriction),
            "Variation" => Ok(Self::Variation),
            "Withdrawal" => Ok(Self::Withdrawal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RegulatedAuthorizationCaseType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000155699 => "100000155699",
            Self::AnnualReassessment => "AnnualReassessment",
            Self::Flu => "FLU",
            Self::FollowUp => "Follow-up",
            Self::InitialMAA => "InitialMAA",
            Self::LiftingSuspension => "LiftingSuspension",
            Self::LineExtension => "LineExtension",
            Self::Orphan => "Orphan",
            Self::Pandemic => "PANDEMIC",
            Self::Psur => "PSUR",
            Self::PaediatricSubmission => "PaediatricSubmission",
            Self::Rmp => "RMP",
            Self::Reformatting => "Reformatting",
            Self::Renewal => "Renewal",
            Self::RepeatUse => "RepeatUse",
            Self::ReviewSuspension => "ReviewSuspension",
            Self::SignalDetection => "SignalDetection",
            Self::SupplementalInformation => "SupplementalInformation",
            Self::TransferMA => "TransferMA",
            Self::UrgentSafetyRestriction => "UrgentSafetyRestriction",
            Self::Variation => "Variation",
            Self::Withdrawal => "Withdrawal",
        }
    }
}
impl ::std::fmt::Debug for RegulatedAuthorizationCaseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RegulatedAuthorizationCaseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RegulatedAuthorizationCaseType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RegulatedAuthorizationCaseType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RegulatedAuthorizationCaseType> for Coding {
    fn from(code: RegulatedAuthorizationCaseType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/regulated-authorization-case-type"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RegulatedAuthorizationCaseType> for CodeableConcept {
    fn from(code: RegulatedAuthorizationCaseType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RegulatedAuthorizationType](http://hl7.org/fhir/ValueSet/regulated-authorization-type)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RegulatedAuthorizationType {
    /** **MarketingAuth**

Marketing Authorization. */
    MarketingAuth,
    /** **Orphan**

Orphan Drug Authorization. */
    Orphan,
    /** **Pediatric**

Pediatric Use Drug Authorization. */
    Pediatric,
}
impl ::core::str::FromStr for RegulatedAuthorizationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "MarketingAuth" => Ok(Self::MarketingAuth),
            "Orphan" => Ok(Self::Orphan),
            "Pediatric" => Ok(Self::Pediatric),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RegulatedAuthorizationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MarketingAuth => "MarketingAuth",
            Self::Orphan => "Orphan",
            Self::Pediatric => "Pediatric",
        }
    }
}
impl ::std::fmt::Debug for RegulatedAuthorizationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RegulatedAuthorizationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RegulatedAuthorizationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RegulatedAuthorizationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RegulatedAuthorizationType> for Coding {
    fn from(code: RegulatedAuthorizationType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/regulated-authorization-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RegulatedAuthorizationType> for CodeableConcept {
    fn from(code: RegulatedAuthorizationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RejectionCriterion](http://hl7.org/fhir/ValueSet/rejection-criteria)**. Criterion for rejection of the specimen by laboratory.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RejectionCriterion {
    /** **broken**

broken specimen container. specimen container broken. */
    Broken,
    /** **clotted**

specimen clotted. specimen clotted. */
    Clotted,
    /** **hemolized**

hemolized specimen. blood specimen hemolized. */
    Hemolized,
    /** **insufficient**

insufficient specimen volume. insufficient quantity of specimen. */
    Insufficient,
    /** **wrong-temperature**

specimen temperature inappropriate. specimen temperature inappropriate. */
    WrongTemperature,
}
impl ::core::str::FromStr for RejectionCriterion {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "broken" => Ok(Self::Broken),
            "clotted" => Ok(Self::Clotted),
            "hemolized" => Ok(Self::Hemolized),
            "insufficient" => Ok(Self::Insufficient),
            "wrong-temperature" => Ok(Self::WrongTemperature),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RejectionCriterion {
    fn as_ref(&self) -> &str {
        match self {
            Self::Broken => "broken",
            Self::Clotted => "clotted",
            Self::Hemolized => "hemolized",
            Self::Insufficient => "insufficient",
            Self::WrongTemperature => "wrong-temperature",
        }
    }
}
impl ::std::fmt::Debug for RejectionCriterion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RejectionCriterion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RejectionCriterion {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RejectionCriterion {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RejectionCriterion> for Coding {
    fn from(code: RejectionCriterion) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/rejection-criteria".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RejectionCriterion> for CodeableConcept {
    fn from(code: RejectionCriterion) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RelatedArtifactType](http://hl7.org/fhir/ValueSet/related-artifact-type)**. The type of relationship to the related artifact.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RelatedArtifactType {
    /** **citation**

Citation. Bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource. */
    Citation,
    /** **composed-of**

Composed Of. The knowledge resource is composed of the given related artifact. */
    ComposedOf,
    /** **depends-on**

Depends On. The knowledge resource depends on the given related artifact. */
    DependsOn,
    /** **derived-from**

Derived From. The knowledge resource is derived from the related artifact. This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but is modified to capture either a different set of overall requirements, or a more specific set of requirements such as those involved in a particular institution or clinical setting. */
    DerivedFrom,
    /** **documentation**

Documentation. Additional documentation for the knowledge resource. This would include additional instructions on usage as well as additional information on clinical context or appropriateness. */
    Documentation,
    /** **justification**

Justification. A summary of the justification for the knowledge resource including supporting evidence, relevant guidelines, or other clinically important information. This information is intended to provide a way to make the justification for the knowledge resource available to the consumer of interventions or results produced by the knowledge resource. */
    Justification,
    /** **predecessor**

Predecessor. The previous version of the knowledge resource. */
    Predecessor,
    /** **successor**

Successor. The next version of the knowledge resource. */
    Successor,
}
impl ::core::str::FromStr for RelatedArtifactType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "citation" => Ok(Self::Citation),
            "composed-of" => Ok(Self::ComposedOf),
            "depends-on" => Ok(Self::DependsOn),
            "derived-from" => Ok(Self::DerivedFrom),
            "documentation" => Ok(Self::Documentation),
            "justification" => Ok(Self::Justification),
            "predecessor" => Ok(Self::Predecessor),
            "successor" => Ok(Self::Successor),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RelatedArtifactType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Citation => "citation",
            Self::ComposedOf => "composed-of",
            Self::DependsOn => "depends-on",
            Self::DerivedFrom => "derived-from",
            Self::Documentation => "documentation",
            Self::Justification => "justification",
            Self::Predecessor => "predecessor",
            Self::Successor => "successor",
        }
    }
}
impl ::std::fmt::Debug for RelatedArtifactType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RelatedArtifactType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RelatedArtifactType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RelatedArtifactType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RelatedArtifactType> for Coding {
    fn from(code: RelatedArtifactType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/related-artifact-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RelatedArtifactType> for CodeableConcept {
    fn from(code: RelatedArtifactType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RemittanceOutcome](http://hl7.org/fhir/ValueSet/remittance-outcome)**. The outcome of the processing.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RemittanceOutcome {
    /** **complete**

Complete. The processing completed without errors. */
    Complete,
    /** **error**

Error. The processing identified errors. */
    Error,
    /** **partial**

Partial. No errors have been detected and some of the adjudication has been performed. */
    Partial,
    /** **queued**

Queued. The Claim/Pre-authorization/Pre-determination has been received but processing has not begun. */
    Queued,
}
impl ::core::str::FromStr for RemittanceOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "error" => Ok(Self::Error),
            "partial" => Ok(Self::Partial),
            "queued" => Ok(Self::Queued),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RemittanceOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Error => "error",
            Self::Partial => "partial",
            Self::Queued => "queued",
        }
    }
}
impl ::std::fmt::Debug for RemittanceOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RemittanceOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RemittanceOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RemittanceOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RemittanceOutcome> for Coding {
    fn from(code: RemittanceOutcome) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/remittance-outcome".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RemittanceOutcome> for CodeableConcept {
    fn from(code: RemittanceOutcome) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReportRelationshipType](http://hl7.org/fhir/ValueSet/report-relation-type)**. The type of relationship between reports.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ReportRelationshipType {
    /** **amendedWith**

Amended With. This document was. */
    AmendedWith,
    /** **amends**

Amends. This document notes corrections or changes to replace or supersede parts of the target document. */
    Amends,
    /** **appendedWith**

Appended With. This document was. */
    AppendedWith,
    /** **appends**

Appends. This document adds additional information to the target document. */
    Appends,
    /** **replacedWith**

Replaced With. This document was. */
    ReplacedWith,
    /** **replaces**

Replaces. This document replaces or supersedes the target document. */
    Replaces,
    /** **transformedWith**

Transformed With. This document was. */
    TransformedWith,
    /** **transforms**

Transforms. This document was generated by transforming the target document (eg format or language conversion). */
    Transforms,
}
impl ::core::str::FromStr for ReportRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amendedWith" => Ok(Self::AmendedWith),
            "amends" => Ok(Self::Amends),
            "appendedWith" => Ok(Self::AppendedWith),
            "appends" => Ok(Self::Appends),
            "replacedWith" => Ok(Self::ReplacedWith),
            "replaces" => Ok(Self::Replaces),
            "transformedWith" => Ok(Self::TransformedWith),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReportRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AmendedWith => "amendedWith",
            Self::Amends => "amends",
            Self::AppendedWith => "appendedWith",
            Self::Appends => "appends",
            Self::ReplacedWith => "replacedWith",
            Self::Replaces => "replaces",
            Self::TransformedWith => "transformedWith",
            Self::Transforms => "transforms",
        }
    }
}
impl ::std::fmt::Debug for ReportRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReportRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReportRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReportRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReportRelationshipType> for Coding {
    fn from(code: ReportRelationshipType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/report-relation-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReportRelationshipType> for CodeableConcept {
    fn from(code: ReportRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ReportSectionType](http://hl7.org/fhir/ValueSet/evidence-report-section)**. Evidence Report Section Type.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ReportSectionType {
    /** **Assertion**

Assertion. Assertion. */
    Assertion,
    /** **Certainty-of-Evidence**

Certainty of Evidence. Certainty of Evidence. */
    CertaintyOfEvidence,
    /** **Column-Header**

Column Header. Denotes the header to use for the column for a tabular report. */
    ColumnHeader,
    /** **Column-Headers**

Column Headers. Denotes a section specifying column headers for a tabular report. */
    ColumnHeaders,
    /** **Control-group-alone-Evidence**

Evidence Results for the control exposure only. Evidence Results for the control exposure only. */
    ControlGroupAloneEvidence,
    /** **Efficacy-outcomes**

Efficacy-outcomes. Outcomes related to efficacy or potential benefits of interventions. */
    EfficacyOutcomes,
    /** **Evidence**

Evidence Results. Evidence Results. */
    Evidence,
    /** **Evidence-Classifier**

Evidence Classifier section. This section is used for classifiers of the evidence. */
    EvidenceClassifier,
    /** **EvidenceVariable**

Evidence Variables used. Evidence Variables used. */
    EvidenceVariable,
    /** **EvidenceVariable-exposure**

Evidence Variable in variable role Exposure. Evidence Variable in variable role Exposure. */
    EvidenceVariableExposure,
    /** **EvidenceVariable-intended**

Evidence Variables intended for interpretation. Evidence Variables intended for interpretation. */
    EvidenceVariableIntended,
    /** **EvidenceVariable-observed**

Evidence Variables actually observed. Evidence Variables as observed in the research data. */
    EvidenceVariableObserved,
    /** **EvidenceVariable-outcome**

Evidence Variable in variable role Outcome (MeasuredVariable). Evidence Variable in variable role Outcome (MeasuredVariable). */
    EvidenceVariableOutcome,
    /** **EvidenceVariable-population**

Evidence Variable in variable role Population. Evidence Variable in variable role Population. */
    EvidenceVariablePopulation,
    /** **Harms-outcomes**

Harms outcomes. Outcomes related to adverse effects or potential harms of interventions. */
    HarmsOutcomes,
    /** **Header**

Header. Denotes the header to use for a Text Summary or above a Table. */
    Header,
    /** **Intervention-group-alone-Evidence**

Evidence Results for the intervention exposure only. Evidence Results for the intervention exposure only. */
    InterventionGroupAloneEvidence,
    /** **Intervention-vs-Control-Evidence**

Evidence Results for comparison of Intervention and Control. Evidence Results for comparison of Intervention and Control. */
    InterventionVsControlEvidence,
    /** **Reasons**

Reasons. Reasons. */
    Reasons,
    /** **References**

References. References. */
    References,
    /** **Row-Headers**

Row Headers. Denotes a section specifying row headers for a tabular report. */
    RowHeaders,
    /** **SampleSize**

Sample Size. Sample Size. */
    SampleSize,
    /** **SummaryOfBodyOfEvidenceFindings**

Summary of Body of Evidence Findings. Summary of Body of Evidence Findings. */
    SummaryOfBodyOfEvidenceFindings,
    /** **SummaryOfIndividualStudyFindings**

Summary of Individual Study Findings. Summary of Individual Study Findings. */
    SummaryOfIndividualStudyFindings,
    /** **Table**

Table. */
    Table,
    /** **Tables**

Tables. Tables. */
    Tables,
    /** **Text-Summary**

Text Summary. Denotes a section specifying text summary for a report. */
    TextSummary,
    /** **Warnings**

Warnings. Warnings. */
    Warnings,
}
impl ::core::str::FromStr for ReportSectionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Assertion" => Ok(Self::Assertion),
            "Certainty-of-Evidence" => Ok(Self::CertaintyOfEvidence),
            "Column-Header" => Ok(Self::ColumnHeader),
            "Column-Headers" => Ok(Self::ColumnHeaders),
            "Control-group-alone-Evidence" => Ok(Self::ControlGroupAloneEvidence),
            "Efficacy-outcomes" => Ok(Self::EfficacyOutcomes),
            "Evidence" => Ok(Self::Evidence),
            "Evidence-Classifier" => Ok(Self::EvidenceClassifier),
            "EvidenceVariable" => Ok(Self::EvidenceVariable),
            "EvidenceVariable-exposure" => Ok(Self::EvidenceVariableExposure),
            "EvidenceVariable-intended" => Ok(Self::EvidenceVariableIntended),
            "EvidenceVariable-observed" => Ok(Self::EvidenceVariableObserved),
            "EvidenceVariable-outcome" => Ok(Self::EvidenceVariableOutcome),
            "EvidenceVariable-population" => Ok(Self::EvidenceVariablePopulation),
            "Harms-outcomes" => Ok(Self::HarmsOutcomes),
            "Header" => Ok(Self::Header),
            "Intervention-group-alone-Evidence" => {
                Ok(Self::InterventionGroupAloneEvidence)
            }
            "Intervention-vs-Control-Evidence" => Ok(Self::InterventionVsControlEvidence),
            "Reasons" => Ok(Self::Reasons),
            "References" => Ok(Self::References),
            "Row-Headers" => Ok(Self::RowHeaders),
            "SampleSize" => Ok(Self::SampleSize),
            "SummaryOfBodyOfEvidenceFindings" => {
                Ok(Self::SummaryOfBodyOfEvidenceFindings)
            }
            "SummaryOfIndividualStudyFindings" => {
                Ok(Self::SummaryOfIndividualStudyFindings)
            }
            "Table" => Ok(Self::Table),
            "Tables" => Ok(Self::Tables),
            "Text-Summary" => Ok(Self::TextSummary),
            "Warnings" => Ok(Self::Warnings),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReportSectionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assertion => "Assertion",
            Self::CertaintyOfEvidence => "Certainty-of-Evidence",
            Self::ColumnHeader => "Column-Header",
            Self::ColumnHeaders => "Column-Headers",
            Self::ControlGroupAloneEvidence => "Control-group-alone-Evidence",
            Self::EfficacyOutcomes => "Efficacy-outcomes",
            Self::Evidence => "Evidence",
            Self::EvidenceClassifier => "Evidence-Classifier",
            Self::EvidenceVariable => "EvidenceVariable",
            Self::EvidenceVariableExposure => "EvidenceVariable-exposure",
            Self::EvidenceVariableIntended => "EvidenceVariable-intended",
            Self::EvidenceVariableObserved => "EvidenceVariable-observed",
            Self::EvidenceVariableOutcome => "EvidenceVariable-outcome",
            Self::EvidenceVariablePopulation => "EvidenceVariable-population",
            Self::HarmsOutcomes => "Harms-outcomes",
            Self::Header => "Header",
            Self::InterventionGroupAloneEvidence => "Intervention-group-alone-Evidence",
            Self::InterventionVsControlEvidence => "Intervention-vs-Control-Evidence",
            Self::Reasons => "Reasons",
            Self::References => "References",
            Self::RowHeaders => "Row-Headers",
            Self::SampleSize => "SampleSize",
            Self::SummaryOfBodyOfEvidenceFindings => "SummaryOfBodyOfEvidenceFindings",
            Self::SummaryOfIndividualStudyFindings => "SummaryOfIndividualStudyFindings",
            Self::Table => "Table",
            Self::Tables => "Tables",
            Self::TextSummary => "Text-Summary",
            Self::Warnings => "Warnings",
        }
    }
}
impl ::std::fmt::Debug for ReportSectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ReportSectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ReportSectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReportSectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReportSectionType> for Coding {
    fn from(code: ReportSectionType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/evidence-report-section".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ReportSectionType> for CodeableConcept {
    fn from(code: ReportSectionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RequestIntent](http://hl7.org/fhir/ValueSet/request-intent)**. Codes indicating the degree of authority/intentionality associated with a request.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RequestIntent {
    /** **directive**

Directive. The request represents a legally binding instruction authored by a Patient or RelatedPerson. */
    Directive,
    /** **filler-order**

Filler Order. The request represents the view of an authorization instantiated by a fulfilling system representing the details of the fulfiller's intention to act upon a submitted order. */
    FillerOrder,
    /** **instance-order**

Instance Order. An order created in fulfillment of a broader order that represents the authorization for a single activity occurrence.  E.g. The administration of a single dose of a drug. */
    InstanceOrder,
    /** **option**

Option. The request represents a component or option for a RequestGroup that establishes timing, conditionality and/or other constraints among a set of requests.  Refer to [[[RequestGroup]]] for additional information on how this status is used. */
    Option,
    /** **order**

Order. The request represents a request/demand and authorization for action by a Practitioner. */
    Order,
    /** **original-order**

Original Order. The request represents an original authorization for action. */
    OriginalOrder,
    /** **plan**

Plan. The request represents an intention to ensure something occurs without providing an authorization for others to act. */
    Plan,
    /** **proposal**

Proposal. The request is a suggestion made by someone/something that does not have an intention to ensure it occurs and without providing an authorization to act. */
    Proposal,
    /** **reflex-order**

Reflex Order. The request represents an automatically generated supplemental authorization for action based on a parent authorization together with initial results of the action taken against that parent authorization. */
    ReflexOrder,
}
impl ::core::str::FromStr for RequestIntent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "directive" => Ok(Self::Directive),
            "filler-order" => Ok(Self::FillerOrder),
            "instance-order" => Ok(Self::InstanceOrder),
            "option" => Ok(Self::Option),
            "order" => Ok(Self::Order),
            "original-order" => Ok(Self::OriginalOrder),
            "plan" => Ok(Self::Plan),
            "proposal" => Ok(Self::Proposal),
            "reflex-order" => Ok(Self::ReflexOrder),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Directive => "directive",
            Self::FillerOrder => "filler-order",
            Self::InstanceOrder => "instance-order",
            Self::Option => "option",
            Self::Order => "order",
            Self::OriginalOrder => "original-order",
            Self::Plan => "plan",
            Self::Proposal => "proposal",
            Self::ReflexOrder => "reflex-order",
        }
    }
}
impl ::std::fmt::Debug for RequestIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RequestIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RequestIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestIntent> for Coding {
    fn from(code: RequestIntent) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/request-intent".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RequestIntent> for CodeableConcept {
    fn from(code: RequestIntent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RequestPriority](http://hl7.org/fhir/ValueSet/request-priority)**. Identifies the level of importance to be assigned to actioning the request.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RequestPriority {
    /** **asap**

ASAP. The request should be actioned as soon as possible - higher priority than urgent. */
    Asap,
    /** **routine**

Routine. The request has normal priority. */
    Routine,
    /** **stat**

STAT. The request should be actioned immediately - highest possible priority.  E.g. an emergency. */
    Stat,
    /** **urgent**

Urgent. The request should be actioned promptly - higher priority than routine. */
    Urgent,
}
impl ::core::str::FromStr for RequestPriority {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "asap" => Ok(Self::Asap),
            "routine" => Ok(Self::Routine),
            "stat" => Ok(Self::Stat),
            "urgent" => Ok(Self::Urgent),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestPriority {
    fn as_ref(&self) -> &str {
        match self {
            Self::Asap => "asap",
            Self::Routine => "routine",
            Self::Stat => "stat",
            Self::Urgent => "urgent",
        }
    }
}
impl ::std::fmt::Debug for RequestPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RequestPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RequestPriority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestPriority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestPriority> for Coding {
    fn from(code: RequestPriority) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/request-priority".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RequestPriority> for CodeableConcept {
    fn from(code: RequestPriority) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RequestResourceType](http://hl7.org/fhir/ValueSet/request-resource-types)**. A list of all the request resource types defined in this version of the FHIR specification.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RequestResourceType {
    /** **Appointment**

Appointment. A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s). */
    Appointment,
    /** **AppointmentResponse**

AppointmentResponse. A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection. */
    AppointmentResponse,
    /** **CarePlan**

CarePlan. Healthcare plan for patient or group. */
    CarePlan,
    /** **Claim**

Claim. Claim, Pre-determination or Pre-authorization. */
    Claim,
    /** **CommunicationRequest**

CommunicationRequest. A request for information to be sent to a receiver. */
    CommunicationRequest,
    /** **Contract**

Contract. Legal Agreement. */
    Contract,
    /** **DeviceRequest**

DeviceRequest. Medical device request. */
    DeviceRequest,
    /** **EnrollmentRequest**

EnrollmentRequest. Enrollment request. */
    EnrollmentRequest,
    /** **ImmunizationRecommendation**

ImmunizationRecommendation. Guidance or advice relating to an immunization. */
    ImmunizationRecommendation,
    /** **MedicationRequest**

MedicationRequest. Ordering of medication for patient or group. */
    MedicationRequest,
    /** **NutritionOrder**

NutritionOrder. Diet, formula or nutritional supplement request. */
    NutritionOrder,
    /** **ServiceRequest**

ServiceRequest. A record of a request for service such as diagnostic investigations, treatments, or operations to be performed. */
    ServiceRequest,
    /** **SupplyRequest**

SupplyRequest. Request for a medication, substance or device. */
    SupplyRequest,
    /** **Task**

Task. A task to be performed. */
    Task,
    /** **VisionPrescription**

VisionPrescription. Prescription for vision correction products for a patient. */
    VisionPrescription,
}
impl ::core::str::FromStr for RequestResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Appointment" => Ok(Self::Appointment),
            "AppointmentResponse" => Ok(Self::AppointmentResponse),
            "CarePlan" => Ok(Self::CarePlan),
            "Claim" => Ok(Self::Claim),
            "CommunicationRequest" => Ok(Self::CommunicationRequest),
            "Contract" => Ok(Self::Contract),
            "DeviceRequest" => Ok(Self::DeviceRequest),
            "EnrollmentRequest" => Ok(Self::EnrollmentRequest),
            "ImmunizationRecommendation" => Ok(Self::ImmunizationRecommendation),
            "MedicationRequest" => Ok(Self::MedicationRequest),
            "NutritionOrder" => Ok(Self::NutritionOrder),
            "ServiceRequest" => Ok(Self::ServiceRequest),
            "SupplyRequest" => Ok(Self::SupplyRequest),
            "Task" => Ok(Self::Task),
            "VisionPrescription" => Ok(Self::VisionPrescription),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Appointment => "Appointment",
            Self::AppointmentResponse => "AppointmentResponse",
            Self::CarePlan => "CarePlan",
            Self::Claim => "Claim",
            Self::CommunicationRequest => "CommunicationRequest",
            Self::Contract => "Contract",
            Self::DeviceRequest => "DeviceRequest",
            Self::EnrollmentRequest => "EnrollmentRequest",
            Self::ImmunizationRecommendation => "ImmunizationRecommendation",
            Self::MedicationRequest => "MedicationRequest",
            Self::NutritionOrder => "NutritionOrder",
            Self::ServiceRequest => "ServiceRequest",
            Self::SupplyRequest => "SupplyRequest",
            Self::Task => "Task",
            Self::VisionPrescription => "VisionPrescription",
        }
    }
}
impl ::std::fmt::Debug for RequestResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RequestResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RequestResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestResourceType> for Coding {
    fn from(code: RequestResourceType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/request-resource-types".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RequestResourceType> for CodeableConcept {
    fn from(code: RequestResourceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RequestStatus](http://hl7.org/fhir/ValueSet/request-status)**. Codes identifying the lifecycle stage of a request.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RequestStatus {
    /** **active**

Active. The request is in force and ready to be acted upon. */
    Active,
    /** **completed**

Completed. The activity described by the request has been fully performed.  No further activity will occur. */
    Completed,
    /** **draft**

Draft. The request has been created but is not yet complete or ready for action. */
    Draft,
    /** **entered-in-error**

Entered in Error. This request should never have existed and should be considered 'void'.  (It is possible that real-world decisions were based on it.  If real-world activity has occurred, the status should be "revoked" rather than "entered-in-error".). */
    EnteredInError,
    /** **on-hold**

On Hold. The request (and any implicit authorization to act) has been temporarily withdrawn but is expected to resume in the future. */
    OnHold,
    /** **revoked**

Revoked. The request (and any implicit authorization to act) has been terminated prior to the known full completion of the intended actions.  No further activity should occur. */
    Revoked,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this request.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply,  but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for RequestStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "on-hold" => Ok(Self::OnHold),
            "revoked" => Ok(Self::Revoked),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::OnHold => "on-hold",
            Self::Revoked => "revoked",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for RequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RequestStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestStatus> for Coding {
    fn from(code: RequestStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/request-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RequestStatus> for CodeableConcept {
    fn from(code: RequestStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResearchElementType](http://hl7.org/fhir/ValueSet/research-element-type)**. The possible types of research elements (E.g. Population, Exposure, Outcome).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResearchElementType {
    /** **exposure**

Exposure. The element defines an exposure within the population that is being researched. */
    Exposure,
    /** **outcome**

Outcome. The element defines an outcome within the population that is being researched. */
    Outcome,
    /** **population**

Population. The element defines the population that forms the basis for research. */
    Population,
}
impl ::core::str::FromStr for ResearchElementType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exposure" => Ok(Self::Exposure),
            "outcome" => Ok(Self::Outcome),
            "population" => Ok(Self::Population),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchElementType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exposure => "exposure",
            Self::Outcome => "outcome",
            Self::Population => "population",
        }
    }
}
impl ::std::fmt::Debug for ResearchElementType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResearchElementType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResearchElementType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchElementType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchElementType> for Coding {
    fn from(code: ResearchElementType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/research-element-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResearchElementType> for CodeableConcept {
    fn from(code: ResearchElementType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResearchStudyObjectiveType](http://hl7.org/fhir/ValueSet/research-study-objective-type)**. Codes for the kind of study objective.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResearchStudyObjectiveType {
    /** **exploratory**

Exploratory. Exploratory questions to be answered in the study. */
    Exploratory,
    /** **primary**

Primary. The main question to be answered, and the one that drives any statistical planning for the study—e.g., calculation of the sample size to provide the appropriate power for statistical testing. */
    Primary,
    /** **secondary**

Secondary. Question to be answered in the study that is of lesser importance than the primary objective. */
    Secondary,
}
impl ::core::str::FromStr for ResearchStudyObjectiveType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exploratory" => Ok(Self::Exploratory),
            "primary" => Ok(Self::Primary),
            "secondary" => Ok(Self::Secondary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyObjectiveType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exploratory => "exploratory",
            Self::Primary => "primary",
            Self::Secondary => "secondary",
        }
    }
}
impl ::std::fmt::Debug for ResearchStudyObjectiveType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResearchStudyObjectiveType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResearchStudyObjectiveType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyObjectiveType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyObjectiveType> for Coding {
    fn from(code: ResearchStudyObjectiveType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/research-study-objective-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResearchStudyObjectiveType> for CodeableConcept {
    fn from(code: ResearchStudyObjectiveType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResearchStudyPhase](http://hl7.org/fhir/ValueSet/research-study-phase)**. Codes for the stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResearchStudyPhase {
    /** **early-phase-1**

Early Phase 1. Designation for optional exploratory trials conducted in accordance with the United States Food and Drug Administration's (FDA) 2006 Guidance on Exploratory Investigational New Drug (IND) Studies. Formerly called Phase 0. */
    EarlyPhase1,
    /** **n-a**

N/A. Trials without phases (for example, studies of devices or behavioral interventions). */
    NA,
    /** **phase-1**

Phase 1. Includes initial studies to determine the metabolism and pharmacologic actions of drugs in humans, the side effects associated with increasing doses, and to gain early evidence of effectiveness; may include healthy participants and/or patients. */
    Phase1,
    /** **phase-1-phase-2**

Phase 1/Phase 2. Trials that are a combination of phases 1 and 2. */
    Phase1Phase2,
    /** **phase-2**

Phase 2. Includes controlled clinical studies conducted to evaluate the effectiveness of the drug for a particular indication or indications in participants with the disease or condition under study and to determine the common short-term side effects and risks. */
    Phase2,
    /** **phase-2-phase-3**

Phase 2/Phase 3. Trials that are a combination of phases 2 and 3. */
    Phase2Phase3,
    /** **phase-3**

Phase 3. Includes trials conducted after preliminary evidence suggesting effectiveness of the drug has been obtained, and are intended to gather additional information to evaluate the overall benefit-risk relationship of the drug. */
    Phase3,
    /** **phase-4**

Phase 4. Studies of FDA-approved drugs to delineate additional information including the drug's risks, benefits, and optimal use. */
    Phase4,
}
impl ::core::str::FromStr for ResearchStudyPhase {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "early-phase-1" => Ok(Self::EarlyPhase1),
            "n-a" => Ok(Self::NA),
            "phase-1" => Ok(Self::Phase1),
            "phase-1-phase-2" => Ok(Self::Phase1Phase2),
            "phase-2" => Ok(Self::Phase2),
            "phase-2-phase-3" => Ok(Self::Phase2Phase3),
            "phase-3" => Ok(Self::Phase3),
            "phase-4" => Ok(Self::Phase4),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyPhase {
    fn as_ref(&self) -> &str {
        match self {
            Self::EarlyPhase1 => "early-phase-1",
            Self::NA => "n-a",
            Self::Phase1 => "phase-1",
            Self::Phase1Phase2 => "phase-1-phase-2",
            Self::Phase2 => "phase-2",
            Self::Phase2Phase3 => "phase-2-phase-3",
            Self::Phase3 => "phase-3",
            Self::Phase4 => "phase-4",
        }
    }
}
impl ::std::fmt::Debug for ResearchStudyPhase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResearchStudyPhase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResearchStudyPhase {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyPhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyPhase> for Coding {
    fn from(code: ResearchStudyPhase) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/research-study-phase".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResearchStudyPhase> for CodeableConcept {
    fn from(code: ResearchStudyPhase) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResearchStudyPrimaryPurposeType](http://hl7.org/fhir/ValueSet/research-study-prim-purp-type)**. Codes for the main intent of the study.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResearchStudyPrimaryPurposeType {
    /** **basic-science**

Basic Science. One or more interventions for examining the basic mechanism of action (for example, physiology or biomechanics of an intervention). */
    BasicScience,
    /** **device-feasibility**

Device Feasibility. An intervention of a device product is being evaluated to determine the feasibility of the product or to test a prototype device and not health outcomes. Such studies are conducted to confirm the design and operating specifications of a device before beginning a full clinical trial. */
    DeviceFeasibility,
    /** **diagnostic**

Diagnostic. One or more interventions are being evaluated for identifying a disease or health condition. */
    Diagnostic,
    /** **health-services-research**

Health Services Research. One or more interventions for evaluating the delivery, processes, management, organization, or financing of healthcare. */
    HealthServicesResearch,
    /** **prevention**

Prevention. One or more interventions are being assessed for preventing the development of a specific disease or health condition. */
    Prevention,
    /** **screening**

Screening. One or more interventions are assessed or examined for identifying a condition, or risk factors for a condition, in people who are not yet known to have the condition or risk factor. */
    Screening,
    /** **supportive-care**

Supportive Care. One or more interventions are evaluated for maximizing comfort, minimizing side effects, or mitigating against a decline in the participant's health or function. */
    SupportiveCare,
    /** **treatment**

Treatment. One or more interventions are being evaluated for treating a disease, syndrome, or condition. */
    Treatment,
}
impl ::core::str::FromStr for ResearchStudyPrimaryPurposeType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "basic-science" => Ok(Self::BasicScience),
            "device-feasibility" => Ok(Self::DeviceFeasibility),
            "diagnostic" => Ok(Self::Diagnostic),
            "health-services-research" => Ok(Self::HealthServicesResearch),
            "prevention" => Ok(Self::Prevention),
            "screening" => Ok(Self::Screening),
            "supportive-care" => Ok(Self::SupportiveCare),
            "treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyPrimaryPurposeType {
    fn as_ref(&self) -> &str {
        match self {
            Self::BasicScience => "basic-science",
            Self::DeviceFeasibility => "device-feasibility",
            Self::Diagnostic => "diagnostic",
            Self::HealthServicesResearch => "health-services-research",
            Self::Prevention => "prevention",
            Self::Screening => "screening",
            Self::SupportiveCare => "supportive-care",
            Self::Treatment => "treatment",
        }
    }
}
impl ::std::fmt::Debug for ResearchStudyPrimaryPurposeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResearchStudyPrimaryPurposeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResearchStudyPrimaryPurposeType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyPrimaryPurposeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyPrimaryPurposeType> for Coding {
    fn from(code: ResearchStudyPrimaryPurposeType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/research-study-prim-purp-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResearchStudyPrimaryPurposeType> for CodeableConcept {
    fn from(code: ResearchStudyPrimaryPurposeType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResearchStudyReasonStopped](http://hl7.org/fhir/ValueSet/research-study-reason-stopped)**. Codes for why the study ended prematurely.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResearchStudyReasonStopped {
    /** **accrual-goal-met**

Accrual Goal Met. The study prematurely ended because the accrual goal was met. */
    AccrualGoalMet,
    /** **closed-due-to-lack-of-study-progress**

Closed due to lack of study progress. The study prematurely ended due to lack of study progress. */
    ClosedDueToLackOfStudyProgress,
    /** **closed-due-to-toxicity**

Closed due to toxicity. The study prematurely ended due to toxicity. */
    ClosedDueToToxicity,
    /** **temporarily-closed-per-study-design**

Temporarily closed per study design. The study prematurely ended temporarily per study design. */
    TemporarilyClosedPerStudyDesign,
}
impl ::core::str::FromStr for ResearchStudyReasonStopped {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accrual-goal-met" => Ok(Self::AccrualGoalMet),
            "closed-due-to-lack-of-study-progress" => {
                Ok(Self::ClosedDueToLackOfStudyProgress)
            }
            "closed-due-to-toxicity" => Ok(Self::ClosedDueToToxicity),
            "temporarily-closed-per-study-design" => {
                Ok(Self::TemporarilyClosedPerStudyDesign)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyReasonStopped {
    fn as_ref(&self) -> &str {
        match self {
            Self::AccrualGoalMet => "accrual-goal-met",
            Self::ClosedDueToLackOfStudyProgress => {
                "closed-due-to-lack-of-study-progress"
            }
            Self::ClosedDueToToxicity => "closed-due-to-toxicity",
            Self::TemporarilyClosedPerStudyDesign => {
                "temporarily-closed-per-study-design"
            }
        }
    }
}
impl ::std::fmt::Debug for ResearchStudyReasonStopped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResearchStudyReasonStopped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResearchStudyReasonStopped {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyReasonStopped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyReasonStopped> for Coding {
    fn from(code: ResearchStudyReasonStopped) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/research-study-reason-stopped".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResearchStudyReasonStopped> for CodeableConcept {
    fn from(code: ResearchStudyReasonStopped) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResearchStudyStatus](http://hl7.org/fhir/ValueSet/research-study-status)**. Codes that convey the current status of the research study.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResearchStudyStatus {
    /** **active**

Active. Study is opened for accrual. */
    Active,
    /** **administratively-completed**

Administratively Completed. Study is completed prematurely and will not resume; patients are no longer examined nor treated. */
    AdministrativelyCompleted,
    /** **approved**

Approved. Protocol is approved by the review board. */
    Approved,
    /** **closed-to-accrual**

Closed to Accrual. Study is closed for accrual; patients can be examined and treated. */
    ClosedToAccrual,
    /** **closed-to-accrual-and-intervention**

Closed to Accrual and Intervention. Study is closed to accrual and intervention, i.e. the study is closed to enrollment, all study subjects have completed treatment or intervention but are still being followed according to the primary objective of the study. */
    ClosedToAccrualAndIntervention,
    /** **completed**

Completed. Study is closed to accrual and intervention, i.e. the study is closed to enrollment, all study subjects have completed treatment
or intervention but are still being followed according to the primary objective of the study. */
    Completed,
    /** **disapproved**

Disapproved. Protocol was disapproved by the review board. */
    Disapproved,
    /** **in-review**

In Review. Protocol is submitted to the review board for approval. */
    InReview,
    /** **temporarily-closed-to-accrual**

Temporarily Closed to Accrual. Study is temporarily closed for accrual; can be potentially resumed in the future; patients can be examined and treated. */
    TemporarilyClosedToAccrual,
    /** **temporarily-closed-to-accrual-and-intervention**

Temporarily Closed to Accrual and Intervention. Study is temporarily closed for accrual and intervention and potentially can be resumed in the future. */
    TemporarilyClosedToAccrualAndIntervention,
    /** **withdrawn**

Withdrawn. Protocol was withdrawn by the lead organization. */
    Withdrawn,
}
impl ::core::str::FromStr for ResearchStudyStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "administratively-completed" => Ok(Self::AdministrativelyCompleted),
            "approved" => Ok(Self::Approved),
            "closed-to-accrual" => Ok(Self::ClosedToAccrual),
            "closed-to-accrual-and-intervention" => {
                Ok(Self::ClosedToAccrualAndIntervention)
            }
            "completed" => Ok(Self::Completed),
            "disapproved" => Ok(Self::Disapproved),
            "in-review" => Ok(Self::InReview),
            "temporarily-closed-to-accrual" => Ok(Self::TemporarilyClosedToAccrual),
            "temporarily-closed-to-accrual-and-intervention" => {
                Ok(Self::TemporarilyClosedToAccrualAndIntervention)
            }
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::AdministrativelyCompleted => "administratively-completed",
            Self::Approved => "approved",
            Self::ClosedToAccrual => "closed-to-accrual",
            Self::ClosedToAccrualAndIntervention => "closed-to-accrual-and-intervention",
            Self::Completed => "completed",
            Self::Disapproved => "disapproved",
            Self::InReview => "in-review",
            Self::TemporarilyClosedToAccrual => "temporarily-closed-to-accrual",
            Self::TemporarilyClosedToAccrualAndIntervention => {
                "temporarily-closed-to-accrual-and-intervention"
            }
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Debug for ResearchStudyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResearchStudyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResearchStudyStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyStatus> for Coding {
    fn from(code: ResearchStudyStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/research-study-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResearchStudyStatus> for CodeableConcept {
    fn from(code: ResearchStudyStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResearchSubjectStatus](http://hl7.org/fhir/ValueSet/research-subject-status)**. Indicates the progression of a study subject through a study.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResearchSubjectStatus {
    /** **candidate**

Candidate. An identified person that can be considered for inclusion in a study. */
    Candidate,
    /** **eligible**

Eligible. A person that has met the eligibility criteria for inclusion in a study. */
    Eligible,
    /** **follow-up**

Follow-up. A person is no longer receiving study intervention and/or being evaluated with tests and procedures according to the protocol, but they are being monitored on a protocol-prescribed schedule. */
    FollowUp,
    /** **ineligible**

Ineligible. A person who did not meet one or more criteria required for participation in a study is considered to have failed screening or
is ineligible for the study. */
    Ineligible,
    /** **not-registered**

Not Registered. A person for whom registration was not completed. */
    NotRegistered,
    /** **off-study**

Off-study. A person that has ended their participation on a study either because their treatment/observation is complete or through not
responding, withdrawal, non-compliance and/or adverse event. */
    OffStudy,
    /** **on-study**

On-study. A person that is enrolled or registered on a study. */
    OnStudy,
    /** **on-study-intervention**

On-study-intervention. The person is receiving the treatment or participating in an activity (e.g. yoga, diet, etc.) that the study is evaluating. */
    OnStudyIntervention,
    /** **on-study-observation**

On-study-observation. The subject is being evaluated via tests and assessments according to the study calendar, but is not receiving any intervention. Note that this state is study-dependent and might not exist in all studies.  A synonym for this is "short-term follow-up". */
    OnStudyObservation,
    /** **pending-on-study**

Pending on-study. A person is pre-registered for a study. */
    PendingOnStudy,
    /** **potential-candidate**

Potential Candidate. A person that is potentially eligible for participation in the study. */
    PotentialCandidate,
    /** **screening**

Screening. A person who is being evaluated for eligibility for a study. */
    Screening,
    /** **withdrawn**

Withdrawn. The person has withdrawn their participation in the study before registration. */
    Withdrawn,
}
impl ::core::str::FromStr for ResearchSubjectStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "candidate" => Ok(Self::Candidate),
            "eligible" => Ok(Self::Eligible),
            "follow-up" => Ok(Self::FollowUp),
            "ineligible" => Ok(Self::Ineligible),
            "not-registered" => Ok(Self::NotRegistered),
            "off-study" => Ok(Self::OffStudy),
            "on-study" => Ok(Self::OnStudy),
            "on-study-intervention" => Ok(Self::OnStudyIntervention),
            "on-study-observation" => Ok(Self::OnStudyObservation),
            "pending-on-study" => Ok(Self::PendingOnStudy),
            "potential-candidate" => Ok(Self::PotentialCandidate),
            "screening" => Ok(Self::Screening),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchSubjectStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Candidate => "candidate",
            Self::Eligible => "eligible",
            Self::FollowUp => "follow-up",
            Self::Ineligible => "ineligible",
            Self::NotRegistered => "not-registered",
            Self::OffStudy => "off-study",
            Self::OnStudy => "on-study",
            Self::OnStudyIntervention => "on-study-intervention",
            Self::OnStudyObservation => "on-study-observation",
            Self::PendingOnStudy => "pending-on-study",
            Self::PotentialCandidate => "potential-candidate",
            Self::Screening => "screening",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Debug for ResearchSubjectStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResearchSubjectStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResearchSubjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchSubjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchSubjectStatus> for Coding {
    fn from(code: ResearchSubjectStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/research-subject-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResearchSubjectStatus> for CodeableConcept {
    fn from(code: ResearchSubjectStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResourceSecurityCategory](http://hl7.org/fhir/resource-security-category)**. Codes indicating how resources behave from a security perspective\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ResourceSecurityCategory {
    /** **anonymous**

Anonymous READ Access Resource. These resources tend to not contain any individual data, or business sensitive data. Most often these Resources will be available for anonymous access, meaning there is no access control based on the user or system requesting. However these Resources do tend to contain important information that must be authenticated back to the source publishing them, and protected from integrity failures in communication. For this reason server authenticated https (TLS) is recommended to provide authentication of the server and integrity protection in transit. This is normal web-server use of https. */
    Anonymous,
    /** **business**

Business Sensitive Resource. These Resources tend to not contain any individual data, but do have data that describe business or service sensitive data. The use of the term Business is not intended to only mean an incorporated business, but rather the more broad concept of an organization, location, or other group that is not identifable as individuals. Often these resources will require some for of client authentication to assure that only authorized access is given. The client access control may be to individuals, or may be to system identity. For this purpose possible client authentication methods such as: mutual-authenticated-TLS, APIKey, App signed JWT, or App OAuth client-id JWT For example: a App that uses a Business protected Provider Directory to determine other business endpoint details. */
    Business,
    /** **individual**

Individual Sensitive Resource. These Resources do NOT contain Patient data, but do contain individual information about other participants. These other individuals are Practitioners, PractitionerRole, CareTeam, or other users. These identities are needed to enable the practice of healthcare. These identities are identities under general privacy regulations, and thus must consider Privacy risk. Often access to these other identities are covered by business relationships. For this purpose access to these Resources will tend to be Role specific using methods such as RBAC or ABAC. */
    Individual,
    /** **not-classified**

Not classified. Some Resources can be used for a wide scope of use-cases that span very sensitive to very non-sensitive. These Resources do not fall into any of the above classifications, as their sensitivity is highly variable. These Resources will need special handling. These Resources often contain metadata that describes the content in a way that can be used for Access Control decisions. */
    NotClassified,
    /** **patient**

Patient Sensitive. These Resources make up the bulk of FHIR and therefore are the most commonly understood. These Resources contain highly sesitive health information, or are closely linked to highly sensitive health information. These Resources will often use the security labels to differentiate various confidentiality levels within this broad group of Patient Sensitive data. Access to these Resources often requires a declared Purpose Of Use. Access to these Resources is often controlled by a Privacy Consent. */
    Patient,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ResourceSecurityCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "anonymous" => Ok(Self::Anonymous),
            "business" => Ok(Self::Business),
            "individual" => Ok(Self::Individual),
            "not-classified" => Ok(Self::NotClassified),
            "patient" => Ok(Self::Patient),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ResourceSecurityCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Anonymous => "anonymous",
            Self::Business => "business",
            Self::Individual => "individual",
            Self::NotClassified => "not-classified",
            Self::Patient => "patient",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ResourceSecurityCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResourceSecurityCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResourceSecurityCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceSecurityCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResourceSecurityCategory> for Coding {
    fn from(code: ResourceSecurityCategory) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/resource-security-category".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResourceSecurityCategory> for CodeableConcept {
    fn from(code: ResourceSecurityCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResourceType](http://hl7.org/fhir/resource-types)**. One of the resource types defined as part of this version of FHIR.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ResourceType {
    /** **Account**

Account. A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc. */
    Account,
    /** **ActivityDefinition**

ActivityDefinition. This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context. */
    ActivityDefinition,
    /** **AdministrableProductDefinition**

AdministrableProductDefinition. A medicinal product in the final form which is suitable for administering to a patient (after any mixing of multiple components, dissolution etc. has been performed). */
    AdministrableProductDefinition,
    /** **AdverseEvent**

AdverseEvent. Actual or  potential/avoided event causing unintended physical injury resulting from or contributed to by medical care, a research study or other healthcare setting factors that requires additional monitoring, treatment, or hospitalization, or that results in death. */
    AdverseEvent,
    /** **AllergyIntolerance**

AllergyIntolerance. Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance. */
    AllergyIntolerance,
    /** **Appointment**

Appointment. A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s). */
    Appointment,
    /** **AppointmentResponse**

AppointmentResponse. A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection. */
    AppointmentResponse,
    /** **AuditEvent**

AuditEvent. A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage. */
    AuditEvent,
    /** **Basic**

Basic. Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don't map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification. */
    Basic,
    /** **Binary**

Binary. A resource that represents the data of a single raw artifact as digital content accessible in its native format.  A Binary resource can contain any content, whether text, image, pdf, zip archive, etc. */
    Binary,
    /** **BiologicallyDerivedProduct**

BiologicallyDerivedProduct. A material substance originating from a biological entity intended to be transplanted or infused
into another (possibly the same) biological entity. */
    BiologicallyDerivedProduct,
    /** **BodyStructure**

BodyStructure. Record details about an anatomical structure.  This resource may be used when a coded concept does not provide the necessary detail needed for the use case. */
    BodyStructure,
    /** **Bundle**

Bundle. A container for a collection of resources. */
    Bundle,
    /** **CapabilityStatement**

CapabilityStatement. A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server for a particular version of FHIR that may be used as a statement of actual server functionality or a statement of required or desired server implementation. */
    CapabilityStatement,
    /** **CarePlan**

CarePlan. Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions. */
    CarePlan,
    /** **CareTeam**

CareTeam. The Care Team includes all the people and organizations who plan to participate in the coordination and delivery of care for a patient. */
    CareTeam,
    /** **CatalogEntry**

CatalogEntry. Catalog entries are wrappers that contextualize items included in a catalog. */
    CatalogEntry,
    /** **ChargeItem**

ChargeItem. The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation. */
    ChargeItem,
    /** **ChargeItemDefinition**

ChargeItemDefinition. The ChargeItemDefinition resource provides the properties that apply to the (billing) codes necessary to calculate costs and prices. The properties may differ largely depending on type and realm, therefore this resource gives only a rough structure and requires profiling for each type of billing code system. */
    ChargeItemDefinition,
    /** **Citation**

Citation. The Citation Resource enables reference to any knowledge artifact for purposes of identification and attribution. The Citation Resource supports existing reference structures and developing publication practices such as versioning, expressing complex contributorship roles, and referencing computable resources. */
    Citation,
    /** **Claim**

Claim. A provider issued list of professional services and products which have been provided, or are to be provided, to a patient which is sent to an insurer for reimbursement. */
    Claim,
    /** **ClaimResponse**

ClaimResponse. This resource provides the adjudication details from the processing of a Claim resource. */
    ClaimResponse,
    /** **ClinicalImpression**

ClinicalImpression. A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score. */
    ClinicalImpression,
    /** **ClinicalUseDefinition**

ClinicalUseDefinition. A single issue - either an indication, contraindication, interaction or an undesirable effect for a medicinal product, medication, device or procedure. */
    ClinicalUseDefinition,
    /** **CodeSystem**

CodeSystem. The CodeSystem resource is used to declare the existence of and describe a code system or code system supplement and its key properties, and optionally define a part or all of its content. */
    CodeSystem,
    /** **Communication**

Communication. An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency that was notified about a reportable condition. */
    Communication,
    /** **CommunicationRequest**

CommunicationRequest. A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition. */
    CommunicationRequest,
    /** **CompartmentDefinition**

CompartmentDefinition. A compartment definition that defines how resources are accessed on a server. */
    CompartmentDefinition,
    /** **Composition**

Composition. A set of healthcare-related information that is assembled together into a single logical package that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. A Composition defines the structure and narrative content necessary for a document. However, a Composition alone does not constitute a document. Rather, the Composition must be the first entry in a Bundle where Bundle.type=document, and any other resources referenced from Composition must be included as subsequent entries in the Bundle (for example Patient, Practitioner, Encounter, etc.). */
    Composition,
    /** **ConceptMap**

ConceptMap. A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models. */
    ConceptMap,
    /** **Condition**

Condition. A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern. */
    Condition,
    /** **Consent**

Consent. A record of a healthcare consumer’s  choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time. */
    Consent,
    /** **Contract**

Contract. Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement. */
    Contract,
    /** **Coverage**

Coverage. Financial instrument which may be used to reimburse or pay for health care products and services. Includes both insurance and self-payment. */
    Coverage,
    /** **CoverageEligibilityRequest**

CoverageEligibilityRequest. The CoverageEligibilityRequest provides patient and insurance coverage information to an insurer for them to respond, in the form of an CoverageEligibilityResponse, with information regarding whether the stated coverage is valid and in-force and optionally to provide the insurance details of the policy. */
    CoverageEligibilityRequest,
    /** **CoverageEligibilityResponse**

CoverageEligibilityResponse. This resource provides eligibility and plan details from the processing of an CoverageEligibilityRequest resource. */
    CoverageEligibilityResponse,
    /** **DetectedIssue**

DetectedIssue. Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc. */
    DetectedIssue,
    /** **Device**

Device. A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device. */
    Device,
    /** **DeviceDefinition**

DeviceDefinition. The characteristics, operational status and capabilities of a medical-related component of a medical device. */
    DeviceDefinition,
    /** **DeviceMetric**

DeviceMetric. Describes a measurement, calculation or setting capability of a medical device. */
    DeviceMetric,
    /** **DeviceRequest**

DeviceRequest. Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker. */
    DeviceRequest,
    /** **DeviceUseStatement**

DeviceUseStatement. A record of a device being used by a patient where the record is the result of a report from the patient or another clinician. */
    DeviceUseStatement,
    /** **DiagnosticReport**

DiagnosticReport. The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports. */
    DiagnosticReport,
    /** **DocumentManifest**

DocumentManifest. A collection of documents compiled for a purpose together with metadata that applies to the collection. */
    DocumentManifest,
    /** **DocumentReference**

DocumentReference. A reference to a document of any kind for any purpose. Provides metadata about the document so that the document can be discovered and managed. The scope of a document is any seralized object with a mime-type, so includes formal patient centric documents (CDA), cliical notes, scanned paper, and non-patient specific documents like policy text. */
    DocumentReference,
    /** **DomainResource**

DomainResource. --- Abstract Type! ---A resource that includes narrative, extensions, and contained resources. */
    DomainResource,
    /** **Encounter**

Encounter. An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient. */
    Encounter,
    /** **Endpoint**

Endpoint. The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information. */
    Endpoint,
    /** **EnrollmentRequest**

EnrollmentRequest. This resource provides the insurance enrollment details to the insurer regarding a specified coverage. */
    EnrollmentRequest,
    /** **EnrollmentResponse**

EnrollmentResponse. This resource provides enrollment and plan details from the processing of an EnrollmentRequest resource. */
    EnrollmentResponse,
    /** **EpisodeOfCare**

EpisodeOfCare. An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time. */
    EpisodeOfCare,
    /** **EventDefinition**

EventDefinition. The EventDefinition resource provides a reusable description of when a particular event can occur. */
    EventDefinition,
    /** **Evidence**

Evidence. The Evidence Resource provides a machine-interpretable expression of an evidence concept including the evidence variables (eg population, exposures/interventions, comparators, outcomes, measured variables, confounding variables), the statistics, and the certainty of this evidence. */
    Evidence,
    /** **EvidenceReport**

EvidenceReport. The EvidenceReport Resource is a specialized container for a collection of resources and codable concepts, adapted to support compositions of Evidence, EvidenceVariable, and Citation resources and related concepts. */
    EvidenceReport,
    /** **EvidenceVariable**

EvidenceVariable. The EvidenceVariable resource describes an element that knowledge (Evidence) is about. */
    EvidenceVariable,
    /** **ExampleScenario**

ExampleScenario. Example of workflow instance. */
    ExampleScenario,
    /** **ExplanationOfBenefit**

ExplanationOfBenefit. This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided. */
    ExplanationOfBenefit,
    /** **FamilyMemberHistory**

FamilyMemberHistory. Significant health conditions for a person related to the patient relevant in the context of care for the patient. */
    FamilyMemberHistory,
    /** **Flag**

Flag. Prospective warnings of potential issues when providing care to the patient. */
    Flag,
    /** **Goal**

Goal. Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc. */
    Goal,
    /** **GraphDefinition**

GraphDefinition. A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set. */
    GraphDefinition,
    /** **Group**

Group. Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively, and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization. */
    Group,
    /** **GuidanceResponse**

GuidanceResponse. A guidance response is the formal response to a guidance request, including any output parameters returned by the evaluation, as well as the description of any proposed actions to be taken. */
    GuidanceResponse,
    /** **HealthcareService**

HealthcareService. The details of a healthcare service available at a location. */
    HealthcareService,
    /** **ImagingStudy**

ImagingStudy. Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities. */
    ImagingStudy,
    /** **Immunization**

Immunization. Describes the event of a patient being administered a vaccine or a record of an immunization as reported by a patient, a clinician or another party. */
    Immunization,
    /** **ImmunizationEvaluation**

ImmunizationEvaluation. Describes a comparison of an immunization event against published recommendations to determine if the administration is "valid" in relation to those  recommendations. */
    ImmunizationEvaluation,
    /** **ImmunizationRecommendation**

ImmunizationRecommendation. A patient's point-in-time set of recommendations (i.e. forecasting) according to a published schedule with optional supporting justification. */
    ImmunizationRecommendation,
    /** **ImplementationGuide**

ImplementationGuide. A set of rules of how a particular interoperability or standards problem is solved - typically through the use of FHIR resources. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts. */
    ImplementationGuide,
    /** **Ingredient**

Ingredient. An ingredient of a manufactured item or pharmaceutical product. */
    Ingredient,
    /** **InsurancePlan**

InsurancePlan. Details of a Health Insurance product/plan provided by an organization. */
    InsurancePlan,
    /** **Invoice**

Invoice. Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose. */
    Invoice,
    /** **Library**

Library. The Library resource is a general-purpose container for knowledge asset definitions. It can be used to describe and expose existing knowledge assets such as logic libraries and information model descriptions, as well as to describe a collection of knowledge assets. */
    Library,
    /** **Linkage**

Linkage. Identifies two or more records (resource instances) that refer to the same real-world "occurrence". */
    Linkage,
    /** **List**

List. A list is a curated collection of resources. */
    List,
    /** **Location**

Location. Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated. */
    Location,
    /** **ManufacturedItemDefinition**

ManufacturedItemDefinition. The definition and characteristics of a medicinal manufactured item, such as a tablet or capsule, as contained in a packaged medicinal product. */
    ManufacturedItemDefinition,
    /** **Measure**

Measure. The Measure resource provides the definition of a quality measure. */
    Measure,
    /** **MeasureReport**

MeasureReport. The MeasureReport resource contains the results of the calculation of a measure; and optionally a reference to the resources involved in that calculation. */
    MeasureReport,
    /** **Media**

Media. A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference. */
    Media,
    /** **Medication**

Medication. This resource is primarily used for the identification and definition of a medication for the purposes of prescribing, dispensing, and administering a medication as well as for making statements about medication use. */
    Medication,
    /** **MedicationAdministration**

MedicationAdministration. Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner. */
    MedicationAdministration,
    /** **MedicationDispense**

MedicationDispense. Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order. */
    MedicationDispense,
    /** **MedicationKnowledge**

MedicationKnowledge. Information about a medication that is used to support knowledge. */
    MedicationKnowledge,
    /** **MedicationRequest**

MedicationRequest. An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns. */
    MedicationRequest,
    /** **MedicationStatement**

MedicationStatement. A record of a medication that is being consumed by a patient.   A MedicationStatement may indicate that the patient may be taking the medication now or has taken the medication in the past or will be taking the medication in the future.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay.   The medication information may come from sources such as the patient's memory, from a prescription bottle,  or from a list of medications the patient, clinician or other party maintains.

The primary difference between a medication statement and a medication administration is that the medication administration has complete administration information and is based on actual administration information from the person who administered the medication.  A medication statement is often, if not always, less specific.  There is no required date/time when the medication was administered, in fact we only know that a source has reported the patient is taking this medication, where details such as time, quantity, or rate or even medication product may be incomplete or missing or less precise.  As stated earlier, the medication statement information may come from the patient's memory, from a prescription bottle or from a list of medications the patient, clinician or other party maintains.  Medication administration is more formal and is not missing detailed information. */
    MedicationStatement,
    /** **MedicinalProductDefinition**

MedicinalProductDefinition. Detailed definition of a medicinal product, typically for uses other than direct patient care (e.g. regulatory use, drug catalogs, to support prescribing, adverse events management etc.). */
    MedicinalProductDefinition,
    /** **MessageDefinition**

MessageDefinition. Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted. */
    MessageDefinition,
    /** **MessageHeader**

MessageHeader. The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle. */
    MessageHeader,
    /** **MolecularSequence**

MolecularSequence. Raw data describing a biological sequence. */
    MolecularSequence,
    /** **NamingSystem**

NamingSystem. A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types. */
    NamingSystem,
    /** **NutritionOrder**

NutritionOrder. A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident. */
    NutritionOrder,
    /** **NutritionProduct**

NutritionProduct. A food or fluid product that is consumed by patients. */
    NutritionProduct,
    /** **Observation**

Observation. Measurements and simple assertions made about a patient, device or other subject. */
    Observation,
    /** **ObservationDefinition**

ObservationDefinition. Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service. */
    ObservationDefinition,
    /** **OperationDefinition**

OperationDefinition. A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction). */
    OperationDefinition,
    /** **OperationOutcome**

OperationOutcome. A collection of error, warning, or information messages that result from a system action. */
    OperationOutcome,
    /** **Organization**

Organization. A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc. */
    Organization,
    /** **OrganizationAffiliation**

OrganizationAffiliation. Defines an affiliation/assotiation/relationship between 2 distinct oganizations, that is not a part-of relationship/sub-division relationship. */
    OrganizationAffiliation,
    /** **PackagedProductDefinition**

PackagedProductDefinition. A medically related item or items, in a container or package. */
    PackagedProductDefinition,
    /** **Parameters**

Parameters. This resource is a non-persisted resource used to pass information into and back from an [operation](operations.html). It has no other use, and there is no RESTful endpoint associated with it. */
    Parameters,
    /** **Patient**

Patient. Demographics and other administrative information about an individual or animal receiving care or other health-related services. */
    Patient,
    /** **PaymentNotice**

PaymentNotice. This resource provides the status of the payment for goods and services rendered, and the request and response resource references. */
    PaymentNotice,
    /** **PaymentReconciliation**

PaymentReconciliation. This resource provides the details including amount of a payment and allocates the payment items being paid. */
    PaymentReconciliation,
    /** **Person**

Person. Demographics and administrative information about a person independent of a specific health-related context. */
    Person,
    /** **PlanDefinition**

PlanDefinition. This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical and non-clinical artifacts such as clinical decision support rules, order sets, protocols, and drug quality specifications. */
    PlanDefinition,
    /** **Practitioner**

Practitioner. A person who is directly or indirectly involved in the provisioning of healthcare. */
    Practitioner,
    /** **PractitionerRole**

PractitionerRole. A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time. */
    PractitionerRole,
    /** **Procedure**

Procedure. An action that is or was performed on or for a patient. This can be a physical intervention like an operation, or less invasive like long term services, counseling, or hypnotherapy. */
    Procedure,
    /** **Provenance**

Provenance. Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies. */
    Provenance,
    /** **Questionnaire**

Questionnaire. A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection. */
    Questionnaire,
    /** **QuestionnaireResponse**

QuestionnaireResponse. A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to. */
    QuestionnaireResponse,
    /** **RegulatedAuthorization**

RegulatedAuthorization. Regulatory approval, clearance or licencing related to a regulated product, treatment, facility or activity that is cited in a guidance, regulation, rule or legislative act. An example is Market Authorization relating to a Medicinal Product. */
    RegulatedAuthorization,
    /** **RelatedPerson**

RelatedPerson. Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process. */
    RelatedPerson,
    /** **RequestGroup**

RequestGroup. A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one". */
    RequestGroup,
    /** **ResearchDefinition**

ResearchDefinition. The ResearchDefinition resource describes the conditional state (population and any exposures being compared within the population) and outcome (if specified) that the knowledge (evidence, assertion, recommendation) is about. */
    ResearchDefinition,
    /** **ResearchElementDefinition**

ResearchElementDefinition. The ResearchElementDefinition resource describes a "PICO" element that knowledge (evidence, assertion, recommendation) is about. */
    ResearchElementDefinition,
    /** **ResearchStudy**

ResearchStudy. A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects. */
    ResearchStudy,
    /** **ResearchSubject**

ResearchSubject. A physical entity which is the primary unit of operational and/or administrative interest in a study. */
    ResearchSubject,
    /** **Resource**

Resource. --- Abstract Type! ---This is the base resource type for everything. */
    Resource,
    /** **RiskAssessment**

RiskAssessment. An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome. */
    RiskAssessment,
    /** **Schedule**

Schedule. A container for slots of time that may be available for booking appointments. */
    Schedule,
    /** **SearchParameter**

SearchParameter. A search parameter that defines a named search item that can be used to search/filter on a resource. */
    SearchParameter,
    /** **ServiceRequest**

ServiceRequest. A record of a request for service such as diagnostic investigations, treatments, or operations to be performed. */
    ServiceRequest,
    /** **Slot**

Slot. A slot of time on a schedule that may be available for booking appointments. */
    Slot,
    /** **Specimen**

Specimen. A sample to be used for analysis. */
    Specimen,
    /** **SpecimenDefinition**

SpecimenDefinition. A kind of specimen with associated set of requirements. */
    SpecimenDefinition,
    /** **StructureDefinition**

StructureDefinition. A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types. */
    StructureDefinition,
    /** **StructureMap**

StructureMap. A Map of relationships between 2 structures that can be used to transform data. */
    StructureMap,
    /** **Subscription**

Subscription. The subscription resource is used to define a push-based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system can take an appropriate action. */
    Subscription,
    /** **SubscriptionStatus**

SubscriptionStatus. The SubscriptionStatus resource describes the state of a Subscription during notifications. */
    SubscriptionStatus,
    /** **SubscriptionTopic**

SubscriptionTopic. Describes a stream of resource state changes identified by trigger criteria and annotated with labels useful to filter projections from this topic. */
    SubscriptionTopic,
    /** **Substance**

Substance. A homogeneous material with a definite composition. */
    Substance,
    /** **SubstanceDefinition**

SubstanceDefinition. The detailed description of a substance, typically at a level beyond what is used for prescribing. */
    SubstanceDefinition,
    /** **SupplyDelivery**

SupplyDelivery. Record of delivery of what is supplied. */
    SupplyDelivery,
    /** **SupplyRequest**

SupplyRequest. A record of a request for a medication, substance or device used in the healthcare setting. */
    SupplyRequest,
    /** **Task**

Task. A task to be performed. */
    Task,
    /** **TerminologyCapabilities**

TerminologyCapabilities. A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation. */
    TerminologyCapabilities,
    /** **TestReport**

TestReport. A summary of information based on the results of executing a TestScript. */
    TestReport,
    /** **TestScript**

TestScript. A structured set of tests against a FHIR server or client implementation to determine compliance against the FHIR specification. */
    TestScript,
    /** **ValueSet**

ValueSet. A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [[[CodeSystem]]] definitions and their use in [coded elements](terminologies.html). */
    ValueSet,
    /** **VerificationResult**

VerificationResult. Describes validation requirements, source(s), status and dates for one or more elements. */
    VerificationResult,
    /** **VisionPrescription**

VisionPrescription. An authorization for the provision of glasses and/or contact lenses to a patient. */
    VisionPrescription,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Account" => Ok(Self::Account),
            "ActivityDefinition" => Ok(Self::ActivityDefinition),
            "AdministrableProductDefinition" => Ok(Self::AdministrableProductDefinition),
            "AdverseEvent" => Ok(Self::AdverseEvent),
            "AllergyIntolerance" => Ok(Self::AllergyIntolerance),
            "Appointment" => Ok(Self::Appointment),
            "AppointmentResponse" => Ok(Self::AppointmentResponse),
            "AuditEvent" => Ok(Self::AuditEvent),
            "Basic" => Ok(Self::Basic),
            "Binary" => Ok(Self::Binary),
            "BiologicallyDerivedProduct" => Ok(Self::BiologicallyDerivedProduct),
            "BodyStructure" => Ok(Self::BodyStructure),
            "Bundle" => Ok(Self::Bundle),
            "CapabilityStatement" => Ok(Self::CapabilityStatement),
            "CarePlan" => Ok(Self::CarePlan),
            "CareTeam" => Ok(Self::CareTeam),
            "CatalogEntry" => Ok(Self::CatalogEntry),
            "ChargeItem" => Ok(Self::ChargeItem),
            "ChargeItemDefinition" => Ok(Self::ChargeItemDefinition),
            "Citation" => Ok(Self::Citation),
            "Claim" => Ok(Self::Claim),
            "ClaimResponse" => Ok(Self::ClaimResponse),
            "ClinicalImpression" => Ok(Self::ClinicalImpression),
            "ClinicalUseDefinition" => Ok(Self::ClinicalUseDefinition),
            "CodeSystem" => Ok(Self::CodeSystem),
            "Communication" => Ok(Self::Communication),
            "CommunicationRequest" => Ok(Self::CommunicationRequest),
            "CompartmentDefinition" => Ok(Self::CompartmentDefinition),
            "Composition" => Ok(Self::Composition),
            "ConceptMap" => Ok(Self::ConceptMap),
            "Condition" => Ok(Self::Condition),
            "Consent" => Ok(Self::Consent),
            "Contract" => Ok(Self::Contract),
            "Coverage" => Ok(Self::Coverage),
            "CoverageEligibilityRequest" => Ok(Self::CoverageEligibilityRequest),
            "CoverageEligibilityResponse" => Ok(Self::CoverageEligibilityResponse),
            "DetectedIssue" => Ok(Self::DetectedIssue),
            "Device" => Ok(Self::Device),
            "DeviceDefinition" => Ok(Self::DeviceDefinition),
            "DeviceMetric" => Ok(Self::DeviceMetric),
            "DeviceRequest" => Ok(Self::DeviceRequest),
            "DeviceUseStatement" => Ok(Self::DeviceUseStatement),
            "DiagnosticReport" => Ok(Self::DiagnosticReport),
            "DocumentManifest" => Ok(Self::DocumentManifest),
            "DocumentReference" => Ok(Self::DocumentReference),
            "DomainResource" => Ok(Self::DomainResource),
            "Encounter" => Ok(Self::Encounter),
            "Endpoint" => Ok(Self::Endpoint),
            "EnrollmentRequest" => Ok(Self::EnrollmentRequest),
            "EnrollmentResponse" => Ok(Self::EnrollmentResponse),
            "EpisodeOfCare" => Ok(Self::EpisodeOfCare),
            "EventDefinition" => Ok(Self::EventDefinition),
            "Evidence" => Ok(Self::Evidence),
            "EvidenceReport" => Ok(Self::EvidenceReport),
            "EvidenceVariable" => Ok(Self::EvidenceVariable),
            "ExampleScenario" => Ok(Self::ExampleScenario),
            "ExplanationOfBenefit" => Ok(Self::ExplanationOfBenefit),
            "FamilyMemberHistory" => Ok(Self::FamilyMemberHistory),
            "Flag" => Ok(Self::Flag),
            "Goal" => Ok(Self::Goal),
            "GraphDefinition" => Ok(Self::GraphDefinition),
            "Group" => Ok(Self::Group),
            "GuidanceResponse" => Ok(Self::GuidanceResponse),
            "HealthcareService" => Ok(Self::HealthcareService),
            "ImagingStudy" => Ok(Self::ImagingStudy),
            "Immunization" => Ok(Self::Immunization),
            "ImmunizationEvaluation" => Ok(Self::ImmunizationEvaluation),
            "ImmunizationRecommendation" => Ok(Self::ImmunizationRecommendation),
            "ImplementationGuide" => Ok(Self::ImplementationGuide),
            "Ingredient" => Ok(Self::Ingredient),
            "InsurancePlan" => Ok(Self::InsurancePlan),
            "Invoice" => Ok(Self::Invoice),
            "Library" => Ok(Self::Library),
            "Linkage" => Ok(Self::Linkage),
            "List" => Ok(Self::List),
            "Location" => Ok(Self::Location),
            "ManufacturedItemDefinition" => Ok(Self::ManufacturedItemDefinition),
            "Measure" => Ok(Self::Measure),
            "MeasureReport" => Ok(Self::MeasureReport),
            "Media" => Ok(Self::Media),
            "Medication" => Ok(Self::Medication),
            "MedicationAdministration" => Ok(Self::MedicationAdministration),
            "MedicationDispense" => Ok(Self::MedicationDispense),
            "MedicationKnowledge" => Ok(Self::MedicationKnowledge),
            "MedicationRequest" => Ok(Self::MedicationRequest),
            "MedicationStatement" => Ok(Self::MedicationStatement),
            "MedicinalProductDefinition" => Ok(Self::MedicinalProductDefinition),
            "MessageDefinition" => Ok(Self::MessageDefinition),
            "MessageHeader" => Ok(Self::MessageHeader),
            "MolecularSequence" => Ok(Self::MolecularSequence),
            "NamingSystem" => Ok(Self::NamingSystem),
            "NutritionOrder" => Ok(Self::NutritionOrder),
            "NutritionProduct" => Ok(Self::NutritionProduct),
            "Observation" => Ok(Self::Observation),
            "ObservationDefinition" => Ok(Self::ObservationDefinition),
            "OperationDefinition" => Ok(Self::OperationDefinition),
            "OperationOutcome" => Ok(Self::OperationOutcome),
            "Organization" => Ok(Self::Organization),
            "OrganizationAffiliation" => Ok(Self::OrganizationAffiliation),
            "PackagedProductDefinition" => Ok(Self::PackagedProductDefinition),
            "Parameters" => Ok(Self::Parameters),
            "Patient" => Ok(Self::Patient),
            "PaymentNotice" => Ok(Self::PaymentNotice),
            "PaymentReconciliation" => Ok(Self::PaymentReconciliation),
            "Person" => Ok(Self::Person),
            "PlanDefinition" => Ok(Self::PlanDefinition),
            "Practitioner" => Ok(Self::Practitioner),
            "PractitionerRole" => Ok(Self::PractitionerRole),
            "Procedure" => Ok(Self::Procedure),
            "Provenance" => Ok(Self::Provenance),
            "Questionnaire" => Ok(Self::Questionnaire),
            "QuestionnaireResponse" => Ok(Self::QuestionnaireResponse),
            "RegulatedAuthorization" => Ok(Self::RegulatedAuthorization),
            "RelatedPerson" => Ok(Self::RelatedPerson),
            "RequestGroup" => Ok(Self::RequestGroup),
            "ResearchDefinition" => Ok(Self::ResearchDefinition),
            "ResearchElementDefinition" => Ok(Self::ResearchElementDefinition),
            "ResearchStudy" => Ok(Self::ResearchStudy),
            "ResearchSubject" => Ok(Self::ResearchSubject),
            "Resource" => Ok(Self::Resource),
            "RiskAssessment" => Ok(Self::RiskAssessment),
            "Schedule" => Ok(Self::Schedule),
            "SearchParameter" => Ok(Self::SearchParameter),
            "ServiceRequest" => Ok(Self::ServiceRequest),
            "Slot" => Ok(Self::Slot),
            "Specimen" => Ok(Self::Specimen),
            "SpecimenDefinition" => Ok(Self::SpecimenDefinition),
            "StructureDefinition" => Ok(Self::StructureDefinition),
            "StructureMap" => Ok(Self::StructureMap),
            "Subscription" => Ok(Self::Subscription),
            "SubscriptionStatus" => Ok(Self::SubscriptionStatus),
            "SubscriptionTopic" => Ok(Self::SubscriptionTopic),
            "Substance" => Ok(Self::Substance),
            "SubstanceDefinition" => Ok(Self::SubstanceDefinition),
            "SupplyDelivery" => Ok(Self::SupplyDelivery),
            "SupplyRequest" => Ok(Self::SupplyRequest),
            "Task" => Ok(Self::Task),
            "TerminologyCapabilities" => Ok(Self::TerminologyCapabilities),
            "TestReport" => Ok(Self::TestReport),
            "TestScript" => Ok(Self::TestScript),
            "ValueSet" => Ok(Self::ValueSet),
            "VerificationResult" => Ok(Self::VerificationResult),
            "VisionPrescription" => Ok(Self::VisionPrescription),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Account => "Account",
            Self::ActivityDefinition => "ActivityDefinition",
            Self::AdministrableProductDefinition => "AdministrableProductDefinition",
            Self::AdverseEvent => "AdverseEvent",
            Self::AllergyIntolerance => "AllergyIntolerance",
            Self::Appointment => "Appointment",
            Self::AppointmentResponse => "AppointmentResponse",
            Self::AuditEvent => "AuditEvent",
            Self::Basic => "Basic",
            Self::Binary => "Binary",
            Self::BiologicallyDerivedProduct => "BiologicallyDerivedProduct",
            Self::BodyStructure => "BodyStructure",
            Self::Bundle => "Bundle",
            Self::CapabilityStatement => "CapabilityStatement",
            Self::CarePlan => "CarePlan",
            Self::CareTeam => "CareTeam",
            Self::CatalogEntry => "CatalogEntry",
            Self::ChargeItem => "ChargeItem",
            Self::ChargeItemDefinition => "ChargeItemDefinition",
            Self::Citation => "Citation",
            Self::Claim => "Claim",
            Self::ClaimResponse => "ClaimResponse",
            Self::ClinicalImpression => "ClinicalImpression",
            Self::ClinicalUseDefinition => "ClinicalUseDefinition",
            Self::CodeSystem => "CodeSystem",
            Self::Communication => "Communication",
            Self::CommunicationRequest => "CommunicationRequest",
            Self::CompartmentDefinition => "CompartmentDefinition",
            Self::Composition => "Composition",
            Self::ConceptMap => "ConceptMap",
            Self::Condition => "Condition",
            Self::Consent => "Consent",
            Self::Contract => "Contract",
            Self::Coverage => "Coverage",
            Self::CoverageEligibilityRequest => "CoverageEligibilityRequest",
            Self::CoverageEligibilityResponse => "CoverageEligibilityResponse",
            Self::DetectedIssue => "DetectedIssue",
            Self::Device => "Device",
            Self::DeviceDefinition => "DeviceDefinition",
            Self::DeviceMetric => "DeviceMetric",
            Self::DeviceRequest => "DeviceRequest",
            Self::DeviceUseStatement => "DeviceUseStatement",
            Self::DiagnosticReport => "DiagnosticReport",
            Self::DocumentManifest => "DocumentManifest",
            Self::DocumentReference => "DocumentReference",
            Self::DomainResource => "DomainResource",
            Self::Encounter => "Encounter",
            Self::Endpoint => "Endpoint",
            Self::EnrollmentRequest => "EnrollmentRequest",
            Self::EnrollmentResponse => "EnrollmentResponse",
            Self::EpisodeOfCare => "EpisodeOfCare",
            Self::EventDefinition => "EventDefinition",
            Self::Evidence => "Evidence",
            Self::EvidenceReport => "EvidenceReport",
            Self::EvidenceVariable => "EvidenceVariable",
            Self::ExampleScenario => "ExampleScenario",
            Self::ExplanationOfBenefit => "ExplanationOfBenefit",
            Self::FamilyMemberHistory => "FamilyMemberHistory",
            Self::Flag => "Flag",
            Self::Goal => "Goal",
            Self::GraphDefinition => "GraphDefinition",
            Self::Group => "Group",
            Self::GuidanceResponse => "GuidanceResponse",
            Self::HealthcareService => "HealthcareService",
            Self::ImagingStudy => "ImagingStudy",
            Self::Immunization => "Immunization",
            Self::ImmunizationEvaluation => "ImmunizationEvaluation",
            Self::ImmunizationRecommendation => "ImmunizationRecommendation",
            Self::ImplementationGuide => "ImplementationGuide",
            Self::Ingredient => "Ingredient",
            Self::InsurancePlan => "InsurancePlan",
            Self::Invoice => "Invoice",
            Self::Library => "Library",
            Self::Linkage => "Linkage",
            Self::List => "List",
            Self::Location => "Location",
            Self::ManufacturedItemDefinition => "ManufacturedItemDefinition",
            Self::Measure => "Measure",
            Self::MeasureReport => "MeasureReport",
            Self::Media => "Media",
            Self::Medication => "Medication",
            Self::MedicationAdministration => "MedicationAdministration",
            Self::MedicationDispense => "MedicationDispense",
            Self::MedicationKnowledge => "MedicationKnowledge",
            Self::MedicationRequest => "MedicationRequest",
            Self::MedicationStatement => "MedicationStatement",
            Self::MedicinalProductDefinition => "MedicinalProductDefinition",
            Self::MessageDefinition => "MessageDefinition",
            Self::MessageHeader => "MessageHeader",
            Self::MolecularSequence => "MolecularSequence",
            Self::NamingSystem => "NamingSystem",
            Self::NutritionOrder => "NutritionOrder",
            Self::NutritionProduct => "NutritionProduct",
            Self::Observation => "Observation",
            Self::ObservationDefinition => "ObservationDefinition",
            Self::OperationDefinition => "OperationDefinition",
            Self::OperationOutcome => "OperationOutcome",
            Self::Organization => "Organization",
            Self::OrganizationAffiliation => "OrganizationAffiliation",
            Self::PackagedProductDefinition => "PackagedProductDefinition",
            Self::Parameters => "Parameters",
            Self::Patient => "Patient",
            Self::PaymentNotice => "PaymentNotice",
            Self::PaymentReconciliation => "PaymentReconciliation",
            Self::Person => "Person",
            Self::PlanDefinition => "PlanDefinition",
            Self::Practitioner => "Practitioner",
            Self::PractitionerRole => "PractitionerRole",
            Self::Procedure => "Procedure",
            Self::Provenance => "Provenance",
            Self::Questionnaire => "Questionnaire",
            Self::QuestionnaireResponse => "QuestionnaireResponse",
            Self::RegulatedAuthorization => "RegulatedAuthorization",
            Self::RelatedPerson => "RelatedPerson",
            Self::RequestGroup => "RequestGroup",
            Self::ResearchDefinition => "ResearchDefinition",
            Self::ResearchElementDefinition => "ResearchElementDefinition",
            Self::ResearchStudy => "ResearchStudy",
            Self::ResearchSubject => "ResearchSubject",
            Self::Resource => "Resource",
            Self::RiskAssessment => "RiskAssessment",
            Self::Schedule => "Schedule",
            Self::SearchParameter => "SearchParameter",
            Self::ServiceRequest => "ServiceRequest",
            Self::Slot => "Slot",
            Self::Specimen => "Specimen",
            Self::SpecimenDefinition => "SpecimenDefinition",
            Self::StructureDefinition => "StructureDefinition",
            Self::StructureMap => "StructureMap",
            Self::Subscription => "Subscription",
            Self::SubscriptionStatus => "SubscriptionStatus",
            Self::SubscriptionTopic => "SubscriptionTopic",
            Self::Substance => "Substance",
            Self::SubstanceDefinition => "SubstanceDefinition",
            Self::SupplyDelivery => "SupplyDelivery",
            Self::SupplyRequest => "SupplyRequest",
            Self::Task => "Task",
            Self::TerminologyCapabilities => "TerminologyCapabilities",
            Self::TestReport => "TestReport",
            Self::TestScript => "TestScript",
            Self::ValueSet => "ValueSet",
            Self::VerificationResult => "VerificationResult",
            Self::VisionPrescription => "VisionPrescription",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResourceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResourceType> for Coding {
    fn from(code: ResourceType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/resource-types".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResourceType> for CodeableConcept {
    fn from(code: ResourceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResourceValidationMode](http://hl7.org/fhir/resource-validation-mode)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum ResourceValidationMode {
    /** **create**

Validate for Create. The server checks the content, and then checks that the content would be acceptable as a create (e.g. that the content would not violate any uniqueness constraints). */
    Create,
    /** **delete**

Validate for Delete. The server ignores the content and checks that the nominated resource is allowed to be deleted (e.g. checking referential integrity rules). */
    Delete,
    /** **profile**

Validate Against a Profile. The server checks an existing resource (must be nominated by id, not provided as a parameter) as valid against the nominated profile. */
    Profile,
    /** **update**

Validate for Update. The server checks the content, and then checks that it would accept it as an update against the nominated specific resource (e.g. that there are no changes to immutable fields the server does not allow to change and checking version integrity if appropriate). */
    Update,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ResourceValidationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "profile" => Ok(Self::Profile),
            "update" => Ok(Self::Update),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ResourceValidationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Create => "create",
            Self::Delete => "delete",
            Self::Profile => "profile",
            Self::Update => "update",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for ResourceValidationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResourceValidationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResourceValidationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceValidationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResourceValidationMode> for Coding {
    fn from(code: ResourceValidationMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/resource-validation-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResourceValidationMode> for CodeableConcept {
    fn from(code: ResourceValidationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResourceVersionPolicy](http://hl7.org/fhir/ValueSet/versioning-policy)**. How the system supports versioning for a resource.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResourceVersionPolicy {
    /** **no-version**

No VersionId Support. VersionId meta-property is not supported (server) or used (client). */
    NoVersion,
    /** **versioned**

Versioned. VersionId meta-property is supported (server) or used (client). */
    Versioned,
    /** **versioned-update**

VersionId tracked fully. VersionId must be correct for updates (server) or will be specified (If-match header) for updates (client). */
    VersionedUpdate,
}
impl ::core::str::FromStr for ResourceVersionPolicy {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "no-version" => Ok(Self::NoVersion),
            "versioned" => Ok(Self::Versioned),
            "versioned-update" => Ok(Self::VersionedUpdate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResourceVersionPolicy {
    fn as_ref(&self) -> &str {
        match self {
            Self::NoVersion => "no-version",
            Self::Versioned => "versioned",
            Self::VersionedUpdate => "versioned-update",
        }
    }
}
impl ::std::fmt::Debug for ResourceVersionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResourceVersionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResourceVersionPolicy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceVersionPolicy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResourceVersionPolicy> for Coding {
    fn from(code: ResourceVersionPolicy) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/versioning-policy".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResourceVersionPolicy> for CodeableConcept {
    fn from(code: ResourceVersionPolicy) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ResponseType](http://hl7.org/fhir/ValueSet/response-code)**. The kind of response to a message.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ResponseType {
    /** **fatal-error**

Fatal Error. The message was rejected because of a problem with the content. There is no point in re-sending without change. The response narrative SHALL describe the issue. */
    FatalError,
    /** **ok**

OK. The message was accepted and processed without error. */
    Ok,
    /** **transient-error**

Transient Error. Some internal unexpected error occurred - wait and try again. Note - this is usually used for things like database unavailable, which may be expected to resolve, though human intervention may be required. */
    TransientError,
}
impl ::core::str::FromStr for ResponseType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fatal-error" => Ok(Self::FatalError),
            "ok" => Ok(Self::Ok),
            "transient-error" => Ok(Self::TransientError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResponseType {
    fn as_ref(&self) -> &str {
        match self {
            Self::FatalError => "fatal-error",
            Self::Ok => "ok",
            Self::TransientError => "transient-error",
        }
    }
}
impl ::std::fmt::Debug for ResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ResponseType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResponseType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResponseType> for Coding {
    fn from(code: ResponseType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/response-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ResponseType> for CodeableConcept {
    fn from(code: ResponseType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RestfulCapabilityMode](http://hl7.org/fhir/ValueSet/restful-capability-mode)**. The mode of a RESTful capability statement.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RestfulCapabilityMode {
    /** **client**

Client. The application acts as a client for this resource. */
    Client,
    /** **server**

Server. The application acts as a server for this resource. */
    Server,
}
impl ::core::str::FromStr for RestfulCapabilityMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client" => Ok(Self::Client),
            "server" => Ok(Self::Server),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RestfulCapabilityMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Client => "client",
            Self::Server => "server",
        }
    }
}
impl ::std::fmt::Debug for RestfulCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RestfulCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RestfulCapabilityMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RestfulCapabilityMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RestfulCapabilityMode> for Coding {
    fn from(code: RestfulCapabilityMode) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/restful-capability-mode".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RestfulCapabilityMode> for CodeableConcept {
    fn from(code: RestfulCapabilityMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RestfulSecurityService](http://hl7.org/fhir/ValueSet/restful-security-service)**. Types of security services used with FHIR.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum RestfulSecurityService {
    /** **Basic**

Basic. Basic authentication defined in HTTP specification. */
    Basic,
    /** **Certificates**

Certificates. SSL where client must have a certificate registered with the server. */
    Certificates,
    /** **Kerberos**

Kerberos. see http://www.ietf.org/rfc/rfc4120.txt. */
    Kerberos,
    /** **NTLM**

NTLM. Microsoft NTLM Authentication. */
    Ntlm,
    /** **OAuth**

OAuth. OAuth (unspecified version see oauth.net). */
    Oauth,
    /** **SMART-on-FHIR**

SMART-on-FHIR. OAuth2 using SMART-on-FHIR profile (see http://docs.smarthealthit.org/). */
    SmartOnFHIR,
}
impl ::core::str::FromStr for RestfulSecurityService {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Basic" => Ok(Self::Basic),
            "Certificates" => Ok(Self::Certificates),
            "Kerberos" => Ok(Self::Kerberos),
            "NTLM" => Ok(Self::Ntlm),
            "OAuth" => Ok(Self::Oauth),
            "SMART-on-FHIR" => Ok(Self::SmartOnFHIR),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RestfulSecurityService {
    fn as_ref(&self) -> &str {
        match self {
            Self::Basic => "Basic",
            Self::Certificates => "Certificates",
            Self::Kerberos => "Kerberos",
            Self::Ntlm => "NTLM",
            Self::Oauth => "OAuth",
            Self::SmartOnFHIR => "SMART-on-FHIR",
        }
    }
}
impl ::std::fmt::Debug for RestfulSecurityService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RestfulSecurityService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RestfulSecurityService {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RestfulSecurityService {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RestfulSecurityService> for Coding {
    fn from(code: RestfulSecurityService) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/restful-security-service".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RestfulSecurityService> for CodeableConcept {
    fn from(code: RestfulSecurityService) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[RiskProbability](http://terminology.hl7.org/CodeSystem/risk-probability)**. Codes representing the likelihood of a particular outcome in a risk assessment.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum RiskProbability {
    /** **certain**

Certain. The specified outcome is effectively guaranteed. */
    Certain,
    /** **high**

High likelihood. The specified outcome is more likely to occur than not. */
    High,
    /** **low**

Low likelihood. The specified outcome is possible but unlikely. */
    Low,
    /** **moderate**

Moderate likelihood. The specified outcome has a reasonable likelihood of occurrence. */
    Moderate,
    /** **negligible**

Negligible likelihood. The specified outcome is exceptionally unlikely. */
    Negligible,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for RiskProbability {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "certain" => Ok(Self::Certain),
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            "negligible" => Ok(Self::Negligible),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for RiskProbability {
    fn as_ref(&self) -> &str {
        match self {
            Self::Certain => "certain",
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
            Self::Negligible => "negligible",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for RiskProbability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for RiskProbability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for RiskProbability {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RiskProbability {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RiskProbability> for Coding {
    fn from(code: RiskProbability) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/risk-probability".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<RiskProbability> for CodeableConcept {
    fn from(code: RiskProbability) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SPDXLicense](http://hl7.org/fhir/ValueSet/spdx-license)**. The license that applies to an Implementation Guide (using an SPDX license Identifiers, or 'not-open-source'). The binding is required but new SPDX license Identifiers are allowed to be used (https://spdx.org/licenses/).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SPDXLicense {
    /** **0BSD**

BSD Zero Clause License. BSD Zero Clause License. */
    N0Bsd,
    /** **AAL**

Attribution Assurance License. Attribution Assurance License. */
    Aal,
    /** **ADSL**

Amazon Digital Services License. Amazon Digital Services License. */
    Adsl,
    /** **AFL-1.1**

Academic Free License v1.1. Academic Free License v1.1. */
    Afl11,
    /** **AFL-1.2**

Academic Free License v1.2. Academic Free License v1.2. */
    Afl12,
    /** **AFL-2.0**

Academic Free License v2.0. Academic Free License v2.0. */
    Afl20,
    /** **AFL-2.1**

Academic Free License v2.1. Academic Free License v2.1. */
    Afl21,
    /** **AFL-3.0**

Academic Free License v3.0. Academic Free License v3.0. */
    Afl30,
    /** **AGPL-1.0-only**

Affero General Public License v1.0 only. Affero General Public License v1.0 only. */
    Agpl10Only,
    /** **AGPL-1.0-or-later**

Affero General Public License v1.0 or later. Affero General Public License v1.0 or later. */
    Agpl10OrLater,
    /** **AGPL-3.0-only**

GNU Affero General Public License v3.0 only. GNU Affero General Public License v3.0 only. */
    Agpl30Only,
    /** **AGPL-3.0-or-later**

GNU Affero General Public License v3.0 or later. GNU Affero General Public License v3.0 or later. */
    Agpl30OrLater,
    /** **AMDPLPA**

AMD's plpa_map.c License. AMD's plpa_map.c License. */
    Amdplpa,
    /** **AML**

Apple MIT License. Apple MIT License. */
    Aml,
    /** **AMPAS**

Academy of Motion Picture Arts and Sciences BSD. Academy of Motion Picture Arts and Sciences BSD. */
    Ampas,
    /** **ANTLR-PD**

ANTLR Software Rights Notice. ANTLR Software Rights Notice. */
    AntlrPd,
    /** **APAFML**

Adobe Postscript AFM License. Adobe Postscript AFM License. */
    Apafml,
    /** **APL-1.0**

Adaptive Public License 1.0. Adaptive Public License 1.0. */
    Apl10,
    /** **APSL-1.0**

Apple Public Source License 1.0. Apple Public Source License 1.0. */
    Apsl10,
    /** **APSL-1.1**

Apple Public Source License 1.1. Apple Public Source License 1.1. */
    Apsl11,
    /** **APSL-1.2**

Apple Public Source License 1.2. Apple Public Source License 1.2. */
    Apsl12,
    /** **APSL-2.0**

Apple Public Source License 2.0. Apple Public Source License 2.0. */
    Apsl20,
    /** **Abstyles**

Abstyles License. Abstyles License. */
    Abstyles,
    /** **Adobe-2006**

Adobe Systems Incorporated Source Code License Agreement. Adobe Systems Incorporated Source Code License Agreement. */
    Adobe2006,
    /** **Adobe-Glyph**

Adobe Glyph List License. Adobe Glyph List License. */
    AdobeGlyph,
    /** **Afmparse**

Afmparse License. Afmparse License. */
    Afmparse,
    /** **Aladdin**

Aladdin Free Public License. Aladdin Free Public License. */
    Aladdin,
    /** **Apache-1.0**

Apache License 1.0. Apache License 1.0. */
    Apache10,
    /** **Apache-1.1**

Apache License 1.1. Apache License 1.1. */
    Apache11,
    /** **Apache-2.0**

Apache License 2.0. Apache License 2.0. */
    Apache20,
    /** **Artistic-1.0**

Artistic License 1.0. Artistic License 1.0. */
    Artistic10,
    /** **Artistic-1.0-Perl**

Artistic License 1.0 (Perl). Artistic License 1.0 (Perl). */
    Artistic10Perl,
    /** **Artistic-1.0-cl8**

Artistic License 1.0 w/clause 8. Artistic License 1.0 w/clause 8. */
    Artistic10Cl8,
    /** **Artistic-2.0**

Artistic License 2.0. Artistic License 2.0. */
    Artistic20,
    /** **BSD-1-Clause**

BSD 1-Clause License. BSD 1-Clause License. */
    Bsd1Clause,
    /** **BSD-2-Clause**

BSD 2-Clause "Simplified" License. BSD 2-Clause "Simplified" License. */
    Bsd2Clause,
    /** **BSD-2-Clause-FreeBSD**

BSD 2-Clause FreeBSD License. BSD 2-Clause FreeBSD License. */
    Bsd2ClauseFreeBSD,
    /** **BSD-2-Clause-NetBSD**

BSD 2-Clause NetBSD License. BSD 2-Clause NetBSD License. */
    Bsd2ClauseNetBSD,
    /** **BSD-2-Clause-Patent**

BSD-2-Clause Plus Patent License. BSD-2-Clause Plus Patent License. */
    Bsd2ClausePatent,
    /** **BSD-3-Clause**

BSD 3-Clause "New" or "Revised" License. BSD 3-Clause "New" or "Revised" License. */
    Bsd3Clause,
    /** **BSD-3-Clause-Attribution**

BSD with attribution. BSD with attribution. */
    Bsd3ClauseAttribution,
    /** **BSD-3-Clause-Clear**

BSD 3-Clause Clear License. BSD 3-Clause Clear License. */
    Bsd3ClauseClear,
    /** **BSD-3-Clause-LBNL**

Lawrence Berkeley National Labs BSD variant license. Lawrence Berkeley National Labs BSD variant license. */
    Bsd3ClauseLBNL,
    /** **BSD-3-Clause-No-Nuclear-License**

BSD 3-Clause No Nuclear License. BSD 3-Clause No Nuclear License. */
    Bsd3ClauseNoNuclearLicense,
    /** **BSD-3-Clause-No-Nuclear-License-2014**

BSD 3-Clause No Nuclear License 2014. BSD 3-Clause No Nuclear License 2014. */
    Bsd3ClauseNoNuclearLicense2014,
    /** **BSD-3-Clause-No-Nuclear-Warranty**

BSD 3-Clause No Nuclear Warranty. BSD 3-Clause No Nuclear Warranty. */
    Bsd3ClauseNoNuclearWarranty,
    /** **BSD-4-Clause**

BSD 4-Clause "Original" or "Old" License. BSD 4-Clause "Original" or "Old" License. */
    Bsd4Clause,
    /** **BSD-4-Clause-UC**

BSD-4-Clause (University of California-Specific). BSD-4-Clause (University of California-Specific). */
    Bsd4ClauseUC,
    /** **BSD-Protection**

BSD Protection License. BSD Protection License. */
    BsdProtection,
    /** **BSD-Source-Code**

BSD Source Code Attribution. BSD Source Code Attribution. */
    BsdSourceCode,
    /** **BSL-1.0**

Boost Software License 1.0. Boost Software License 1.0. */
    Bsl10,
    /** **Bahyph**

Bahyph License. Bahyph License. */
    Bahyph,
    /** **Barr**

Barr License. Barr License. */
    Barr,
    /** **Beerware**

Beerware License. Beerware License. */
    Beerware,
    /** **BitTorrent-1.0**

BitTorrent Open Source License v1.0. BitTorrent Open Source License v1.0. */
    BitTorrent10,
    /** **BitTorrent-1.1**

BitTorrent Open Source License v1.1. BitTorrent Open Source License v1.1. */
    BitTorrent11,
    /** **Borceux**

Borceux license. Borceux license. */
    Borceux,
    /** **CATOSL-1.1**

Computer Associates Trusted Open Source License 1.1. Computer Associates Trusted Open Source License 1.1. */
    Catosl11,
    /** **CC-BY-1.0**

Creative Commons Attribution 1.0 Generic. Creative Commons Attribution 1.0 Generic. */
    CcBy10,
    /** **CC-BY-2.0**

Creative Commons Attribution 2.0 Generic. Creative Commons Attribution 2.0 Generic. */
    CcBy20,
    /** **CC-BY-2.5**

Creative Commons Attribution 2.5 Generic. Creative Commons Attribution 2.5 Generic. */
    CcBy25,
    /** **CC-BY-3.0**

Creative Commons Attribution 3.0 Unported. Creative Commons Attribution 3.0 Unported. */
    CcBy30,
    /** **CC-BY-4.0**

Creative Commons Attribution 4.0 International. Creative Commons Attribution 4.0 International. */
    CcBy40,
    /** **CC-BY-NC-1.0**

Creative Commons Attribution Non Commercial 1.0 Generic. Creative Commons Attribution Non Commercial 1.0 Generic. */
    CcByNc10,
    /** **CC-BY-NC-2.0**

Creative Commons Attribution Non Commercial 2.0 Generic. Creative Commons Attribution Non Commercial 2.0 Generic. */
    CcByNc20,
    /** **CC-BY-NC-2.5**

Creative Commons Attribution Non Commercial 2.5 Generic. Creative Commons Attribution Non Commercial 2.5 Generic. */
    CcByNc25,
    /** **CC-BY-NC-3.0**

Creative Commons Attribution Non Commercial 3.0 Unported. Creative Commons Attribution Non Commercial 3.0 Unported. */
    CcByNc30,
    /** **CC-BY-NC-4.0**

Creative Commons Attribution Non Commercial 4.0 International. Creative Commons Attribution Non Commercial 4.0 International. */
    CcByNc40,
    /** **CC-BY-NC-ND-1.0**

Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic. Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic. */
    CcByNcNd10,
    /** **CC-BY-NC-ND-2.0**

Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic. Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic. */
    CcByNcNd20,
    /** **CC-BY-NC-ND-2.5**

Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic. Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic. */
    CcByNcNd25,
    /** **CC-BY-NC-ND-3.0**

Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported. Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported. */
    CcByNcNd30,
    /** **CC-BY-NC-ND-4.0**

Creative Commons Attribution Non Commercial No Derivatives 4.0 International. Creative Commons Attribution Non Commercial No Derivatives 4.0 International. */
    CcByNcNd40,
    /** **CC-BY-NC-SA-1.0**

Creative Commons Attribution Non Commercial Share Alike 1.0 Generic. Creative Commons Attribution Non Commercial Share Alike 1.0 Generic. */
    CcByNcSa10,
    /** **CC-BY-NC-SA-2.0**

Creative Commons Attribution Non Commercial Share Alike 2.0 Generic. Creative Commons Attribution Non Commercial Share Alike 2.0 Generic. */
    CcByNcSa20,
    /** **CC-BY-NC-SA-2.5**

Creative Commons Attribution Non Commercial Share Alike 2.5 Generic. Creative Commons Attribution Non Commercial Share Alike 2.5 Generic. */
    CcByNcSa25,
    /** **CC-BY-NC-SA-3.0**

Creative Commons Attribution Non Commercial Share Alike 3.0 Unported. Creative Commons Attribution Non Commercial Share Alike 3.0 Unported. */
    CcByNcSa30,
    /** **CC-BY-NC-SA-4.0**

Creative Commons Attribution Non Commercial Share Alike 4.0 International. Creative Commons Attribution Non Commercial Share Alike 4.0 International. */
    CcByNcSa40,
    /** **CC-BY-ND-1.0**

Creative Commons Attribution No Derivatives 1.0 Generic. Creative Commons Attribution No Derivatives 1.0 Generic. */
    CcByNd10,
    /** **CC-BY-ND-2.0**

Creative Commons Attribution No Derivatives 2.0 Generic. Creative Commons Attribution No Derivatives 2.0 Generic. */
    CcByNd20,
    /** **CC-BY-ND-2.5**

Creative Commons Attribution No Derivatives 2.5 Generic. Creative Commons Attribution No Derivatives 2.5 Generic. */
    CcByNd25,
    /** **CC-BY-ND-3.0**

Creative Commons Attribution No Derivatives 3.0 Unported. Creative Commons Attribution No Derivatives 3.0 Unported. */
    CcByNd30,
    /** **CC-BY-ND-4.0**

Creative Commons Attribution No Derivatives 4.0 International. Creative Commons Attribution No Derivatives 4.0 International. */
    CcByNd40,
    /** **CC-BY-SA-1.0**

Creative Commons Attribution Share Alike 1.0 Generic. Creative Commons Attribution Share Alike 1.0 Generic. */
    CcBySa10,
    /** **CC-BY-SA-2.0**

Creative Commons Attribution Share Alike 2.0 Generic. Creative Commons Attribution Share Alike 2.0 Generic. */
    CcBySa20,
    /** **CC-BY-SA-2.5**

Creative Commons Attribution Share Alike 2.5 Generic. Creative Commons Attribution Share Alike 2.5 Generic. */
    CcBySa25,
    /** **CC-BY-SA-3.0**

Creative Commons Attribution Share Alike 3.0 Unported. Creative Commons Attribution Share Alike 3.0 Unported. */
    CcBySa30,
    /** **CC-BY-SA-4.0**

Creative Commons Attribution Share Alike 4.0 International. Creative Commons Attribution Share Alike 4.0 International. */
    CcBySa40,
    /** **CC0-1.0**

Creative Commons Zero v1.0 Universal. Creative Commons Zero v1.0 Universal. */
    Cc010,
    /** **CDDL-1.0**

Common Development and Distribution License 1.0. Common Development and Distribution License 1.0. */
    Cddl10,
    /** **CDDL-1.1**

Common Development and Distribution License 1.1. Common Development and Distribution License 1.1. */
    Cddl11,
    /** **CDLA-Permissive-1.0**

Community Data License Agreement Permissive 1.0. Community Data License Agreement Permissive 1.0. */
    CdlaPermissive10,
    /** **CDLA-Sharing-1.0**

Community Data License Agreement Sharing 1.0. Community Data License Agreement Sharing 1.0. */
    CdlaSharing10,
    /** **CECILL-1.0**

CeCILL Free Software License Agreement v1.0. CeCILL Free Software License Agreement v1.0. */
    Cecill10,
    /** **CECILL-1.1**

CeCILL Free Software License Agreement v1.1. CeCILL Free Software License Agreement v1.1. */
    Cecill11,
    /** **CECILL-2.0**

CeCILL Free Software License Agreement v2.0. CeCILL Free Software License Agreement v2.0. */
    Cecill20,
    /** **CECILL-2.1**

CeCILL Free Software License Agreement v2.1. CeCILL Free Software License Agreement v2.1. */
    Cecill21,
    /** **CECILL-B**

CeCILL-B Free Software License Agreement. CeCILL-B Free Software License Agreement. */
    CecillB,
    /** **CECILL-C**

CeCILL-C Free Software License Agreement. CeCILL-C Free Software License Agreement. */
    CecillC,
    /** **CNRI-Jython**

CNRI Jython License. CNRI Jython License. */
    CnriJython,
    /** **CNRI-Python**

CNRI Python License. CNRI Python License. */
    CnriPython,
    /** **CNRI-Python-GPL-Compatible**

CNRI Python Open Source GPL Compatible License Agreement. CNRI Python Open Source GPL Compatible License Agreement. */
    CnriPythonGPLCompatible,
    /** **CPAL-1.0**

Common Public Attribution License 1.0. Common Public Attribution License 1.0. */
    Cpal10,
    /** **CPL-1.0**

Common Public License 1.0. Common Public License 1.0. */
    Cpl10,
    /** **CPOL-1.02**

Code Project Open License 1.02. Code Project Open License 1.02. */
    Cpol102,
    /** **CUA-OPL-1.0**

CUA Office Public License v1.0. CUA Office Public License v1.0. */
    CuaOpl10,
    /** **Caldera**

Caldera License. Caldera License. */
    Caldera,
    /** **ClArtistic**

Clarified Artistic License. Clarified Artistic License. */
    ClArtistic,
    /** **Condor-1.1**

Condor Public License v1.1. Condor Public License v1.1. */
    Condor11,
    /** **Crossword**

Crossword License. Crossword License. */
    Crossword,
    /** **CrystalStacker**

CrystalStacker License. CrystalStacker License. */
    CrystalStacker,
    /** **Cube**

Cube License. Cube License. */
    Cube,
    /** **D-FSL-1.0**

Deutsche Freie Software Lizenz. Deutsche Freie Software Lizenz. */
    DFsl10,
    /** **DOC**

DOC License. DOC License. */
    Doc,
    /** **DSDP**

DSDP License. DSDP License. */
    Dsdp,
    /** **Dotseqn**

Dotseqn License. Dotseqn License. */
    Dotseqn,
    /** **ECL-1.0**

Educational Community License v1.0. Educational Community License v1.0. */
    Ecl10,
    /** **ECL-2.0**

Educational Community License v2.0. Educational Community License v2.0. */
    Ecl20,
    /** **EFL-1.0**

Eiffel Forum License v1.0. Eiffel Forum License v1.0. */
    Efl10,
    /** **EFL-2.0**

Eiffel Forum License v2.0. Eiffel Forum License v2.0. */
    Efl20,
    /** **EPL-1.0**

Eclipse Public License 1.0. Eclipse Public License 1.0. */
    Epl10,
    /** **EPL-2.0**

Eclipse Public License 2.0. Eclipse Public License 2.0. */
    Epl20,
    /** **EUDatagrid**

EU DataGrid Software License. EU DataGrid Software License. */
    Eudatagrid,
    /** **EUPL-1.0**

European Union Public License 1.0. European Union Public License 1.0. */
    Eupl10,
    /** **EUPL-1.1**

European Union Public License 1.1. European Union Public License 1.1. */
    Eupl11,
    /** **EUPL-1.2**

European Union Public License 1.2. European Union Public License 1.2. */
    Eupl12,
    /** **Entessa**

Entessa Public License v1.0. Entessa Public License v1.0. */
    Entessa,
    /** **ErlPL-1.1**

Erlang Public License v1.1. Erlang Public License v1.1. */
    ErlPL11,
    /** **Eurosym**

Eurosym License. Eurosym License. */
    Eurosym,
    /** **FSFAP**

FSF All Permissive License. FSF All Permissive License. */
    Fsfap,
    /** **FSFUL**

FSF Unlimited License. FSF Unlimited License. */
    Fsful,
    /** **FSFULLR**

FSF Unlimited License (with License Retention). FSF Unlimited License (with License Retention). */
    Fsfullr,
    /** **FTL**

Freetype Project License. Freetype Project License. */
    Ftl,
    /** **Fair**

Fair License. Fair License. */
    Fair,
    /** **Frameworx-1.0**

Frameworx Open License 1.0. Frameworx Open License 1.0. */
    Frameworx10,
    /** **FreeImage**

FreeImage Public License v1.0. FreeImage Public License v1.0. */
    FreeImage,
    /** **GFDL-1.1-only**

GNU Free Documentation License v1.1 only. GNU Free Documentation License v1.1 only. */
    Gfdl11Only,
    /** **GFDL-1.1-or-later**

GNU Free Documentation License v1.1 or later. GNU Free Documentation License v1.1 or later. */
    Gfdl11OrLater,
    /** **GFDL-1.2-only**

GNU Free Documentation License v1.2 only. GNU Free Documentation License v1.2 only. */
    Gfdl12Only,
    /** **GFDL-1.2-or-later**

GNU Free Documentation License v1.2 or later. GNU Free Documentation License v1.2 or later. */
    Gfdl12OrLater,
    /** **GFDL-1.3-only**

GNU Free Documentation License v1.3 only. GNU Free Documentation License v1.3 only. */
    Gfdl13Only,
    /** **GFDL-1.3-or-later**

GNU Free Documentation License v1.3 or later. GNU Free Documentation License v1.3 or later. */
    Gfdl13OrLater,
    /** **GL2PS**

GL2PS License. GL2PS License. */
    Gl2Ps,
    /** **GPL-1.0-only**

GNU General Public License v1.0 only. GNU General Public License v1.0 only. */
    Gpl10Only,
    /** **GPL-1.0-or-later**

GNU General Public License v1.0 or later. GNU General Public License v1.0 or later. */
    Gpl10OrLater,
    /** **GPL-2.0-only**

GNU General Public License v2.0 only. GNU General Public License v2.0 only. */
    Gpl20Only,
    /** **GPL-2.0-or-later**

GNU General Public License v2.0 or later. GNU General Public License v2.0 or later. */
    Gpl20OrLater,
    /** **GPL-3.0-only**

GNU General Public License v3.0 only. GNU General Public License v3.0 only. */
    Gpl30Only,
    /** **GPL-3.0-or-later**

GNU General Public License v3.0 or later. GNU General Public License v3.0 or later. */
    Gpl30OrLater,
    /** **Giftware**

Giftware License. Giftware License. */
    Giftware,
    /** **Glide**

3dfx Glide License. 3dfx Glide License. */
    Glide,
    /** **Glulxe**

Glulxe License. Glulxe License. */
    Glulxe,
    /** **HPND**

Historical Permission Notice and Disclaimer. Historical Permission Notice and Disclaimer. */
    Hpnd,
    /** **HaskellReport**

Haskell Language Report License. Haskell Language Report License. */
    HaskellReport,
    /** **IBM-pibs**

IBM PowerPC Initialization and Boot Software. IBM PowerPC Initialization and Boot Software. */
    IbmPibs,
    /** **ICU**

ICU License. ICU License. */
    Icu,
    /** **IJG**

Independent JPEG Group License. Independent JPEG Group License. */
    Ijg,
    /** **IPA**

IPA Font License. IPA Font License. */
    Ipa,
    /** **IPL-1.0**

IBM Public License v1.0. IBM Public License v1.0. */
    Ipl10,
    /** **ISC**

ISC License. ISC License. */
    Isc,
    /** **ImageMagick**

ImageMagick License. ImageMagick License. */
    ImageMagick,
    /** **Imlib2**

Imlib2 License. Imlib2 License. */
    Imlib2,
    /** **Info-ZIP**

Info-ZIP License. Info-ZIP License. */
    InfoZIP,
    /** **Intel**

Intel Open Source License. Intel Open Source License. */
    Intel,
    /** **Intel-ACPI**

Intel ACPI Software License Agreement. Intel ACPI Software License Agreement. */
    IntelACPI,
    /** **Interbase-1.0**

Interbase Public License v1.0. Interbase Public License v1.0. */
    Interbase10,
    /** **JSON**

JSON License. JSON License. */
    Json,
    /** **JasPer-2.0**

JasPer License. JasPer License. */
    JasPer20,
    /** **LAL-1.2**

Licence Art Libre 1.2. Licence Art Libre 1.2. */
    Lal12,
    /** **LAL-1.3**

Licence Art Libre 1.3. Licence Art Libre 1.3. */
    Lal13,
    /** **LGPL-2.0-only**

GNU Library General Public License v2 only. GNU Library General Public License v2 only. */
    Lgpl20Only,
    /** **LGPL-2.0-or-later**

GNU Library General Public License v2 or later. GNU Library General Public License v2 or later. */
    Lgpl20OrLater,
    /** **LGPL-2.1-only**

GNU Lesser General Public License v2.1 only. GNU Lesser General Public License v2.1 only. */
    Lgpl21Only,
    /** **LGPL-2.1-or-later**

GNU Lesser General Public License v2.1 or later. GNU Lesser General Public License v2.1 or later. */
    Lgpl21OrLater,
    /** **LGPL-3.0-only**

GNU Lesser General Public License v3.0 only. GNU Lesser General Public License v3.0 only. */
    Lgpl30Only,
    /** **LGPL-3.0-or-later**

GNU Lesser General Public License v3.0 or later. GNU Lesser General Public License v3.0 or later. */
    Lgpl30OrLater,
    /** **LGPLLR**

Lesser General Public License For Linguistic Resources. Lesser General Public License For Linguistic Resources. */
    Lgpllr,
    /** **LPL-1.0**

Lucent Public License Version 1.0. Lucent Public License Version 1.0. */
    Lpl10,
    /** **LPL-1.02**

Lucent Public License v1.02. Lucent Public License v1.02. */
    Lpl102,
    /** **LPPL-1.0**

LaTeX Project Public License v1.0. LaTeX Project Public License v1.0. */
    Lppl10,
    /** **LPPL-1.1**

LaTeX Project Public License v1.1. LaTeX Project Public License v1.1. */
    Lppl11,
    /** **LPPL-1.2**

LaTeX Project Public License v1.2. LaTeX Project Public License v1.2. */
    Lppl12,
    /** **LPPL-1.3a**

LaTeX Project Public License v1.3a. LaTeX Project Public License v1.3a. */
    Lppl13A,
    /** **LPPL-1.3c**

LaTeX Project Public License v1.3c. LaTeX Project Public License v1.3c. */
    Lppl13C,
    /** **Latex2e**

Latex2e License. Latex2e License. */
    Latex2E,
    /** **Leptonica**

Leptonica License. Leptonica License. */
    Leptonica,
    /** **LiLiQ-P-1.1**

Licence Libre du Québec – Permissive version 1.1. Licence Libre du Québec – Permissive version 1.1. */
    LiLiQP11,
    /** **LiLiQ-R-1.1**

Licence Libre du Québec – Réciprocité version 1.1. Licence Libre du Québec – Réciprocité version 1.1. */
    LiLiQR11,
    /** **LiLiQ-Rplus-1.1**

Licence Libre du Québec – Réciprocité forte version 1.1. Licence Libre du Québec – Réciprocité forte version 1.1. */
    LiLiQRplus11,
    /** **Libpng**

libpng License. libpng License. */
    Libpng,
    /** **Linux-OpenIB**

Linux Kernel Variant of OpenIB.org license. Linux Kernel Variant of OpenIB.org license. */
    LinuxOpenIB,
    /** **MIT**

MIT License. MIT License. */
    Mit,
    /** **MIT-0**

MIT No Attribution. MIT No Attribution. */
    Mit0,
    /** **MIT-CMU**

CMU License. CMU License. */
    MitCmu,
    /** **MIT-advertising**

Enlightenment License (e16). Enlightenment License (e16). */
    MitAdvertising,
    /** **MIT-enna**

enna License. enna License. */
    MitEnna,
    /** **MIT-feh**

feh License. feh License. */
    MitFeh,
    /** **MITNFA**

MIT +no-false-attribs license. MIT +no-false-attribs license. */
    Mitnfa,
    /** **MPL-1.0**

Mozilla Public License 1.0. Mozilla Public License 1.0. */
    Mpl10,
    /** **MPL-1.1**

Mozilla Public License 1.1. Mozilla Public License 1.1. */
    Mpl11,
    /** **MPL-2.0**

Mozilla Public License 2.0. Mozilla Public License 2.0. */
    Mpl20,
    /** **MPL-2.0-no-copyleft-exception**

Mozilla Public License 2.0 (no copyleft exception). Mozilla Public License 2.0 (no copyleft exception). */
    Mpl20NoCopyleftException,
    /** **MS-PL**

Microsoft Public License. Microsoft Public License. */
    MsPl,
    /** **MS-RL**

Microsoft Reciprocal License. Microsoft Reciprocal License. */
    MsRl,
    /** **MTLL**

Matrix Template Library License. Matrix Template Library License. */
    Mtll,
    /** **MakeIndex**

MakeIndex License. MakeIndex License. */
    MakeIndex,
    /** **MirOS**

MirOS License. MirOS License. */
    MirOS,
    /** **Motosoto**

Motosoto License. Motosoto License. */
    Motosoto,
    /** **Multics**

Multics License. Multics License. */
    Multics,
    /** **Mup**

Mup License. Mup License. */
    Mup,
    /** **NASA-1.3**

NASA Open Source Agreement 1.3. NASA Open Source Agreement 1.3. */
    Nasa13,
    /** **NBPL-1.0**

Net Boolean Public License v1. Net Boolean Public License v1. */
    Nbpl10,
    /** **NCSA**

University of Illinois/NCSA Open Source License. University of Illinois/NCSA Open Source License. */
    Ncsa,
    /** **NGPL**

Nethack General Public License. Nethack General Public License. */
    Ngpl,
    /** **NLOD-1.0**

Norwegian Licence for Open Government Data. Norwegian Licence for Open Government Data. */
    Nlod10,
    /** **NLPL**

No Limit Public License. No Limit Public License. */
    Nlpl,
    /** **NOSL**

Netizen Open Source License. Netizen Open Source License. */
    Nosl,
    /** **NPL-1.0**

Netscape Public License v1.0. Netscape Public License v1.0. */
    Npl10,
    /** **NPL-1.1**

Netscape Public License v1.1. Netscape Public License v1.1. */
    Npl11,
    /** **NPOSL-3.0**

Non-Profit Open Software License 3.0. Non-Profit Open Software License 3.0. */
    Nposl30,
    /** **NRL**

NRL License. NRL License. */
    Nrl,
    /** **NTP**

NTP License. NTP License. */
    Ntp,
    /** **Naumen**

Naumen Public License. Naumen Public License. */
    Naumen,
    /** **Net-SNMP**

Net-SNMP License. Net-SNMP License. */
    NetSNMP,
    /** **NetCDF**

NetCDF license. NetCDF license. */
    NetCDF,
    /** **Newsletr**

Newsletr License. Newsletr License. */
    Newsletr,
    /** **Nokia**

Nokia Open Source License. Nokia Open Source License. */
    Nokia,
    /** **Noweb**

Noweb License. Noweb License. */
    Noweb,
    /** **OCCT-PL**

Open CASCADE Technology Public License. Open CASCADE Technology Public License. */
    OcctPl,
    /** **OCLC-2.0**

OCLC Research Public License 2.0. OCLC Research Public License 2.0. */
    Oclc20,
    /** **ODbL-1.0**

ODC Open Database License v1.0. ODC Open Database License v1.0. */
    OdbL10,
    /** **OFL-1.0**

SIL Open Font License 1.0. SIL Open Font License 1.0. */
    Ofl10,
    /** **OFL-1.1**

SIL Open Font License 1.1. SIL Open Font License 1.1. */
    Ofl11,
    /** **OGTSL**

Open Group Test Suite License. Open Group Test Suite License. */
    Ogtsl,
    /** **OLDAP-1.1**

Open LDAP Public License v1.1. Open LDAP Public License v1.1. */
    Oldap11,
    /** **OLDAP-1.2**

Open LDAP Public License v1.2. Open LDAP Public License v1.2. */
    Oldap12,
    /** **OLDAP-1.3**

Open LDAP Public License v1.3. Open LDAP Public License v1.3. */
    Oldap13,
    /** **OLDAP-1.4**

Open LDAP Public License v1.4. Open LDAP Public License v1.4. */
    Oldap14,
    /** **OLDAP-2.0**

Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B). Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B). */
    Oldap20,
    /** **OLDAP-2.0.1**

Open LDAP Public License v2.0.1. Open LDAP Public License v2.0.1. */
    Oldap201,
    /** **OLDAP-2.1**

Open LDAP Public License v2.1. Open LDAP Public License v2.1. */
    Oldap21,
    /** **OLDAP-2.2**

Open LDAP Public License v2.2. Open LDAP Public License v2.2. */
    Oldap22,
    /** **OLDAP-2.2.1**

Open LDAP Public License v2.2.1. Open LDAP Public License v2.2.1. */
    Oldap221,
    /** **OLDAP-2.2.2**

Open LDAP Public License 2.2.2. Open LDAP Public License 2.2.2. */
    Oldap222,
    /** **OLDAP-2.3**

Open LDAP Public License v2.3. Open LDAP Public License v2.3. */
    Oldap23,
    /** **OLDAP-2.4**

Open LDAP Public License v2.4. Open LDAP Public License v2.4. */
    Oldap24,
    /** **OLDAP-2.5**

Open LDAP Public License v2.5. Open LDAP Public License v2.5. */
    Oldap25,
    /** **OLDAP-2.6**

Open LDAP Public License v2.6. Open LDAP Public License v2.6. */
    Oldap26,
    /** **OLDAP-2.7**

Open LDAP Public License v2.7. Open LDAP Public License v2.7. */
    Oldap27,
    /** **OLDAP-2.8**

Open LDAP Public License v2.8. Open LDAP Public License v2.8. */
    Oldap28,
    /** **OML**

Open Market License. Open Market License. */
    Oml,
    /** **OPL-1.0**

Open Public License v1.0. Open Public License v1.0. */
    Opl10,
    /** **OSET-PL-2.1**

OSET Public License version 2.1. OSET Public License version 2.1. */
    OsetPl21,
    /** **OSL-1.0**

Open Software License 1.0. Open Software License 1.0. */
    Osl10,
    /** **OSL-1.1**

Open Software License 1.1. Open Software License 1.1. */
    Osl11,
    /** **OSL-2.0**

Open Software License 2.0. Open Software License 2.0. */
    Osl20,
    /** **OSL-2.1**

Open Software License 2.1. Open Software License 2.1. */
    Osl21,
    /** **OSL-3.0**

Open Software License 3.0. Open Software License 3.0. */
    Osl30,
    /** **OpenSSL**

OpenSSL License. OpenSSL License. */
    OpenSSL,
    /** **PDDL-1.0**

ODC Public Domain Dedication & License 1.0. ODC Public Domain Dedication & License 1.0. */
    Pddl10,
    /** **PHP-3.0**

PHP License v3.0. PHP License v3.0. */
    Php30,
    /** **PHP-3.01**

PHP License v3.01. PHP License v3.01. */
    Php301,
    /** **Plexus**

Plexus Classworlds License. Plexus Classworlds License. */
    Plexus,
    /** **PostgreSQL**

PostgreSQL License. PostgreSQL License. */
    PostgreSQL,
    /** **Python-2.0**

Python License 2.0. Python License 2.0. */
    Python20,
    /** **QPL-1.0**

Q Public License 1.0. Q Public License 1.0. */
    Qpl10,
    /** **Qhull**

Qhull License. Qhull License. */
    Qhull,
    /** **RHeCos-1.1**

Red Hat eCos Public License v1.1. Red Hat eCos Public License v1.1. */
    RheCos11,
    /** **RPL-1.1**

Reciprocal Public License 1.1. Reciprocal Public License 1.1. */
    Rpl11,
    /** **RPL-1.5**

Reciprocal Public License 1.5. Reciprocal Public License 1.5. */
    Rpl15,
    /** **RPSL-1.0**

RealNetworks Public Source License v1.0. RealNetworks Public Source License v1.0. */
    Rpsl10,
    /** **RSA-MD**

RSA Message-Digest License. RSA Message-Digest License. */
    RsaMd,
    /** **RSCPL**

Ricoh Source Code Public License. Ricoh Source Code Public License. */
    Rscpl,
    /** **Rdisc**

Rdisc License. Rdisc License. */
    Rdisc,
    /** **Ruby**

Ruby License. Ruby License. */
    Ruby,
    /** **SAX-PD**

Sax Public Domain Notice. Sax Public Domain Notice. */
    SaxPd,
    /** **SCEA**

SCEA Shared Source License. SCEA Shared Source License. */
    Scea,
    /** **SGI-B-1.0**

SGI Free Software License B v1.0. SGI Free Software License B v1.0. */
    SgiB10,
    /** **SGI-B-1.1**

SGI Free Software License B v1.1. SGI Free Software License B v1.1. */
    SgiB11,
    /** **SGI-B-2.0**

SGI Free Software License B v2.0. SGI Free Software License B v2.0. */
    SgiB20,
    /** **SISSL**

Sun Industry Standards Source License v1.1. Sun Industry Standards Source License v1.1. */
    Sissl,
    /** **SISSL-1.2**

Sun Industry Standards Source License v1.2. Sun Industry Standards Source License v1.2. */
    Sissl12,
    /** **SMLNJ**

Standard ML of New Jersey License. Standard ML of New Jersey License. */
    Smlnj,
    /** **SMPPL**

Secure Messaging Protocol Public License. Secure Messaging Protocol Public License. */
    Smppl,
    /** **SNIA**

SNIA Public License 1.1. SNIA Public License 1.1. */
    Snia,
    /** **SPL-1.0**

Sun Public License v1.0. Sun Public License v1.0. */
    Spl10,
    /** **SWL**

Scheme Widget Library (SWL) Software License Agreement. Scheme Widget Library (SWL) Software License Agreement. */
    Swl,
    /** **Saxpath**

Saxpath License. Saxpath License. */
    Saxpath,
    /** **Sendmail**

Sendmail License. Sendmail License. */
    Sendmail,
    /** **SimPL-2.0**

Simple Public License 2.0. Simple Public License 2.0. */
    SimPL20,
    /** **Sleepycat**

Sleepycat License. Sleepycat License. */
    Sleepycat,
    /** **Spencer-86**

Spencer License 86. Spencer License 86. */
    Spencer86,
    /** **Spencer-94**

Spencer License 94. Spencer License 94. */
    Spencer94,
    /** **Spencer-99**

Spencer License 99. Spencer License 99. */
    Spencer99,
    /** **SugarCRM-1.1.3**

SugarCRM Public License v1.1.3. SugarCRM Public License v1.1.3. */
    SugarCRM113,
    /** **TCL**

TCL/TK License. TCL/TK License. */
    Tcl,
    /** **TCP-wrappers**

TCP Wrappers License. TCP Wrappers License. */
    TcpWrappers,
    /** **TMate**

TMate Open Source License. TMate Open Source License. */
    Tmate,
    /** **TORQUE-1.1**

TORQUE v2.5+ Software License v1.1. TORQUE v2.5+ Software License v1.1. */
    Torque11,
    /** **TOSL**

Trusster Open Source License. Trusster Open Source License. */
    Tosl,
    /** **UPL-1.0**

Universal Permissive License v1.0. Universal Permissive License v1.0. */
    Upl10,
    /** **Unicode-DFS-2015**

Unicode License Agreement - Data Files and Software (2015). Unicode License Agreement - Data Files and Software (2015). */
    UnicodeDFS2015,
    /** **Unicode-DFS-2016**

Unicode License Agreement - Data Files and Software (2016). Unicode License Agreement - Data Files and Software (2016). */
    UnicodeDFS2016,
    /** **Unicode-TOU**

Unicode Terms of Use. Unicode Terms of Use. */
    UnicodeTOU,
    /** **Unlicense**

The Unlicense. The Unlicense. */
    Unlicense,
    /** **VOSTROM**

VOSTROM Public License for Open Source. VOSTROM Public License for Open Source. */
    Vostrom,
    /** **VSL-1.0**

Vovida Software License v1.0. Vovida Software License v1.0. */
    Vsl10,
    /** **Vim**

Vim License. Vim License. */
    Vim,
    /** **W3C**

W3C Software Notice and License (2002-12-31). W3C Software Notice and License (2002-12-31). */
    W3C,
    /** **W3C-19980720**

W3C Software Notice and License (1998-07-20). W3C Software Notice and License (1998-07-20). */
    W3C19980720,
    /** **W3C-20150513**

W3C Software Notice and Document License (2015-05-13). W3C Software Notice and Document License (2015-05-13). */
    W3C20150513,
    /** **WTFPL**

Do What The F*ck You Want To Public License. Do What The F*ck You Want To Public License. */
    Wtfpl,
    /** **Watcom-1.0**

Sybase Open Watcom Public License 1.0. Sybase Open Watcom Public License 1.0. */
    Watcom10,
    /** **Wsuipa**

Wsuipa License. Wsuipa License. */
    Wsuipa,
    /** **X11**

X11 License. X11 License. */
    X11,
    /** **XFree86-1.1**

XFree86 License 1.1. XFree86 License 1.1. */
    Xfree8611,
    /** **XSkat**

XSkat License. XSkat License. */
    Xskat,
    /** **Xerox**

Xerox License. Xerox License. */
    Xerox,
    /** **Xnet**

X.Net License. X.Net License. */
    Xnet,
    /** **YPL-1.0**

Yahoo! Public License v1.0. Yahoo! Public License v1.0. */
    Ypl10,
    /** **YPL-1.1**

Yahoo! Public License v1.1. Yahoo! Public License v1.1. */
    Ypl11,
    /** **ZPL-1.1**

Zope Public License 1.1. Zope Public License 1.1. */
    Zpl11,
    /** **ZPL-2.0**

Zope Public License 2.0. Zope Public License 2.0. */
    Zpl20,
    /** **ZPL-2.1**

Zope Public License 2.1. Zope Public License 2.1. */
    Zpl21,
    /** **Zed**

Zed License. Zed License. */
    Zed,
    /** **Zend-2.0**

Zend License v2.0. Zend License v2.0. */
    Zend20,
    /** **Zimbra-1.3**

Zimbra Public License v1.3. Zimbra Public License v1.3. */
    Zimbra13,
    /** **Zimbra-1.4**

Zimbra Public License v1.4. Zimbra Public License v1.4. */
    Zimbra14,
    /** **Zlib**

zlib License. zlib License. */
    Zlib,
    /** **bzip2-1.0.5**

bzip2 and libbzip2 License v1.0.5. bzip2 and libbzip2 License v1.0.5. */
    Bzip2105,
    /** **bzip2-1.0.6**

bzip2 and libbzip2 License v1.0.6. bzip2 and libbzip2 License v1.0.6. */
    Bzip2106,
    /** **curl**

curl License. curl License. */
    Curl,
    /** **diffmark**

diffmark license. diffmark license. */
    Diffmark,
    /** **dvipdfm**

dvipdfm License. dvipdfm License. */
    Dvipdfm,
    /** **eGenix**

eGenix.com Public License 1.1.0. eGenix.com Public License 1.1.0. */
    Egenix,
    /** **gSOAP-1.3b**

gSOAP Public License v1.3b. gSOAP Public License v1.3b. */
    Gsoap13B,
    /** **gnuplot**

gnuplot License. gnuplot License. */
    Gnuplot,
    /** **iMatix**

iMatix Standard Function Library Agreement. iMatix Standard Function Library Agreement. */
    Imatix,
    /** **libtiff**

libtiff License. libtiff License. */
    Libtiff,
    /** **mpich2**

mpich2 License. mpich2 License. */
    Mpich2,
    /** **not-open-source**

Not open source. Not an open source license. */
    NotOpenSource,
    /** **psfrag**

psfrag License. psfrag License. */
    Psfrag,
    /** **psutils**

psutils License. psutils License. */
    Psutils,
    /** **xinetd**

xinetd License. xinetd License. */
    Xinetd,
    /** **xpp**

XPP License. XPP License. */
    Xpp,
    /** **zlib-acknowledgement**

zlib/libpng License with Acknowledgement. zlib/libpng License with Acknowledgement. */
    ZlibAcknowledgement,
}
impl ::core::str::FromStr for SPDXLicense {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0BSD" => Ok(Self::N0Bsd),
            "AAL" => Ok(Self::Aal),
            "ADSL" => Ok(Self::Adsl),
            "AFL-1.1" => Ok(Self::Afl11),
            "AFL-1.2" => Ok(Self::Afl12),
            "AFL-2.0" => Ok(Self::Afl20),
            "AFL-2.1" => Ok(Self::Afl21),
            "AFL-3.0" => Ok(Self::Afl30),
            "AGPL-1.0-only" => Ok(Self::Agpl10Only),
            "AGPL-1.0-or-later" => Ok(Self::Agpl10OrLater),
            "AGPL-3.0-only" => Ok(Self::Agpl30Only),
            "AGPL-3.0-or-later" => Ok(Self::Agpl30OrLater),
            "AMDPLPA" => Ok(Self::Amdplpa),
            "AML" => Ok(Self::Aml),
            "AMPAS" => Ok(Self::Ampas),
            "ANTLR-PD" => Ok(Self::AntlrPd),
            "APAFML" => Ok(Self::Apafml),
            "APL-1.0" => Ok(Self::Apl10),
            "APSL-1.0" => Ok(Self::Apsl10),
            "APSL-1.1" => Ok(Self::Apsl11),
            "APSL-1.2" => Ok(Self::Apsl12),
            "APSL-2.0" => Ok(Self::Apsl20),
            "Abstyles" => Ok(Self::Abstyles),
            "Adobe-2006" => Ok(Self::Adobe2006),
            "Adobe-Glyph" => Ok(Self::AdobeGlyph),
            "Afmparse" => Ok(Self::Afmparse),
            "Aladdin" => Ok(Self::Aladdin),
            "Apache-1.0" => Ok(Self::Apache10),
            "Apache-1.1" => Ok(Self::Apache11),
            "Apache-2.0" => Ok(Self::Apache20),
            "Artistic-1.0" => Ok(Self::Artistic10),
            "Artistic-1.0-Perl" => Ok(Self::Artistic10Perl),
            "Artistic-1.0-cl8" => Ok(Self::Artistic10Cl8),
            "Artistic-2.0" => Ok(Self::Artistic20),
            "BSD-1-Clause" => Ok(Self::Bsd1Clause),
            "BSD-2-Clause" => Ok(Self::Bsd2Clause),
            "BSD-2-Clause-FreeBSD" => Ok(Self::Bsd2ClauseFreeBSD),
            "BSD-2-Clause-NetBSD" => Ok(Self::Bsd2ClauseNetBSD),
            "BSD-2-Clause-Patent" => Ok(Self::Bsd2ClausePatent),
            "BSD-3-Clause" => Ok(Self::Bsd3Clause),
            "BSD-3-Clause-Attribution" => Ok(Self::Bsd3ClauseAttribution),
            "BSD-3-Clause-Clear" => Ok(Self::Bsd3ClauseClear),
            "BSD-3-Clause-LBNL" => Ok(Self::Bsd3ClauseLBNL),
            "BSD-3-Clause-No-Nuclear-License" => Ok(Self::Bsd3ClauseNoNuclearLicense),
            "BSD-3-Clause-No-Nuclear-License-2014" => {
                Ok(Self::Bsd3ClauseNoNuclearLicense2014)
            }
            "BSD-3-Clause-No-Nuclear-Warranty" => Ok(Self::Bsd3ClauseNoNuclearWarranty),
            "BSD-4-Clause" => Ok(Self::Bsd4Clause),
            "BSD-4-Clause-UC" => Ok(Self::Bsd4ClauseUC),
            "BSD-Protection" => Ok(Self::BsdProtection),
            "BSD-Source-Code" => Ok(Self::BsdSourceCode),
            "BSL-1.0" => Ok(Self::Bsl10),
            "Bahyph" => Ok(Self::Bahyph),
            "Barr" => Ok(Self::Barr),
            "Beerware" => Ok(Self::Beerware),
            "BitTorrent-1.0" => Ok(Self::BitTorrent10),
            "BitTorrent-1.1" => Ok(Self::BitTorrent11),
            "Borceux" => Ok(Self::Borceux),
            "CATOSL-1.1" => Ok(Self::Catosl11),
            "CC-BY-1.0" => Ok(Self::CcBy10),
            "CC-BY-2.0" => Ok(Self::CcBy20),
            "CC-BY-2.5" => Ok(Self::CcBy25),
            "CC-BY-3.0" => Ok(Self::CcBy30),
            "CC-BY-4.0" => Ok(Self::CcBy40),
            "CC-BY-NC-1.0" => Ok(Self::CcByNc10),
            "CC-BY-NC-2.0" => Ok(Self::CcByNc20),
            "CC-BY-NC-2.5" => Ok(Self::CcByNc25),
            "CC-BY-NC-3.0" => Ok(Self::CcByNc30),
            "CC-BY-NC-4.0" => Ok(Self::CcByNc40),
            "CC-BY-NC-ND-1.0" => Ok(Self::CcByNcNd10),
            "CC-BY-NC-ND-2.0" => Ok(Self::CcByNcNd20),
            "CC-BY-NC-ND-2.5" => Ok(Self::CcByNcNd25),
            "CC-BY-NC-ND-3.0" => Ok(Self::CcByNcNd30),
            "CC-BY-NC-ND-4.0" => Ok(Self::CcByNcNd40),
            "CC-BY-NC-SA-1.0" => Ok(Self::CcByNcSa10),
            "CC-BY-NC-SA-2.0" => Ok(Self::CcByNcSa20),
            "CC-BY-NC-SA-2.5" => Ok(Self::CcByNcSa25),
            "CC-BY-NC-SA-3.0" => Ok(Self::CcByNcSa30),
            "CC-BY-NC-SA-4.0" => Ok(Self::CcByNcSa40),
            "CC-BY-ND-1.0" => Ok(Self::CcByNd10),
            "CC-BY-ND-2.0" => Ok(Self::CcByNd20),
            "CC-BY-ND-2.5" => Ok(Self::CcByNd25),
            "CC-BY-ND-3.0" => Ok(Self::CcByNd30),
            "CC-BY-ND-4.0" => Ok(Self::CcByNd40),
            "CC-BY-SA-1.0" => Ok(Self::CcBySa10),
            "CC-BY-SA-2.0" => Ok(Self::CcBySa20),
            "CC-BY-SA-2.5" => Ok(Self::CcBySa25),
            "CC-BY-SA-3.0" => Ok(Self::CcBySa30),
            "CC-BY-SA-4.0" => Ok(Self::CcBySa40),
            "CC0-1.0" => Ok(Self::Cc010),
            "CDDL-1.0" => Ok(Self::Cddl10),
            "CDDL-1.1" => Ok(Self::Cddl11),
            "CDLA-Permissive-1.0" => Ok(Self::CdlaPermissive10),
            "CDLA-Sharing-1.0" => Ok(Self::CdlaSharing10),
            "CECILL-1.0" => Ok(Self::Cecill10),
            "CECILL-1.1" => Ok(Self::Cecill11),
            "CECILL-2.0" => Ok(Self::Cecill20),
            "CECILL-2.1" => Ok(Self::Cecill21),
            "CECILL-B" => Ok(Self::CecillB),
            "CECILL-C" => Ok(Self::CecillC),
            "CNRI-Jython" => Ok(Self::CnriJython),
            "CNRI-Python" => Ok(Self::CnriPython),
            "CNRI-Python-GPL-Compatible" => Ok(Self::CnriPythonGPLCompatible),
            "CPAL-1.0" => Ok(Self::Cpal10),
            "CPL-1.0" => Ok(Self::Cpl10),
            "CPOL-1.02" => Ok(Self::Cpol102),
            "CUA-OPL-1.0" => Ok(Self::CuaOpl10),
            "Caldera" => Ok(Self::Caldera),
            "ClArtistic" => Ok(Self::ClArtistic),
            "Condor-1.1" => Ok(Self::Condor11),
            "Crossword" => Ok(Self::Crossword),
            "CrystalStacker" => Ok(Self::CrystalStacker),
            "Cube" => Ok(Self::Cube),
            "D-FSL-1.0" => Ok(Self::DFsl10),
            "DOC" => Ok(Self::Doc),
            "DSDP" => Ok(Self::Dsdp),
            "Dotseqn" => Ok(Self::Dotseqn),
            "ECL-1.0" => Ok(Self::Ecl10),
            "ECL-2.0" => Ok(Self::Ecl20),
            "EFL-1.0" => Ok(Self::Efl10),
            "EFL-2.0" => Ok(Self::Efl20),
            "EPL-1.0" => Ok(Self::Epl10),
            "EPL-2.0" => Ok(Self::Epl20),
            "EUDatagrid" => Ok(Self::Eudatagrid),
            "EUPL-1.0" => Ok(Self::Eupl10),
            "EUPL-1.1" => Ok(Self::Eupl11),
            "EUPL-1.2" => Ok(Self::Eupl12),
            "Entessa" => Ok(Self::Entessa),
            "ErlPL-1.1" => Ok(Self::ErlPL11),
            "Eurosym" => Ok(Self::Eurosym),
            "FSFAP" => Ok(Self::Fsfap),
            "FSFUL" => Ok(Self::Fsful),
            "FSFULLR" => Ok(Self::Fsfullr),
            "FTL" => Ok(Self::Ftl),
            "Fair" => Ok(Self::Fair),
            "Frameworx-1.0" => Ok(Self::Frameworx10),
            "FreeImage" => Ok(Self::FreeImage),
            "GFDL-1.1-only" => Ok(Self::Gfdl11Only),
            "GFDL-1.1-or-later" => Ok(Self::Gfdl11OrLater),
            "GFDL-1.2-only" => Ok(Self::Gfdl12Only),
            "GFDL-1.2-or-later" => Ok(Self::Gfdl12OrLater),
            "GFDL-1.3-only" => Ok(Self::Gfdl13Only),
            "GFDL-1.3-or-later" => Ok(Self::Gfdl13OrLater),
            "GL2PS" => Ok(Self::Gl2Ps),
            "GPL-1.0-only" => Ok(Self::Gpl10Only),
            "GPL-1.0-or-later" => Ok(Self::Gpl10OrLater),
            "GPL-2.0-only" => Ok(Self::Gpl20Only),
            "GPL-2.0-or-later" => Ok(Self::Gpl20OrLater),
            "GPL-3.0-only" => Ok(Self::Gpl30Only),
            "GPL-3.0-or-later" => Ok(Self::Gpl30OrLater),
            "Giftware" => Ok(Self::Giftware),
            "Glide" => Ok(Self::Glide),
            "Glulxe" => Ok(Self::Glulxe),
            "HPND" => Ok(Self::Hpnd),
            "HaskellReport" => Ok(Self::HaskellReport),
            "IBM-pibs" => Ok(Self::IbmPibs),
            "ICU" => Ok(Self::Icu),
            "IJG" => Ok(Self::Ijg),
            "IPA" => Ok(Self::Ipa),
            "IPL-1.0" => Ok(Self::Ipl10),
            "ISC" => Ok(Self::Isc),
            "ImageMagick" => Ok(Self::ImageMagick),
            "Imlib2" => Ok(Self::Imlib2),
            "Info-ZIP" => Ok(Self::InfoZIP),
            "Intel" => Ok(Self::Intel),
            "Intel-ACPI" => Ok(Self::IntelACPI),
            "Interbase-1.0" => Ok(Self::Interbase10),
            "JSON" => Ok(Self::Json),
            "JasPer-2.0" => Ok(Self::JasPer20),
            "LAL-1.2" => Ok(Self::Lal12),
            "LAL-1.3" => Ok(Self::Lal13),
            "LGPL-2.0-only" => Ok(Self::Lgpl20Only),
            "LGPL-2.0-or-later" => Ok(Self::Lgpl20OrLater),
            "LGPL-2.1-only" => Ok(Self::Lgpl21Only),
            "LGPL-2.1-or-later" => Ok(Self::Lgpl21OrLater),
            "LGPL-3.0-only" => Ok(Self::Lgpl30Only),
            "LGPL-3.0-or-later" => Ok(Self::Lgpl30OrLater),
            "LGPLLR" => Ok(Self::Lgpllr),
            "LPL-1.0" => Ok(Self::Lpl10),
            "LPL-1.02" => Ok(Self::Lpl102),
            "LPPL-1.0" => Ok(Self::Lppl10),
            "LPPL-1.1" => Ok(Self::Lppl11),
            "LPPL-1.2" => Ok(Self::Lppl12),
            "LPPL-1.3a" => Ok(Self::Lppl13A),
            "LPPL-1.3c" => Ok(Self::Lppl13C),
            "Latex2e" => Ok(Self::Latex2E),
            "Leptonica" => Ok(Self::Leptonica),
            "LiLiQ-P-1.1" => Ok(Self::LiLiQP11),
            "LiLiQ-R-1.1" => Ok(Self::LiLiQR11),
            "LiLiQ-Rplus-1.1" => Ok(Self::LiLiQRplus11),
            "Libpng" => Ok(Self::Libpng),
            "Linux-OpenIB" => Ok(Self::LinuxOpenIB),
            "MIT" => Ok(Self::Mit),
            "MIT-0" => Ok(Self::Mit0),
            "MIT-CMU" => Ok(Self::MitCmu),
            "MIT-advertising" => Ok(Self::MitAdvertising),
            "MIT-enna" => Ok(Self::MitEnna),
            "MIT-feh" => Ok(Self::MitFeh),
            "MITNFA" => Ok(Self::Mitnfa),
            "MPL-1.0" => Ok(Self::Mpl10),
            "MPL-1.1" => Ok(Self::Mpl11),
            "MPL-2.0" => Ok(Self::Mpl20),
            "MPL-2.0-no-copyleft-exception" => Ok(Self::Mpl20NoCopyleftException),
            "MS-PL" => Ok(Self::MsPl),
            "MS-RL" => Ok(Self::MsRl),
            "MTLL" => Ok(Self::Mtll),
            "MakeIndex" => Ok(Self::MakeIndex),
            "MirOS" => Ok(Self::MirOS),
            "Motosoto" => Ok(Self::Motosoto),
            "Multics" => Ok(Self::Multics),
            "Mup" => Ok(Self::Mup),
            "NASA-1.3" => Ok(Self::Nasa13),
            "NBPL-1.0" => Ok(Self::Nbpl10),
            "NCSA" => Ok(Self::Ncsa),
            "NGPL" => Ok(Self::Ngpl),
            "NLOD-1.0" => Ok(Self::Nlod10),
            "NLPL" => Ok(Self::Nlpl),
            "NOSL" => Ok(Self::Nosl),
            "NPL-1.0" => Ok(Self::Npl10),
            "NPL-1.1" => Ok(Self::Npl11),
            "NPOSL-3.0" => Ok(Self::Nposl30),
            "NRL" => Ok(Self::Nrl),
            "NTP" => Ok(Self::Ntp),
            "Naumen" => Ok(Self::Naumen),
            "Net-SNMP" => Ok(Self::NetSNMP),
            "NetCDF" => Ok(Self::NetCDF),
            "Newsletr" => Ok(Self::Newsletr),
            "Nokia" => Ok(Self::Nokia),
            "Noweb" => Ok(Self::Noweb),
            "OCCT-PL" => Ok(Self::OcctPl),
            "OCLC-2.0" => Ok(Self::Oclc20),
            "ODbL-1.0" => Ok(Self::OdbL10),
            "OFL-1.0" => Ok(Self::Ofl10),
            "OFL-1.1" => Ok(Self::Ofl11),
            "OGTSL" => Ok(Self::Ogtsl),
            "OLDAP-1.1" => Ok(Self::Oldap11),
            "OLDAP-1.2" => Ok(Self::Oldap12),
            "OLDAP-1.3" => Ok(Self::Oldap13),
            "OLDAP-1.4" => Ok(Self::Oldap14),
            "OLDAP-2.0" => Ok(Self::Oldap20),
            "OLDAP-2.0.1" => Ok(Self::Oldap201),
            "OLDAP-2.1" => Ok(Self::Oldap21),
            "OLDAP-2.2" => Ok(Self::Oldap22),
            "OLDAP-2.2.1" => Ok(Self::Oldap221),
            "OLDAP-2.2.2" => Ok(Self::Oldap222),
            "OLDAP-2.3" => Ok(Self::Oldap23),
            "OLDAP-2.4" => Ok(Self::Oldap24),
            "OLDAP-2.5" => Ok(Self::Oldap25),
            "OLDAP-2.6" => Ok(Self::Oldap26),
            "OLDAP-2.7" => Ok(Self::Oldap27),
            "OLDAP-2.8" => Ok(Self::Oldap28),
            "OML" => Ok(Self::Oml),
            "OPL-1.0" => Ok(Self::Opl10),
            "OSET-PL-2.1" => Ok(Self::OsetPl21),
            "OSL-1.0" => Ok(Self::Osl10),
            "OSL-1.1" => Ok(Self::Osl11),
            "OSL-2.0" => Ok(Self::Osl20),
            "OSL-2.1" => Ok(Self::Osl21),
            "OSL-3.0" => Ok(Self::Osl30),
            "OpenSSL" => Ok(Self::OpenSSL),
            "PDDL-1.0" => Ok(Self::Pddl10),
            "PHP-3.0" => Ok(Self::Php30),
            "PHP-3.01" => Ok(Self::Php301),
            "Plexus" => Ok(Self::Plexus),
            "PostgreSQL" => Ok(Self::PostgreSQL),
            "Python-2.0" => Ok(Self::Python20),
            "QPL-1.0" => Ok(Self::Qpl10),
            "Qhull" => Ok(Self::Qhull),
            "RHeCos-1.1" => Ok(Self::RheCos11),
            "RPL-1.1" => Ok(Self::Rpl11),
            "RPL-1.5" => Ok(Self::Rpl15),
            "RPSL-1.0" => Ok(Self::Rpsl10),
            "RSA-MD" => Ok(Self::RsaMd),
            "RSCPL" => Ok(Self::Rscpl),
            "Rdisc" => Ok(Self::Rdisc),
            "Ruby" => Ok(Self::Ruby),
            "SAX-PD" => Ok(Self::SaxPd),
            "SCEA" => Ok(Self::Scea),
            "SGI-B-1.0" => Ok(Self::SgiB10),
            "SGI-B-1.1" => Ok(Self::SgiB11),
            "SGI-B-2.0" => Ok(Self::SgiB20),
            "SISSL" => Ok(Self::Sissl),
            "SISSL-1.2" => Ok(Self::Sissl12),
            "SMLNJ" => Ok(Self::Smlnj),
            "SMPPL" => Ok(Self::Smppl),
            "SNIA" => Ok(Self::Snia),
            "SPL-1.0" => Ok(Self::Spl10),
            "SWL" => Ok(Self::Swl),
            "Saxpath" => Ok(Self::Saxpath),
            "Sendmail" => Ok(Self::Sendmail),
            "SimPL-2.0" => Ok(Self::SimPL20),
            "Sleepycat" => Ok(Self::Sleepycat),
            "Spencer-86" => Ok(Self::Spencer86),
            "Spencer-94" => Ok(Self::Spencer94),
            "Spencer-99" => Ok(Self::Spencer99),
            "SugarCRM-1.1.3" => Ok(Self::SugarCRM113),
            "TCL" => Ok(Self::Tcl),
            "TCP-wrappers" => Ok(Self::TcpWrappers),
            "TMate" => Ok(Self::Tmate),
            "TORQUE-1.1" => Ok(Self::Torque11),
            "TOSL" => Ok(Self::Tosl),
            "UPL-1.0" => Ok(Self::Upl10),
            "Unicode-DFS-2015" => Ok(Self::UnicodeDFS2015),
            "Unicode-DFS-2016" => Ok(Self::UnicodeDFS2016),
            "Unicode-TOU" => Ok(Self::UnicodeTOU),
            "Unlicense" => Ok(Self::Unlicense),
            "VOSTROM" => Ok(Self::Vostrom),
            "VSL-1.0" => Ok(Self::Vsl10),
            "Vim" => Ok(Self::Vim),
            "W3C" => Ok(Self::W3C),
            "W3C-19980720" => Ok(Self::W3C19980720),
            "W3C-20150513" => Ok(Self::W3C20150513),
            "WTFPL" => Ok(Self::Wtfpl),
            "Watcom-1.0" => Ok(Self::Watcom10),
            "Wsuipa" => Ok(Self::Wsuipa),
            "X11" => Ok(Self::X11),
            "XFree86-1.1" => Ok(Self::Xfree8611),
            "XSkat" => Ok(Self::Xskat),
            "Xerox" => Ok(Self::Xerox),
            "Xnet" => Ok(Self::Xnet),
            "YPL-1.0" => Ok(Self::Ypl10),
            "YPL-1.1" => Ok(Self::Ypl11),
            "ZPL-1.1" => Ok(Self::Zpl11),
            "ZPL-2.0" => Ok(Self::Zpl20),
            "ZPL-2.1" => Ok(Self::Zpl21),
            "Zed" => Ok(Self::Zed),
            "Zend-2.0" => Ok(Self::Zend20),
            "Zimbra-1.3" => Ok(Self::Zimbra13),
            "Zimbra-1.4" => Ok(Self::Zimbra14),
            "Zlib" => Ok(Self::Zlib),
            "bzip2-1.0.5" => Ok(Self::Bzip2105),
            "bzip2-1.0.6" => Ok(Self::Bzip2106),
            "curl" => Ok(Self::Curl),
            "diffmark" => Ok(Self::Diffmark),
            "dvipdfm" => Ok(Self::Dvipdfm),
            "eGenix" => Ok(Self::Egenix),
            "gSOAP-1.3b" => Ok(Self::Gsoap13B),
            "gnuplot" => Ok(Self::Gnuplot),
            "iMatix" => Ok(Self::Imatix),
            "libtiff" => Ok(Self::Libtiff),
            "mpich2" => Ok(Self::Mpich2),
            "not-open-source" => Ok(Self::NotOpenSource),
            "psfrag" => Ok(Self::Psfrag),
            "psutils" => Ok(Self::Psutils),
            "xinetd" => Ok(Self::Xinetd),
            "xpp" => Ok(Self::Xpp),
            "zlib-acknowledgement" => Ok(Self::ZlibAcknowledgement),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SPDXLicense {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0Bsd => "0BSD",
            Self::Aal => "AAL",
            Self::Adsl => "ADSL",
            Self::Afl11 => "AFL-1.1",
            Self::Afl12 => "AFL-1.2",
            Self::Afl20 => "AFL-2.0",
            Self::Afl21 => "AFL-2.1",
            Self::Afl30 => "AFL-3.0",
            Self::Agpl10Only => "AGPL-1.0-only",
            Self::Agpl10OrLater => "AGPL-1.0-or-later",
            Self::Agpl30Only => "AGPL-3.0-only",
            Self::Agpl30OrLater => "AGPL-3.0-or-later",
            Self::Amdplpa => "AMDPLPA",
            Self::Aml => "AML",
            Self::Ampas => "AMPAS",
            Self::AntlrPd => "ANTLR-PD",
            Self::Apafml => "APAFML",
            Self::Apl10 => "APL-1.0",
            Self::Apsl10 => "APSL-1.0",
            Self::Apsl11 => "APSL-1.1",
            Self::Apsl12 => "APSL-1.2",
            Self::Apsl20 => "APSL-2.0",
            Self::Abstyles => "Abstyles",
            Self::Adobe2006 => "Adobe-2006",
            Self::AdobeGlyph => "Adobe-Glyph",
            Self::Afmparse => "Afmparse",
            Self::Aladdin => "Aladdin",
            Self::Apache10 => "Apache-1.0",
            Self::Apache11 => "Apache-1.1",
            Self::Apache20 => "Apache-2.0",
            Self::Artistic10 => "Artistic-1.0",
            Self::Artistic10Perl => "Artistic-1.0-Perl",
            Self::Artistic10Cl8 => "Artistic-1.0-cl8",
            Self::Artistic20 => "Artistic-2.0",
            Self::Bsd1Clause => "BSD-1-Clause",
            Self::Bsd2Clause => "BSD-2-Clause",
            Self::Bsd2ClauseFreeBSD => "BSD-2-Clause-FreeBSD",
            Self::Bsd2ClauseNetBSD => "BSD-2-Clause-NetBSD",
            Self::Bsd2ClausePatent => "BSD-2-Clause-Patent",
            Self::Bsd3Clause => "BSD-3-Clause",
            Self::Bsd3ClauseAttribution => "BSD-3-Clause-Attribution",
            Self::Bsd3ClauseClear => "BSD-3-Clause-Clear",
            Self::Bsd3ClauseLBNL => "BSD-3-Clause-LBNL",
            Self::Bsd3ClauseNoNuclearLicense => "BSD-3-Clause-No-Nuclear-License",
            Self::Bsd3ClauseNoNuclearLicense2014 => {
                "BSD-3-Clause-No-Nuclear-License-2014"
            }
            Self::Bsd3ClauseNoNuclearWarranty => "BSD-3-Clause-No-Nuclear-Warranty",
            Self::Bsd4Clause => "BSD-4-Clause",
            Self::Bsd4ClauseUC => "BSD-4-Clause-UC",
            Self::BsdProtection => "BSD-Protection",
            Self::BsdSourceCode => "BSD-Source-Code",
            Self::Bsl10 => "BSL-1.0",
            Self::Bahyph => "Bahyph",
            Self::Barr => "Barr",
            Self::Beerware => "Beerware",
            Self::BitTorrent10 => "BitTorrent-1.0",
            Self::BitTorrent11 => "BitTorrent-1.1",
            Self::Borceux => "Borceux",
            Self::Catosl11 => "CATOSL-1.1",
            Self::CcBy10 => "CC-BY-1.0",
            Self::CcBy20 => "CC-BY-2.0",
            Self::CcBy25 => "CC-BY-2.5",
            Self::CcBy30 => "CC-BY-3.0",
            Self::CcBy40 => "CC-BY-4.0",
            Self::CcByNc10 => "CC-BY-NC-1.0",
            Self::CcByNc20 => "CC-BY-NC-2.0",
            Self::CcByNc25 => "CC-BY-NC-2.5",
            Self::CcByNc30 => "CC-BY-NC-3.0",
            Self::CcByNc40 => "CC-BY-NC-4.0",
            Self::CcByNcNd10 => "CC-BY-NC-ND-1.0",
            Self::CcByNcNd20 => "CC-BY-NC-ND-2.0",
            Self::CcByNcNd25 => "CC-BY-NC-ND-2.5",
            Self::CcByNcNd30 => "CC-BY-NC-ND-3.0",
            Self::CcByNcNd40 => "CC-BY-NC-ND-4.0",
            Self::CcByNcSa10 => "CC-BY-NC-SA-1.0",
            Self::CcByNcSa20 => "CC-BY-NC-SA-2.0",
            Self::CcByNcSa25 => "CC-BY-NC-SA-2.5",
            Self::CcByNcSa30 => "CC-BY-NC-SA-3.0",
            Self::CcByNcSa40 => "CC-BY-NC-SA-4.0",
            Self::CcByNd10 => "CC-BY-ND-1.0",
            Self::CcByNd20 => "CC-BY-ND-2.0",
            Self::CcByNd25 => "CC-BY-ND-2.5",
            Self::CcByNd30 => "CC-BY-ND-3.0",
            Self::CcByNd40 => "CC-BY-ND-4.0",
            Self::CcBySa10 => "CC-BY-SA-1.0",
            Self::CcBySa20 => "CC-BY-SA-2.0",
            Self::CcBySa25 => "CC-BY-SA-2.5",
            Self::CcBySa30 => "CC-BY-SA-3.0",
            Self::CcBySa40 => "CC-BY-SA-4.0",
            Self::Cc010 => "CC0-1.0",
            Self::Cddl10 => "CDDL-1.0",
            Self::Cddl11 => "CDDL-1.1",
            Self::CdlaPermissive10 => "CDLA-Permissive-1.0",
            Self::CdlaSharing10 => "CDLA-Sharing-1.0",
            Self::Cecill10 => "CECILL-1.0",
            Self::Cecill11 => "CECILL-1.1",
            Self::Cecill20 => "CECILL-2.0",
            Self::Cecill21 => "CECILL-2.1",
            Self::CecillB => "CECILL-B",
            Self::CecillC => "CECILL-C",
            Self::CnriJython => "CNRI-Jython",
            Self::CnriPython => "CNRI-Python",
            Self::CnriPythonGPLCompatible => "CNRI-Python-GPL-Compatible",
            Self::Cpal10 => "CPAL-1.0",
            Self::Cpl10 => "CPL-1.0",
            Self::Cpol102 => "CPOL-1.02",
            Self::CuaOpl10 => "CUA-OPL-1.0",
            Self::Caldera => "Caldera",
            Self::ClArtistic => "ClArtistic",
            Self::Condor11 => "Condor-1.1",
            Self::Crossword => "Crossword",
            Self::CrystalStacker => "CrystalStacker",
            Self::Cube => "Cube",
            Self::DFsl10 => "D-FSL-1.0",
            Self::Doc => "DOC",
            Self::Dsdp => "DSDP",
            Self::Dotseqn => "Dotseqn",
            Self::Ecl10 => "ECL-1.0",
            Self::Ecl20 => "ECL-2.0",
            Self::Efl10 => "EFL-1.0",
            Self::Efl20 => "EFL-2.0",
            Self::Epl10 => "EPL-1.0",
            Self::Epl20 => "EPL-2.0",
            Self::Eudatagrid => "EUDatagrid",
            Self::Eupl10 => "EUPL-1.0",
            Self::Eupl11 => "EUPL-1.1",
            Self::Eupl12 => "EUPL-1.2",
            Self::Entessa => "Entessa",
            Self::ErlPL11 => "ErlPL-1.1",
            Self::Eurosym => "Eurosym",
            Self::Fsfap => "FSFAP",
            Self::Fsful => "FSFUL",
            Self::Fsfullr => "FSFULLR",
            Self::Ftl => "FTL",
            Self::Fair => "Fair",
            Self::Frameworx10 => "Frameworx-1.0",
            Self::FreeImage => "FreeImage",
            Self::Gfdl11Only => "GFDL-1.1-only",
            Self::Gfdl11OrLater => "GFDL-1.1-or-later",
            Self::Gfdl12Only => "GFDL-1.2-only",
            Self::Gfdl12OrLater => "GFDL-1.2-or-later",
            Self::Gfdl13Only => "GFDL-1.3-only",
            Self::Gfdl13OrLater => "GFDL-1.3-or-later",
            Self::Gl2Ps => "GL2PS",
            Self::Gpl10Only => "GPL-1.0-only",
            Self::Gpl10OrLater => "GPL-1.0-or-later",
            Self::Gpl20Only => "GPL-2.0-only",
            Self::Gpl20OrLater => "GPL-2.0-or-later",
            Self::Gpl30Only => "GPL-3.0-only",
            Self::Gpl30OrLater => "GPL-3.0-or-later",
            Self::Giftware => "Giftware",
            Self::Glide => "Glide",
            Self::Glulxe => "Glulxe",
            Self::Hpnd => "HPND",
            Self::HaskellReport => "HaskellReport",
            Self::IbmPibs => "IBM-pibs",
            Self::Icu => "ICU",
            Self::Ijg => "IJG",
            Self::Ipa => "IPA",
            Self::Ipl10 => "IPL-1.0",
            Self::Isc => "ISC",
            Self::ImageMagick => "ImageMagick",
            Self::Imlib2 => "Imlib2",
            Self::InfoZIP => "Info-ZIP",
            Self::Intel => "Intel",
            Self::IntelACPI => "Intel-ACPI",
            Self::Interbase10 => "Interbase-1.0",
            Self::Json => "JSON",
            Self::JasPer20 => "JasPer-2.0",
            Self::Lal12 => "LAL-1.2",
            Self::Lal13 => "LAL-1.3",
            Self::Lgpl20Only => "LGPL-2.0-only",
            Self::Lgpl20OrLater => "LGPL-2.0-or-later",
            Self::Lgpl21Only => "LGPL-2.1-only",
            Self::Lgpl21OrLater => "LGPL-2.1-or-later",
            Self::Lgpl30Only => "LGPL-3.0-only",
            Self::Lgpl30OrLater => "LGPL-3.0-or-later",
            Self::Lgpllr => "LGPLLR",
            Self::Lpl10 => "LPL-1.0",
            Self::Lpl102 => "LPL-1.02",
            Self::Lppl10 => "LPPL-1.0",
            Self::Lppl11 => "LPPL-1.1",
            Self::Lppl12 => "LPPL-1.2",
            Self::Lppl13A => "LPPL-1.3a",
            Self::Lppl13C => "LPPL-1.3c",
            Self::Latex2E => "Latex2e",
            Self::Leptonica => "Leptonica",
            Self::LiLiQP11 => "LiLiQ-P-1.1",
            Self::LiLiQR11 => "LiLiQ-R-1.1",
            Self::LiLiQRplus11 => "LiLiQ-Rplus-1.1",
            Self::Libpng => "Libpng",
            Self::LinuxOpenIB => "Linux-OpenIB",
            Self::Mit => "MIT",
            Self::Mit0 => "MIT-0",
            Self::MitCmu => "MIT-CMU",
            Self::MitAdvertising => "MIT-advertising",
            Self::MitEnna => "MIT-enna",
            Self::MitFeh => "MIT-feh",
            Self::Mitnfa => "MITNFA",
            Self::Mpl10 => "MPL-1.0",
            Self::Mpl11 => "MPL-1.1",
            Self::Mpl20 => "MPL-2.0",
            Self::Mpl20NoCopyleftException => "MPL-2.0-no-copyleft-exception",
            Self::MsPl => "MS-PL",
            Self::MsRl => "MS-RL",
            Self::Mtll => "MTLL",
            Self::MakeIndex => "MakeIndex",
            Self::MirOS => "MirOS",
            Self::Motosoto => "Motosoto",
            Self::Multics => "Multics",
            Self::Mup => "Mup",
            Self::Nasa13 => "NASA-1.3",
            Self::Nbpl10 => "NBPL-1.0",
            Self::Ncsa => "NCSA",
            Self::Ngpl => "NGPL",
            Self::Nlod10 => "NLOD-1.0",
            Self::Nlpl => "NLPL",
            Self::Nosl => "NOSL",
            Self::Npl10 => "NPL-1.0",
            Self::Npl11 => "NPL-1.1",
            Self::Nposl30 => "NPOSL-3.0",
            Self::Nrl => "NRL",
            Self::Ntp => "NTP",
            Self::Naumen => "Naumen",
            Self::NetSNMP => "Net-SNMP",
            Self::NetCDF => "NetCDF",
            Self::Newsletr => "Newsletr",
            Self::Nokia => "Nokia",
            Self::Noweb => "Noweb",
            Self::OcctPl => "OCCT-PL",
            Self::Oclc20 => "OCLC-2.0",
            Self::OdbL10 => "ODbL-1.0",
            Self::Ofl10 => "OFL-1.0",
            Self::Ofl11 => "OFL-1.1",
            Self::Ogtsl => "OGTSL",
            Self::Oldap11 => "OLDAP-1.1",
            Self::Oldap12 => "OLDAP-1.2",
            Self::Oldap13 => "OLDAP-1.3",
            Self::Oldap14 => "OLDAP-1.4",
            Self::Oldap20 => "OLDAP-2.0",
            Self::Oldap201 => "OLDAP-2.0.1",
            Self::Oldap21 => "OLDAP-2.1",
            Self::Oldap22 => "OLDAP-2.2",
            Self::Oldap221 => "OLDAP-2.2.1",
            Self::Oldap222 => "OLDAP-2.2.2",
            Self::Oldap23 => "OLDAP-2.3",
            Self::Oldap24 => "OLDAP-2.4",
            Self::Oldap25 => "OLDAP-2.5",
            Self::Oldap26 => "OLDAP-2.6",
            Self::Oldap27 => "OLDAP-2.7",
            Self::Oldap28 => "OLDAP-2.8",
            Self::Oml => "OML",
            Self::Opl10 => "OPL-1.0",
            Self::OsetPl21 => "OSET-PL-2.1",
            Self::Osl10 => "OSL-1.0",
            Self::Osl11 => "OSL-1.1",
            Self::Osl20 => "OSL-2.0",
            Self::Osl21 => "OSL-2.1",
            Self::Osl30 => "OSL-3.0",
            Self::OpenSSL => "OpenSSL",
            Self::Pddl10 => "PDDL-1.0",
            Self::Php30 => "PHP-3.0",
            Self::Php301 => "PHP-3.01",
            Self::Plexus => "Plexus",
            Self::PostgreSQL => "PostgreSQL",
            Self::Python20 => "Python-2.0",
            Self::Qpl10 => "QPL-1.0",
            Self::Qhull => "Qhull",
            Self::RheCos11 => "RHeCos-1.1",
            Self::Rpl11 => "RPL-1.1",
            Self::Rpl15 => "RPL-1.5",
            Self::Rpsl10 => "RPSL-1.0",
            Self::RsaMd => "RSA-MD",
            Self::Rscpl => "RSCPL",
            Self::Rdisc => "Rdisc",
            Self::Ruby => "Ruby",
            Self::SaxPd => "SAX-PD",
            Self::Scea => "SCEA",
            Self::SgiB10 => "SGI-B-1.0",
            Self::SgiB11 => "SGI-B-1.1",
            Self::SgiB20 => "SGI-B-2.0",
            Self::Sissl => "SISSL",
            Self::Sissl12 => "SISSL-1.2",
            Self::Smlnj => "SMLNJ",
            Self::Smppl => "SMPPL",
            Self::Snia => "SNIA",
            Self::Spl10 => "SPL-1.0",
            Self::Swl => "SWL",
            Self::Saxpath => "Saxpath",
            Self::Sendmail => "Sendmail",
            Self::SimPL20 => "SimPL-2.0",
            Self::Sleepycat => "Sleepycat",
            Self::Spencer86 => "Spencer-86",
            Self::Spencer94 => "Spencer-94",
            Self::Spencer99 => "Spencer-99",
            Self::SugarCRM113 => "SugarCRM-1.1.3",
            Self::Tcl => "TCL",
            Self::TcpWrappers => "TCP-wrappers",
            Self::Tmate => "TMate",
            Self::Torque11 => "TORQUE-1.1",
            Self::Tosl => "TOSL",
            Self::Upl10 => "UPL-1.0",
            Self::UnicodeDFS2015 => "Unicode-DFS-2015",
            Self::UnicodeDFS2016 => "Unicode-DFS-2016",
            Self::UnicodeTOU => "Unicode-TOU",
            Self::Unlicense => "Unlicense",
            Self::Vostrom => "VOSTROM",
            Self::Vsl10 => "VSL-1.0",
            Self::Vim => "Vim",
            Self::W3C => "W3C",
            Self::W3C19980720 => "W3C-19980720",
            Self::W3C20150513 => "W3C-20150513",
            Self::Wtfpl => "WTFPL",
            Self::Watcom10 => "Watcom-1.0",
            Self::Wsuipa => "Wsuipa",
            Self::X11 => "X11",
            Self::Xfree8611 => "XFree86-1.1",
            Self::Xskat => "XSkat",
            Self::Xerox => "Xerox",
            Self::Xnet => "Xnet",
            Self::Ypl10 => "YPL-1.0",
            Self::Ypl11 => "YPL-1.1",
            Self::Zpl11 => "ZPL-1.1",
            Self::Zpl20 => "ZPL-2.0",
            Self::Zpl21 => "ZPL-2.1",
            Self::Zed => "Zed",
            Self::Zend20 => "Zend-2.0",
            Self::Zimbra13 => "Zimbra-1.3",
            Self::Zimbra14 => "Zimbra-1.4",
            Self::Zlib => "Zlib",
            Self::Bzip2105 => "bzip2-1.0.5",
            Self::Bzip2106 => "bzip2-1.0.6",
            Self::Curl => "curl",
            Self::Diffmark => "diffmark",
            Self::Dvipdfm => "dvipdfm",
            Self::Egenix => "eGenix",
            Self::Gsoap13B => "gSOAP-1.3b",
            Self::Gnuplot => "gnuplot",
            Self::Imatix => "iMatix",
            Self::Libtiff => "libtiff",
            Self::Mpich2 => "mpich2",
            Self::NotOpenSource => "not-open-source",
            Self::Psfrag => "psfrag",
            Self::Psutils => "psutils",
            Self::Xinetd => "xinetd",
            Self::Xpp => "xpp",
            Self::ZlibAcknowledgement => "zlib-acknowledgement",
        }
    }
}
impl ::std::fmt::Debug for SPDXLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SPDXLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SPDXLicense {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SPDXLicense {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SPDXLicense> for Coding {
    fn from(code: SPDXLicense) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/spdx-license".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SPDXLicense> for CodeableConcept {
    fn from(code: SPDXLicense) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SearchComparator](http://hl7.org/fhir/ValueSet/search-comparator)**. What Search Comparator Codes are supported in search.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SearchComparator {
    /** **ap**

Approximately. the value for the parameter in the resource is approximately the same to the provided value. */
    Ap,
    /** **eb**

Ends Before. the value for the parameter in the resource ends before the provided value. */
    Eb,
    /** **eq**

Equals. the value for the parameter in the resource is equal to the provided value. */
    Eq,
    /** **ge**

Greater or Equals. the value for the parameter in the resource is greater or equal to the provided value. */
    Ge,
    /** **gt**

Greater Than. the value for the parameter in the resource is greater than the provided value. */
    Gt,
    /** **le**

Less of Equal. the value for the parameter in the resource is less or equal to the provided value. */
    Le,
    /** **lt**

Less Than. the value for the parameter in the resource is less than the provided value. */
    Lt,
    /** **ne**

Not Equals. the value for the parameter in the resource is not equal to the provided value. */
    Ne,
    /** **sa**

Starts After. the value for the parameter in the resource starts after the provided value. */
    Sa,
}
impl ::core::str::FromStr for SearchComparator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ap" => Ok(Self::Ap),
            "eb" => Ok(Self::Eb),
            "eq" => Ok(Self::Eq),
            "ge" => Ok(Self::Ge),
            "gt" => Ok(Self::Gt),
            "le" => Ok(Self::Le),
            "lt" => Ok(Self::Lt),
            "ne" => Ok(Self::Ne),
            "sa" => Ok(Self::Sa),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchComparator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ap => "ap",
            Self::Eb => "eb",
            Self::Eq => "eq",
            Self::Ge => "ge",
            Self::Gt => "gt",
            Self::Le => "le",
            Self::Lt => "lt",
            Self::Ne => "ne",
            Self::Sa => "sa",
        }
    }
}
impl ::std::fmt::Debug for SearchComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SearchComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SearchComparator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchComparator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchComparator> for Coding {
    fn from(code: SearchComparator) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-comparator".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SearchComparator> for CodeableConcept {
    fn from(code: SearchComparator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SearchEntryMode](http://hl7.org/fhir/ValueSet/search-entry-mode)**. Why an entry is in the result set - whether it's included as a match or because of an _include requirement, or to convey information or warning information about the search process.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SearchEntryMode {
    /** **include**

Include. This resource is returned because it is referred to from another resource in the search set. */
    Include,
    /** **match**

Match. This resource matched the search specification. */
    Match,
    /** **outcome**

Outcome. An OperationOutcome that provides additional information about the processing of a search. */
    Outcome,
}
impl ::core::str::FromStr for SearchEntryMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "include" => Ok(Self::Include),
            "match" => Ok(Self::Match),
            "outcome" => Ok(Self::Outcome),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchEntryMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Include => "include",
            Self::Match => "match",
            Self::Outcome => "outcome",
        }
    }
}
impl ::std::fmt::Debug for SearchEntryMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SearchEntryMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SearchEntryMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchEntryMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchEntryMode> for Coding {
    fn from(code: SearchEntryMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-entry-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SearchEntryMode> for CodeableConcept {
    fn from(code: SearchEntryMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SearchModifierCode](http://hl7.org/fhir/ValueSet/search-modifier-code)**. A supported modifier for a search parameter.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SearchModifierCode {
    /** **above**

Above. The search parameter tests whether the value in a resource subsumes the specified value (is-a, or hierarchical relationships). */
    Above,
    /** **below**

Below. The search parameter tests whether the value in a resource is subsumed by the specified value (is-a, or hierarchical relationships). */
    Below,
    /** **contains**

Contains. The search parameter returns resources that include the supplied parameter value anywhere within the field being searched. */
    Contains,
    /** **exact**

Exact. The search parameter returns resources that have a value that exactly matches the supplied parameter (the whole string, including casing and accents). */
    Exact,
    /** **identifier**

Identifier. The search parameter applies to the identifier on the resource, not the reference. */
    Identifier,
    /** **in**

In. The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is in the specified value set. */
    In,
    /** **missing**

Missing. The search parameter returns resources that have a value or not. */
    Missing,
    /** **not**

Not. The search parameter returns resources that do not contain a match. */
    Not,
    /** **not-in**

Not In. The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is not in the specified value set. */
    NotIn,
    /** **ofType**

Of Type. The search parameter has the format system|code|value, where the system and code refer to an Identifier.type.coding.system and .code, and match if any of the type codes match. All 3 parts must be present. */
    OfType,
    /** **text**

Text. The search parameter is processed as a string that searches text associated with the code/value - either CodeableConcept.text, Coding.display, or Identifier.type.text. */
    Text,
    /** **type**

Type. The search parameter only applies to the Resource Type specified as a modifier (e.g. the modifier is not actually :type, but :Patient etc.). */
    Type,
}
impl ::core::str::FromStr for SearchModifierCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "above" => Ok(Self::Above),
            "below" => Ok(Self::Below),
            "contains" => Ok(Self::Contains),
            "exact" => Ok(Self::Exact),
            "identifier" => Ok(Self::Identifier),
            "in" => Ok(Self::In),
            "missing" => Ok(Self::Missing),
            "not" => Ok(Self::Not),
            "not-in" => Ok(Self::NotIn),
            "ofType" => Ok(Self::OfType),
            "text" => Ok(Self::Text),
            "type" => Ok(Self::Type),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchModifierCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Above => "above",
            Self::Below => "below",
            Self::Contains => "contains",
            Self::Exact => "exact",
            Self::Identifier => "identifier",
            Self::In => "in",
            Self::Missing => "missing",
            Self::Not => "not",
            Self::NotIn => "not-in",
            Self::OfType => "ofType",
            Self::Text => "text",
            Self::Type => "type",
        }
    }
}
impl ::std::fmt::Debug for SearchModifierCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SearchModifierCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SearchModifierCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchModifierCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchModifierCode> for Coding {
    fn from(code: SearchModifierCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-modifier-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SearchModifierCode> for CodeableConcept {
    fn from(code: SearchModifierCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SearchParamType](http://hl7.org/fhir/ValueSet/search-param-type)**. Data types allowed to be used for search parameters.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SearchParamType {
    /** **composite**

Composite. A composite search parameter that combines a search on two values together. */
    Composite,
    /** **date**

Date/DateTime. Search parameter is on a date/time. The date format is the standard XML format, though other formats may be supported. */
    Date,
    /** **number**

Number. Search parameter SHALL be a number (a whole number, or a decimal). */
    Number,
    /** **quantity**

Quantity. A search parameter that searches on a quantity. */
    Quantity,
    /** **reference**

Reference. A reference to another resource (Reference or canonical). */
    Reference,
    /** **special**

Special. Special logic applies to this parameter per the description of the search parameter. */
    Special,
    /** **string**

String. Search parameter is a simple string, like a name part. Search is case-insensitive and accent-insensitive. May match just the start of a string. String parameters may contain spaces. */
    String,
    /** **token**

Token. Search parameter on a coded element or identifier. May be used to search through the text, display, code and code/codesystem (for codes) and label, system and key (for identifier). Its value is either a string or a pair of namespace and value, separated by a "|", depending on the modifier used. */
    Token,
    /** **uri**

URI. A search parameter that searches on a URI (RFC 3986). */
    Uri,
}
impl ::core::str::FromStr for SearchParamType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "composite" => Ok(Self::Composite),
            "date" => Ok(Self::Date),
            "number" => Ok(Self::Number),
            "quantity" => Ok(Self::Quantity),
            "reference" => Ok(Self::Reference),
            "special" => Ok(Self::Special),
            "string" => Ok(Self::String),
            "token" => Ok(Self::Token),
            "uri" => Ok(Self::Uri),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchParamType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Composite => "composite",
            Self::Date => "date",
            Self::Number => "number",
            Self::Quantity => "quantity",
            Self::Reference => "reference",
            Self::Special => "special",
            Self::String => "string",
            Self::Token => "token",
            Self::Uri => "uri",
        }
    }
}
impl ::std::fmt::Debug for SearchParamType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SearchParamType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SearchParamType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchParamType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchParamType> for Coding {
    fn from(code: SearchParamType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-param-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SearchParamType> for CodeableConcept {
    fn from(code: SearchParamType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SecurityRoleType](http://terminology.hl7.org/CodeSystem/extra-security-role-type)**. This CodeSystem contains Additional FHIR-defined Security Role types not defined elsewhere\n\nFHIR version: 4.3.0-cibuild."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum SecurityRoleType {
    /** **authserver**

authorization server. An entity providing authorization services to enable the electronic sharing of health-related information based on resource owner's preapproved permissions. For example, an UMA Authorization Server[UMA] */
    Authserver,
    /** **datacollector**

data collector. An entity that collects information over which the data subject may have certain rights under policy or law to control that information's management and distribution by data collectors, including the right to access, retrieve, distribute, or delete that information. */
    Datacollector,
    /** **dataprocessor**

data processor. An entity that processes collected information over which the data subject may have certain rights under policy or law to control that information's management and distribution by data processors, including the right to access, retrieve, distribute, or delete that information. */
    Dataprocessor,
    /** **datasubject**

data subject. A person whose personal information is collected or processed, and who may have certain rights under policy or law to control that information's management and distribution by data collectors or processors, including the right to access, retrieve, distribute, or delete that information. */
    Datasubject,
    /** **humanuser**

human user. The human user that has participated. */
    Humanuser,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SecurityRoleType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "authserver" => Ok(Self::Authserver),
            "datacollector" => Ok(Self::Datacollector),
            "dataprocessor" => Ok(Self::Dataprocessor),
            "datasubject" => Ok(Self::Datasubject),
            "humanuser" => Ok(Self::Humanuser),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SecurityRoleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Authserver => "authserver",
            Self::Datacollector => "datacollector",
            Self::Dataprocessor => "dataprocessor",
            Self::Datasubject => "datasubject",
            Self::Humanuser => "humanuser",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for SecurityRoleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SecurityRoleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SecurityRoleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SecurityRoleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SecurityRoleType> for Coding {
    fn from(code: SecurityRoleType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/extra-security-role-type"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SecurityRoleType> for CodeableConcept {
    fn from(code: SecurityRoleType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[ServiceProvisionConditions](http://hl7.org/fhir/ValueSet/service-provision-conditions)**. The code(s) that detail the conditions under which the healthcare service is available/offered.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum ServiceProvisionConditions {
    /** **cost**

Fees apply. Fees apply for this service. */
    Cost,
    /** **disc**

Discounts Available. There are discounts available on this service for qualifying patients. */
    Disc,
    /** **free**

Free. This service is available for no patient cost. */
    Free,
}
impl ::core::str::FromStr for ServiceProvisionConditions {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cost" => Ok(Self::Cost),
            "disc" => Ok(Self::Disc),
            "free" => Ok(Self::Free),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ServiceProvisionConditions {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cost => "cost",
            Self::Disc => "disc",
            Self::Free => "free",
        }
    }
}
impl ::std::fmt::Debug for ServiceProvisionConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for ServiceProvisionConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for ServiceProvisionConditions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ServiceProvisionConditions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ServiceProvisionConditions> for Coding {
    fn from(code: ServiceProvisionConditions) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/service-provision-conditions".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<ServiceProvisionConditions> for CodeableConcept {
    fn from(code: ServiceProvisionConditions) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SignatureTypeCodes](http://hl7.org/fhir/ValueSet/signature-type)**. The Digital Signature Purposes, an indication of the reason an entity signs a document. This is included in the signed information and can be used when determining accountability for various actions concerning the document. Examples include: author, transcriptionist/recorder, and witness.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SignatureTypeCodes {
    /** **1.2.840.10065.1.12.1.1**

Author's Signature. the signature of the primary or sole author of a health information document. There can be only one primary author of a health information document. */
    N128401006511211,
    /** **1.2.840.10065.1.12.1.10**

Identity Witness Signature. the signature of an individual who has witnessed another individual who is known to them signing a document. (Example the identity witness is a notary public.) */
    N1284010065112110,
    /** **1.2.840.10065.1.12.1.11**

Consent Witness Signature. the signature of an individual who has witnessed the health care provider counselling a patient. */
    N1284010065112111,
    /** **1.2.840.10065.1.12.1.12**

Interpreter Signature. the signature of an individual who has translated health care information during an event or the obtaining of consent to a treatment. */
    N1284010065112112,
    /** **1.2.840.10065.1.12.1.13**

Review Signature. the signature of a person, device, or algorithm that has reviewed or filtered data for inclusion into the patient record. ( Examples: (1) a medical records clerk who scans a document for inclusion in the medical record, enters header information, or catalogues and classifies the data, or a combination thereof; (2) a gateway that receives data from another computer system and interprets that data or changes its format, or both, before entering it into the patient record.) */
    N1284010065112113,
    /** **1.2.840.10065.1.12.1.14**

Source Signature. the signature of an automated data source. (Examples: (1) the signature for an image that is generated by a device for inclusion in the patient record; (2) the signature for an ECG derived by an ECG system for inclusion in the patient record; (3) the data from a biomedical monitoring device or system that is for inclusion in the patient record.) */
    N1284010065112114,
    /** **1.2.840.10065.1.12.1.15**

Addendum Signature. the signature on a new amended document of an individual who has corrected, edited, or amended an original health information document. An addendum signature can either be a signature type or a signature sub-type (see 8.1). Any document with an addendum signature shall have a companion document that is the original document with its original, unaltered content, and original signatures. The original document shall be referenced via an attribute in the new document, which contains, for example, the digest of the old document. Whether the original, unaltered, document is always displayed with the addended document is a local matter, but the original, unaltered, document must remain as part of the patient record and be retrievable on demand. */
    N1284010065112115,
    /** **1.2.840.10065.1.12.1.16**

Modification Signature. the signature on an original document of an individual who has generated a new amended document. This (original) document shall reference the new document via an additional signature purpose. This is the inverse of an addendum signature and provides a pointer from the original to the amended document. */
    N1284010065112116,
    /** **1.2.840.10065.1.12.1.17**

Administrative (Error/Edit) Signature. the signature of an individual who is certifying that the document is invalidated by an error(s), or is placed in the wrong chart. An administrative (error/edit) signature must include an addendum to the document and therefore shall have an addendum signature sub-type (see 8.1). This signature is reserved for the highest health information system administrative classification, since it is a statement that the entire document is invalidated by the error and that the document should no longer be used for patient care, although for legal reasons the document must remain part of the permanent patient record. */
    N1284010065112117,
    /** **1.2.840.10065.1.12.1.18**

Timestamp Signature. the signature by an entity or device trusted to provide accurate timestamps. This timestamp might be provided, for example, in the signature time attribute. */
    N1284010065112118,
    /** **1.2.840.10065.1.12.1.2**

Coauthor's Signature. the signature of a health information document coauthor. There can be multiple coauthors of a health information document. */
    N128401006511212,
    /** **1.2.840.10065.1.12.1.3**

Co-participant's Signature. the signature of an individual who is a participant in the health information document but is not an author or coauthor. (Example a surgeon who is required by institutional, regulatory, or legal rules to sign an operative report, but who was not involved in the authorship of that report.) */
    N128401006511213,
    /** **1.2.840.10065.1.12.1.4**

Transcriptionist/Recorder Signature. the signature of an individual who has transcribed a dictated document or recorded written text into a digital machine readable format. */
    N128401006511214,
    /** **1.2.840.10065.1.12.1.5**

Verification Signature. a signature verifying the information contained in a document. (Example a physician is required to countersign a verbal order that has previously been recorded in the medical record by a registered nurse who has carried out the verbal order.) */
    N128401006511215,
    /** **1.2.840.10065.1.12.1.6**

Validation Signature. a signature validating a health information document for inclusion in the patient record. (Example a medical student or resident is credentialed to perform history or physical examinations and to write progress notes. The attending physician signs the history and physical examination to validate the entry for inclusion in the patient's medical record.) */
    N128401006511216,
    /** **1.2.840.10065.1.12.1.7**

Consent Signature. the signature of an individual consenting to what is described in a health information document. */
    N128401006511217,
    /** **1.2.840.10065.1.12.1.8**

Signature Witness Signature. the signature of a witness to any other signature. */
    N128401006511218,
    /** **1.2.840.10065.1.12.1.9**

Event Witness Signature. the signature of a witness to an event. (Example the witness has observed a procedure and is attesting to this fact.) */
    N128401006511219,
}
impl ::core::str::FromStr for SignatureTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1.2.840.10065.1.12.1.1" => Ok(Self::N128401006511211),
            "1.2.840.10065.1.12.1.10" => Ok(Self::N1284010065112110),
            "1.2.840.10065.1.12.1.11" => Ok(Self::N1284010065112111),
            "1.2.840.10065.1.12.1.12" => Ok(Self::N1284010065112112),
            "1.2.840.10065.1.12.1.13" => Ok(Self::N1284010065112113),
            "1.2.840.10065.1.12.1.14" => Ok(Self::N1284010065112114),
            "1.2.840.10065.1.12.1.15" => Ok(Self::N1284010065112115),
            "1.2.840.10065.1.12.1.16" => Ok(Self::N1284010065112116),
            "1.2.840.10065.1.12.1.17" => Ok(Self::N1284010065112117),
            "1.2.840.10065.1.12.1.18" => Ok(Self::N1284010065112118),
            "1.2.840.10065.1.12.1.2" => Ok(Self::N128401006511212),
            "1.2.840.10065.1.12.1.3" => Ok(Self::N128401006511213),
            "1.2.840.10065.1.12.1.4" => Ok(Self::N128401006511214),
            "1.2.840.10065.1.12.1.5" => Ok(Self::N128401006511215),
            "1.2.840.10065.1.12.1.6" => Ok(Self::N128401006511216),
            "1.2.840.10065.1.12.1.7" => Ok(Self::N128401006511217),
            "1.2.840.10065.1.12.1.8" => Ok(Self::N128401006511218),
            "1.2.840.10065.1.12.1.9" => Ok(Self::N128401006511219),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SignatureTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N128401006511211 => "1.2.840.10065.1.12.1.1",
            Self::N1284010065112110 => "1.2.840.10065.1.12.1.10",
            Self::N1284010065112111 => "1.2.840.10065.1.12.1.11",
            Self::N1284010065112112 => "1.2.840.10065.1.12.1.12",
            Self::N1284010065112113 => "1.2.840.10065.1.12.1.13",
            Self::N1284010065112114 => "1.2.840.10065.1.12.1.14",
            Self::N1284010065112115 => "1.2.840.10065.1.12.1.15",
            Self::N1284010065112116 => "1.2.840.10065.1.12.1.16",
            Self::N1284010065112117 => "1.2.840.10065.1.12.1.17",
            Self::N1284010065112118 => "1.2.840.10065.1.12.1.18",
            Self::N128401006511212 => "1.2.840.10065.1.12.1.2",
            Self::N128401006511213 => "1.2.840.10065.1.12.1.3",
            Self::N128401006511214 => "1.2.840.10065.1.12.1.4",
            Self::N128401006511215 => "1.2.840.10065.1.12.1.5",
            Self::N128401006511216 => "1.2.840.10065.1.12.1.6",
            Self::N128401006511217 => "1.2.840.10065.1.12.1.7",
            Self::N128401006511218 => "1.2.840.10065.1.12.1.8",
            Self::N128401006511219 => "1.2.840.10065.1.12.1.9",
        }
    }
}
impl ::std::fmt::Debug for SignatureTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SignatureTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SignatureTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SignatureTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SignatureTypeCodes> for Coding {
    fn from(code: SignatureTypeCodes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/signature-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SignatureTypeCodes> for CodeableConcept {
    fn from(code: SignatureTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SlicingRules](http://hl7.org/fhir/ValueSet/resource-slicing-rules)**. How slices are interpreted when evaluating an instance.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SlicingRules {
    /** **closed**

Closed. No additional content is allowed other than that described by the slices in this profile. */
    Closed,
    /** **open**

Open. Additional content is allowed anywhere in the list. */
    Open,
    /** **openAtEnd**

Open at End. Additional content is allowed, but only at the end of the list. Note that using this requires that the slices be ordered, which makes it hard to share uses. This should only be done where absolutely required. */
    OpenAtEnd,
}
impl ::core::str::FromStr for SlicingRules {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "closed" => Ok(Self::Closed),
            "open" => Ok(Self::Open),
            "openAtEnd" => Ok(Self::OpenAtEnd),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SlicingRules {
    fn as_ref(&self) -> &str {
        match self {
            Self::Closed => "closed",
            Self::Open => "open",
            Self::OpenAtEnd => "openAtEnd",
        }
    }
}
impl ::std::fmt::Debug for SlicingRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SlicingRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SlicingRules {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SlicingRules {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SlicingRules> for Coding {
    fn from(code: SlicingRules) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/resource-slicing-rules".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SlicingRules> for CodeableConcept {
    fn from(code: SlicingRules) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SlotStatus](http://hl7.org/fhir/ValueSet/slotstatus)**. The free/busy status of the slot.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SlotStatus {
    /** **busy**

Busy. Indicates that the time interval is busy because one  or more events have been scheduled for that interval. */
    Busy,
    /** **busy-tentative**

Busy (Tentative). Indicates that the time interval is busy because one or more events have been tentatively scheduled for that interval. */
    BusyTentative,
    /** **busy-unavailable**

Busy (Unavailable). Indicates that the time interval is busy and that the interval cannot be scheduled. */
    BusyUnavailable,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **free**

Free. Indicates that the time interval is free for scheduling. */
    Free,
}
impl ::core::str::FromStr for SlotStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "busy" => Ok(Self::Busy),
            "busy-tentative" => Ok(Self::BusyTentative),
            "busy-unavailable" => Ok(Self::BusyUnavailable),
            "entered-in-error" => Ok(Self::EnteredInError),
            "free" => Ok(Self::Free),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SlotStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Busy => "busy",
            Self::BusyTentative => "busy-tentative",
            Self::BusyUnavailable => "busy-unavailable",
            Self::EnteredInError => "entered-in-error",
            Self::Free => "free",
        }
    }
}
impl ::std::fmt::Debug for SlotStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SlotStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SlotStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SlotStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SlotStatus> for Coding {
    fn from(code: SlotStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/slotstatus".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SlotStatus> for CodeableConcept {
    fn from(code: SlotStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SmartCapabilities](http://hl7.org/fhir/ValueSet/smart-capabilities)**. Codes that define what the server is capable of.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SmartCapabilities {
    /** **client-confidential-symmetric**

Confidential Client Profile. support for SMART’s confidential client profile (symmetric client secret authentication). */
    ClientConfidentialSymmetric,
    /** **client-public**

Public Client Profile. support for SMART’s public client profile (no client authentication). */
    ClientPublic,
    /** **context-ehr-encounter**

Allows "Encounter Level Launch Context (EHR)". support for encounter-level launch context (requested by launch/encounter scope, conveyed via encounter token parameter). */
    ContextEhrEncounter,
    /** **context-ehr-patient**

Allows "Patient Level Launch Context (EHR)". support for patient-level launch context (requested by launch/patient scope, conveyed via patient token parameter). */
    ContextEhrPatient,
    /** **context-passthrough-banner**

Allows "Need Patient Banner". support for “need patient banner” launch context (conveyed via need_patient_banner token parameter). */
    ContextPassthroughBanner,
    /** **context-passthrough-style**

Allows "Smart Style Style". support for “SMART style URL” launch context (conveyed via smart_style_url token parameter). */
    ContextPassthroughStyle,
    /** **context-standalone-encounter**

Allows "Encounter Level Launch Context (STANDALONE)". support for encounter-level launch context (requested by launch/encounter scope, conveyed via encounter token parameter). */
    ContextStandaloneEncounter,
    /** **context-standalone-patient**

Allows "Patient Level Launch Context (STANDALONE)". support for patient-level launch context (requested by launch/patient scope, conveyed via patient token parameter). */
    ContextStandalonePatient,
    /** **launch-ehr**

EHR Launch Mode. support for SMART’s EHR Launch mode. */
    LaunchEhr,
    /** **launch-standalone**

Standalone Launch Mode. support for SMART’s Standalone Launch mode. */
    LaunchStandalone,
    /** **permission-offline**

Supports Refresh Token. support for refresh tokens (requested by offline_access scope). */
    PermissionOffline,
    /** **permission-patient**

Supports Patient Level Scopes. support for patient-level scopes (e.g. patient/Observation.read). */
    PermissionPatient,
    /** **permission-user**

Supports User Level Scopes. support for user-level scopes (e.g. user/Appointment.read). */
    PermissionUser,
    /** **sso-openid-connect**

Supports OpenID Connect. support for SMART’s OpenID Connect profile. */
    SsoOpenidConnect,
}
impl ::core::str::FromStr for SmartCapabilities {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client-confidential-symmetric" => Ok(Self::ClientConfidentialSymmetric),
            "client-public" => Ok(Self::ClientPublic),
            "context-ehr-encounter" => Ok(Self::ContextEhrEncounter),
            "context-ehr-patient" => Ok(Self::ContextEhrPatient),
            "context-passthrough-banner" => Ok(Self::ContextPassthroughBanner),
            "context-passthrough-style" => Ok(Self::ContextPassthroughStyle),
            "context-standalone-encounter" => Ok(Self::ContextStandaloneEncounter),
            "context-standalone-patient" => Ok(Self::ContextStandalonePatient),
            "launch-ehr" => Ok(Self::LaunchEhr),
            "launch-standalone" => Ok(Self::LaunchStandalone),
            "permission-offline" => Ok(Self::PermissionOffline),
            "permission-patient" => Ok(Self::PermissionPatient),
            "permission-user" => Ok(Self::PermissionUser),
            "sso-openid-connect" => Ok(Self::SsoOpenidConnect),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SmartCapabilities {
    fn as_ref(&self) -> &str {
        match self {
            Self::ClientConfidentialSymmetric => "client-confidential-symmetric",
            Self::ClientPublic => "client-public",
            Self::ContextEhrEncounter => "context-ehr-encounter",
            Self::ContextEhrPatient => "context-ehr-patient",
            Self::ContextPassthroughBanner => "context-passthrough-banner",
            Self::ContextPassthroughStyle => "context-passthrough-style",
            Self::ContextStandaloneEncounter => "context-standalone-encounter",
            Self::ContextStandalonePatient => "context-standalone-patient",
            Self::LaunchEhr => "launch-ehr",
            Self::LaunchStandalone => "launch-standalone",
            Self::PermissionOffline => "permission-offline",
            Self::PermissionPatient => "permission-patient",
            Self::PermissionUser => "permission-user",
            Self::SsoOpenidConnect => "sso-openid-connect",
        }
    }
}
impl ::std::fmt::Debug for SmartCapabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SmartCapabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SmartCapabilities {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SmartCapabilities {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SmartCapabilities> for Coding {
    fn from(code: SmartCapabilities) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/smart-capabilities".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SmartCapabilities> for CodeableConcept {
    fn from(code: SmartCapabilities) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SortDirection](http://hl7.org/fhir/ValueSet/sort-direction)**. The possible sort directions, ascending or descending.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SortDirection {
    /** **ascending**

Ascending. Sort by the value ascending, so that lower values appear first. */
    Ascending,
    /** **descending**

Descending. Sort by the value descending, so that lower values appear last. */
    Descending,
}
impl ::core::str::FromStr for SortDirection {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ascending" => Ok(Self::Ascending),
            "descending" => Ok(Self::Descending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SortDirection {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ascending => "ascending",
            Self::Descending => "descending",
        }
    }
}
impl ::std::fmt::Debug for SortDirection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SortDirection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SortDirection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SortDirection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SortDirection> for Coding {
    fn from(code: SortDirection) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/sort-direction".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SortDirection> for CodeableConcept {
    fn from(code: SortDirection) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SpecialArrangements](http://terminology.hl7.org/CodeSystem/encounter-special-arrangements)**. This codesystem defines a set of codes that can be used to indicate the kinds of special arrangements in place for a patient's visit.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum SpecialArrangements {
    /** **add-bed**

Additional bedding. An additional bed made available for a person accompanying the patient, for example a parent accompanying a child. */
    AddBed,
    /** **att**

Attendant. A person who accompanies a patient to provide assistive services necessary for the patient's care during the encounter. */
    Att,
    /** **dog**

Guide dog. The patient has a guide dog and the location used for the encounter should be able to support the presence of the service animal. */
    Dog,
    /** **int**

Interpreter. The patient is not fluent in the local language and requires an interpreter to be available. Refer to the Patient.Language property for the type of interpreter required. */
    Int,
    /** **wheel**

Wheelchair. The patient requires a wheelchair to be made available for the encounter. */
    Wheel,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SpecialArrangements {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "add-bed" => Ok(Self::AddBed),
            "att" => Ok(Self::Att),
            "dog" => Ok(Self::Dog),
            "int" => Ok(Self::Int),
            "wheel" => Ok(Self::Wheel),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SpecialArrangements {
    fn as_ref(&self) -> &str {
        match self {
            Self::AddBed => "add-bed",
            Self::Att => "att",
            Self::Dog => "dog",
            Self::Int => "int",
            Self::Wheel => "wheel",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for SpecialArrangements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SpecialArrangements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SpecialArrangements {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecialArrangements {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecialArrangements> for Coding {
    fn from(code: SpecialArrangements) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/encounter-special-arrangements"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SpecialArrangements> for CodeableConcept {
    fn from(code: SpecialArrangements) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SpecialMeasures](http://hl7.org/fhir/ValueSet/medicinal-product-special-measures)**. Extra measures defined for a Medicinal Product, such as requirement to conduct post-authorisation studies.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SpecialMeasures {
    /** **Post-authorisationStudies**

Requirement to conduct post-authorisation studies. Requirement to conduct post-authorisation studies */
    PostAuthorisationStudies,
}
impl ::core::str::FromStr for SpecialMeasures {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Post-authorisationStudies" => Ok(Self::PostAuthorisationStudies),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecialMeasures {
    fn as_ref(&self) -> &str {
        match self {
            Self::PostAuthorisationStudies => "Post-authorisationStudies",
        }
    }
}
impl ::std::fmt::Debug for SpecialMeasures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SpecialMeasures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SpecialMeasures {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecialMeasures {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecialMeasures> for Coding {
    fn from(code: SpecialMeasures) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/medicinal-product-special-measures"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SpecialMeasures> for CodeableConcept {
    fn from(code: SpecialMeasures) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SpecialValues](http://hl7.org/fhir/ValueSet/special-values)**. A set of generally useful codes defined so they can be included in value sets.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SpecialValues {
    /** **false**

false. Boolean false. */
    False,
    /** **nil-known**

Nil Known. The are no known applicable values in this context. */
    NilKnown,
    /** **sufficient**

Sufficient Quantity. The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material. */
    Sufficient,
    /** **trace**

Trace Amount Detected. The content is greater than zero, but too small to be quantified. */
    Trace,
    /** **true**

true. Boolean true. */
    True,
    /** **withdrawn**

Value Withdrawn. The value is no longer available. */
    Withdrawn,
}
impl ::core::str::FromStr for SpecialValues {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "false" => Ok(Self::False),
            "nil-known" => Ok(Self::NilKnown),
            "sufficient" => Ok(Self::Sufficient),
            "trace" => Ok(Self::Trace),
            "true" => Ok(Self::True),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecialValues {
    fn as_ref(&self) -> &str {
        match self {
            Self::False => "false",
            Self::NilKnown => "nil-known",
            Self::Sufficient => "sufficient",
            Self::Trace => "trace",
            Self::True => "true",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Debug for SpecialValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SpecialValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SpecialValues {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecialValues {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecialValues> for Coding {
    fn from(code: SpecialValues) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/special-values".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SpecialValues> for CodeableConcept {
    fn from(code: SpecialValues) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SpecimenContainedPreference](http://hl7.org/fhir/ValueSet/specimen-contained-preference)**. Degree of preference of a type of conditioned specimen.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SpecimenContainedPreference {
    /** **alternate**

Alternate. This type of conditioned specimen is an alternate. */
    Alternate,
    /** **preferred**

Preferred. This type of contained specimen is preferred to collect this kind of specimen. */
    Preferred,
}
impl ::core::str::FromStr for SpecimenContainedPreference {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alternate" => Ok(Self::Alternate),
            "preferred" => Ok(Self::Preferred),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecimenContainedPreference {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alternate => "alternate",
            Self::Preferred => "preferred",
        }
    }
}
impl ::std::fmt::Debug for SpecimenContainedPreference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SpecimenContainedPreference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SpecimenContainedPreference {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecimenContainedPreference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecimenContainedPreference> for Coding {
    fn from(code: SpecimenContainedPreference) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/specimen-contained-preference".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SpecimenContainedPreference> for CodeableConcept {
    fn from(code: SpecimenContainedPreference) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SpecimenStatus](http://hl7.org/fhir/ValueSet/specimen-status)**. Codes providing the status/availability of a specimen.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SpecimenStatus {
    /** **available**

Available. The physical specimen is present and in good condition. */
    Available,
    /** **entered-in-error**

Entered in Error. The specimen was entered in error and therefore nullified. */
    EnteredInError,
    /** **unavailable**

Unavailable. There is no physical specimen because it is either lost, destroyed or consumed. */
    Unavailable,
    /** **unsatisfactory**

Unsatisfactory. The specimen cannot be used because of a quality issue such as a broken container, contamination, or too old. */
    Unsatisfactory,
}
impl ::core::str::FromStr for SpecimenStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "entered-in-error" => Ok(Self::EnteredInError),
            "unavailable" => Ok(Self::Unavailable),
            "unsatisfactory" => Ok(Self::Unsatisfactory),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecimenStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::EnteredInError => "entered-in-error",
            Self::Unavailable => "unavailable",
            Self::Unsatisfactory => "unsatisfactory",
        }
    }
}
impl ::std::fmt::Debug for SpecimenStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SpecimenStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SpecimenStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecimenStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecimenStatus> for Coding {
    fn from(code: SpecimenStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/specimen-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SpecimenStatus> for CodeableConcept {
    fn from(code: SpecimenStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StandardsStatus](http://hl7.org/fhir/standards-status)**. Status codes indicating the 'standards' level of an artifact\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum StandardsStatus {
    /** **deprecated**

Deprecated. This portion of the specification is provided for implementer assistance, and does not make rules that implementers are required to follow. Typical examples of this content in the FHIR specification are tables of contents, registries, examples, and implementer advice. */
    Deprecated,
    /** **draft**

Draft. This portion of the specification is not considered to be complete enough or sufficiently reviewed to be safe for implementation. It may have known issues or still be in the "in development" stage. It is included in the publication as a place-holder, to solicit feedback from the implementation community and/or to give implementers some insight as to functionality likely to be included in future versions of the specification. Content at this level should only be implemented by the brave or desperate and is very much "use at your own risk". The content that is Draft that will usually be elevated to Trial Use once review and correction is complete after it has been subjected to ballot. */
    Draft,
    /** **external**

External. This is content that is managed outside the FHIR Specification, but included for implementer convenience. */
    External,
    /** **informative**

Informative. This portion of the specification is provided for implementer assistance, and does not make rules that implementers are required to follow. Typical examples of this content in the FHIR specification are tables of contents, registries, examples, and implementer advice. */
    Informative,
    /** **normative**

Normative. This content has been subject to review and production implementation in a wide variety of environments. The content is considered to be stable and has been 'locked', subjecting it to FHIR Inter-version Compatibility Rules. While changes are possible, they are expected to be infrequent and are tightly constrained. Compatibility Rules. */
    Normative,
    /** **trial-use**

Trial-Use. This content has been well reviewed and is considered by the authors to be ready for use in production systems. It has been subjected to ballot and approved as an official standard. However, it has not yet seen widespread use in production across the full spectrum of environments it is intended to be used in. In some cases, there may be documented known issues that require implementation experience to determine appropriate resolutions for.

Future versions of FHIR may make significant changes to Trial Use content that are not compatible with previously published content. */
    TrialUse,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for StandardsStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deprecated" => Ok(Self::Deprecated),
            "draft" => Ok(Self::Draft),
            "external" => Ok(Self::External),
            "informative" => Ok(Self::Informative),
            "normative" => Ok(Self::Normative),
            "trial-use" => Ok(Self::TrialUse),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for StandardsStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deprecated => "deprecated",
            Self::Draft => "draft",
            Self::External => "external",
            Self::Informative => "informative",
            Self::Normative => "normative",
            Self::TrialUse => "trial-use",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for StandardsStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StandardsStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StandardsStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StandardsStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StandardsStatus> for Coding {
    fn from(code: StandardsStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/standards-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StandardsStatus> for CodeableConcept {
    fn from(code: StandardsStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StatisticModelCode](http://hl7.org/fhir/ValueSet/statistic-model-code)**. The role that the assertion variable plays.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StatisticModelCode {
    /** **adjusted**

Adjusted analysis. Used for adjusted analysis, paired with variable element(s) */
    Adjusted,
    /** **anova**

ANOVA (ANalysis Of VAriance). Used for ANOVA method of analysis, may be paired with "value" to express degrees of freedom */
    Anova,
    /** **anovaOneWay**

one-way ANOVA. Used for one-way ANOVA method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaOneWay,
    /** **anovaThreeWay**

3-way ANOVA. Used for 3-way ANOVA method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaThreeWay,
    /** **anovaTwoWay**

2-way ANOVA without replication. Used for 2-way ANOVA without replication method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaTwoWay,
    /** **anovaTwoWayReplication**

2-way ANOVA with replication. Used for 2-way ANOVA with replication method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaTwoWayReplication,
    /** **binomialDistributionRegression**

Binomial Distribution for Regression. Used for Binomial Distribution for Regression, no additional elements needed */
    BinomialDistributionRegression,
    /** **chiSquareTest**

Chi-square test. Used for Chi-square test, may be paired with "value" to express degrees of freedom */
    ChiSquareTest,
    /** **chiSquareTestHomogeneity**

Chi-square test for homogeneity. Used for Chi-square test for homogeneity, may be paired with "value" to express degrees of freedom */
    ChiSquareTestHomogeneity,
    /** **chiSquareTestTrend**

Chi-square test for trend. Used for Chi-square test for trend, may be paired with "value" to express degrees of freedom */
    ChiSquareTestTrend,
    /** **coxProportionalHazards**

Cox Proportional Hazards. Used for Cox proportional hazards method of analysis, no additional elements needed */
    CoxProportionalHazards,
    /** **dersimonianLairdMethod**

Dersimonian-Laird method. Used for Dersimonian-Laird method of tau estimation, no additional elements needed */
    DersimonianLairdMethod,
    /** **effectsFixed**

Fixed-effects. From a fixed-effects analysis, no additional elements needed */
    EffectsFixed,
    /** **effectsRandom**

Random-effects. From a random-effects analysis, no additional elements needed */
    EffectsRandom,
    /** **empiricalBayes**

Empirical Bayes method. Used for Empirical Bayes method of tau estimation, no additional elements needed */
    EmpiricalBayes,
    /** **fishersExactTest**

Fisher’s exact test. Used for Fisher's exact test, may be paired with "value" to express degrees of freedom */
    FishersExactTest,
    /** **friedmanTest**

Friedman test. Used for Friedman test, no additional elements needed */
    FriedmanTest,
    /** **glm**

GLM (Generalized Linear Model). Used for GLM (Generalized Linear Model), no additional elements needed */
    Glm,
    /** **glmGeneralizedLogit**

GLM with generalized logit link. Used for GLM with generalized logit link, no additional elements needed */
    GlmGeneralizedLogit,
    /** **glmIdentity**

GLM with identity link. Used for GLM with identity link, no additional elements needed */
    GlmIdentity,
    /** **glmLog**

GLM with log link. Used for GLM with log link, no additional elements needed */
    GlmLog,
    /** **glmLogit**

GLM with logit link. Used for GLM with logit link, no additional elements needed */
    GlmLogit,
    /** **glmProbit**

GLM with probit link. Used for GLM with probit link, no additional elements needed */
    GlmProbit,
    /** **glmm**

Generalized linear mixed model (GLMM). Used for Generalized linear mixed model (GLMM), no additional elements needed */
    Glmm,
    /** **glmmGeneralizedLogit**

GLMM with generalized logit link. Used for GLMM with generalized logit link, no additional elements needed */
    GlmmGeneralizedLogit,
    /** **glmmIdentity**

GLMM with identity link. Used for GLMM with identity link, no additional elements needed */
    GlmmIdentity,
    /** **glmmLog**

GLMM with log link. Used for GLMM with log link, no additional elements needed */
    GlmmLog,
    /** **glmmLogit**

GLMM with logit link. Used for GLMM with logit link, no additional elements needed */
    GlmmLogit,
    /** **glmmProbit**

GLMM with probit link. Used for GLMM with probit link, no additional elements needed */
    GlmmProbit,
    /** **goodmanKruskasGamma**

Goodman Kruska’s Gamma. Used for Goodman Kruska’s Gamma, no additional elements needed */
    GoodmanKruskasGamma,
    /** **hartungKnapp**

Hartung-Knapp adjustment. Hartung-Knapp/Hartung-Knapp-Sidik-Jonkman adjustment used in meta-analysis, no additional elements needed */
    HartungKnapp,
    /** **hedgesMethod**

Hedges method. Used for Hedges method of tau estimation, no additional elements needed */
    HedgesMethod,
    /** **hunterSchmidt**

Hunter-Schmidt method. Used for Hunter-Schmidt method of tau estimation, no additional elements needed */
    HunterSchmidt,
    /** **interactionTerm**

Interaction term. Used for interaction term, paired with "value" and two or more variable elements */
    InteractionTerm,
    /** **inverseVariance**

Inverse variance method. Used for inverse variance method of meta-analysis, no additional elements needed */
    InverseVariance,
    /** **kendallCorrelation**

Kendall correlation. Used for Kendall correlation, no additional elements needed */
    KendallCorrelation,
    /** **kruskalWallisTest**

Kruskal Wallis test. Used for Kruskal Wallis test, may be paired with "value" to express degrees of freedom */
    KruskalWallisTest,
    /** **linearRegression**

Linear Regression. Used for linear regression method of analysis, no additional elements needed */
    LinearRegression,
    /** **logisticRegression**

Logistic Regression. Used for logistic regression method of analysis, no additional elements needed */
    LogisticRegression,
    /** **mannWhitneyUTest**

Mann-Whitney U test. Used for Mann-Whitney U test, no additional elements needed */
    MannWhitneyUTest,
    /** **manova**

multivariate ANOVA (MANOVA). Used for multivariate ANOVA (MANOVA) method of analysis, may be paired with "value" to express degrees of freedom */
    Manova,
    /** **manteHaenszelMethod**

Mantel-Haenszel method. Used for Mantel-Haenszel method, no additional elements needed */
    ManteHaenszelMethod,
    /** **maximumLikelihood**

Maximum Likelihood method. Used for Maximum Likelihood method of tau estimation, no additional elements needed */
    MaximumLikelihood,
    /** **mcnemarsTest**

McNemar’s test. Used for McNemar's test, no additional elements needed */
    McnemarsTest,
    /** **metaAnalysis**

Meta-analysis. Used for meta-analysis, no additional elements needed */
    MetaAnalysis,
    /** **modifiedHartungKnapp**

Modified Hartung-Knapp adjustment. Modified Hartung-Knapp/Hartung-Knapp-Sidik-Jonkman adjustment used in meta-analysis, no additional elements needed */
    ModifiedHartungKnapp,
    /** **multinomialDistributionRegression**

Multinomial Distribution for Regression. Used for Multinomial Distribution for Regression, no additional elements needed */
    MultinomialDistributionRegression,
    /** **negativeBinomialRegression**

Negative Binomial Regression. Used for Negative Binomial Regression, no additional elements needed */
    NegativeBinomialRegression,
    /** **oneSampleTTest**

1-sample t-test. Used for 1-sample t-test, may be paired with "value" to express degrees of freedom */
    OneSampleTTest,
    /** **oneTailedTest**

one-tailed test (1 threshold). Used for one-tailed test (1 threshold), no additional elements needed */
    OneTailedTest,
    /** **pairedTTest**

paired t-test. Used for paired t-test, may be paired with "value" to express degrees of freedom */
    PairedTTest,
    /** **pauleMandelMethod**

Paule-Mandel method. Used for Paule-Mandel method of tau estimation, no additional elements needed */
    PauleMandelMethod,
    /** **pearsonCorrelation**

Pearson correlation. Used for Pearson correlation, no additional elements needed */
    PearsonCorrelation,
    /** **petoMethod**

Peto method. Used for Peto method of meta-analysis, no additional elements needed */
    PetoMethod,
    /** **poissonRegression**

Poisson Regression. Used for Poisson Regression, no additional elements needed */
    PoissonRegression,
    /** **polynomialRegression**

Polynomial Regression. Used for Polynomial regression method of analysis, no additional elements needed */
    PolynomialRegression,
    /** **poolGeneralizedLinearMixedModel**

Generalized linear mixed model (GLMM). Generalized linear mixed model (GLMM) method for pooling in meta-analysis */
    PoolGeneralizedLinearMixedModel,
    /** **poolInverseVariance**

Inverse variance method. Inverse variance method for pooling in meta-analysis */
    PoolInverseVariance,
    /** **poolMantelHaenzsel**

Mantel-Haenszel method. Mantel-Haenszel method for pooling in meta-analysis */
    PoolMantelHaenzsel,
    /** **poolPeto**

Peto method. Peto method for pooling in meta-analysis */
    PoolPeto,
    /** **restrictedLikelihood**

Restricted Maximum Likelihood method. Used for Restricted Maximum Likelihood method of tau estimation, no additional elements needed */
    RestrictedLikelihood,
    /** **sidikJonkman**

Sidik-Jonkman method. Used for Sidik-Jonkman method of tau estimation, no additional elements needed */
    SidikJonkman,
    /** **signTest**

sign test. Used for sign test, no additional elements needed */
    SignTest,
    /** **spearmanCorrelation**

Spearman correlation. Used for Spearman correlation, no additional elements needed */
    SpearmanCorrelation,
    /** **tauDersimonianLaird**

Dersimonian-Laird method. Dersimonian-Laird method for tau squared */
    TauDersimonianLaird,
    /** **tauEmpiricalBayes**

Empirical Bayes method. Empirical Bayes method for tau squared */
    TauEmpiricalBayes,
    /** **tauHedges**

Hedges method. Hedges method for tau squared */
    TauHedges,
    /** **tauHunterSchmidt**

Hunter-Schmidt method. Hunter-Schmidt method for tau squared */
    TauHunterSchmidt,
    /** **tauMaximumLikelihood**

Maximum Likelihood method. Maximum Likelihood method for tau squared */
    TauMaximumLikelihood,
    /** **tauPauleMandel**

Paule-Mandel method. Paule-Mandel method for tau squared */
    TauPauleMandel,
    /** **tauRestrictedMaximumLikelihood**

Restricted Maximum Likelihood method. Restricted Maximum Likelihood method for tau squared */
    TauRestrictedMaximumLikelihood,
    /** **tauSidikJonkman**

Sidik-Jonkman method. Sidik-Jonkman method for tau squared */
    TauSidikJonkman,
    /** **twoSampleTTest**

2-sample t-test. Used for 2-sample t-test, may be paired with "value" to express degrees of freedom */
    TwoSampleTTest,
    /** **twoTailedTest**

two-tailed test (2 thresholds). Used for two-tailed test (2 threshold), no additional elements needed */
    TwoTailedTest,
    /** **wilcoxonRankSumTest**

Wilcoxon rank-sum test. Used for Wilcoxon rank-sum test, no additional elements needed */
    WilcoxonRankSumTest,
    /** **wilcoxonSignedRankTest**

Wilcoxon signed-rank test. Used for Wilcoxon signed-rank test, no additional elements needed */
    WilcoxonSignedRankTest,
    /** **zTest**

z-test. Used for z-test, no additional elements needed */
    Ztest,
    /** **zeroCellConstant**

Zero-cell adjustment with constant. Zero-cell adjustment done by adding a constant to all cells of affected studies, paired with "value" to define the constant */
    ZeroCellConstant,
    /** **zeroCellContinuityCorrection**

Zero-cell adjustment with continuity correction. Zero-cell adjustment done by treatment arm continuity correction, no additional elements needed */
    ZeroCellContinuityCorrection,
}
impl ::core::str::FromStr for StatisticModelCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "adjusted" => Ok(Self::Adjusted),
            "anova" => Ok(Self::Anova),
            "anovaOneWay" => Ok(Self::AnovaOneWay),
            "anovaThreeWay" => Ok(Self::AnovaThreeWay),
            "anovaTwoWay" => Ok(Self::AnovaTwoWay),
            "anovaTwoWayReplication" => Ok(Self::AnovaTwoWayReplication),
            "binomialDistributionRegression" => Ok(Self::BinomialDistributionRegression),
            "chiSquareTest" => Ok(Self::ChiSquareTest),
            "chiSquareTestHomogeneity" => Ok(Self::ChiSquareTestHomogeneity),
            "chiSquareTestTrend" => Ok(Self::ChiSquareTestTrend),
            "coxProportionalHazards" => Ok(Self::CoxProportionalHazards),
            "dersimonianLairdMethod" => Ok(Self::DersimonianLairdMethod),
            "effectsFixed" => Ok(Self::EffectsFixed),
            "effectsRandom" => Ok(Self::EffectsRandom),
            "empiricalBayes" => Ok(Self::EmpiricalBayes),
            "fishersExactTest" => Ok(Self::FishersExactTest),
            "friedmanTest" => Ok(Self::FriedmanTest),
            "glm" => Ok(Self::Glm),
            "glmGeneralizedLogit" => Ok(Self::GlmGeneralizedLogit),
            "glmIdentity" => Ok(Self::GlmIdentity),
            "glmLog" => Ok(Self::GlmLog),
            "glmLogit" => Ok(Self::GlmLogit),
            "glmProbit" => Ok(Self::GlmProbit),
            "glmm" => Ok(Self::Glmm),
            "glmmGeneralizedLogit" => Ok(Self::GlmmGeneralizedLogit),
            "glmmIdentity" => Ok(Self::GlmmIdentity),
            "glmmLog" => Ok(Self::GlmmLog),
            "glmmLogit" => Ok(Self::GlmmLogit),
            "glmmProbit" => Ok(Self::GlmmProbit),
            "goodmanKruskasGamma" => Ok(Self::GoodmanKruskasGamma),
            "hartungKnapp" => Ok(Self::HartungKnapp),
            "hedgesMethod" => Ok(Self::HedgesMethod),
            "hunterSchmidt" => Ok(Self::HunterSchmidt),
            "interactionTerm" => Ok(Self::InteractionTerm),
            "inverseVariance" => Ok(Self::InverseVariance),
            "kendallCorrelation" => Ok(Self::KendallCorrelation),
            "kruskalWallisTest" => Ok(Self::KruskalWallisTest),
            "linearRegression" => Ok(Self::LinearRegression),
            "logisticRegression" => Ok(Self::LogisticRegression),
            "mannWhitneyUTest" => Ok(Self::MannWhitneyUTest),
            "manova" => Ok(Self::Manova),
            "manteHaenszelMethod" => Ok(Self::ManteHaenszelMethod),
            "maximumLikelihood" => Ok(Self::MaximumLikelihood),
            "mcnemarsTest" => Ok(Self::McnemarsTest),
            "metaAnalysis" => Ok(Self::MetaAnalysis),
            "modifiedHartungKnapp" => Ok(Self::ModifiedHartungKnapp),
            "multinomialDistributionRegression" => {
                Ok(Self::MultinomialDistributionRegression)
            }
            "negativeBinomialRegression" => Ok(Self::NegativeBinomialRegression),
            "oneSampleTTest" => Ok(Self::OneSampleTTest),
            "oneTailedTest" => Ok(Self::OneTailedTest),
            "pairedTTest" => Ok(Self::PairedTTest),
            "pauleMandelMethod" => Ok(Self::PauleMandelMethod),
            "pearsonCorrelation" => Ok(Self::PearsonCorrelation),
            "petoMethod" => Ok(Self::PetoMethod),
            "poissonRegression" => Ok(Self::PoissonRegression),
            "polynomialRegression" => Ok(Self::PolynomialRegression),
            "poolGeneralizedLinearMixedModel" => {
                Ok(Self::PoolGeneralizedLinearMixedModel)
            }
            "poolInverseVariance" => Ok(Self::PoolInverseVariance),
            "poolMantelHaenzsel" => Ok(Self::PoolMantelHaenzsel),
            "poolPeto" => Ok(Self::PoolPeto),
            "restrictedLikelihood" => Ok(Self::RestrictedLikelihood),
            "sidikJonkman" => Ok(Self::SidikJonkman),
            "signTest" => Ok(Self::SignTest),
            "spearmanCorrelation" => Ok(Self::SpearmanCorrelation),
            "tauDersimonianLaird" => Ok(Self::TauDersimonianLaird),
            "tauEmpiricalBayes" => Ok(Self::TauEmpiricalBayes),
            "tauHedges" => Ok(Self::TauHedges),
            "tauHunterSchmidt" => Ok(Self::TauHunterSchmidt),
            "tauMaximumLikelihood" => Ok(Self::TauMaximumLikelihood),
            "tauPauleMandel" => Ok(Self::TauPauleMandel),
            "tauRestrictedMaximumLikelihood" => Ok(Self::TauRestrictedMaximumLikelihood),
            "tauSidikJonkman" => Ok(Self::TauSidikJonkman),
            "twoSampleTTest" => Ok(Self::TwoSampleTTest),
            "twoTailedTest" => Ok(Self::TwoTailedTest),
            "wilcoxonRankSumTest" => Ok(Self::WilcoxonRankSumTest),
            "wilcoxonSignedRankTest" => Ok(Self::WilcoxonSignedRankTest),
            "zTest" => Ok(Self::Ztest),
            "zeroCellConstant" => Ok(Self::ZeroCellConstant),
            "zeroCellContinuityCorrection" => Ok(Self::ZeroCellContinuityCorrection),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StatisticModelCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adjusted => "adjusted",
            Self::Anova => "anova",
            Self::AnovaOneWay => "anovaOneWay",
            Self::AnovaThreeWay => "anovaThreeWay",
            Self::AnovaTwoWay => "anovaTwoWay",
            Self::AnovaTwoWayReplication => "anovaTwoWayReplication",
            Self::BinomialDistributionRegression => "binomialDistributionRegression",
            Self::ChiSquareTest => "chiSquareTest",
            Self::ChiSquareTestHomogeneity => "chiSquareTestHomogeneity",
            Self::ChiSquareTestTrend => "chiSquareTestTrend",
            Self::CoxProportionalHazards => "coxProportionalHazards",
            Self::DersimonianLairdMethod => "dersimonianLairdMethod",
            Self::EffectsFixed => "effectsFixed",
            Self::EffectsRandom => "effectsRandom",
            Self::EmpiricalBayes => "empiricalBayes",
            Self::FishersExactTest => "fishersExactTest",
            Self::FriedmanTest => "friedmanTest",
            Self::Glm => "glm",
            Self::GlmGeneralizedLogit => "glmGeneralizedLogit",
            Self::GlmIdentity => "glmIdentity",
            Self::GlmLog => "glmLog",
            Self::GlmLogit => "glmLogit",
            Self::GlmProbit => "glmProbit",
            Self::Glmm => "glmm",
            Self::GlmmGeneralizedLogit => "glmmGeneralizedLogit",
            Self::GlmmIdentity => "glmmIdentity",
            Self::GlmmLog => "glmmLog",
            Self::GlmmLogit => "glmmLogit",
            Self::GlmmProbit => "glmmProbit",
            Self::GoodmanKruskasGamma => "goodmanKruskasGamma",
            Self::HartungKnapp => "hartungKnapp",
            Self::HedgesMethod => "hedgesMethod",
            Self::HunterSchmidt => "hunterSchmidt",
            Self::InteractionTerm => "interactionTerm",
            Self::InverseVariance => "inverseVariance",
            Self::KendallCorrelation => "kendallCorrelation",
            Self::KruskalWallisTest => "kruskalWallisTest",
            Self::LinearRegression => "linearRegression",
            Self::LogisticRegression => "logisticRegression",
            Self::MannWhitneyUTest => "mannWhitneyUTest",
            Self::Manova => "manova",
            Self::ManteHaenszelMethod => "manteHaenszelMethod",
            Self::MaximumLikelihood => "maximumLikelihood",
            Self::McnemarsTest => "mcnemarsTest",
            Self::MetaAnalysis => "metaAnalysis",
            Self::ModifiedHartungKnapp => "modifiedHartungKnapp",
            Self::MultinomialDistributionRegression => {
                "multinomialDistributionRegression"
            }
            Self::NegativeBinomialRegression => "negativeBinomialRegression",
            Self::OneSampleTTest => "oneSampleTTest",
            Self::OneTailedTest => "oneTailedTest",
            Self::PairedTTest => "pairedTTest",
            Self::PauleMandelMethod => "pauleMandelMethod",
            Self::PearsonCorrelation => "pearsonCorrelation",
            Self::PetoMethod => "petoMethod",
            Self::PoissonRegression => "poissonRegression",
            Self::PolynomialRegression => "polynomialRegression",
            Self::PoolGeneralizedLinearMixedModel => "poolGeneralizedLinearMixedModel",
            Self::PoolInverseVariance => "poolInverseVariance",
            Self::PoolMantelHaenzsel => "poolMantelHaenzsel",
            Self::PoolPeto => "poolPeto",
            Self::RestrictedLikelihood => "restrictedLikelihood",
            Self::SidikJonkman => "sidikJonkman",
            Self::SignTest => "signTest",
            Self::SpearmanCorrelation => "spearmanCorrelation",
            Self::TauDersimonianLaird => "tauDersimonianLaird",
            Self::TauEmpiricalBayes => "tauEmpiricalBayes",
            Self::TauHedges => "tauHedges",
            Self::TauHunterSchmidt => "tauHunterSchmidt",
            Self::TauMaximumLikelihood => "tauMaximumLikelihood",
            Self::TauPauleMandel => "tauPauleMandel",
            Self::TauRestrictedMaximumLikelihood => "tauRestrictedMaximumLikelihood",
            Self::TauSidikJonkman => "tauSidikJonkman",
            Self::TwoSampleTTest => "twoSampleTTest",
            Self::TwoTailedTest => "twoTailedTest",
            Self::WilcoxonRankSumTest => "wilcoxonRankSumTest",
            Self::WilcoxonSignedRankTest => "wilcoxonSignedRankTest",
            Self::Ztest => "zTest",
            Self::ZeroCellConstant => "zeroCellConstant",
            Self::ZeroCellContinuityCorrection => "zeroCellContinuityCorrection",
        }
    }
}
impl ::std::fmt::Debug for StatisticModelCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StatisticModelCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StatisticModelCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StatisticModelCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StatisticModelCode> for Coding {
    fn from(code: StatisticModelCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/statistic-model-code".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StatisticModelCode> for CodeableConcept {
    fn from(code: StatisticModelCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StatisticType](http://hl7.org/fhir/ValueSet/statistic-type)**. The role that the assertion variable plays.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StatisticType {
    /** **0000100**

Standardized Mean Difference. Computed by forming the difference between two means, divided by an estimate of the within-group standard deviation. It is used to provide an estimatation of the effect size between two treatments when the predictor (independent variable) is categorical and the response(dependent) variable is continuous */
    N0000100,
    /** **0000301**

Covariance. The strength of correlation between a set (2 or more) of random variables. The covariance is obtained by forming: cov(x,y)=e([x-e(x)][y-e(y)] where e(x), e(y) is the expected value (mean) of variable x and y respectively. Covariance is symmetric so cov(x,y)=cov(y,x). The covariance is usefull when looking at the variance of the sum of the 2 random variables since: var(x+y) = var(x) +var(y) +2cov(x,y) the covariance cov(x,y) is used to obtain the coefficient of correlation cor(x,y) by normalizing (dividing) cov(x,y) but the product of the standard deviations of x and y. */
    N0000301,
    /** **0000424**

Risk Difference. Difference between the observed risks (proportions of individuals with the outcome of interest) in the two groups. The risk difference is straightforward to interpret: it describes the actual difference in the observed risk of events between experimental and control interventions. */
    N0000424,
    /** **0000457**

Mean Difference. The mean difference, or difference in means, measures the absolute difference between the mean value in two different groups. */
    N0000457,
    /** **0000565**

Regression Coefficient. Generated by a type of data transformation called a regression, which aims to model a response variable by expression the predictor variables as part of a function where variable terms are modified by a number. A regression coefficient is one such number. */
    N0000565,
    /** **C16726**

Incidence. The relative frequency of occurrence of something. */
    C16726,
    /** **C16932**

Odds Ratio. The ratio of the odds of an event occurring in one group to the odds of it occurring in another group, or to a sample-based estimate of that ratio. */
    C16932,
    /** **C17010**

Prevalence. The ratio (for a given time period) of the number of occurrences of a disease or event to the number of units at risk in the population. */
    C17010,
    /** **C25463**

Count. The number or amount of something */
    C25463,
    /** **C25564**

Maximum. The largest possible quantity or degree. */
    C25564,
    /** **C25570**

Minimum. The smallest possible quantity. */
    C25570,
    /** **C28007**

Median. The value which has an equal number of values greater and less than it. */
    C28007,
    /** **C44256**

Proportion. Quotient of quantities of the same kind for different components within the same system. [Use for univariate outcomes within an individual.] */
    C44256,
    /** **C53319**

Mean. The sum of a set of values divided by the number of values in the set. */
    C53319,
    /** **C65171**

Spearman Rank-Order Correlation . A distribution-free analog of correlation analysis. Like regression, it can be applied to compare two independent random variables, each at several levels (which may be discrete or continuous). Unlike regression, Spearman's rank correlation works on ranked (relative) data, rather than directly on the data itself. */
    C65171,
    /** **C65172**

Pearson Correlation Coefficient. A measure of the correlation of two variables X and Y measured on the same object or organism, that is, a measure of the tendency of the variables to increase or decrease together. It is defined as the sum of the products of the standard scores of the two measures divided by the degrees of freedom. */
    C65172,
    /** **C93150**

Hazard Ratio. A measure of how often a particular event happens in one group compared to how often it happens in another group, over time. In cancer research, hazard ratios are often used in clinical trials to measure survival at any point in time in a group of patients who have been given a specific treatment compared to a control group given another treatment or a placebo. A hazard ratio of one means that there is no difference in survival between the two groups. A hazard ratio of greater than one or less than one means that survival was better in one of the groups. */
    C93150,
    /** **C93152**

Relative Risk.  A measure of the risk of a certain event happening in one group compared to the risk of the same event happening in another group. In cancer research, risk ratios are used in prospective (forward looking) studies, such as cohort studies and clinical trials. A risk ratio of one means there is no difference between two groups in terms of their risk of cancer, based on whether or not they were exposed to a certain substance or factor, or how they responded to two treatments being compared. A risk ratio of greater than one or of less than one usually means that being exposed to a certain substance or factor either increases (risk ratio greater than one) or decreases (risk ratio less than one) the risk of cancer, or that the treatments being compared do not have the same effects. */
    C93152,
    /** **absolute-MedianDiff**

Absolute Median Difference. Computed by forming the difference between two medians. */
    AbsoluteMedianDiff,
    /** **descriptive**

Descriptive. Descriptive measure reported as narrative. */
    Descriptive,
    /** **predictedRisk**

Predicted Risk. A special use case where the proportion is derived from a formula rather than derived from summary evidence. */
    PredictedRisk,
    /** **rate-ratio**

Incidence Rate Ratio. A type of relative effect estimate that compares rates over time (eg events per person-years). */
    RateRatio,
}
impl ::core::str::FromStr for StatisticType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0000100" => Ok(Self::N0000100),
            "0000301" => Ok(Self::N0000301),
            "0000424" => Ok(Self::N0000424),
            "0000457" => Ok(Self::N0000457),
            "0000565" => Ok(Self::N0000565),
            "C16726" => Ok(Self::C16726),
            "C16932" => Ok(Self::C16932),
            "C17010" => Ok(Self::C17010),
            "C25463" => Ok(Self::C25463),
            "C25564" => Ok(Self::C25564),
            "C25570" => Ok(Self::C25570),
            "C28007" => Ok(Self::C28007),
            "C44256" => Ok(Self::C44256),
            "C53319" => Ok(Self::C53319),
            "C65171" => Ok(Self::C65171),
            "C65172" => Ok(Self::C65172),
            "C93150" => Ok(Self::C93150),
            "C93152" => Ok(Self::C93152),
            "absolute-MedianDiff" => Ok(Self::AbsoluteMedianDiff),
            "descriptive" => Ok(Self::Descriptive),
            "predictedRisk" => Ok(Self::PredictedRisk),
            "rate-ratio" => Ok(Self::RateRatio),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StatisticType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0000100 => "0000100",
            Self::N0000301 => "0000301",
            Self::N0000424 => "0000424",
            Self::N0000457 => "0000457",
            Self::N0000565 => "0000565",
            Self::C16726 => "C16726",
            Self::C16932 => "C16932",
            Self::C17010 => "C17010",
            Self::C25463 => "C25463",
            Self::C25564 => "C25564",
            Self::C25570 => "C25570",
            Self::C28007 => "C28007",
            Self::C44256 => "C44256",
            Self::C53319 => "C53319",
            Self::C65171 => "C65171",
            Self::C65172 => "C65172",
            Self::C93150 => "C93150",
            Self::C93152 => "C93152",
            Self::AbsoluteMedianDiff => "absolute-MedianDiff",
            Self::Descriptive => "descriptive",
            Self::PredictedRisk => "predictedRisk",
            Self::RateRatio => "rate-ratio",
        }
    }
}
impl ::std::fmt::Debug for StatisticType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StatisticType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StatisticType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StatisticType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StatisticType> for Coding {
    fn from(code: StatisticType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/statistic-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StatisticType> for CodeableConcept {
    fn from(code: StatisticType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StatisticsCode](http://hl7.org/fhir/observation-statistics)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum StatisticsCode {
    /** **20-percent**

20th Percentile. The 20th [Percentile](https://en.wikipedia.org/wiki/Percentile) of N measurements over the stated period. */
    N20Percent,
    /** **4-dev**

Quartile Deviation. The difference between the upper and lower [Quartiles](https://en.wikipedia.org/wiki/Quartile) is called the Interquartile range. (IQR = Q3-Q1) Quartile deviation or Semi-interquartile range is one-half the difference between the first and the third quartiles. */
    N4Dev,
    /** **4-lower**

Lower Quartile. The lower [Quartile](https://en.wikipedia.org/wiki/Quartile) Boundary of N measurements over the stated period. */
    N4Lower,
    /** **4-upper**

Upper Quartile. The upper [Quartile](https://en.wikipedia.org/wiki/Quartile) Boundary of N measurements over the stated period. */
    N4Upper,
    /** **5-1**

1st Quintile. The lowest of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N51,
    /** **5-2**

2nd Quintile. The second of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N52,
    /** **5-3**

3rd Quintile. The third of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N53,
    /** **5-4**

4th Quintile. The fourth of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N54,
    /** **80-percent**

80th Percentile. The 80th [Percentile](https://en.wikipedia.org/wiki/Percentile) of N measurements over the stated period. */
    N80Percent,
    /** **average**

Average. The [mean](https://en.wikipedia.org/wiki/Arithmetic_mean) of N measurements over the stated period. */
    Average,
    /** **count**

Count. The [number] of valid measurements over the stated period that contributed to the other statistical outputs. */
    Count,
    /** **kurtosis**

Kurtosis. Kurtosis  is a measure of the "tailedness" of the probability distribution of a real-valued random variable.   Source: [Wikipedia](https://en.wikipedia.org/wiki/Kurtosis). */
    Kurtosis,
    /** **maximum**

Maximum. The [maximum](https://en.wikipedia.org/wiki/Maximal_element) value of N measurements over the stated period. */
    Maximum,
    /** **median**

Median. The [median](https://en.wikipedia.org/wiki/Median) of N measurements over the stated period. */
    Median,
    /** **minimum**

Minimum. The [minimum](https://en.wikipedia.org/wiki/Minimal_element) value of N measurements over the stated period. */
    Minimum,
    /** **regression**

Regression. Linear regression is an approach for modeling two-dimensional sample points with one independent variable and one dependent variable (conventionally, the x and y coordinates in a Cartesian coordinate system) and finds a linear function (a non-vertical straight line) that, as accurately as possible, predicts the dependent variable values as a function of the independent variables. Source: [Wikipedia](https://en.wikipedia.org/wiki/Simple_linear_regression)  This Statistic code will return both a gradient and an intercept value. */
    Regression,
    /** **skew**

Skew. Skewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean. The skewness value can be positive or negative, or even undefined.  Source: [Wikipedia](https://en.wikipedia.org/wiki/Skewness). */
    Skew,
    /** **std-dev**

Standard Deviation. The [standard deviation](https://en.wikipedia.org/wiki/Standard_deviation) of N measurements over the stated period. */
    StdDev,
    /** **sum**

Sum. The [sum](https://en.wikipedia.org/wiki/Summation) of N measurements over the stated period. */
    Sum,
    /** **total-count**

Total Count. The total [number] of valid measurements over the stated period, including observations that were ignored because they did not contain valid result values. */
    TotalCount,
    /** **variance**

Variance. The [variance](https://en.wikipedia.org/wiki/Variance) of N measurements over the stated period. */
    Variance,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for StatisticsCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "20-percent" => Ok(Self::N20Percent),
            "4-dev" => Ok(Self::N4Dev),
            "4-lower" => Ok(Self::N4Lower),
            "4-upper" => Ok(Self::N4Upper),
            "5-1" => Ok(Self::N51),
            "5-2" => Ok(Self::N52),
            "5-3" => Ok(Self::N53),
            "5-4" => Ok(Self::N54),
            "80-percent" => Ok(Self::N80Percent),
            "average" => Ok(Self::Average),
            "count" => Ok(Self::Count),
            "kurtosis" => Ok(Self::Kurtosis),
            "maximum" => Ok(Self::Maximum),
            "median" => Ok(Self::Median),
            "minimum" => Ok(Self::Minimum),
            "regression" => Ok(Self::Regression),
            "skew" => Ok(Self::Skew),
            "std-dev" => Ok(Self::StdDev),
            "sum" => Ok(Self::Sum),
            "total-count" => Ok(Self::TotalCount),
            "variance" => Ok(Self::Variance),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for StatisticsCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::N20Percent => "20-percent",
            Self::N4Dev => "4-dev",
            Self::N4Lower => "4-lower",
            Self::N4Upper => "4-upper",
            Self::N51 => "5-1",
            Self::N52 => "5-2",
            Self::N53 => "5-3",
            Self::N54 => "5-4",
            Self::N80Percent => "80-percent",
            Self::Average => "average",
            Self::Count => "count",
            Self::Kurtosis => "kurtosis",
            Self::Maximum => "maximum",
            Self::Median => "median",
            Self::Minimum => "minimum",
            Self::Regression => "regression",
            Self::Skew => "skew",
            Self::StdDev => "std-dev",
            Self::Sum => "sum",
            Self::TotalCount => "total-count",
            Self::Variance => "variance",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for StatisticsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StatisticsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StatisticsCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StatisticsCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StatisticsCode> for Coding {
    fn from(code: StatisticsCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/observation-statistics".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StatisticsCode> for CodeableConcept {
    fn from(code: StatisticsCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StrengthOfRecommendationRating](http://hl7.org/fhir/ValueSet/recommendation-strength)**. A rating system that describes the strength of the recommendation, such as the GRADE, DynaMed, or HGPS systems.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StrengthOfRecommendationRating {
    /** **strong**

Strong. Strong recommendation. */
    Strong,
    /** **weak**

Weak. Weak recommendation. */
    Weak,
}
impl ::core::str::FromStr for StrengthOfRecommendationRating {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "strong" => Ok(Self::Strong),
            "weak" => Ok(Self::Weak),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StrengthOfRecommendationRating {
    fn as_ref(&self) -> &str {
        match self {
            Self::Strong => "strong",
            Self::Weak => "weak",
        }
    }
}
impl ::std::fmt::Debug for StrengthOfRecommendationRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StrengthOfRecommendationRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StrengthOfRecommendationRating {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StrengthOfRecommendationRating {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StrengthOfRecommendationRating> for Coding {
    fn from(code: StrengthOfRecommendationRating) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/recommendation-strength".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StrengthOfRecommendationRating> for CodeableConcept {
    fn from(code: StrengthOfRecommendationRating) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureDefinitionKind](http://hl7.org/fhir/ValueSet/structure-definition-kind)**. Defines the type of structure that a definition is describing.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureDefinitionKind {
    /** **complex-type**

Complex Data Type. A  complex structure that defines a set of data elements that is suitable for use in 'resources'. The base specification defines a number of complex types, and other specifications can define additional types. These structures do not have a maintained identity. */
    ComplexType,
    /** **logical**

Logical. A pattern or a template that is not intended to be a real resource or complex type. */
    Logical,
    /** **primitive-type**

Primitive Data Type. A primitive type that has a value and an extension. These can be used throughout complex datatype, Resource and extension definitions. Only the base specification can define primitive types. */
    PrimitiveType,
    /** **resource**

Resource. A 'resource' - a directed acyclic graph of elements that aggregrates other types into an identifiable entity. The base FHIR resources are defined by the FHIR specification itself but other 'resources' can be defined in additional specifications (though these will not be recognised as 'resources' by the FHIR specification (i.e. they do not get end-points etc, or act as the targets of references in FHIR defined resources - though other specificatiosn can treat them this way). */
    Resource,
}
impl ::core::str::FromStr for StructureDefinitionKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complex-type" => Ok(Self::ComplexType),
            "logical" => Ok(Self::Logical),
            "primitive-type" => Ok(Self::PrimitiveType),
            "resource" => Ok(Self::Resource),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureDefinitionKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::ComplexType => "complex-type",
            Self::Logical => "logical",
            Self::PrimitiveType => "primitive-type",
            Self::Resource => "resource",
        }
    }
}
impl ::std::fmt::Debug for StructureDefinitionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureDefinitionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureDefinitionKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureDefinitionKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureDefinitionKind> for Coding {
    fn from(code: StructureDefinitionKind) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/structure-definition-kind".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureDefinitionKind> for CodeableConcept {
    fn from(code: StructureDefinitionKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapContextType](http://hl7.org/fhir/ValueSet/map-context-type)**. How to interpret the context.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapContextType {
    /** **type**

Type. The context specifies a type. */
    Type,
    /** **variable**

Variable. The context specifies a variable. */
    Variable,
}
impl ::core::str::FromStr for StructureMapContextType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "type" => Ok(Self::Type),
            "variable" => Ok(Self::Variable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapContextType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Type => "type",
            Self::Variable => "variable",
        }
    }
}
impl ::std::fmt::Debug for StructureMapContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapContextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapContextType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapContextType> for Coding {
    fn from(code: StructureMapContextType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-context-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapContextType> for CodeableConcept {
    fn from(code: StructureMapContextType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapGroupTypeMode](http://hl7.org/fhir/ValueSet/map-group-type-mode)**. If this is the default rule set to apply for the source type, or this combination of types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapGroupTypeMode {
    /** **none**

Not a Default. This group is not a default group for the types. */
    None,
    /** **type-and-types**

Default for type + combination. This group is a default mapping group for the specified types. */
    TypeAndTypes,
    /** **types**

Default for Type Combination. This group is a default mapping group for the specified types and for the primary source type. */
    Types,
}
impl ::core::str::FromStr for StructureMapGroupTypeMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "none" => Ok(Self::None),
            "type-and-types" => Ok(Self::TypeAndTypes),
            "types" => Ok(Self::Types),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapGroupTypeMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::None => "none",
            Self::TypeAndTypes => "type-and-types",
            Self::Types => "types",
        }
    }
}
impl ::std::fmt::Debug for StructureMapGroupTypeMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapGroupTypeMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapGroupTypeMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapGroupTypeMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapGroupTypeMode> for Coding {
    fn from(code: StructureMapGroupTypeMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-group-type-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapGroupTypeMode> for CodeableConcept {
    fn from(code: StructureMapGroupTypeMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapInputMode](http://hl7.org/fhir/ValueSet/map-input-mode)**. Mode for this instance of data.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapInputMode {
    /** **source**

Source Instance. Names an input instance used a source for mapping. */
    Source,
    /** **target**

Target Instance. Names an instance that is being populated. */
    Target,
}
impl ::core::str::FromStr for StructureMapInputMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "source" => Ok(Self::Source),
            "target" => Ok(Self::Target),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapInputMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Source => "source",
            Self::Target => "target",
        }
    }
}
impl ::std::fmt::Debug for StructureMapInputMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapInputMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapInputMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapInputMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapInputMode> for Coding {
    fn from(code: StructureMapInputMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-input-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapInputMode> for CodeableConcept {
    fn from(code: StructureMapInputMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapModelMode](http://hl7.org/fhir/ValueSet/map-model-mode)**. How the referenced structure is used in this mapping.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapModelMode {
    /** **produced**

Produced Structure Definition. This structure describes an instance that the mapping engine may ask to create that is used a target of data. */
    Produced,
    /** **queried**

Queried Structure Definition. This structure describes an instance that the mapping engine may ask for that is used a source of data. */
    Queried,
    /** **source**

Source Structure Definition. This structure describes an instance passed to the mapping engine that is used a source of data. */
    Source,
    /** **target**

Target Structure Definition. This structure describes an instance passed to the mapping engine that is used a target of data. */
    Target,
}
impl ::core::str::FromStr for StructureMapModelMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "produced" => Ok(Self::Produced),
            "queried" => Ok(Self::Queried),
            "source" => Ok(Self::Source),
            "target" => Ok(Self::Target),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapModelMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Produced => "produced",
            Self::Queried => "queried",
            Self::Source => "source",
            Self::Target => "target",
        }
    }
}
impl ::std::fmt::Debug for StructureMapModelMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapModelMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapModelMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapModelMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapModelMode> for Coding {
    fn from(code: StructureMapModelMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-model-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapModelMode> for CodeableConcept {
    fn from(code: StructureMapModelMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapSourceListMode](http://hl7.org/fhir/ValueSet/map-source-list-mode)**. If field is a list, how to manage the source.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapSourceListMode {
    /** **first**

First. Only process this rule for the first in the list. */
    First,
    /** **last**

Last. Only process this rule for the last in the list. */
    Last,
    /** **not_first**

All but the first. Process this rule for all but the first. */
    NotFirst,
    /** **not_last**

All but the last. Process this rule for all but the last. */
    NotLast,
    /** **only_one**

Enforce only one. Only process this rule is there is only item. */
    OnlyOne,
}
impl ::core::str::FromStr for StructureMapSourceListMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "first" => Ok(Self::First),
            "last" => Ok(Self::Last),
            "not_first" => Ok(Self::NotFirst),
            "not_last" => Ok(Self::NotLast),
            "only_one" => Ok(Self::OnlyOne),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapSourceListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::First => "first",
            Self::Last => "last",
            Self::NotFirst => "not_first",
            Self::NotLast => "not_last",
            Self::OnlyOne => "only_one",
        }
    }
}
impl ::std::fmt::Debug for StructureMapSourceListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapSourceListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapSourceListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapSourceListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapSourceListMode> for Coding {
    fn from(code: StructureMapSourceListMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-source-list-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapSourceListMode> for CodeableConcept {
    fn from(code: StructureMapSourceListMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapTargetListMode](http://hl7.org/fhir/ValueSet/map-target-list-mode)**. If field is a list, how to manage the production.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapTargetListMode {
    /** **collate**

Collate. re-use the first item in the list, and keep adding content to it. */
    Collate,
    /** **first**

First. when the target list is being assembled, the items for this rule go first. If more than one rule defines a first item (for a given instance of mapping) then this is an error. */
    First,
    /** **last**

Last. when the target list is being assembled, the items for this rule go last. If more than one rule defines a last item (for a given instance of mapping) then this is an error. */
    Last,
    /** **share**

Share. the target instance is shared with the target instances generated by another rule (up to the first common n items, then create new ones). */
    Share,
}
impl ::core::str::FromStr for StructureMapTargetListMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "collate" => Ok(Self::Collate),
            "first" => Ok(Self::First),
            "last" => Ok(Self::Last),
            "share" => Ok(Self::Share),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapTargetListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Collate => "collate",
            Self::First => "first",
            Self::Last => "last",
            Self::Share => "share",
        }
    }
}
impl ::std::fmt::Debug for StructureMapTargetListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapTargetListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapTargetListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapTargetListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapTargetListMode> for Coding {
    fn from(code: StructureMapTargetListMode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-target-list-mode".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapTargetListMode> for CodeableConcept {
    fn from(code: StructureMapTargetListMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StructureMapTransform](http://hl7.org/fhir/ValueSet/map-transform)**. How data is copied/created.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StructureMapTransform {
    /** **append**

append. append(source...) - source is element or string. */
    Append,
    /** **c**

c. Create a Coding. Parameters = (system. Code[, display]). */
    C,
    /** **cast**

cast. cast(source, type?) - case source from one type to another. target type can be left as implicit if there is one and only one target type known. */
    Cast,
    /** **cc**

cc. Create a CodeableConcept. Parameters = (text) or (system. Code[, display]). */
    Cc,
    /** **copy**

copy. copy(source). */
    Copy,
    /** **cp**

cp. Create a contact details. Parameters = (value) or (system, value). If no system is provided, the system should be inferred from the content of the value. */
    Cp,
    /** **create**

create. create(type : string) - type is passed through to the application on the standard API, and must be known by it. */
    Create,
    /** **dateOp**

dateOp. Perform a date operation. *Parameters to be documented*. */
    DateOp,
    /** **escape**

escape. escape(source, fmt1, fmt2) - change source from one kind of escaping to another (plain, java, xml, json). note that this is for when the string itself is escaped. */
    Escape,
    /** **evaluate**

evaluate. Execute the supplied FHIRPath expression and use the value returned by that. */
    Evaluate,
    /** **id**

id. Create an identifier. Parameters = (system, value[, type]) where type is a code from the identifier type value set. */
    Id,
    /** **pointer**

pointer. Return the appropriate string to put in a reference that refers to the resource provided as a parameter. */
    Pointer,
    /** **qty**

qty. Create a quantity. Parameters = (text) or (value, unit, [system, code]) where text is the natural representation e.g. [comparator]value[space]unit. */
    Qty,
    /** **reference**

reference. reference(source : object) - return a string that references the provided tree properly. */
    Reference,
    /** **translate**

translate. translate(source, uri_of_map) - use the translate operation. */
    Translate,
    /** **truncate**

truncate. truncate(source, length) - source must be stringy type. */
    Truncate,
    /** **uuid**

uuid. Generate a random UUID (in lowercase). No Parameters. */
    Uuid,
}
impl ::core::str::FromStr for StructureMapTransform {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "append" => Ok(Self::Append),
            "c" => Ok(Self::C),
            "cast" => Ok(Self::Cast),
            "cc" => Ok(Self::Cc),
            "copy" => Ok(Self::Copy),
            "cp" => Ok(Self::Cp),
            "create" => Ok(Self::Create),
            "dateOp" => Ok(Self::DateOp),
            "escape" => Ok(Self::Escape),
            "evaluate" => Ok(Self::Evaluate),
            "id" => Ok(Self::Id),
            "pointer" => Ok(Self::Pointer),
            "qty" => Ok(Self::Qty),
            "reference" => Ok(Self::Reference),
            "translate" => Ok(Self::Translate),
            "truncate" => Ok(Self::Truncate),
            "uuid" => Ok(Self::Uuid),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapTransform {
    fn as_ref(&self) -> &str {
        match self {
            Self::Append => "append",
            Self::C => "c",
            Self::Cast => "cast",
            Self::Cc => "cc",
            Self::Copy => "copy",
            Self::Cp => "cp",
            Self::Create => "create",
            Self::DateOp => "dateOp",
            Self::Escape => "escape",
            Self::Evaluate => "evaluate",
            Self::Id => "id",
            Self::Pointer => "pointer",
            Self::Qty => "qty",
            Self::Reference => "reference",
            Self::Translate => "translate",
            Self::Truncate => "truncate",
            Self::Uuid => "uuid",
        }
    }
}
impl ::std::fmt::Debug for StructureMapTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StructureMapTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StructureMapTransform {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapTransform {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapTransform> for Coding {
    fn from(code: StructureMapTransform) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/map-transform".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StructureMapTransform> for CodeableConcept {
    fn from(code: StructureMapTransform) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[StudyType](http://hl7.org/fhir/ValueSet/study-type)**. The type of study the evidence was derived from.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum StudyType {
    /** **CCT**

controlled trial (non-randomized). controlled (but not randomized) trial. */
    Cct,
    /** **RCT**

randomized trial. randomized controlled trial. */
    Rct,
    /** **case-control**

case-control study. case-control study. */
    CaseControl,
    /** **case-report**

case report. a single case report. */
    CaseReport,
    /** **cohort**

comparative cohort study. observational study comparing cohorts. */
    Cohort,
    /** **mixed**

mixed methods. a combination of 1 or more types of studies. */
    Mixed,
    /** **series**

uncontrolled cohort or case series. uncontrolled cohort or case series. */
    Series,
}
impl ::core::str::FromStr for StudyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CCT" => Ok(Self::Cct),
            "RCT" => Ok(Self::Rct),
            "case-control" => Ok(Self::CaseControl),
            "case-report" => Ok(Self::CaseReport),
            "cohort" => Ok(Self::Cohort),
            "mixed" => Ok(Self::Mixed),
            "series" => Ok(Self::Series),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StudyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cct => "CCT",
            Self::Rct => "RCT",
            Self::CaseControl => "case-control",
            Self::CaseReport => "case-report",
            Self::Cohort => "cohort",
            Self::Mixed => "mixed",
            Self::Series => "series",
        }
    }
}
impl ::std::fmt::Debug for StudyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for StudyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for StudyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StudyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StudyType> for Coding {
    fn from(code: StudyType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/study-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<StudyType> for CodeableConcept {
    fn from(code: StudyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubscriberRelationshipCodes](http://terminology.hl7.org/CodeSystem/subscriber-relationship)**. This value set includes codes for the relationship between the Subscriber and the Beneficiary (insured/covered party/patient).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum SubscriberRelationshipCodes {
    /** **child**

Child. The Beneficiary is a child of the Subscriber */
    Child,
    /** **common**

Common Law Spouse. The Beneficiary is a common law spouse or equivalent of the Subscriber */
    Common,
    /** **injured**

Injured Party. The Beneficiary is covered under insurance of the subscriber due to an injury. */
    Injured,
    /** **other**

Other. The Beneficiary has some other relationship the Subscriber */
    Other,
    /** **parent**

Parent. The Beneficiary is a parent of the Subscriber */
    Parent,
    /** **self**

Self. The Beneficiary is the Subscriber */
    _Self,
    /** **spouse**

Spouse. The Beneficiary is a spouse or equivalent of the Subscriber */
    Spouse,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SubscriberRelationshipCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "child" => Ok(Self::Child),
            "common" => Ok(Self::Common),
            "injured" => Ok(Self::Injured),
            "other" => Ok(Self::Other),
            "parent" => Ok(Self::Parent),
            "self" => Ok(Self::_Self),
            "spouse" => Ok(Self::Spouse),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SubscriberRelationshipCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Child => "child",
            Self::Common => "common",
            Self::Injured => "injured",
            Self::Other => "other",
            Self::Parent => "parent",
            Self::_Self => "self",
            Self::Spouse => "spouse",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for SubscriberRelationshipCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubscriberRelationshipCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubscriberRelationshipCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriberRelationshipCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriberRelationshipCodes> for Coding {
    fn from(code: SubscriberRelationshipCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/subscriber-relationship"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubscriberRelationshipCodes> for CodeableConcept {
    fn from(code: SubscriberRelationshipCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubscriptionChannelType](http://hl7.org/fhir/ValueSet/subscription-channel-type)**. The type of method used to execute a subscription.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubscriptionChannelType {
    /** **email**

Email. The channel is executed by sending an email to the email addressed in the URI (which must be a mailto:). */
    Email,
    /** **message**

Message. The channel is executed by sending a message (e.g. a Bundle with a MessageHeader resource etc.) to the application identified in the URI. */
    Message,
    /** **rest-hook**

Rest Hook. The channel is executed by making a post to the URI. If a payload is included, the URL is interpreted as the service base, and an update (PUT) is made. */
    RestHook,
    /** **sms**

SMS. The channel is executed by sending an SMS message to the phone number identified in the URL (tel:). */
    Sms,
    /** **websocket**

Websocket. The channel is executed by sending a packet across a web socket connection maintained by the client. The URL identifies the websocket, and the client binds to this URL. */
    Websocket,
}
impl ::core::str::FromStr for SubscriptionChannelType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "email" => Ok(Self::Email),
            "message" => Ok(Self::Message),
            "rest-hook" => Ok(Self::RestHook),
            "sms" => Ok(Self::Sms),
            "websocket" => Ok(Self::Websocket),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionChannelType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Email => "email",
            Self::Message => "message",
            Self::RestHook => "rest-hook",
            Self::Sms => "sms",
            Self::Websocket => "websocket",
        }
    }
}
impl ::std::fmt::Debug for SubscriptionChannelType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubscriptionChannelType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubscriptionChannelType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionChannelType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionChannelType> for Coding {
    fn from(code: SubscriptionChannelType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/subscription-channel-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubscriptionChannelType> for CodeableConcept {
    fn from(code: SubscriptionChannelType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubscriptionNotificationType](http://hl7.org/fhir/ValueSet/subscription-notification-type)**. The type of notification represented by the status message.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubscriptionNotificationType {
    /** **event-notification**

Event Notification. The status was generated for an event to the subscriber. */
    EventNotification,
    /** **handshake**

Handshake. The status was generated as part of the setup or verification of a communications channel. */
    Handshake,
    /** **heartbeat**

Heartbeat. The status was generated to perform a heartbeat notification to the subscriber. */
    Heartbeat,
    /** **query-event**

Query Event. The status was generated in response to an event query/request. */
    QueryEvent,
    /** **query-status**

Query Status. The status was generated in response to a status query/request. */
    QueryStatus,
}
impl ::core::str::FromStr for SubscriptionNotificationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "event-notification" => Ok(Self::EventNotification),
            "handshake" => Ok(Self::Handshake),
            "heartbeat" => Ok(Self::Heartbeat),
            "query-event" => Ok(Self::QueryEvent),
            "query-status" => Ok(Self::QueryStatus),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionNotificationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::EventNotification => "event-notification",
            Self::Handshake => "handshake",
            Self::Heartbeat => "heartbeat",
            Self::QueryEvent => "query-event",
            Self::QueryStatus => "query-status",
        }
    }
}
impl ::std::fmt::Debug for SubscriptionNotificationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubscriptionNotificationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubscriptionNotificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionNotificationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionNotificationType> for Coding {
    fn from(code: SubscriptionNotificationType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/subscription-notification-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubscriptionNotificationType> for CodeableConcept {
    fn from(code: SubscriptionNotificationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubscriptionSearchModifer](http://terminology.hl7.org/CodeSystem/subscription-search-modifier)**. This codesystem defines a set of codes that can be used to filter Subscription triggers.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum SubscriptionSearchModifer {
    /** **=**

=. Used to match a value according to FHIR Search rules (e.g., Patient/123, Encounter/2002). */
    Equal,
    /** **above**

Above. The search parameter is a concept with the form [system]|[code], and the search parameter tests whether the coding in a resource subsumes the specified search code. */
    Above,
    /** **ap**

Approximately. The value for the parameter in the resource is approximately the same to the provided value. Note that the recommended value for the approximation is 10% of the stated value (or for a date, 10% of the gap between now and the date), but systems may choose other values where appropriate. */
    Ap,
    /** **below**

Below. The search parameter is a concept with the form [system]|[code], and the search parameter tests whether the coding in a resource is subsumed by the specified search code. */
    Below,
    /** **eb**

Ends Before. The value for the parameter in the resource ends before the provided value. */
    Eb,
    /** **eq**

Equal. The value for the parameter in the resource is equal to the provided value. */
    Eq,
    /** **ge**

Greater Than or Equal. The value for the parameter in the resource is greater or equal to the provided value. */
    Ge,
    /** **gt**

Greater Than. The value for the parameter in the resource is greater than the provided value. */
    Gt,
    /** **in**

In. The search parameter is a member of a Group or List, or the search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the value is present in the specified Group, List, or Value Set. */
    In,
    /** **le**

Less Than or Equal. The value for the parameter in the resource is less or equal to the provided value. */
    Le,
    /** **lt**

Less Than. The value for the parameter in the resource is less than the provided value. */
    Lt,
    /** **ne**

Not Equal. The value for the parameter in the resource is not equal to the provided value. */
    Ne,
    /** **not-in**

Not In. The search parameter is a member of a Group or List, or the search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the value is NOT present in the specified Group, List, or Value Set. */
    NotIn,
    /** **of-type**

Of Type. The search parameter has the format system|code|value, where the system and code refer to a Identifier.type.coding.system and .code, and match if any of the type codes match. All 3 parts must be present. */
    OfType,
    /** **sa**

Starts After. The value for the parameter in the resource starts after the provided value. */
    Sa,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SubscriptionSearchModifer {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "=" => Ok(Self::Equal),
            "above" => Ok(Self::Above),
            "ap" => Ok(Self::Ap),
            "below" => Ok(Self::Below),
            "eb" => Ok(Self::Eb),
            "eq" => Ok(Self::Eq),
            "ge" => Ok(Self::Ge),
            "gt" => Ok(Self::Gt),
            "in" => Ok(Self::In),
            "le" => Ok(Self::Le),
            "lt" => Ok(Self::Lt),
            "ne" => Ok(Self::Ne),
            "not-in" => Ok(Self::NotIn),
            "of-type" => Ok(Self::OfType),
            "sa" => Ok(Self::Sa),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SubscriptionSearchModifer {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equal => "=",
            Self::Above => "above",
            Self::Ap => "ap",
            Self::Below => "below",
            Self::Eb => "eb",
            Self::Eq => "eq",
            Self::Ge => "ge",
            Self::Gt => "gt",
            Self::In => "in",
            Self::Le => "le",
            Self::Lt => "lt",
            Self::Ne => "ne",
            Self::NotIn => "not-in",
            Self::OfType => "of-type",
            Self::Sa => "sa",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for SubscriptionSearchModifer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubscriptionSearchModifer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubscriptionSearchModifer {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionSearchModifer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionSearchModifer> for Coding {
    fn from(code: SubscriptionSearchModifer) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/subscription-search-modifier"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubscriptionSearchModifer> for CodeableConcept {
    fn from(code: SubscriptionSearchModifer) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubscriptionStatus](http://hl7.org/fhir/ValueSet/subscription-status)**. The status of a subscription.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubscriptionStatus {
    /** **active**

Active. The subscription is active. */
    Active,
    /** **error**

Error. The server has an error executing the notification. */
    Error,
    /** **off**

Off. Too many errors have occurred or the subscription has expired. */
    Off,
    /** **requested**

Requested. The client has requested the subscription, and the server has not yet set it up. */
    Requested,
}
impl ::core::str::FromStr for SubscriptionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "error" => Ok(Self::Error),
            "off" => Ok(Self::Off),
            "requested" => Ok(Self::Requested),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Error => "error",
            Self::Off => "off",
            Self::Requested => "requested",
        }
    }
}
impl ::std::fmt::Debug for SubscriptionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubscriptionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubscriptionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionStatus> for Coding {
    fn from(code: SubscriptionStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/subscription-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubscriptionStatus> for CodeableConcept {
    fn from(code: SubscriptionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceAmountType](http://hl7.org/fhir/ValueSet/substance-amount-type)**. The type of a numeric quantity measurement.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceAmountType {
    /** **Approximately**

Approximately. */
    Approximately,
    /** **Average**

Average. */
    Average,
    /** **LessThan**

Less Than. */
    LessThan,
    /** **MoreThan**

More Than. */
    MoreThan,
}
impl ::core::str::FromStr for SubstanceAmountType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Approximately" => Ok(Self::Approximately),
            "Average" => Ok(Self::Average),
            "LessThan" => Ok(Self::LessThan),
            "MoreThan" => Ok(Self::MoreThan),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceAmountType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Approximately => "Approximately",
            Self::Average => "Average",
            Self::LessThan => "LessThan",
            Self::MoreThan => "MoreThan",
        }
    }
}
impl ::std::fmt::Debug for SubstanceAmountType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceAmountType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceAmountType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceAmountType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceAmountType> for Coding {
    fn from(code: SubstanceAmountType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-amount-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceAmountType> for CodeableConcept {
    fn from(code: SubstanceAmountType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceGrade](http://hl7.org/fhir/ValueSet/substance-grade)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceGrade {
    /** **BP**

British Pharmacopoeia. */
    Bp,
    /** **CompanyStandard**

Company Standard. */
    CompanyStandard,
    /** **JP**

Japanese Pharmacopoeia. */
    Jp,
    /** **Ph.Eur**

European Pharmacopoeia. */
    PhEur,
    /** **USP-NF**

USP/NF United States Pharmacopeia (USP) and the National Formulary (NF). */
    UspNf,
}
impl ::core::str::FromStr for SubstanceGrade {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BP" => Ok(Self::Bp),
            "CompanyStandard" => Ok(Self::CompanyStandard),
            "JP" => Ok(Self::Jp),
            "Ph.Eur" => Ok(Self::PhEur),
            "USP-NF" => Ok(Self::UspNf),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceGrade {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bp => "BP",
            Self::CompanyStandard => "CompanyStandard",
            Self::Jp => "JP",
            Self::PhEur => "Ph.Eur",
            Self::UspNf => "USP-NF",
        }
    }
}
impl ::std::fmt::Debug for SubstanceGrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceGrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceGrade {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceGrade {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceGrade> for Coding {
    fn from(code: SubstanceGrade) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/substance-grade".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceGrade> for CodeableConcept {
    fn from(code: SubstanceGrade) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceNameAuthority](http://hl7.org/fhir/ValueSet/substance-name-authority)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceNameAuthority {
    /** **BAN**

BAN. */
    Ban,
    /** **COSING**

COSING. */
    Cosing,
    /** **FCC**

FCC. */
    Fcc,
    /** **HAB**

HAB. */
    Hab,
    /** **INCI**

INCI. */
    Inci,
    /** **INN**

INN. */
    Inn,
    /** **IUIS**

IUIS. */
    Iuis,
    /** **JAN**

JAN. */
    Jan,
    /** **JECFA**

JECFA. */
    Jecfa,
    /** **MARTINDALE**

MARTINDALE. */
    Martindale,
    /** **PHF**

PHF. */
    Phf,
    /** **Ph.Eur.**

Ph.Eur.. */
    PhEur,
    /** **PhF**

PhF (Pharmacopée française). */
    PhF,
    /** **USAN**

USAN. */
    Usan,
    /** **USP**

USP. */
    Usp,
}
impl ::core::str::FromStr for SubstanceNameAuthority {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BAN" => Ok(Self::Ban),
            "COSING" => Ok(Self::Cosing),
            "FCC" => Ok(Self::Fcc),
            "HAB" => Ok(Self::Hab),
            "INCI" => Ok(Self::Inci),
            "INN" => Ok(Self::Inn),
            "IUIS" => Ok(Self::Iuis),
            "JAN" => Ok(Self::Jan),
            "JECFA" => Ok(Self::Jecfa),
            "MARTINDALE" => Ok(Self::Martindale),
            "PHF" => Ok(Self::Phf),
            "Ph.Eur." => Ok(Self::PhEur),
            "PhF" => Ok(Self::PhF),
            "USAN" => Ok(Self::Usan),
            "USP" => Ok(Self::Usp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceNameAuthority {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ban => "BAN",
            Self::Cosing => "COSING",
            Self::Fcc => "FCC",
            Self::Hab => "HAB",
            Self::Inci => "INCI",
            Self::Inn => "INN",
            Self::Iuis => "IUIS",
            Self::Jan => "JAN",
            Self::Jecfa => "JECFA",
            Self::Martindale => "MARTINDALE",
            Self::Phf => "PHF",
            Self::PhEur => "Ph.Eur.",
            Self::PhF => "PhF",
            Self::Usan => "USAN",
            Self::Usp => "USP",
        }
    }
}
impl ::std::fmt::Debug for SubstanceNameAuthority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceNameAuthority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceNameAuthority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceNameAuthority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceNameAuthority> for Coding {
    fn from(code: SubstanceNameAuthority) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-name-authority".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceNameAuthority> for CodeableConcept {
    fn from(code: SubstanceNameAuthority) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceNameDomain](http://hl7.org/fhir/ValueSet/substance-name-domain)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceNameDomain {
    /** **ActiveIngredient**

Active Ingredient. */
    ActiveIngredient,
    /** **FoodColorAdditive**

Food Color Additive. */
    FoodColorAdditive,
}
impl ::core::str::FromStr for SubstanceNameDomain {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActiveIngredient" => Ok(Self::ActiveIngredient),
            "FoodColorAdditive" => Ok(Self::FoodColorAdditive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceNameDomain {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActiveIngredient => "ActiveIngredient",
            Self::FoodColorAdditive => "FoodColorAdditive",
        }
    }
}
impl ::std::fmt::Debug for SubstanceNameDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceNameDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceNameDomain {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceNameDomain {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceNameDomain> for Coding {
    fn from(code: SubstanceNameDomain) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-name-domain".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceNameDomain> for CodeableConcept {
    fn from(code: SubstanceNameDomain) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceNameType](http://hl7.org/fhir/ValueSet/substance-name-type)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceNameType {
    /** **Brand**

brand. */
    Brand,
    /** **Scientific**

scientific. */
    Scientific,
    /** **Systematic**

systematic. */
    Systematic,
}
impl ::core::str::FromStr for SubstanceNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Brand" => Ok(Self::Brand),
            "Scientific" => Ok(Self::Scientific),
            "Systematic" => Ok(Self::Systematic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Brand => "Brand",
            Self::Scientific => "Scientific",
            Self::Systematic => "Systematic",
        }
    }
}
impl ::std::fmt::Debug for SubstanceNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceNameType> for Coding {
    fn from(code: SubstanceNameType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/substance-name-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceNameType> for CodeableConcept {
    fn from(code: SubstanceNameType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceOpticalActivity](http://hl7.org/fhir/ValueSet/substance-optical-activity)**. The optical rotation type of a substance.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceOpticalActivity {
    /** **+**

dextrorotary. */
    Plus,
    /** **-**

levorotary. */
    Minus,
}
impl ::core::str::FromStr for SubstanceOpticalActivity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "+" => Ok(Self::Plus),
            "-" => Ok(Self::Minus),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceOpticalActivity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Plus => "+",
            Self::Minus => "-",
        }
    }
}
impl ::std::fmt::Debug for SubstanceOpticalActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceOpticalActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceOpticalActivity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceOpticalActivity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceOpticalActivity> for Coding {
    fn from(code: SubstanceOpticalActivity) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-optical-activity".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceOpticalActivity> for CodeableConcept {
    fn from(code: SubstanceOpticalActivity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceRelationshipType](http://hl7.org/fhir/ValueSet/substance-relationship-type)**. The relationship between two substance types.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceRelationshipType {
    /** **ActiveMoiety**

Active moiety. */
    ActiveMoiety,
    /** **Impurity**

Impurity of. */
    Impurity,
    /** **Polymorph**

Polymorph of. */
    Polymorph,
    /** **Salt**

Salt to parent. */
    Salt,
    /** **StartingMaterial**

Starting material for. */
    StartingMaterial,
}
impl ::core::str::FromStr for SubstanceRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActiveMoiety" => Ok(Self::ActiveMoiety),
            "Impurity" => Ok(Self::Impurity),
            "Polymorph" => Ok(Self::Polymorph),
            "Salt" => Ok(Self::Salt),
            "StartingMaterial" => Ok(Self::StartingMaterial),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActiveMoiety => "ActiveMoiety",
            Self::Impurity => "Impurity",
            Self::Polymorph => "Polymorph",
            Self::Salt => "Salt",
            Self::StartingMaterial => "StartingMaterial",
        }
    }
}
impl ::std::fmt::Debug for SubstanceRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceRelationshipType> for Coding {
    fn from(code: SubstanceRelationshipType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-relationship-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceRelationshipType> for CodeableConcept {
    fn from(code: SubstanceRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceRepresentationFormat](http://hl7.org/fhir/ValueSet/substance-representation-format)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceRepresentationFormat {
    /** **CDX**

CDX. */
    Cdx,
    /** **InChI**

InChI. */
    InChI,
    /** **MOLFILE**

MOLFILE. */
    Molfile,
    /** **PDB**

PDB. */
    Pdb,
    /** **SDF**

SDF. */
    Sdf,
    /** **SMILES**

SMILES. */
    Smiles,
    /** **mmCIF**

mmCIF. */
    MmCIF,
}
impl ::core::str::FromStr for SubstanceRepresentationFormat {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CDX" => Ok(Self::Cdx),
            "InChI" => Ok(Self::InChI),
            "MOLFILE" => Ok(Self::Molfile),
            "PDB" => Ok(Self::Pdb),
            "SDF" => Ok(Self::Sdf),
            "SMILES" => Ok(Self::Smiles),
            "mmCIF" => Ok(Self::MmCIF),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceRepresentationFormat {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cdx => "CDX",
            Self::InChI => "InChI",
            Self::Molfile => "MOLFILE",
            Self::Pdb => "PDB",
            Self::Sdf => "SDF",
            Self::Smiles => "SMILES",
            Self::MmCIF => "mmCIF",
        }
    }
}
impl ::std::fmt::Debug for SubstanceRepresentationFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceRepresentationFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceRepresentationFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceRepresentationFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceRepresentationFormat> for Coding {
    fn from(code: SubstanceRepresentationFormat) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-representation-format".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceRepresentationFormat> for CodeableConcept {
    fn from(code: SubstanceRepresentationFormat) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceRepresentationType](http://hl7.org/fhir/ValueSet/substance-representation-type)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceRepresentationType {
    /** **Brand**

brand. */
    Brand,
    /** **Scientific**

scientific. */
    Scientific,
    /** **Systematic**

systematic. */
    Systematic,
}
impl ::core::str::FromStr for SubstanceRepresentationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Brand" => Ok(Self::Brand),
            "Scientific" => Ok(Self::Scientific),
            "Systematic" => Ok(Self::Systematic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceRepresentationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Brand => "Brand",
            Self::Scientific => "Scientific",
            Self::Systematic => "Systematic",
        }
    }
}
impl ::std::fmt::Debug for SubstanceRepresentationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceRepresentationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceRepresentationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceRepresentationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceRepresentationType> for Coding {
    fn from(code: SubstanceRepresentationType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-representation-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceRepresentationType> for CodeableConcept {
    fn from(code: SubstanceRepresentationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceSourceMaterialGenus](http://hl7.org/fhir/ValueSet/substance-source-material-genus)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialGenus {
    /** **Ginkgo**

Ginkgo. */
    Ginkgo,
    /** **InfluenzavirusA**

Influenza A virus. */
    InfluenzavirusA,
    /** **Mycobacterium**

Mycobacterium. */
    Mycobacterium,
}
impl ::core::str::FromStr for SubstanceSourceMaterialGenus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Ginkgo" => Ok(Self::Ginkgo),
            "InfluenzavirusA" => Ok(Self::InfluenzavirusA),
            "Mycobacterium" => Ok(Self::Mycobacterium),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialGenus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ginkgo => "Ginkgo",
            Self::InfluenzavirusA => "InfluenzavirusA",
            Self::Mycobacterium => "Mycobacterium",
        }
    }
}
impl ::std::fmt::Debug for SubstanceSourceMaterialGenus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceSourceMaterialGenus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialGenus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialGenus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceSourceMaterialGenus> for Coding {
    fn from(code: SubstanceSourceMaterialGenus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-source-material-genus".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceSourceMaterialGenus> for CodeableConcept {
    fn from(code: SubstanceSourceMaterialGenus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceSourceMaterialPart](http://hl7.org/fhir/ValueSet/substance-source-material-part)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialPart {
    /** **Animal**

animal. */
    Animal,
    /** **Mineral**

mineral. */
    Mineral,
    /** **Plant**

plant. */
    Plant,
}
impl ::core::str::FromStr for SubstanceSourceMaterialPart {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Animal" => Ok(Self::Animal),
            "Mineral" => Ok(Self::Mineral),
            "Plant" => Ok(Self::Plant),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialPart {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "Animal",
            Self::Mineral => "Mineral",
            Self::Plant => "Plant",
        }
    }
}
impl ::std::fmt::Debug for SubstanceSourceMaterialPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceSourceMaterialPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceSourceMaterialPart> for Coding {
    fn from(code: SubstanceSourceMaterialPart) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-source-material-part".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceSourceMaterialPart> for CodeableConcept {
    fn from(code: SubstanceSourceMaterialPart) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceSourceMaterialSpecies](http://hl7.org/fhir/ValueSet/substance-source-material-species)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialSpecies {
    /** **GinkgoBiloba**

Ginkgo biloba. */
    GinkgoBiloba,
    /** **OleaEuropaea**

Olea europaea. */
    OleaEuropaea,
}
impl ::core::str::FromStr for SubstanceSourceMaterialSpecies {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "GinkgoBiloba" => Ok(Self::GinkgoBiloba),
            "OleaEuropaea" => Ok(Self::OleaEuropaea),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialSpecies {
    fn as_ref(&self) -> &str {
        match self {
            Self::GinkgoBiloba => "GinkgoBiloba",
            Self::OleaEuropaea => "OleaEuropaea",
        }
    }
}
impl ::std::fmt::Debug for SubstanceSourceMaterialSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceSourceMaterialSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialSpecies {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialSpecies {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceSourceMaterialSpecies> for Coding {
    fn from(code: SubstanceSourceMaterialSpecies) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-source-material-species"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceSourceMaterialSpecies> for CodeableConcept {
    fn from(code: SubstanceSourceMaterialSpecies) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceSourceMaterialType](http://hl7.org/fhir/ValueSet/substance-source-material-type)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialType {
    /** **Animal**

animal. */
    Animal,
    /** **Mineral**

mineral. */
    Mineral,
    /** **Plant**

plant. */
    Plant,
}
impl ::core::str::FromStr for SubstanceSourceMaterialType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Animal" => Ok(Self::Animal),
            "Mineral" => Ok(Self::Mineral),
            "Plant" => Ok(Self::Plant),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "Animal",
            Self::Mineral => "Mineral",
            Self::Plant => "Plant",
        }
    }
}
impl ::std::fmt::Debug for SubstanceSourceMaterialType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceSourceMaterialType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceSourceMaterialType> for Coding {
    fn from(code: SubstanceSourceMaterialType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-source-material-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceSourceMaterialType> for CodeableConcept {
    fn from(code: SubstanceSourceMaterialType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceStereochemistry](http://hl7.org/fhir/ValueSet/substance-stereochemistry)**. The stereochemistry type of a substance.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceStereochemistry {
    /** **ConstitutionalIsomer**

constitutional isomer. */
    ConstitutionalIsomer,
    /** **Enantiomer**

enantiomer. */
    Enantiomer,
    /** **Stereoisomer**

stereoisomer. */
    Stereoisomer,
}
impl ::core::str::FromStr for SubstanceStereochemistry {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ConstitutionalIsomer" => Ok(Self::ConstitutionalIsomer),
            "Enantiomer" => Ok(Self::Enantiomer),
            "Stereoisomer" => Ok(Self::Stereoisomer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceStereochemistry {
    fn as_ref(&self) -> &str {
        match self {
            Self::ConstitutionalIsomer => "ConstitutionalIsomer",
            Self::Enantiomer => "Enantiomer",
            Self::Stereoisomer => "Stereoisomer",
        }
    }
}
impl ::std::fmt::Debug for SubstanceStereochemistry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceStereochemistry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceStereochemistry {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceStereochemistry {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceStereochemistry> for Coding {
    fn from(code: SubstanceStereochemistry) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-stereochemistry".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceStereochemistry> for CodeableConcept {
    fn from(code: SubstanceStereochemistry) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceStructureTechnique](http://hl7.org/fhir/ValueSet/substance-structure-technique)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceStructureTechnique {
    /** **HPLC**

HPLC. */
    Hplc,
    /** **LigandBindingAssay**

Ligand binding assay. */
    LigandBindingAssay,
    /** **NMR**

NMR. */
    Nmr,
    /** **PeptideMapping**

Peptide mapping. */
    PeptideMapping,
    /** **X-Ray**

X-ray. */
    XRay,
}
impl ::core::str::FromStr for SubstanceStructureTechnique {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "HPLC" => Ok(Self::Hplc),
            "LigandBindingAssay" => Ok(Self::LigandBindingAssay),
            "NMR" => Ok(Self::Nmr),
            "PeptideMapping" => Ok(Self::PeptideMapping),
            "X-Ray" => Ok(Self::XRay),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceStructureTechnique {
    fn as_ref(&self) -> &str {
        match self {
            Self::Hplc => "HPLC",
            Self::LigandBindingAssay => "LigandBindingAssay",
            Self::Nmr => "NMR",
            Self::PeptideMapping => "PeptideMapping",
            Self::XRay => "X-Ray",
        }
    }
}
impl ::std::fmt::Debug for SubstanceStructureTechnique {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceStructureTechnique {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceStructureTechnique {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceStructureTechnique {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceStructureTechnique> for Coding {
    fn from(code: SubstanceStructureTechnique) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-structure-technique".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceStructureTechnique> for CodeableConcept {
    fn from(code: SubstanceStructureTechnique) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceWeightMethod](http://hl7.org/fhir/ValueSet/substance-weight-method)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceWeightMethod {
    /** **Calculated**

calculated. */
    Calculated,
    /** **End-groupAnalysis**

End-group analysis. */
    EndGroupAnalysis,
    /** **End-groupTitration**

End-group titration. */
    EndGroupTitration,
    /** **GelPermeationCentrifugation**

gel permeation centrifugation. */
    GelPermeationCentrifugation,
    /** **LighScattering**

light scattering. */
    LighScattering,
    /** **SDS-PAGE**

SDS-PAGE (sodium dodecyl sulfate-polyacrylamide gel electrophoresis). */
    SdsPage,
    /** **Size-ExclusionChromatography**

Size-exclusion chromatography. */
    SizeExclusionChromatography,
    /** **Viscosity**

viscosity. */
    Viscosity,
}
impl ::core::str::FromStr for SubstanceWeightMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Calculated" => Ok(Self::Calculated),
            "End-groupAnalysis" => Ok(Self::EndGroupAnalysis),
            "End-groupTitration" => Ok(Self::EndGroupTitration),
            "GelPermeationCentrifugation" => Ok(Self::GelPermeationCentrifugation),
            "LighScattering" => Ok(Self::LighScattering),
            "SDS-PAGE" => Ok(Self::SdsPage),
            "Size-ExclusionChromatography" => Ok(Self::SizeExclusionChromatography),
            "Viscosity" => Ok(Self::Viscosity),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceWeightMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calculated => "Calculated",
            Self::EndGroupAnalysis => "End-groupAnalysis",
            Self::EndGroupTitration => "End-groupTitration",
            Self::GelPermeationCentrifugation => "GelPermeationCentrifugation",
            Self::LighScattering => "LighScattering",
            Self::SdsPage => "SDS-PAGE",
            Self::SizeExclusionChromatography => "Size-ExclusionChromatography",
            Self::Viscosity => "Viscosity",
        }
    }
}
impl ::std::fmt::Debug for SubstanceWeightMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceWeightMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceWeightMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceWeightMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceWeightMethod> for Coding {
    fn from(code: SubstanceWeightMethod) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-weight-method".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceWeightMethod> for CodeableConcept {
    fn from(code: SubstanceWeightMethod) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SubstanceWeightType](http://hl7.org/fhir/ValueSet/substance-weight-type)**.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SubstanceWeightType {
    /** **Average**

number average. */
    Average,
    /** **Exact**

exact. */
    Exact,
    /** **WeightAverage**

weight average. */
    WeightAverage,
}
impl ::core::str::FromStr for SubstanceWeightType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Average" => Ok(Self::Average),
            "Exact" => Ok(Self::Exact),
            "WeightAverage" => Ok(Self::WeightAverage),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceWeightType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Average => "Average",
            Self::Exact => "Exact",
            Self::WeightAverage => "WeightAverage",
        }
    }
}
impl ::std::fmt::Debug for SubstanceWeightType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SubstanceWeightType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SubstanceWeightType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceWeightType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceWeightType> for Coding {
    fn from(code: SubstanceWeightType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/substance-weight-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SubstanceWeightType> for CodeableConcept {
    fn from(code: SubstanceWeightType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SupplyDeliveryStatus](http://hl7.org/fhir/ValueSet/supplydelivery-status)**. Status of the supply delivery.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SupplyDeliveryStatus {
    /** **abandoned**

Abandoned. Delivery was not completed. */
    Abandoned,
    /** **completed**

Delivered. Supply has been delivered ("completed"). */
    Completed,
    /** **entered-in-error**

Entered In Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "abandoned" rather than "entered-in-error".). */
    EnteredInError,
    /** **in-progress**

In Progress. Supply has been requested, but not delivered. */
    InProgress,
}
impl ::core::str::FromStr for SupplyDeliveryStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abandoned" => Ok(Self::Abandoned),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyDeliveryStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abandoned => "abandoned",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
        }
    }
}
impl ::std::fmt::Debug for SupplyDeliveryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SupplyDeliveryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SupplyDeliveryStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyDeliveryStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyDeliveryStatus> for Coding {
    fn from(code: SupplyDeliveryStatus) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/supplydelivery-status".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SupplyDeliveryStatus> for CodeableConcept {
    fn from(code: SupplyDeliveryStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SupplyItemType](http://terminology.hl7.org/CodeSystem/supply-item-type)**. This value sets refers to a specific supply item.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum SupplyItemType {
    /** **device**

Device. What is supplied (or requested) is a device. */
    Device,
    /** **medication**

Medication. Supply is a kind of medication. */
    Medication,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SupplyItemType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "device" => Ok(Self::Device),
            "medication" => Ok(Self::Medication),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SupplyItemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "device",
            Self::Medication => "medication",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for SupplyItemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SupplyItemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SupplyItemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyItemType> for Coding {
    fn from(code: SupplyItemType) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/supply-item-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SupplyItemType> for CodeableConcept {
    fn from(code: SupplyItemType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SupplyRequestReason](http://hl7.org/fhir/ValueSet/supplyrequest-reason)**. The reason why the supply item was requested.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SupplyRequestReason {
    /** **patient-care**

Patient Care. The supply has been requested for use in direct patient care. */
    PatientCare,
    /** **ward-stock**

Ward Stock. The supply has been requested for creating or replenishing ward stock. */
    WardStock,
}
impl ::core::str::FromStr for SupplyRequestReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "patient-care" => Ok(Self::PatientCare),
            "ward-stock" => Ok(Self::WardStock),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyRequestReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::PatientCare => "patient-care",
            Self::WardStock => "ward-stock",
        }
    }
}
impl ::std::fmt::Debug for SupplyRequestReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SupplyRequestReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SupplyRequestReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyRequestReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyRequestReason> for Coding {
    fn from(code: SupplyRequestReason) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/supplyrequest-reason".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SupplyRequestReason> for CodeableConcept {
    fn from(code: SupplyRequestReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SupplyRequestStatus](http://hl7.org/fhir/ValueSet/supplyrequest-status)**. Status of the supply request.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SupplyRequestStatus {
    /** **active**

Active. The request is ready to be acted upon. */
    Active,
    /** **cancelled**

Cancelled. The authorization/request to act has been terminated prior to the full completion of the intended actions.  No further activity should occur. */
    Cancelled,
    /** **completed**

Completed. Activity against the request has been sufficiently completed to the satisfaction of the requester. */
    Completed,
    /** **draft**

Draft. The request has been created but is not yet complete or ready for action. */
    Draft,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **suspended**

Suspended. The authorization/request to act has been temporarily withdrawn but is expected to resume in the future. */
    Suspended,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for SupplyRequestStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "suspended" => Ok(Self::Suspended),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyRequestStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Suspended => "suspended",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for SupplyRequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SupplyRequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SupplyRequestStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyRequestStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyRequestStatus> for Coding {
    fn from(code: SupplyRequestStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/supplyrequest-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SupplyRequestStatus> for CodeableConcept {
    fn from(code: SupplyRequestStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SupplyType](http://terminology.hl7.org/CodeSystem/supply-kind)**. This value sets refers to a Category of supply.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum SupplyType {
    /** **central**

Central Supply. Supply is stored and requested from central supply. */
    Central,
    /** **nonstock**

Non-Stock. Supply is not onsite and must be requested from an outside vendor using a non-stock requisition. */
    Nonstock,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SupplyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "central" => Ok(Self::Central),
            "nonstock" => Ok(Self::Nonstock),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SupplyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Central => "central",
            Self::Nonstock => "nonstock",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for SupplyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SupplyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SupplyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyType> for Coding {
    fn from(code: SupplyType) -> Self {
        CodingInner {
            system: Some("http://terminology.hl7.org/CodeSystem/supply-kind".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SupplyType> for CodeableConcept {
    fn from(code: SupplyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SurfaceCodes](http://terminology.hl7.org/CodeSystem/FDI-surface)**. This value set includes a smattering of FDI tooth surface codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum SurfaceCodes {
    /** **B**

Buccal. The surface of a posterior tooth facing the cheeks. */
    B,
    /** **D**

Distal. The surface of a tooth that faces away from the midline of the face. */
    D,
    /** **DI**

Distoincisal. The Distoincisal surfaces of a tooth. */
    Di,
    /** **DO**

Distoclusal. The Distoclusal surfaces of a tooth. */
    Do,
    /** **I**

Incisal. The biting edge of anterior teeth. */
    I,
    /** **L**

Lingual. The surface of a tooth facing the tongue. */
    L,
    /** **M**

Mesial. The surface of a tooth that is closest to the midline (middle) of the face. */
    M,
    /** **MO**

Mesioclusal. The Mesioclusal surfaces of a tooth. */
    Mo,
    /** **MOD**

Mesioclusodistal. The Mesioclusodistal surfaces of a tooth. */
    Mod,
    /** **O**

Occlusal. The chewing surface of posterior teeth. */
    O,
    /** **V**

Ventral. The surface of a tooth facing the lips. */
    V,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SurfaceCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "B" => Ok(Self::B),
            "D" => Ok(Self::D),
            "DI" => Ok(Self::Di),
            "DO" => Ok(Self::Do),
            "I" => Ok(Self::I),
            "L" => Ok(Self::L),
            "M" => Ok(Self::M),
            "MO" => Ok(Self::Mo),
            "MOD" => Ok(Self::Mod),
            "O" => Ok(Self::O),
            "V" => Ok(Self::V),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SurfaceCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::B => "B",
            Self::D => "D",
            Self::Di => "DI",
            Self::Do => "DO",
            Self::I => "I",
            Self::L => "L",
            Self::M => "M",
            Self::Mo => "MO",
            Self::Mod => "MOD",
            Self::O => "O",
            Self::V => "V",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for SurfaceCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SurfaceCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SurfaceCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SurfaceCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SurfaceCodes> for Coding {
    fn from(code: SurfaceCodes) -> Self {
        CodingInner {
            system: Some("http://terminology.hl7.org/CodeSystem/FDI-surface".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SurfaceCodes> for CodeableConcept {
    fn from(code: SurfaceCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[SynthesisType](http://hl7.org/fhir/ValueSet/synthesis-type)**. Types of combining results from a body of evidence (eg. summary data meta-analysis).\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum SynthesisType {
    /** **IPD-MA**

individual patient data meta-analysis. A meta-analysis of the individual participant data from individual studies or data sets. */
    IpdMa,
    /** **NotApplicable**

not applicable. Not applicable because the evidence is not from a synthesis but from a single study. Used fo explicitly state that it's not a synthesis. */
    NotApplicable,
    /** **classification**

classifcation of results. An approach describing a body of evidence by categorically classifying individual studies (eg 3 studies showed beneft and 2 studied found no effect). */
    Classification,
    /** **combined-NMA**

combined direct plus indirect network meta-analysis. An composite meta-analysis derived from direct comparisons and indirect comparisons in a network meta-analysis. */
    CombinedNMA,
    /** **indirect-NMA**

indirect network meta-analysis. An indirect meta-analysis derived from 2 or more direct comparisons in a network meta-analysis. */
    IndirectNMA,
    /** **range**

range of results. A range of results across a body of evidence. */
    Range,
    /** **std-MA**

summary data meta-analysis. A meta-analysis of the summary data of estimates from individual studies or data sets. */
    StdMA,
}
impl ::core::str::FromStr for SynthesisType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "IPD-MA" => Ok(Self::IpdMa),
            "NotApplicable" => Ok(Self::NotApplicable),
            "classification" => Ok(Self::Classification),
            "combined-NMA" => Ok(Self::CombinedNMA),
            "indirect-NMA" => Ok(Self::IndirectNMA),
            "range" => Ok(Self::Range),
            "std-MA" => Ok(Self::StdMA),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SynthesisType {
    fn as_ref(&self) -> &str {
        match self {
            Self::IpdMa => "IPD-MA",
            Self::NotApplicable => "NotApplicable",
            Self::Classification => "classification",
            Self::CombinedNMA => "combined-NMA",
            Self::IndirectNMA => "indirect-NMA",
            Self::Range => "range",
            Self::StdMA => "std-MA",
        }
    }
}
impl ::std::fmt::Debug for SynthesisType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for SynthesisType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for SynthesisType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SynthesisType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SynthesisType> for Coding {
    fn from(code: SynthesisType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/synthesis-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<SynthesisType> for CodeableConcept {
    fn from(code: SynthesisType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TargetSpecies](http://hl7.org/fhir/ValueSet/target-species)**. A species for which a medicinal product is intended.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TargetSpecies {
    /** **100000108874**

Dove. */
    N100000108874,
    /** **100000108875**

Quail. */
    N100000108875,
    /** **100000108876**

Snipe. */
    N100000108876,
    /** **100000108877**

Sparrow. */
    N100000108877,
    /** **100000108878**

Starling. */
    N100000108878,
    /** **100000108879**

Swan. */
    N100000108879,
    /** **100000108880**

Turkey hen. */
    N100000108880,
    /** **100000108881**

Turkey cock. */
    N100000108881,
    /** **100000108882**

Turkeys. */
    N100000108882,
    /** **100000108883**

Turkey for reproduction. */
    N100000108883,
    /** **100000108884**

Poult. */
    N100000108884,
    /** **100000108885**

Turtle dove. */
    N100000108885,
    /** **100000108886**

Bison. */
    N100000108886,
    /** **100000108887**

Buffalo. */
    N100000108887,
    /** **100000108888**

Cows. */
    N100000108888,
    /** **100000108889**

Cow for reproduction. */
    N100000108889,
    /** **100000108890**

Bull for reproduction. */
    N100000108890,
    /** **100000108891**

Ox. */
    N100000108891,
    /** **100000108892**

Bullock. */
    N100000108892,
    /** **100000108893**

Cattle. */
    N100000108893,
    /** **100000108894**

Beef cattle. */
    N100000108894,
    /** **100000108895**

Dairy cattle. */
    N100000108895,
    /** **100000108896**

Dry cow. */
    N100000108896,
    /** **100000108897**

Bull. */
    N100000108897,
    /** **100000108898**

Lactating cow. */
    N100000108898,
    /** **100000108899**

All other food producing species. */
    N100000108899,
    /** **100000108900**

All non-food producing species. */
    N100000108900,
    /** **100000108901**

All species  . */
    N100000108901,
    /** **100000108902**

Carnivores. */
    N100000108902,
    /** **100000108903**

Domestic animals. */
    N100000108903,
    /** **100000108904**

Fur animals. */
    N100000108904,
    /** **100000108905**

Game animals. */
    N100000108905,
    /** **100000108906**

Laboratory animals. */
    N100000108906,
    /** **100000108907**

Major species. */
    N100000108907,
    /** **100000108908**

Minor species. */
    N100000108908,
    /** **100000108909**

Ruminant. */
    N100000108909,
    /** **100000108910**

Ruminant and porcine. */
    N100000108910,
    /** **100000108911**

Small animals. */
    N100000108911,
    /** **100000108912**

Crocodile. */
    N100000108912,
    /** **100000108913**

Frog. */
    N100000108913,
    /** **100000108914**

Iguana. */
    N100000108914,
    /** **100000108915**

Lizard. */
    N100000108915,
    /** **100000108916**

Amphibians. */
    N100000108916,
    /** **100000108917**

Reptiles. */
    N100000108917,
    /** **100000108918**

Reptiles for production. */
    N100000108918,
    /** **100000108919**

Snake. */
    N100000108919,
    /** **100000108920**

Tortoise. */
    N100000108920,
    /** **100000108921**

Turtle. */
    N100000108921,
    /** **100000108922**

Honey bees. */
    N100000108922,
    /** **100000108923**

Crustacean. */
    N100000108923,
    /** **100000108924**

Spider. */
    N100000108924,
    /** **100000108925**

Indian hen. */
    N100000108925,
    /** **100000108926**

African Goshawk. */
    N100000108926,
    /** **100000108927**

Black Kite. */
    N100000108927,
    /** **100000108928**

Budgerigar. */
    N100000108928,
    /** **100000108929**

Bustard. */
    N100000108929,
    /** **100000108930**

Buzzard. */
    N100000108930,
    /** **100000108931**

Hen. */
    N100000108931,
    /** **100000108932**

Layer hen. */
    N100000108932,
    /** **100000108933**

Cock. */
    N100000108933,
    /** **100000108934**

Broiler. */
    N100000108934,
    /** **100000108935**

Chickens. */
    N100000108935,
    /** **100000108936**

Chicken embryonated eggs. */
    N100000108936,
    /** **100000108937**

Chicken for reproduction. */
    N100000108937,
    /** **100000108938**

Replacement chick. */
    N100000108938,
    /** **100000108939**

Chick. */
    N100000108939,
    /** **100000108940**

Pullet. */
    N100000108940,
    /** **100000108941**

Cockatiel. */
    N100000108941,
    /** **100000108942**

Cockatoo. */
    N100000108942,
    /** **100000108943**

Common canary. */
    N100000108943,
    /** **100000108944**

Crow. */
    N100000108944,
    /** **100000108945**

Duck. */
    N100000108945,
    /** **100000108946**

Duck broiler. */
    N100000108946,
    /** **100000108947**

Duckling. */
    N100000108947,
    /** **100000108948**

Eagle. */
    N100000108948,
    /** **100000108949**

Emu. */
    N100000108949,
    /** **100000108950**

Goose. */
    N100000108950,
    /** **100000108951**

Guinea fowl. */
    N100000108951,
    /** **100000108952**

Kestrel. */
    N100000108952,
    /** **100000108953**

Kite. */
    N100000108953,
    /** **100000108954**

Macaw. */
    N100000108954,
    /** **100000108955**

Ostrich. */
    N100000108955,
    /** **100000108956**

Birds. */
    N100000108956,
    /** **100000108957**

Fowls. */
    N100000108957,
    /** **100000108958**

Finch. */
    N100000108958,
    /** **100000108959**

Galliformes. */
    N100000108959,
    /** **100000108960**

Game birds. */
    N100000108960,
    /** **100000108961**

Pekin duck. */
    N100000108961,
    /** **100000108962**

Ornamental birds. */
    N100000108962,
    /** **100000108963**

Poultry. */
    N100000108963,
    /** **100000108964**

Owl. */
    N100000108964,
    /** **100000108965**

Parakeet. */
    N100000108965,
    /** **100000108966**

Parrot. */
    N100000108966,
    /** **100000108967**

Partridge. */
    N100000108967,
    /** **100000108968**

Peregrine Falcon. */
    N100000108968,
    /** **100000108969**

Pheasants. */
    N100000108969,
    /** **100000108970**

Carrier pigeon. */
    N100000108970,
    /** **100000108971**

Newborn calves. */
    N100000108971,
    /** **100000108972**

Pregnant cow. */
    N100000108972,
    /** **100000108973**

Pregnant heifer. */
    N100000108973,
    /** **100000108974**

Pre-ruminant cattle. */
    N100000108974,
    /** **100000108975**

Ruminant cattle. */
    N100000108975,
    /** **100000108976**

Wild cattle. */
    N100000108976,
    /** **100000108977**

Calf. */
    N100000108977,
    /** **100000108978**

Heifers. */
    N100000108978,
    /** **100000108979**

Other Bovids. */
    N100000108979,
    /** **100000108980**

Alpaca. */
    N100000108980,
    /** **100000108981**

Camel. */
    N100000108981,
    /** **100000108982**

Llama. */
    N100000108982,
    /** **100000108983**

Other Camelids. */
    N100000108983,
    /** **100000108984**

Bitch. */
    N100000108984,
    /** **100000108985**

Bitch for reproduction. */
    N100000108985,
    /** **100000108986**

Adult male dog. */
    N100000108986,
    /** **100000108987**

Adult male dog for reproduction. */
    N100000108987,
    /** **100000108988**

Dogs. */
    N100000108988,
    /** **100000108989**

Lactating bitch. */
    N100000108989,
    /** **100000108990**

Large dog. */
    N100000108990,
    /** **100000108991**

Medium dog. */
    N100000108991,
    /** **100000108992**

Pregnant bitch. */
    N100000108992,
    /** **100000108993**

Small dog. */
    N100000108993,
    /** **100000108994**

Very large dog. */
    N100000108994,
    /** **100000108995**

Very small dog. */
    N100000108995,
    /** **100000108996**

Puppy. */
    N100000108996,
    /** **100000108997**

Foxes. */
    N100000108997,
    /** **100000108998**

Jackal. */
    N100000108998,
    /** **100000108999**

Other Canids. */
    N100000108999,
    /** **100000109000**

Raccoon dogs. */
    N100000109000,
    /** **100000109001**

Wolf. */
    N100000109001,
    /** **100000109002**

Chamois. */
    N100000109002,
    /** **100000109003**

Other Caprines. */
    N100000109003,
    /** **100000109004**

Adult female goat. */
    N100000109004,
    /** **100000109005**

Adult male goat. */
    N100000109005,
    /** **100000109006**

Dry adult female goat. */
    N100000109006,
    /** **100000109007**

Goats. */
    N100000109007,
    /** **100000109008**

Lactating adult female goat. */
    N100000109008,
    /** **100000109009**

Pregnant adult female goat. */
    N100000109009,
    /** **100000109010**

Pre-ruminant goat. */
    N100000109010,
    /** **100000109011**

Ruminant goat. */
    N100000109011,
    /** **100000109012**

Wild goat. */
    N100000109012,
    /** **100000109013**

Kid. */
    N100000109013,
    /** **100000109014**

Other Ovids. */
    N100000109014,
    /** **100000109015**

Ewe. */
    N100000109015,
    /** **100000109016**

Ram. */
    N100000109016,
    /** **100000109017**

Dry ewe. */
    N100000109017,
    /** **100000109018**

Lactating ewe. */
    N100000109018,
    /** **100000109019**

Pregnant ewe. */
    N100000109019,
    /** **100000109020**

Pre-ruminant sheep. */
    N100000109020,
    /** **100000109021**

Ruminant sheep. */
    N100000109021,
    /** **100000109022**

Sheep. */
    N100000109022,
    /** **100000109023**

Sheep for meat production. */
    N100000109023,
    /** **100000109024**

Dairy sheep. */
    N100000109024,
    /** **100000109025**

Wild sheep. */
    N100000109025,
    /** **100000109026**

Lamb. */
    N100000109026,
    /** **100000109027**

Elk. */
    N100000109027,
    /** **100000109028**

Fallow deer. */
    N100000109028,
    /** **100000109029**

Moose. */
    N100000109029,
    /** **100000109030**

Antelope. */
    N100000109030,
    /** **100000109031**

Cervid. */
    N100000109031,
    /** **100000109032**

Deer. */
    N100000109032,
    /** **100000109033**

Other Deer. */
    N100000109033,
    /** **100000109034**

Red deer. */
    N100000109034,
    /** **100000109035**

Reindeer. */
    N100000109035,
    /** **100000109036**

Roe deer. */
    N100000109036,
    /** **100000109037**

Donkey. */
    N100000109037,
    /** **100000109038**

Mare. */
    N100000109038,
    /** **100000109039**

Gelding. */
    N100000109039,
    /** **100000109040**

Horses. */
    N100000109040,
    /** **100000109041**

Stallion. */
    N100000109041,
    /** **100000109042**

Pony. */
    N100000109042,
    /** **100000109043**

Pregnant mare. */
    N100000109043,
    /** **100000109044**

Non food-producing horse. */
    N100000109044,
    /** **100000109045**

Suckling colt. */
    N100000109045,
    /** **100000109046**

Colt. */
    N100000109046,
    /** **100000109047**

Mule. */
    N100000109047,
    /** **100000109048**

Equid. */
    N100000109048,
    /** **100000109049**

Female equid. */
    N100000109049,
    /** **100000109050**

Other Equids. */
    N100000109050,
    /** **100000109051**

Zebra. */
    N100000109051,
    /** **100000109052**

Bobcat. */
    N100000109052,
    /** **100000109053**

Adult female cat. */
    N100000109053,
    /** **100000109054**

Adult female cat for reproduction. */
    N100000109054,
    /** **100000109055**

Adult male cat. */
    N100000109055,
    /** **100000109056**

Cats. */
    N100000109056,
    /** **100000109057**

Lactating cat. */
    N100000109057,
    /** **100000109058**

Large cat. */
    N100000109058,
    /** **100000109059**

Medium cat. */
    N100000109059,
    /** **100000109060**

Pregnant cat. */
    N100000109060,
    /** **100000109061**

Small cat. */
    N100000109061,
    /** **100000109062**

Kitten. */
    N100000109062,
    /** **100000109063**

Cougar. */
    N100000109063,
    /** **100000109064**

Jaguar. */
    N100000109064,
    /** **100000109065**

Leopard. */
    N100000109065,
    /** **100000109066**

Lion. */
    N100000109066,
    /** **100000109067**

Lynx. */
    N100000109067,
    /** **100000109068**

Other Felids. */
    N100000109068,
    /** **100000109069**

Tiger. */
    N100000109069,
    /** **100000109070**

Tsushima wild cat. */
    N100000109070,
    /** **100000109071**

Other Leporids. */
    N100000109071,
    /** **100000109072**

Hare. */
    N100000109072,
    /** **100000109073**

Female rabbit for reproduction. */
    N100000109073,
}
impl ::core::str::FromStr for TargetSpecies {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000108874" => Ok(Self::N100000108874),
            "100000108875" => Ok(Self::N100000108875),
            "100000108876" => Ok(Self::N100000108876),
            "100000108877" => Ok(Self::N100000108877),
            "100000108878" => Ok(Self::N100000108878),
            "100000108879" => Ok(Self::N100000108879),
            "100000108880" => Ok(Self::N100000108880),
            "100000108881" => Ok(Self::N100000108881),
            "100000108882" => Ok(Self::N100000108882),
            "100000108883" => Ok(Self::N100000108883),
            "100000108884" => Ok(Self::N100000108884),
            "100000108885" => Ok(Self::N100000108885),
            "100000108886" => Ok(Self::N100000108886),
            "100000108887" => Ok(Self::N100000108887),
            "100000108888" => Ok(Self::N100000108888),
            "100000108889" => Ok(Self::N100000108889),
            "100000108890" => Ok(Self::N100000108890),
            "100000108891" => Ok(Self::N100000108891),
            "100000108892" => Ok(Self::N100000108892),
            "100000108893" => Ok(Self::N100000108893),
            "100000108894" => Ok(Self::N100000108894),
            "100000108895" => Ok(Self::N100000108895),
            "100000108896" => Ok(Self::N100000108896),
            "100000108897" => Ok(Self::N100000108897),
            "100000108898" => Ok(Self::N100000108898),
            "100000108899" => Ok(Self::N100000108899),
            "100000108900" => Ok(Self::N100000108900),
            "100000108901" => Ok(Self::N100000108901),
            "100000108902" => Ok(Self::N100000108902),
            "100000108903" => Ok(Self::N100000108903),
            "100000108904" => Ok(Self::N100000108904),
            "100000108905" => Ok(Self::N100000108905),
            "100000108906" => Ok(Self::N100000108906),
            "100000108907" => Ok(Self::N100000108907),
            "100000108908" => Ok(Self::N100000108908),
            "100000108909" => Ok(Self::N100000108909),
            "100000108910" => Ok(Self::N100000108910),
            "100000108911" => Ok(Self::N100000108911),
            "100000108912" => Ok(Self::N100000108912),
            "100000108913" => Ok(Self::N100000108913),
            "100000108914" => Ok(Self::N100000108914),
            "100000108915" => Ok(Self::N100000108915),
            "100000108916" => Ok(Self::N100000108916),
            "100000108917" => Ok(Self::N100000108917),
            "100000108918" => Ok(Self::N100000108918),
            "100000108919" => Ok(Self::N100000108919),
            "100000108920" => Ok(Self::N100000108920),
            "100000108921" => Ok(Self::N100000108921),
            "100000108922" => Ok(Self::N100000108922),
            "100000108923" => Ok(Self::N100000108923),
            "100000108924" => Ok(Self::N100000108924),
            "100000108925" => Ok(Self::N100000108925),
            "100000108926" => Ok(Self::N100000108926),
            "100000108927" => Ok(Self::N100000108927),
            "100000108928" => Ok(Self::N100000108928),
            "100000108929" => Ok(Self::N100000108929),
            "100000108930" => Ok(Self::N100000108930),
            "100000108931" => Ok(Self::N100000108931),
            "100000108932" => Ok(Self::N100000108932),
            "100000108933" => Ok(Self::N100000108933),
            "100000108934" => Ok(Self::N100000108934),
            "100000108935" => Ok(Self::N100000108935),
            "100000108936" => Ok(Self::N100000108936),
            "100000108937" => Ok(Self::N100000108937),
            "100000108938" => Ok(Self::N100000108938),
            "100000108939" => Ok(Self::N100000108939),
            "100000108940" => Ok(Self::N100000108940),
            "100000108941" => Ok(Self::N100000108941),
            "100000108942" => Ok(Self::N100000108942),
            "100000108943" => Ok(Self::N100000108943),
            "100000108944" => Ok(Self::N100000108944),
            "100000108945" => Ok(Self::N100000108945),
            "100000108946" => Ok(Self::N100000108946),
            "100000108947" => Ok(Self::N100000108947),
            "100000108948" => Ok(Self::N100000108948),
            "100000108949" => Ok(Self::N100000108949),
            "100000108950" => Ok(Self::N100000108950),
            "100000108951" => Ok(Self::N100000108951),
            "100000108952" => Ok(Self::N100000108952),
            "100000108953" => Ok(Self::N100000108953),
            "100000108954" => Ok(Self::N100000108954),
            "100000108955" => Ok(Self::N100000108955),
            "100000108956" => Ok(Self::N100000108956),
            "100000108957" => Ok(Self::N100000108957),
            "100000108958" => Ok(Self::N100000108958),
            "100000108959" => Ok(Self::N100000108959),
            "100000108960" => Ok(Self::N100000108960),
            "100000108961" => Ok(Self::N100000108961),
            "100000108962" => Ok(Self::N100000108962),
            "100000108963" => Ok(Self::N100000108963),
            "100000108964" => Ok(Self::N100000108964),
            "100000108965" => Ok(Self::N100000108965),
            "100000108966" => Ok(Self::N100000108966),
            "100000108967" => Ok(Self::N100000108967),
            "100000108968" => Ok(Self::N100000108968),
            "100000108969" => Ok(Self::N100000108969),
            "100000108970" => Ok(Self::N100000108970),
            "100000108971" => Ok(Self::N100000108971),
            "100000108972" => Ok(Self::N100000108972),
            "100000108973" => Ok(Self::N100000108973),
            "100000108974" => Ok(Self::N100000108974),
            "100000108975" => Ok(Self::N100000108975),
            "100000108976" => Ok(Self::N100000108976),
            "100000108977" => Ok(Self::N100000108977),
            "100000108978" => Ok(Self::N100000108978),
            "100000108979" => Ok(Self::N100000108979),
            "100000108980" => Ok(Self::N100000108980),
            "100000108981" => Ok(Self::N100000108981),
            "100000108982" => Ok(Self::N100000108982),
            "100000108983" => Ok(Self::N100000108983),
            "100000108984" => Ok(Self::N100000108984),
            "100000108985" => Ok(Self::N100000108985),
            "100000108986" => Ok(Self::N100000108986),
            "100000108987" => Ok(Self::N100000108987),
            "100000108988" => Ok(Self::N100000108988),
            "100000108989" => Ok(Self::N100000108989),
            "100000108990" => Ok(Self::N100000108990),
            "100000108991" => Ok(Self::N100000108991),
            "100000108992" => Ok(Self::N100000108992),
            "100000108993" => Ok(Self::N100000108993),
            "100000108994" => Ok(Self::N100000108994),
            "100000108995" => Ok(Self::N100000108995),
            "100000108996" => Ok(Self::N100000108996),
            "100000108997" => Ok(Self::N100000108997),
            "100000108998" => Ok(Self::N100000108998),
            "100000108999" => Ok(Self::N100000108999),
            "100000109000" => Ok(Self::N100000109000),
            "100000109001" => Ok(Self::N100000109001),
            "100000109002" => Ok(Self::N100000109002),
            "100000109003" => Ok(Self::N100000109003),
            "100000109004" => Ok(Self::N100000109004),
            "100000109005" => Ok(Self::N100000109005),
            "100000109006" => Ok(Self::N100000109006),
            "100000109007" => Ok(Self::N100000109007),
            "100000109008" => Ok(Self::N100000109008),
            "100000109009" => Ok(Self::N100000109009),
            "100000109010" => Ok(Self::N100000109010),
            "100000109011" => Ok(Self::N100000109011),
            "100000109012" => Ok(Self::N100000109012),
            "100000109013" => Ok(Self::N100000109013),
            "100000109014" => Ok(Self::N100000109014),
            "100000109015" => Ok(Self::N100000109015),
            "100000109016" => Ok(Self::N100000109016),
            "100000109017" => Ok(Self::N100000109017),
            "100000109018" => Ok(Self::N100000109018),
            "100000109019" => Ok(Self::N100000109019),
            "100000109020" => Ok(Self::N100000109020),
            "100000109021" => Ok(Self::N100000109021),
            "100000109022" => Ok(Self::N100000109022),
            "100000109023" => Ok(Self::N100000109023),
            "100000109024" => Ok(Self::N100000109024),
            "100000109025" => Ok(Self::N100000109025),
            "100000109026" => Ok(Self::N100000109026),
            "100000109027" => Ok(Self::N100000109027),
            "100000109028" => Ok(Self::N100000109028),
            "100000109029" => Ok(Self::N100000109029),
            "100000109030" => Ok(Self::N100000109030),
            "100000109031" => Ok(Self::N100000109031),
            "100000109032" => Ok(Self::N100000109032),
            "100000109033" => Ok(Self::N100000109033),
            "100000109034" => Ok(Self::N100000109034),
            "100000109035" => Ok(Self::N100000109035),
            "100000109036" => Ok(Self::N100000109036),
            "100000109037" => Ok(Self::N100000109037),
            "100000109038" => Ok(Self::N100000109038),
            "100000109039" => Ok(Self::N100000109039),
            "100000109040" => Ok(Self::N100000109040),
            "100000109041" => Ok(Self::N100000109041),
            "100000109042" => Ok(Self::N100000109042),
            "100000109043" => Ok(Self::N100000109043),
            "100000109044" => Ok(Self::N100000109044),
            "100000109045" => Ok(Self::N100000109045),
            "100000109046" => Ok(Self::N100000109046),
            "100000109047" => Ok(Self::N100000109047),
            "100000109048" => Ok(Self::N100000109048),
            "100000109049" => Ok(Self::N100000109049),
            "100000109050" => Ok(Self::N100000109050),
            "100000109051" => Ok(Self::N100000109051),
            "100000109052" => Ok(Self::N100000109052),
            "100000109053" => Ok(Self::N100000109053),
            "100000109054" => Ok(Self::N100000109054),
            "100000109055" => Ok(Self::N100000109055),
            "100000109056" => Ok(Self::N100000109056),
            "100000109057" => Ok(Self::N100000109057),
            "100000109058" => Ok(Self::N100000109058),
            "100000109059" => Ok(Self::N100000109059),
            "100000109060" => Ok(Self::N100000109060),
            "100000109061" => Ok(Self::N100000109061),
            "100000109062" => Ok(Self::N100000109062),
            "100000109063" => Ok(Self::N100000109063),
            "100000109064" => Ok(Self::N100000109064),
            "100000109065" => Ok(Self::N100000109065),
            "100000109066" => Ok(Self::N100000109066),
            "100000109067" => Ok(Self::N100000109067),
            "100000109068" => Ok(Self::N100000109068),
            "100000109069" => Ok(Self::N100000109069),
            "100000109070" => Ok(Self::N100000109070),
            "100000109071" => Ok(Self::N100000109071),
            "100000109072" => Ok(Self::N100000109072),
            "100000109073" => Ok(Self::N100000109073),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TargetSpecies {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000108874 => "100000108874",
            Self::N100000108875 => "100000108875",
            Self::N100000108876 => "100000108876",
            Self::N100000108877 => "100000108877",
            Self::N100000108878 => "100000108878",
            Self::N100000108879 => "100000108879",
            Self::N100000108880 => "100000108880",
            Self::N100000108881 => "100000108881",
            Self::N100000108882 => "100000108882",
            Self::N100000108883 => "100000108883",
            Self::N100000108884 => "100000108884",
            Self::N100000108885 => "100000108885",
            Self::N100000108886 => "100000108886",
            Self::N100000108887 => "100000108887",
            Self::N100000108888 => "100000108888",
            Self::N100000108889 => "100000108889",
            Self::N100000108890 => "100000108890",
            Self::N100000108891 => "100000108891",
            Self::N100000108892 => "100000108892",
            Self::N100000108893 => "100000108893",
            Self::N100000108894 => "100000108894",
            Self::N100000108895 => "100000108895",
            Self::N100000108896 => "100000108896",
            Self::N100000108897 => "100000108897",
            Self::N100000108898 => "100000108898",
            Self::N100000108899 => "100000108899",
            Self::N100000108900 => "100000108900",
            Self::N100000108901 => "100000108901",
            Self::N100000108902 => "100000108902",
            Self::N100000108903 => "100000108903",
            Self::N100000108904 => "100000108904",
            Self::N100000108905 => "100000108905",
            Self::N100000108906 => "100000108906",
            Self::N100000108907 => "100000108907",
            Self::N100000108908 => "100000108908",
            Self::N100000108909 => "100000108909",
            Self::N100000108910 => "100000108910",
            Self::N100000108911 => "100000108911",
            Self::N100000108912 => "100000108912",
            Self::N100000108913 => "100000108913",
            Self::N100000108914 => "100000108914",
            Self::N100000108915 => "100000108915",
            Self::N100000108916 => "100000108916",
            Self::N100000108917 => "100000108917",
            Self::N100000108918 => "100000108918",
            Self::N100000108919 => "100000108919",
            Self::N100000108920 => "100000108920",
            Self::N100000108921 => "100000108921",
            Self::N100000108922 => "100000108922",
            Self::N100000108923 => "100000108923",
            Self::N100000108924 => "100000108924",
            Self::N100000108925 => "100000108925",
            Self::N100000108926 => "100000108926",
            Self::N100000108927 => "100000108927",
            Self::N100000108928 => "100000108928",
            Self::N100000108929 => "100000108929",
            Self::N100000108930 => "100000108930",
            Self::N100000108931 => "100000108931",
            Self::N100000108932 => "100000108932",
            Self::N100000108933 => "100000108933",
            Self::N100000108934 => "100000108934",
            Self::N100000108935 => "100000108935",
            Self::N100000108936 => "100000108936",
            Self::N100000108937 => "100000108937",
            Self::N100000108938 => "100000108938",
            Self::N100000108939 => "100000108939",
            Self::N100000108940 => "100000108940",
            Self::N100000108941 => "100000108941",
            Self::N100000108942 => "100000108942",
            Self::N100000108943 => "100000108943",
            Self::N100000108944 => "100000108944",
            Self::N100000108945 => "100000108945",
            Self::N100000108946 => "100000108946",
            Self::N100000108947 => "100000108947",
            Self::N100000108948 => "100000108948",
            Self::N100000108949 => "100000108949",
            Self::N100000108950 => "100000108950",
            Self::N100000108951 => "100000108951",
            Self::N100000108952 => "100000108952",
            Self::N100000108953 => "100000108953",
            Self::N100000108954 => "100000108954",
            Self::N100000108955 => "100000108955",
            Self::N100000108956 => "100000108956",
            Self::N100000108957 => "100000108957",
            Self::N100000108958 => "100000108958",
            Self::N100000108959 => "100000108959",
            Self::N100000108960 => "100000108960",
            Self::N100000108961 => "100000108961",
            Self::N100000108962 => "100000108962",
            Self::N100000108963 => "100000108963",
            Self::N100000108964 => "100000108964",
            Self::N100000108965 => "100000108965",
            Self::N100000108966 => "100000108966",
            Self::N100000108967 => "100000108967",
            Self::N100000108968 => "100000108968",
            Self::N100000108969 => "100000108969",
            Self::N100000108970 => "100000108970",
            Self::N100000108971 => "100000108971",
            Self::N100000108972 => "100000108972",
            Self::N100000108973 => "100000108973",
            Self::N100000108974 => "100000108974",
            Self::N100000108975 => "100000108975",
            Self::N100000108976 => "100000108976",
            Self::N100000108977 => "100000108977",
            Self::N100000108978 => "100000108978",
            Self::N100000108979 => "100000108979",
            Self::N100000108980 => "100000108980",
            Self::N100000108981 => "100000108981",
            Self::N100000108982 => "100000108982",
            Self::N100000108983 => "100000108983",
            Self::N100000108984 => "100000108984",
            Self::N100000108985 => "100000108985",
            Self::N100000108986 => "100000108986",
            Self::N100000108987 => "100000108987",
            Self::N100000108988 => "100000108988",
            Self::N100000108989 => "100000108989",
            Self::N100000108990 => "100000108990",
            Self::N100000108991 => "100000108991",
            Self::N100000108992 => "100000108992",
            Self::N100000108993 => "100000108993",
            Self::N100000108994 => "100000108994",
            Self::N100000108995 => "100000108995",
            Self::N100000108996 => "100000108996",
            Self::N100000108997 => "100000108997",
            Self::N100000108998 => "100000108998",
            Self::N100000108999 => "100000108999",
            Self::N100000109000 => "100000109000",
            Self::N100000109001 => "100000109001",
            Self::N100000109002 => "100000109002",
            Self::N100000109003 => "100000109003",
            Self::N100000109004 => "100000109004",
            Self::N100000109005 => "100000109005",
            Self::N100000109006 => "100000109006",
            Self::N100000109007 => "100000109007",
            Self::N100000109008 => "100000109008",
            Self::N100000109009 => "100000109009",
            Self::N100000109010 => "100000109010",
            Self::N100000109011 => "100000109011",
            Self::N100000109012 => "100000109012",
            Self::N100000109013 => "100000109013",
            Self::N100000109014 => "100000109014",
            Self::N100000109015 => "100000109015",
            Self::N100000109016 => "100000109016",
            Self::N100000109017 => "100000109017",
            Self::N100000109018 => "100000109018",
            Self::N100000109019 => "100000109019",
            Self::N100000109020 => "100000109020",
            Self::N100000109021 => "100000109021",
            Self::N100000109022 => "100000109022",
            Self::N100000109023 => "100000109023",
            Self::N100000109024 => "100000109024",
            Self::N100000109025 => "100000109025",
            Self::N100000109026 => "100000109026",
            Self::N100000109027 => "100000109027",
            Self::N100000109028 => "100000109028",
            Self::N100000109029 => "100000109029",
            Self::N100000109030 => "100000109030",
            Self::N100000109031 => "100000109031",
            Self::N100000109032 => "100000109032",
            Self::N100000109033 => "100000109033",
            Self::N100000109034 => "100000109034",
            Self::N100000109035 => "100000109035",
            Self::N100000109036 => "100000109036",
            Self::N100000109037 => "100000109037",
            Self::N100000109038 => "100000109038",
            Self::N100000109039 => "100000109039",
            Self::N100000109040 => "100000109040",
            Self::N100000109041 => "100000109041",
            Self::N100000109042 => "100000109042",
            Self::N100000109043 => "100000109043",
            Self::N100000109044 => "100000109044",
            Self::N100000109045 => "100000109045",
            Self::N100000109046 => "100000109046",
            Self::N100000109047 => "100000109047",
            Self::N100000109048 => "100000109048",
            Self::N100000109049 => "100000109049",
            Self::N100000109050 => "100000109050",
            Self::N100000109051 => "100000109051",
            Self::N100000109052 => "100000109052",
            Self::N100000109053 => "100000109053",
            Self::N100000109054 => "100000109054",
            Self::N100000109055 => "100000109055",
            Self::N100000109056 => "100000109056",
            Self::N100000109057 => "100000109057",
            Self::N100000109058 => "100000109058",
            Self::N100000109059 => "100000109059",
            Self::N100000109060 => "100000109060",
            Self::N100000109061 => "100000109061",
            Self::N100000109062 => "100000109062",
            Self::N100000109063 => "100000109063",
            Self::N100000109064 => "100000109064",
            Self::N100000109065 => "100000109065",
            Self::N100000109066 => "100000109066",
            Self::N100000109067 => "100000109067",
            Self::N100000109068 => "100000109068",
            Self::N100000109069 => "100000109069",
            Self::N100000109070 => "100000109070",
            Self::N100000109071 => "100000109071",
            Self::N100000109072 => "100000109072",
            Self::N100000109073 => "100000109073",
        }
    }
}
impl ::std::fmt::Debug for TargetSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TargetSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TargetSpecies {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TargetSpecies {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TargetSpecies> for Coding {
    fn from(code: TargetSpecies) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/target-species".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TargetSpecies> for CodeableConcept {
    fn from(code: TargetSpecies) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TaskCode](http://hl7.org/fhir/ValueSet/task-code.html)**. Codes indicating the type of action that is expected to be performed\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TaskCode {
    /** **abort**

Mark the focal resource as no longer active. Abort, cancel or withdraw the focal resource, as appropriate for the type of resource. */
    Abort,
    /** **approve**

Activate/approve the focal resource. Take what actions are needed to transition the focus resource from 'draft' to 'active' or 'in-progress', as appropriate for the resource type.  This may involve additing additional content, approval, validation, etc. */
    Approve,
    /** **change**

Change the focal resource. Update the focal resource of the owning system to reflect the content specified as the Task.focus */
    Change,
    /** **fulfill**

Fulfill the focal request. Act to perform the actions defined in the focus request.  This might result in a 'more assertive' request (order for a plan or proposal, filler order for a placer order), but is intend to eventually result in events.  The degree of fulfillment requested might be limited by Task.restriction. */
    Fulfill,
    /** **replace**

Replace the focal resource with the input resource. Replace the focal resource with the specified input resource */
    Replace,
    /** **resume**

Re-activate the focal resource. Transition the focal resource from 'suspended' to 'active' or 'in-progress' as appropriate for the resource type. */
    Resume,
    /** **suspend**

Suspend the focal resource. Transition the focal resource from 'active' or 'in-progress' to 'suspended' */
    Suspend,
}
impl ::core::str::FromStr for TaskCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abort" => Ok(Self::Abort),
            "approve" => Ok(Self::Approve),
            "change" => Ok(Self::Change),
            "fulfill" => Ok(Self::Fulfill),
            "replace" => Ok(Self::Replace),
            "resume" => Ok(Self::Resume),
            "suspend" => Ok(Self::Suspend),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TaskCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abort => "abort",
            Self::Approve => "approve",
            Self::Change => "change",
            Self::Fulfill => "fulfill",
            Self::Replace => "replace",
            Self::Resume => "resume",
            Self::Suspend => "suspend",
        }
    }
}
impl ::std::fmt::Debug for TaskCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TaskCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TaskCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TaskCode> for Coding {
    fn from(code: TaskCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/task-code.html".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TaskCode> for CodeableConcept {
    fn from(code: TaskCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TaskIntent](http://hl7.org/fhir/task-intent)**. Distinguishes whether the task is a proposal, plan or full order.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum TaskIntent {
    /** **unknown**

Unknown. The intent is not known.  When dealing with Task, it's not always known (or relevant) how the task was initiated - i.e. whether it was proposed, planned, ordered or just done spontaneously. */
    Unknown,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TaskIntent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "unknown" => Ok(Self::Unknown),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TaskIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for TaskIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TaskIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TaskIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TaskIntent> for Coding {
    fn from(code: TaskIntent) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/task-intent".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TaskIntent> for CodeableConcept {
    fn from(code: TaskIntent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TaskStatus](http://hl7.org/fhir/ValueSet/task-status)**. The current status of the task.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TaskStatus {
    /** **accepted**

Accepted. The potential performer has agreed to execute the task but has not yet started work. */
    Accepted,
    /** **cancelled**

Cancelled. The task was not completed. */
    Cancelled,
    /** **completed**

Completed. The task has been completed. */
    Completed,
    /** **draft**

Draft. The task is not yet ready to be acted upon. */
    Draft,
    /** **entered-in-error**

Entered in Error. The task should never have existed and is retained only because of the possibility it may have used. */
    EnteredInError,
    /** **failed**

Failed. The task was attempted but could not be completed due to some error. */
    Failed,
    /** **in-progress**

In Progress. The task has been started but is not yet complete. */
    InProgress,
    /** **on-hold**

On Hold. The task has been started but work has been paused. */
    OnHold,
    /** **ready**

Ready. The task is ready to be performed, but no action has yet been taken.  Used in place of requested/received/accepted/rejected when request assignment and acceptance is a given. */
    Ready,
    /** **received**

Received. A potential performer has claimed ownership of the task and is evaluating whether to perform it. */
    Received,
    /** **rejected**

Rejected. The potential performer who claimed ownership of the task has decided not to execute it prior to performing any action. */
    Rejected,
    /** **requested**

Requested. The task is ready to be acted upon and action is sought. */
    Requested,
}
impl ::core::str::FromStr for TaskStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "failed" => Ok(Self::Failed),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "ready" => Ok(Self::Ready),
            "received" => Ok(Self::Received),
            "rejected" => Ok(Self::Rejected),
            "requested" => Ok(Self::Requested),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TaskStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Failed => "failed",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::Ready => "ready",
            Self::Received => "received",
            Self::Rejected => "rejected",
            Self::Requested => "requested",
        }
    }
}
impl ::std::fmt::Debug for TaskStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TaskStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TaskStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TaskStatus> for Coding {
    fn from(code: TaskStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/task-status".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TaskStatus> for CodeableConcept {
    fn from(code: TaskStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TemplateStatusCodeLifeCycle](urn:oid:2.16.840.1.113883.3.1937.98.11.8)**. Life cycle of the Status Code of a Template Design (Version)\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TemplateStatusCodeLifeCycle {
    /** **active**

active. Design has been deemed fit for the intended purpose and is published by the governance      group. */
    Active,
    /** **cancelled**

Cancelled. A drafted design is determined to be erroneous or not fit for intended purpose and is      discontinued before ever being published in an active state. */
    Cancelled,
    /** **draft**

Draft. Design is under development (nascent). */
    Draft,
    /** **pending**

Under pre-publication review. Design is completed and is being reviewed. */
    Pending,
    /** **rejected**

Rejected. A previously drafted design is determined to be erroneous or not fit for intended purpose      and is discontinued before ever being published for consideration in a pending state. */
    Rejected,
    /** **retired**

retired. A previously active design is discontinued from use. It should no longer be used for future      designs, but for historical purposes may be used to process data previously recorded using      this design. A newer design may or may not exist. The design is published in the retired      state. */
    Retired,
    /** **review**

In Review. Design is active, but is under review. The review may result in a change to the design.      The change may necessitate a new version to be created. This in turn may result in the      prior version of the template to be retired. Alternatively, the review may result in a      change to the design that does not require a new version to be created, or it may result      in no change to the design at all. */
    Review,
    /** **terminated**

Terminated. A design is determined to be erroneous or not fit for the intended purpose and should      no longer be used, even for historical purposes. No new designs can be developed for this      template. The associated template no longer needs to be published, but if published, is      shown in the terminated state. */
    Terminated,
}
impl ::core::str::FromStr for TemplateStatusCodeLifeCycle {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "pending" => Ok(Self::Pending),
            "rejected" => Ok(Self::Rejected),
            "retired" => Ok(Self::Retired),
            "review" => Ok(Self::Review),
            "terminated" => Ok(Self::Terminated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TemplateStatusCodeLifeCycle {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::Pending => "pending",
            Self::Rejected => "rejected",
            Self::Retired => "retired",
            Self::Review => "review",
            Self::Terminated => "terminated",
        }
    }
}
impl ::std::fmt::Debug for TemplateStatusCodeLifeCycle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TemplateStatusCodeLifeCycle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TemplateStatusCodeLifeCycle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TemplateStatusCodeLifeCycle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TemplateStatusCodeLifeCycle> for Coding {
    fn from(code: TemplateStatusCodeLifeCycle) -> Self {
        CodingInner {
            system: Some("urn:oid:2.16.840.1.113883.3.1937.98.11.8".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TemplateStatusCodeLifeCycle> for CodeableConcept {
    fn from(code: TemplateStatusCodeLifeCycle) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestReportActionResult](http://hl7.org/fhir/ValueSet/report-action-result-codes)**. The results of executing an action.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestReportActionResult {
    /** **error**

Error. The action encountered a fatal error and the engine was unable to process. */
    Error,
    /** **fail**

Fail. The action failed. */
    Fail,
    /** **pass**

Pass. The action was successful. */
    Pass,
    /** **skip**

Skip. The action was skipped. */
    Skip,
    /** **warning**

Warning. The action passed but with warnings. */
    Warning,
}
impl ::core::str::FromStr for TestReportActionResult {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "fail" => Ok(Self::Fail),
            "pass" => Ok(Self::Pass),
            "skip" => Ok(Self::Skip),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportActionResult {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Fail => "fail",
            Self::Pass => "pass",
            Self::Skip => "skip",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Debug for TestReportActionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestReportActionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestReportActionResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportActionResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportActionResult> for Coding {
    fn from(code: TestReportActionResult) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/report-action-result-codes".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestReportActionResult> for CodeableConcept {
    fn from(code: TestReportActionResult) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestReportParticipantType](http://hl7.org/fhir/ValueSet/report-participant-type)**. The type of participant.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestReportParticipantType {
    /** **client**

Client. A FHIR Client. */
    Client,
    /** **server**

Server. A FHIR Server. */
    Server,
    /** **test-engine**

Test Engine. The test execution engine. */
    TestEngine,
}
impl ::core::str::FromStr for TestReportParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client" => Ok(Self::Client),
            "server" => Ok(Self::Server),
            "test-engine" => Ok(Self::TestEngine),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Client => "client",
            Self::Server => "server",
            Self::TestEngine => "test-engine",
        }
    }
}
impl ::std::fmt::Debug for TestReportParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestReportParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestReportParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportParticipantType> for Coding {
    fn from(code: TestReportParticipantType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/report-participant-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestReportParticipantType> for CodeableConcept {
    fn from(code: TestReportParticipantType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestReportResult](http://hl7.org/fhir/ValueSet/report-result-codes)**. The reported execution result.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestReportResult {
    /** **fail**

Fail. One or more test operations failed one or more asserts. */
    Fail,
    /** **pass**

Pass. All test operations successfully passed all asserts. */
    Pass,
    /** **pending**

Pending. One or more test operations is pending execution completion. */
    Pending,
}
impl ::core::str::FromStr for TestReportResult {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fail" => Ok(Self::Fail),
            "pass" => Ok(Self::Pass),
            "pending" => Ok(Self::Pending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportResult {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fail => "fail",
            Self::Pass => "pass",
            Self::Pending => "pending",
        }
    }
}
impl ::std::fmt::Debug for TestReportResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestReportResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestReportResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportResult> for Coding {
    fn from(code: TestReportResult) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/report-result-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestReportResult> for CodeableConcept {
    fn from(code: TestReportResult) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestReportStatus](http://hl7.org/fhir/ValueSet/report-status-codes)**. The current status of the test report.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestReportStatus {
    /** **completed**

Completed. All test operations have completed. */
    Completed,
    /** **entered-in-error**

Entered In Error. This test report was entered or created in error. */
    EnteredInError,
    /** **in-progress**

In Progress. A test operations is currently executing. */
    InProgress,
    /** **stopped**

Stopped. The test script execution was manually stopped. */
    Stopped,
    /** **waiting**

Waiting. A test operation is waiting for an external client request. */
    Waiting,
}
impl ::core::str::FromStr for TestReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "stopped" => Ok(Self::Stopped),
            "waiting" => Ok(Self::Waiting),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Stopped => "stopped",
            Self::Waiting => "waiting",
        }
    }
}
impl ::std::fmt::Debug for TestReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportStatus> for Coding {
    fn from(code: TestReportStatus) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/report-status-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestReportStatus> for CodeableConcept {
    fn from(code: TestReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestScriptOperationCodes](http://terminology.hl7.org/CodeSystem/testscript-operation-codes)**. This value set defines a set of codes that are used to indicate the supported operations of a testing engine or tool.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum TestScriptOperationCodes {
    /** **apply**

$apply. Realizes an ActivityDefinition in a specific context */
    Apply,
    /** **batch**

Batch. Update, create or delete a set of resources as independent actions. */
    Batch,
    /** **capabilities**

Capabilities. Get a capability statement for the system. */
    Capabilities,
    /** **closure**

$closure. Closure Table Maintenance */
    Closure,
    /** **conforms**

$conforms. Compare two systems CapabilityStatements */
    Conforms,
    /** **create**

Create. Create a new resource with a server assigned id. */
    Create,
    /** **data-requirements**

$data-requirements. Aggregates and returns the parameters and data requirements for a resource and all its dependencies as a single module definition */
    DataRequirements,
    /** **delete**

Delete. Delete a resource. */
    Delete,
    /** **deleteCondMultiple**

Conditional Delete Multiple. Conditionally delete one or more resources based on search parameters. */
    DeleteCondMultiple,
    /** **deleteCondSingle**

Conditional Delete Single. Conditionally delete a single resource based on search parameters. */
    DeleteCondSingle,
    /** **document**

$document. Generate a Document */
    Document,
    /** **evaluate**

$evaluate. Request clinical decision support guidance based on a specific decision support module */
    Evaluate,
    /** **evaluate-measure**

$evaluate-measure. Invoke an eMeasure and obtain the results */
    EvaluateMeasure,
    /** **everything**

$everything. Return all the related information as described in the Encounter or Patient */
    Everything,
    /** **expand**

$expand. Value Set Expansion */
    Expand,
    /** **find**

$find. Find a functional list */
    Find,
    /** **find-matches**

$find-matches. Finding Codes based on supplied properties */
    FindMatches,
    /** **graphql**

$graphql. Invoke a GraphQL query */
    Graphql,
    /** **history**

History. Retrieve the change history for a particular resource or resource type. */
    History,
    /** **implements**

$implements. Test if a server implements a client's required operations */
    Implements,
    /** **lastn**

$lastn. Last N Observations Query */
    Lastn,
    /** **lookup**

$lookup. Concept Look Up and Decomposition */
    Lookup,
    /** **match**

$match. Find patient matches using MPI based logic */
    Match,
    /** **meta**

$meta. Access a list of profiles, tags, and security labels */
    Meta,
    /** **meta-add**

$meta-add. Add profiles, tags, and security labels to a resource */
    MetaAdd,
    /** **meta-delete**

$meta-delete. Delete profiles, tags, and security labels for a resource */
    MetaDelete,
    /** **patch**

Patch. Patch an existing resource by its id. */
    Patch,
    /** **populate**

$populate. Populate Questionnaire */
    Populate,
    /** **populatehtml**

$populatehtml. Generate HTML for Questionnaire */
    Populatehtml,
    /** **populatelink**

$populatelink. Generate a link to a Questionnaire completion webpage */
    Populatelink,
    /** **process-message**

$process-message. Process a message according to the defined event */
    ProcessMessage,
    /** **questionnaire**

$questionnaire. Build Questionnaire */
    Questionnaire,
    /** **read**

Read. Read the current state of the resource. */
    Read,
    /** **search**

Search. Search based on some filter criteria. */
    Search,
    /** **stats**

$stats. Observation Statistics */
    Stats,
    /** **subset**

$subset. Fetch a subset of the CapabilityStatement resource */
    Subset,
    /** **subsumes**

$subsumes. CodeSystem Subsumption Testing */
    Subsumes,
    /** **transaction**

Transaction. Update, create or delete a set of resources as a single transaction. */
    Transaction,
    /** **transform**

$transform. Model Instance Transformation */
    Transform,
    /** **translate**

$translate. Concept Translation */
    Translate,
    /** **update**

Update. Update an existing resource by its id. */
    Update,
    /** **updateCreate**

Create using Update. Update an existing resource by its id (or create it if it is new). */
    UpdateCreate,
    /** **validate**

$validate. Validate a resource */
    Validate,
    /** **validate-code**

$validate-code. ValueSet based Validation */
    ValidateCode,
    /** **vread**

Version Read. Read the state of a specific version of the resource. */
    Vread,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TestScriptOperationCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "apply" => Ok(Self::Apply),
            "batch" => Ok(Self::Batch),
            "capabilities" => Ok(Self::Capabilities),
            "closure" => Ok(Self::Closure),
            "conforms" => Ok(Self::Conforms),
            "create" => Ok(Self::Create),
            "data-requirements" => Ok(Self::DataRequirements),
            "delete" => Ok(Self::Delete),
            "deleteCondMultiple" => Ok(Self::DeleteCondMultiple),
            "deleteCondSingle" => Ok(Self::DeleteCondSingle),
            "document" => Ok(Self::Document),
            "evaluate" => Ok(Self::Evaluate),
            "evaluate-measure" => Ok(Self::EvaluateMeasure),
            "everything" => Ok(Self::Everything),
            "expand" => Ok(Self::Expand),
            "find" => Ok(Self::Find),
            "find-matches" => Ok(Self::FindMatches),
            "graphql" => Ok(Self::Graphql),
            "history" => Ok(Self::History),
            "implements" => Ok(Self::Implements),
            "lastn" => Ok(Self::Lastn),
            "lookup" => Ok(Self::Lookup),
            "match" => Ok(Self::Match),
            "meta" => Ok(Self::Meta),
            "meta-add" => Ok(Self::MetaAdd),
            "meta-delete" => Ok(Self::MetaDelete),
            "patch" => Ok(Self::Patch),
            "populate" => Ok(Self::Populate),
            "populatehtml" => Ok(Self::Populatehtml),
            "populatelink" => Ok(Self::Populatelink),
            "process-message" => Ok(Self::ProcessMessage),
            "questionnaire" => Ok(Self::Questionnaire),
            "read" => Ok(Self::Read),
            "search" => Ok(Self::Search),
            "stats" => Ok(Self::Stats),
            "subset" => Ok(Self::Subset),
            "subsumes" => Ok(Self::Subsumes),
            "transaction" => Ok(Self::Transaction),
            "transform" => Ok(Self::Transform),
            "translate" => Ok(Self::Translate),
            "update" => Ok(Self::Update),
            "updateCreate" => Ok(Self::UpdateCreate),
            "validate" => Ok(Self::Validate),
            "validate-code" => Ok(Self::ValidateCode),
            "vread" => Ok(Self::Vread),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TestScriptOperationCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Apply => "apply",
            Self::Batch => "batch",
            Self::Capabilities => "capabilities",
            Self::Closure => "closure",
            Self::Conforms => "conforms",
            Self::Create => "create",
            Self::DataRequirements => "data-requirements",
            Self::Delete => "delete",
            Self::DeleteCondMultiple => "deleteCondMultiple",
            Self::DeleteCondSingle => "deleteCondSingle",
            Self::Document => "document",
            Self::Evaluate => "evaluate",
            Self::EvaluateMeasure => "evaluate-measure",
            Self::Everything => "everything",
            Self::Expand => "expand",
            Self::Find => "find",
            Self::FindMatches => "find-matches",
            Self::Graphql => "graphql",
            Self::History => "history",
            Self::Implements => "implements",
            Self::Lastn => "lastn",
            Self::Lookup => "lookup",
            Self::Match => "match",
            Self::Meta => "meta",
            Self::MetaAdd => "meta-add",
            Self::MetaDelete => "meta-delete",
            Self::Patch => "patch",
            Self::Populate => "populate",
            Self::Populatehtml => "populatehtml",
            Self::Populatelink => "populatelink",
            Self::ProcessMessage => "process-message",
            Self::Questionnaire => "questionnaire",
            Self::Read => "read",
            Self::Search => "search",
            Self::Stats => "stats",
            Self::Subset => "subset",
            Self::Subsumes => "subsumes",
            Self::Transaction => "transaction",
            Self::Transform => "transform",
            Self::Translate => "translate",
            Self::Update => "update",
            Self::UpdateCreate => "updateCreate",
            Self::Validate => "validate",
            Self::ValidateCode => "validate-code",
            Self::Vread => "vread",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for TestScriptOperationCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestScriptOperationCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestScriptOperationCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptOperationCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptOperationCodes> for Coding {
    fn from(code: TestScriptOperationCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/testscript-operation-codes"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestScriptOperationCodes> for CodeableConcept {
    fn from(code: TestScriptOperationCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestScriptProfileDestinationTypes](http://terminology.hl7.org/CodeSystem/testscript-profile-destination-types)**. This value set defines a set of codes that are used to indicate the profile type of a test system when acting as the destination within a TestScript.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum TestScriptProfileDestinationTypes {
    /** **FHIR-SDC-FormManager**

FHIR SDC FormManager. A FHIR server acting as a Structured Data Capture Form Manager. */
    FhirSdcFormManager,
    /** **FHIR-SDC-FormProcessor**

FHIR SDC FormProcessor. A FHIR server acting as a Structured Data Capture Form Processor. */
    FhirSdcFormProcessor,
    /** **FHIR-SDC-FormReceiver**

FHIR SDC FormReceiver. A FHIR server acting as a Structured Data Capture Form Receiver. */
    FhirSdcFormReceiver,
    /** **FHIR-Server**

FHIR Server. General FHIR server used to respond to operations sent from a FHIR client. */
    FhirServer,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TestScriptProfileDestinationTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "FHIR-SDC-FormManager" => Ok(Self::FhirSdcFormManager),
            "FHIR-SDC-FormProcessor" => Ok(Self::FhirSdcFormProcessor),
            "FHIR-SDC-FormReceiver" => Ok(Self::FhirSdcFormReceiver),
            "FHIR-Server" => Ok(Self::FhirServer),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TestScriptProfileDestinationTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::FhirSdcFormManager => "FHIR-SDC-FormManager",
            Self::FhirSdcFormProcessor => "FHIR-SDC-FormProcessor",
            Self::FhirSdcFormReceiver => "FHIR-SDC-FormReceiver",
            Self::FhirServer => "FHIR-Server",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for TestScriptProfileDestinationTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestScriptProfileDestinationTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestScriptProfileDestinationTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptProfileDestinationTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptProfileDestinationTypes> for Coding {
    fn from(code: TestScriptProfileDestinationTypes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/testscript-profile-destination-types"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestScriptProfileDestinationTypes> for CodeableConcept {
    fn from(code: TestScriptProfileDestinationTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestScriptProfileOriginTypes](http://terminology.hl7.org/CodeSystem/testscript-profile-origin-types)**. This value set defines a set of codes that are used to indicate the profile type of a test system when acting as the origin within a TestScript.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum TestScriptProfileOriginTypes {
    /** **FHIR-Client**

FHIR Client. General FHIR client used to initiate operations against a FHIR server. */
    FhirClient,
    /** **FHIR-SDC-FormFiller**

FHIR SDC FormFiller. A FHIR client acting as a Structured Data Capture Form Filler. */
    FhirSdcFormFiller,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TestScriptProfileOriginTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "FHIR-Client" => Ok(Self::FhirClient),
            "FHIR-SDC-FormFiller" => Ok(Self::FhirSdcFormFiller),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TestScriptProfileOriginTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::FhirClient => "FHIR-Client",
            Self::FhirSdcFormFiller => "FHIR-SDC-FormFiller",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for TestScriptProfileOriginTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestScriptProfileOriginTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestScriptProfileOriginTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptProfileOriginTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptProfileOriginTypes> for Coding {
    fn from(code: TestScriptProfileOriginTypes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/testscript-profile-origin-types"
                    .to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestScriptProfileOriginTypes> for CodeableConcept {
    fn from(code: TestScriptProfileOriginTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TestScriptRequestMethodCode](http://hl7.org/fhir/ValueSet/http-operations)**. The allowable request method or HTTP operation codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TestScriptRequestMethodCode {
    /** **delete**

DELETE. HTTP DELETE operation. */
    Delete,
    /** **get**

GET. HTTP GET operation. */
    Get,
    /** **head**

HEAD. HTTP HEAD operation. */
    Head,
    /** **options**

OPTIONS. HTTP OPTIONS operation. */
    Options,
    /** **patch**

PATCH. HTTP PATCH operation. */
    Patch,
    /** **post**

POST. HTTP POST operation. */
    Post,
    /** **put**

PUT. HTTP PUT operation. */
    Put,
}
impl ::core::str::FromStr for TestScriptRequestMethodCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "delete" => Ok(Self::Delete),
            "get" => Ok(Self::Get),
            "head" => Ok(Self::Head),
            "options" => Ok(Self::Options),
            "patch" => Ok(Self::Patch),
            "post" => Ok(Self::Post),
            "put" => Ok(Self::Put),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestScriptRequestMethodCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Delete => "delete",
            Self::Get => "get",
            Self::Head => "head",
            Self::Options => "options",
            Self::Patch => "patch",
            Self::Post => "post",
            Self::Put => "put",
        }
    }
}
impl ::std::fmt::Debug for TestScriptRequestMethodCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TestScriptRequestMethodCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TestScriptRequestMethodCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptRequestMethodCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptRequestMethodCode> for Coding {
    fn from(code: TestScriptRequestMethodCode) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/http-operations".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TestScriptRequestMethodCode> for CodeableConcept {
    fn from(code: TestScriptRequestMethodCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TherapyRelationshipType](http://hl7.org/fhir/ValueSet/therapy-relationship-type)**. Classification of relationship between a therapy and a contraindication or an indication.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TherapyRelationshipType {
    /** **contraindicated-except-with**

Contraindicated unless the other therapy is given. Contraindicated unless the other therapy is given */
    ContraindicatedExceptWith,
    /** **contraindicated-only-with**

Only contraindicated if the other therapy is given. Only contraindicated if the other therapy is given */
    ContraindicatedOnlyWith,
    /** **indicated-except-with**

Indicated except when the other therapy is given. Indicated except when the other therapy is given */
    IndicatedExceptWith,
    /** **indicated-only-before**

Indicated only if the other therapy is planned to be given afterwards (prep). Indicated only if the other therapy is planned to be given afterwards (prep) */
    IndicatedOnlyBefore,
    /** **indicated-only-with**

Indicated only when the other therapy is given (co-occurrent). Indicated only when the other therapy is given (co-occurrent) */
    IndicatedOnlyWith,
    /** **replace-other-therapy**

Indicated to replace the other therapy. Indicated to replace the other therapy */
    ReplaceOtherTherapy,
    /** **replace-other-therapy-contraindicated**

Indicated to replace the other contraindicated therapy. Indicated to replace the other contraindicated therapy. */
    ReplaceOtherTherapyContraindicated,
    /** **replace-other-therapy-not-effective**

Indicated to replace the other therapy not effective on patient. Indicated to replace the other therapy not effective on patient */
    ReplaceOtherTherapyNotEffective,
    /** **replace-other-therapy-not-tolerated**

Indicated to replace the other therapy not well tolerated by patient. Indicated to replace the other therapy not well tolerated by patient */
    ReplaceOtherTherapyNotTolerated,
}
impl ::core::str::FromStr for TherapyRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contraindicated-except-with" => Ok(Self::ContraindicatedExceptWith),
            "contraindicated-only-with" => Ok(Self::ContraindicatedOnlyWith),
            "indicated-except-with" => Ok(Self::IndicatedExceptWith),
            "indicated-only-before" => Ok(Self::IndicatedOnlyBefore),
            "indicated-only-with" => Ok(Self::IndicatedOnlyWith),
            "replace-other-therapy" => Ok(Self::ReplaceOtherTherapy),
            "replace-other-therapy-contraindicated" => {
                Ok(Self::ReplaceOtherTherapyContraindicated)
            }
            "replace-other-therapy-not-effective" => {
                Ok(Self::ReplaceOtherTherapyNotEffective)
            }
            "replace-other-therapy-not-tolerated" => {
                Ok(Self::ReplaceOtherTherapyNotTolerated)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TherapyRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ContraindicatedExceptWith => "contraindicated-except-with",
            Self::ContraindicatedOnlyWith => "contraindicated-only-with",
            Self::IndicatedExceptWith => "indicated-except-with",
            Self::IndicatedOnlyBefore => "indicated-only-before",
            Self::IndicatedOnlyWith => "indicated-only-with",
            Self::ReplaceOtherTherapy => "replace-other-therapy",
            Self::ReplaceOtherTherapyContraindicated => {
                "replace-other-therapy-contraindicated"
            }
            Self::ReplaceOtherTherapyNotEffective => {
                "replace-other-therapy-not-effective"
            }
            Self::ReplaceOtherTherapyNotTolerated => {
                "replace-other-therapy-not-tolerated"
            }
        }
    }
}
impl ::std::fmt::Debug for TherapyRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TherapyRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TherapyRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TherapyRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TherapyRelationshipType> for Coding {
    fn from(code: TherapyRelationshipType) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/therapy-relationship-type".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TherapyRelationshipType> for CodeableConcept {
    fn from(code: TherapyRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TitleType](http://hl7.org/fhir/ValueSet/title-type)**. Used to express the reason and specific aspect for the variant title, such as language and specific language.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TitleType {
    /** **acronym**

Acronym. Abbreviation used as title */
    Acronym,
    /** **autotranslated**

Different language derived from autotranslation. Machine translated form of title in a different language, language element codes the language into which it was translated by machine. */
    Autotranslated,
    /** **duplicate-uid**

Different text for the same object with a different identifier. An alternative form of the title in two or more entries, e.g. in multiple medline entries */
    DuplicateUid,
    /** **earlier-title**

Different text in an earlier version. Alternative form of title in an earlier version such as epub ahead of print. */
    EarlierTitle,
    /** **human-use**

Human use. Human-friendly title */
    HumanUse,
    /** **language**

Different language. Additional form of title in a different language. */
    Language,
    /** **machine-use**

Machine use. Machine-friendly title */
    MachineUse,
    /** **official**

Official title. The official or authoritative title. */
    Official,
    /** **plain-language**

Plain language title. Title using language common to lay public discourse. */
    PlainLanguage,
    /** **primary**

Primary title. Main title for common use. The primary title used for representation if multiple titles exist. */
    Primary,
    /** **scientific**

Scientific title. Title using scientific terminology. */
    Scientific,
    /** **short-title**

Short title. Brief title (e.g. 'running title' or title used in page headers) */
    ShortTitle,
    /** **subtitle**

Subtitle. Subtitle or secondary title. */
    Subtitle,
}
impl ::core::str::FromStr for TitleType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acronym" => Ok(Self::Acronym),
            "autotranslated" => Ok(Self::Autotranslated),
            "duplicate-uid" => Ok(Self::DuplicateUid),
            "earlier-title" => Ok(Self::EarlierTitle),
            "human-use" => Ok(Self::HumanUse),
            "language" => Ok(Self::Language),
            "machine-use" => Ok(Self::MachineUse),
            "official" => Ok(Self::Official),
            "plain-language" => Ok(Self::PlainLanguage),
            "primary" => Ok(Self::Primary),
            "scientific" => Ok(Self::Scientific),
            "short-title" => Ok(Self::ShortTitle),
            "subtitle" => Ok(Self::Subtitle),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TitleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acronym => "acronym",
            Self::Autotranslated => "autotranslated",
            Self::DuplicateUid => "duplicate-uid",
            Self::EarlierTitle => "earlier-title",
            Self::HumanUse => "human-use",
            Self::Language => "language",
            Self::MachineUse => "machine-use",
            Self::Official => "official",
            Self::PlainLanguage => "plain-language",
            Self::Primary => "primary",
            Self::Scientific => "scientific",
            Self::ShortTitle => "short-title",
            Self::Subtitle => "subtitle",
        }
    }
}
impl ::std::fmt::Debug for TitleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TitleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TitleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TitleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TitleType> for Coding {
    fn from(code: TitleType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/title-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TitleType> for CodeableConcept {
    fn from(code: TitleType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TriggerType](http://hl7.org/fhir/ValueSet/trigger-type)**. The type of trigger.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TriggerType {
    /** **data-access-ended**

Data Access Ended. The trigger occurs whenever access to data of a particular type is completed. */
    DataAccessEnded,
    /** **data-accessed**

Data Accessed. The trigger occurs whenever data of a particular type is accessed. */
    DataAccessed,
    /** **data-added**

Data Added. The trigger occurs whenever data of a particular type is added. */
    DataAdded,
    /** **data-changed**

Data Changed. The trigger occurs whenever data of a particular type is changed in any way, either added, modified, or removed. */
    DataChanged,
    /** **data-modified**

Data Updated. The trigger occurs whenever data of a particular type is modified. */
    DataModified,
    /** **data-removed**

Data Removed. The trigger occurs whenever data of a particular type is removed. */
    DataRemoved,
    /** **named-event**

Named Event. The trigger occurs in response to a specific named event, and no other information about the trigger is specified. Named events are completely pre-coordinated, and the formal semantics of the trigger are not provided. */
    NamedEvent,
    /** **periodic**

Periodic. The trigger occurs at a specific time or periodically as described by a timing or schedule. A periodic event cannot have any data elements, but may have a name assigned as a shorthand for the event. */
    Periodic,
}
impl ::core::str::FromStr for TriggerType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-access-ended" => Ok(Self::DataAccessEnded),
            "data-accessed" => Ok(Self::DataAccessed),
            "data-added" => Ok(Self::DataAdded),
            "data-changed" => Ok(Self::DataChanged),
            "data-modified" => Ok(Self::DataModified),
            "data-removed" => Ok(Self::DataRemoved),
            "named-event" => Ok(Self::NamedEvent),
            "periodic" => Ok(Self::Periodic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TriggerType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataAccessEnded => "data-access-ended",
            Self::DataAccessed => "data-accessed",
            Self::DataAdded => "data-added",
            Self::DataChanged => "data-changed",
            Self::DataModified => "data-modified",
            Self::DataRemoved => "data-removed",
            Self::NamedEvent => "named-event",
            Self::Periodic => "periodic",
        }
    }
}
impl ::std::fmt::Debug for TriggerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TriggerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TriggerType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TriggerType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TriggerType> for Coding {
    fn from(code: TriggerType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/trigger-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TriggerType> for CodeableConcept {
    fn from(code: TriggerType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[TypeDerivationRule](http://hl7.org/fhir/ValueSet/type-derivation-rule)**. How a type relates to its baseDefinition.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum TypeDerivationRule {
    /** **constraint**

Constraint. This definition adds additional rules to an existing concrete type. */
    Constraint,
    /** **specialization**

Specialization. This definition defines a new type that adds additional elements to the base type. */
    Specialization,
}
impl ::core::str::FromStr for TypeDerivationRule {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "constraint" => Ok(Self::Constraint),
            "specialization" => Ok(Self::Specialization),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TypeDerivationRule {
    fn as_ref(&self) -> &str {
        match self {
            Self::Constraint => "constraint",
            Self::Specialization => "specialization",
        }
    }
}
impl ::std::fmt::Debug for TypeDerivationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for TypeDerivationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for TypeDerivationRule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TypeDerivationRule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TypeDerivationRule> for Coding {
    fn from(code: TypeDerivationRule) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/type-derivation-rule".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<TypeDerivationRule> for CodeableConcept {
    fn from(code: TypeDerivationRule) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[UDIEntryType](http://hl7.org/fhir/ValueSet/udi-entry-type)**. Codes to identify how UDI data was entered.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum UDIEntryType {
    /** **barcode**

Barcode. a barcodescanner captured the data from the device label. */
    Barcode,
    /** **card**

Card. The data originated from a patient's implant card and was read by an operator. */
    Card,
    /** **manual**

Manual. The data was read from the label by a person and manually entered. (e.g.  via a keyboard). */
    Manual,
    /** **rfid**

RFID. An RFID chip reader captured the data from the device label. */
    Rfid,
    /** **self-reported**

Self Reported. The data originated from a patient source and was not directly scanned or read from a label or card. */
    SelfReported,
    /** **unknown**

Unknown. The method of data capture has not been determined. */
    Unknown,
}
impl ::core::str::FromStr for UDIEntryType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "barcode" => Ok(Self::Barcode),
            "card" => Ok(Self::Card),
            "manual" => Ok(Self::Manual),
            "rfid" => Ok(Self::Rfid),
            "self-reported" => Ok(Self::SelfReported),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UDIEntryType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Barcode => "barcode",
            Self::Card => "card",
            Self::Manual => "manual",
            Self::Rfid => "rfid",
            Self::SelfReported => "self-reported",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Debug for UDIEntryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for UDIEntryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for UDIEntryType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UDIEntryType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UDIEntryType> for Coding {
    fn from(code: UDIEntryType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/udi-entry-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<UDIEntryType> for CodeableConcept {
    fn from(code: UDIEntryType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[USCLSCodes](http://terminology.hl7.org/CodeSystem/ex-USCLS)**. This value set includes a smattering of USCLS codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum USCLSCodes {
    /** **1101**

Exam, comp, primary. Exam, comp, primary */
    N1101,
    /** **1102**

Exam, comp, mixed. Exam, comp, mixed */
    N1102,
    /** **1103**

Exam, comp, permanent. Exam, comp, permanent */
    N1103,
    /** **11101**

Polishing, 1 unit. Polishing, 1 unit */
    N11101,
    /** **11102**

Polishing, 2 unit. Polishing, 2 unit */
    N11102,
    /** **11103**

Polishing, 3 unit. Polishing, 3 unit */
    N11103,
    /** **11104**

Polishing, 4 unit. Polishing, 4 unit */
    N11104,
    /** **1201**

Exam, recall. Exam, recall */
    N1201,
    /** **1205**

Exam, emergency. Exam, emergency */
    N1205,
    /** **2101**

Radiograph, series (12). Radiograph, series (12) */
    N2101,
    /** **2102**

Radiograph, series (16). Radiograph, series (16) */
    N2102,
    /** **21211**

Amalgam, 1 surface. Amalgam, 1 surface */
    N21211,
    /** **21212**

Amalgam, 2 surface. Amalgam, 2 surface */
    N21212,
    /** **2141**

Radiograph, bitewing. Radiograph, bitewing */
    N2141,
    /** **2601**

Radiograph, panoramic. Radiograph, panoramic */
    N2601,
    /** **27211**

Crown, PFM. Crown, PFM */
    N27211,
    /** **67211**

Maryland Bridge. Maryland Bridge */
    N67211,
    /** **99111**

Lab, commercial. Lab, commercial */
    N99111,
    /** **99333**

Lab, in office. Lab, in office */
    N99333,
    /** **99555**

Expense. Expense */
    N99555,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for USCLSCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1101" => Ok(Self::N1101),
            "1102" => Ok(Self::N1102),
            "1103" => Ok(Self::N1103),
            "11101" => Ok(Self::N11101),
            "11102" => Ok(Self::N11102),
            "11103" => Ok(Self::N11103),
            "11104" => Ok(Self::N11104),
            "1201" => Ok(Self::N1201),
            "1205" => Ok(Self::N1205),
            "2101" => Ok(Self::N2101),
            "2102" => Ok(Self::N2102),
            "21211" => Ok(Self::N21211),
            "21212" => Ok(Self::N21212),
            "2141" => Ok(Self::N2141),
            "2601" => Ok(Self::N2601),
            "27211" => Ok(Self::N27211),
            "67211" => Ok(Self::N67211),
            "99111" => Ok(Self::N99111),
            "99333" => Ok(Self::N99333),
            "99555" => Ok(Self::N99555),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for USCLSCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1101 => "1101",
            Self::N1102 => "1102",
            Self::N1103 => "1103",
            Self::N11101 => "11101",
            Self::N11102 => "11102",
            Self::N11103 => "11103",
            Self::N11104 => "11104",
            Self::N1201 => "1201",
            Self::N1205 => "1205",
            Self::N2101 => "2101",
            Self::N2102 => "2102",
            Self::N21211 => "21211",
            Self::N21212 => "21212",
            Self::N2141 => "2141",
            Self::N2601 => "2601",
            Self::N27211 => "27211",
            Self::N67211 => "67211",
            Self::N99111 => "99111",
            Self::N99333 => "99333",
            Self::N99555 => "99555",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for USCLSCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for USCLSCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for USCLSCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for USCLSCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<USCLSCodes> for Coding {
    fn from(code: USCLSCodes) -> Self {
        CodingInner {
            system: Some("http://terminology.hl7.org/CodeSystem/ex-USCLS".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<USCLSCodes> for CodeableConcept {
    fn from(code: USCLSCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[UndesirablEffectFrequency](http://hl7.org/fhir/ValueSet/undesirable-effect-frequency)**. A categorisation for a frequency of occurence of an undesirable effect.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum UndesirablEffectFrequency {
    /** **Common**

Common. */
    Common,
    /** **Rare**

Rare. */
    Rare,
    /** **Uncommon**

Uncommon. */
    Uncommon,
}
impl ::core::str::FromStr for UndesirablEffectFrequency {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Common" => Ok(Self::Common),
            "Rare" => Ok(Self::Rare),
            "Uncommon" => Ok(Self::Uncommon),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UndesirablEffectFrequency {
    fn as_ref(&self) -> &str {
        match self {
            Self::Common => "Common",
            Self::Rare => "Rare",
            Self::Uncommon => "Uncommon",
        }
    }
}
impl ::std::fmt::Debug for UndesirablEffectFrequency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for UndesirablEffectFrequency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for UndesirablEffectFrequency {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UndesirablEffectFrequency {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UndesirablEffectFrequency> for Coding {
    fn from(code: UndesirablEffectFrequency) -> Self {
        CodingInner {
            system: Some(
                "http://hl7.org/fhir/ValueSet/undesirable-effect-frequency".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<UndesirablEffectFrequency> for CodeableConcept {
    fn from(code: UndesirablEffectFrequency) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[UnitOfPresentation](http://hl7.org/fhir/ValueSet/unit-of-presentation)**. The presentation type in which an administrable medicinal product is given to a patient.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum UnitOfPresentation {
    /** **200000002108**

Barrel. */
    N200000002108,
    /** **200000002109**

Blister. */
    N200000002109,
    /** **200000002110**

Block. */
    N200000002110,
    /** **200000002111**

Bottle. */
    N200000002111,
    /** **200000002112**

Cachet. */
    N200000002112,
    /** **200000002113**

Capsule. */
    N200000002113,
    /** **200000002114**

Cartridge. */
    N200000002114,
    /** **200000002115**

Collar. */
    N200000002115,
    /** **200000002116**

Container. */
    N200000002116,
    /** **200000002117**

Cup. */
    N200000002117,
    /** **200000002118**

Cylinder. */
    N200000002118,
    /** **200000002119**

Dart. */
    N200000002119,
    /** **200000002120**

Dressing. */
    N200000002120,
    /** **200000002121**

Drop. */
    N200000002121,
    /** **200000002122**

Film. */
    N200000002122,
    /** **200000002123**

Chewing gum. */
    N200000002123,
    /** **200000002124**

Implant. */
    N200000002124,
    /** **200000002125**

Inhaler. */
    N200000002125,
    /** **200000002126**

Insert. */
    N200000002126,
    /** **200000002127**

Jar. */
    N200000002127,
    /** **200000002128**

Lozenge. */
    N200000002128,
    /** **200000002129**

Lyophilisate. */
    N200000002129,
    /** **200000002130**

Matrix. */
    N200000002130,
    /** **200000002131**

Pad. */
    N200000002131,
    /** **200000002132**

Paper. */
    N200000002132,
    /** **200000002133**

Pastille. */
    N200000002133,
    /** **200000002134**

Patch. */
    N200000002134,
    /** **200000002135**

Pen. */
    N200000002135,
    /** **200000002136**

Pendant. */
    N200000002136,
    /** **200000002137**

Pessary. */
    N200000002137,
    /** **200000002138**

Pillule. */
    N200000002138,
    /** **200000002139**

Pipette. */
    N200000002139,
    /** **200000002140**

Plaster. */
    N200000002140,
    /** **200000002141**

Plug. */
    N200000002141,
    /** **200000002142**

Pouch. */
    N200000002142,
    /** **200000002143**

Sachet. */
    N200000002143,
    /** **200000002144**

Sponge. */
    N200000002144,
    /** **200000002145**

Spoonful. */
    N200000002145,
    /** **200000002146**

Stick. */
    N200000002146,
    /** **200000002147**

Straw. */
    N200000002147,
    /** **200000002148**

Strip. */
    N200000002148,
    /** **200000002149**

Suppository. */
    N200000002149,
    /** **200000002150**

Syringe. */
    N200000002150,
    /** **200000002151**

System. */
    N200000002151,
    /** **200000002152**

Tablet. */
    N200000002152,
    /** **200000002153**

Tag. */
    N200000002153,
    /** **200000002154**

Tampon. */
    N200000002154,
    /** **200000002155**

Thread. */
    N200000002155,
    /** **200000002156**

Tube. */
    N200000002156,
    /** **200000002157**

Vessel. */
    N200000002157,
    /** **200000002158**

Vial. */
    N200000002158,
    /** **200000002159**

Puff. */
    N200000002159,
    /** **200000002163**

Actuation. */
    N200000002163,
    /** **200000002164**

Ampoule. */
    N200000002164,
    /** **200000002165**

Applicator. */
    N200000002165,
    /** **200000002166**

Bag. */
    N200000002166,
}
impl ::core::str::FromStr for UnitOfPresentation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "200000002108" => Ok(Self::N200000002108),
            "200000002109" => Ok(Self::N200000002109),
            "200000002110" => Ok(Self::N200000002110),
            "200000002111" => Ok(Self::N200000002111),
            "200000002112" => Ok(Self::N200000002112),
            "200000002113" => Ok(Self::N200000002113),
            "200000002114" => Ok(Self::N200000002114),
            "200000002115" => Ok(Self::N200000002115),
            "200000002116" => Ok(Self::N200000002116),
            "200000002117" => Ok(Self::N200000002117),
            "200000002118" => Ok(Self::N200000002118),
            "200000002119" => Ok(Self::N200000002119),
            "200000002120" => Ok(Self::N200000002120),
            "200000002121" => Ok(Self::N200000002121),
            "200000002122" => Ok(Self::N200000002122),
            "200000002123" => Ok(Self::N200000002123),
            "200000002124" => Ok(Self::N200000002124),
            "200000002125" => Ok(Self::N200000002125),
            "200000002126" => Ok(Self::N200000002126),
            "200000002127" => Ok(Self::N200000002127),
            "200000002128" => Ok(Self::N200000002128),
            "200000002129" => Ok(Self::N200000002129),
            "200000002130" => Ok(Self::N200000002130),
            "200000002131" => Ok(Self::N200000002131),
            "200000002132" => Ok(Self::N200000002132),
            "200000002133" => Ok(Self::N200000002133),
            "200000002134" => Ok(Self::N200000002134),
            "200000002135" => Ok(Self::N200000002135),
            "200000002136" => Ok(Self::N200000002136),
            "200000002137" => Ok(Self::N200000002137),
            "200000002138" => Ok(Self::N200000002138),
            "200000002139" => Ok(Self::N200000002139),
            "200000002140" => Ok(Self::N200000002140),
            "200000002141" => Ok(Self::N200000002141),
            "200000002142" => Ok(Self::N200000002142),
            "200000002143" => Ok(Self::N200000002143),
            "200000002144" => Ok(Self::N200000002144),
            "200000002145" => Ok(Self::N200000002145),
            "200000002146" => Ok(Self::N200000002146),
            "200000002147" => Ok(Self::N200000002147),
            "200000002148" => Ok(Self::N200000002148),
            "200000002149" => Ok(Self::N200000002149),
            "200000002150" => Ok(Self::N200000002150),
            "200000002151" => Ok(Self::N200000002151),
            "200000002152" => Ok(Self::N200000002152),
            "200000002153" => Ok(Self::N200000002153),
            "200000002154" => Ok(Self::N200000002154),
            "200000002155" => Ok(Self::N200000002155),
            "200000002156" => Ok(Self::N200000002156),
            "200000002157" => Ok(Self::N200000002157),
            "200000002158" => Ok(Self::N200000002158),
            "200000002159" => Ok(Self::N200000002159),
            "200000002163" => Ok(Self::N200000002163),
            "200000002164" => Ok(Self::N200000002164),
            "200000002165" => Ok(Self::N200000002165),
            "200000002166" => Ok(Self::N200000002166),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UnitOfPresentation {
    fn as_ref(&self) -> &str {
        match self {
            Self::N200000002108 => "200000002108",
            Self::N200000002109 => "200000002109",
            Self::N200000002110 => "200000002110",
            Self::N200000002111 => "200000002111",
            Self::N200000002112 => "200000002112",
            Self::N200000002113 => "200000002113",
            Self::N200000002114 => "200000002114",
            Self::N200000002115 => "200000002115",
            Self::N200000002116 => "200000002116",
            Self::N200000002117 => "200000002117",
            Self::N200000002118 => "200000002118",
            Self::N200000002119 => "200000002119",
            Self::N200000002120 => "200000002120",
            Self::N200000002121 => "200000002121",
            Self::N200000002122 => "200000002122",
            Self::N200000002123 => "200000002123",
            Self::N200000002124 => "200000002124",
            Self::N200000002125 => "200000002125",
            Self::N200000002126 => "200000002126",
            Self::N200000002127 => "200000002127",
            Self::N200000002128 => "200000002128",
            Self::N200000002129 => "200000002129",
            Self::N200000002130 => "200000002130",
            Self::N200000002131 => "200000002131",
            Self::N200000002132 => "200000002132",
            Self::N200000002133 => "200000002133",
            Self::N200000002134 => "200000002134",
            Self::N200000002135 => "200000002135",
            Self::N200000002136 => "200000002136",
            Self::N200000002137 => "200000002137",
            Self::N200000002138 => "200000002138",
            Self::N200000002139 => "200000002139",
            Self::N200000002140 => "200000002140",
            Self::N200000002141 => "200000002141",
            Self::N200000002142 => "200000002142",
            Self::N200000002143 => "200000002143",
            Self::N200000002144 => "200000002144",
            Self::N200000002145 => "200000002145",
            Self::N200000002146 => "200000002146",
            Self::N200000002147 => "200000002147",
            Self::N200000002148 => "200000002148",
            Self::N200000002149 => "200000002149",
            Self::N200000002150 => "200000002150",
            Self::N200000002151 => "200000002151",
            Self::N200000002152 => "200000002152",
            Self::N200000002153 => "200000002153",
            Self::N200000002154 => "200000002154",
            Self::N200000002155 => "200000002155",
            Self::N200000002156 => "200000002156",
            Self::N200000002157 => "200000002157",
            Self::N200000002158 => "200000002158",
            Self::N200000002159 => "200000002159",
            Self::N200000002163 => "200000002163",
            Self::N200000002164 => "200000002164",
            Self::N200000002165 => "200000002165",
            Self::N200000002166 => "200000002166",
        }
    }
}
impl ::std::fmt::Debug for UnitOfPresentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for UnitOfPresentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for UnitOfPresentation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UnitOfPresentation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UnitOfPresentation> for Coding {
    fn from(code: UnitOfPresentation) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/unit-of-presentation".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<UnitOfPresentation> for CodeableConcept {
    fn from(code: UnitOfPresentation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[UnitTypeCodes](http://terminology.hl7.org/CodeSystem/benefit-unit)**. This value set includes a smattering of Unit type codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum UnitTypeCodes {
    /** **family**

Family. A family, typically includes self, spouse(s) and children to a defined age */
    Family,
    /** **individual**

Individual. A single individual */
    Individual,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for UnitTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "family" => Ok(Self::Family),
            "individual" => Ok(Self::Individual),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for UnitTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Family => "family",
            Self::Individual => "individual",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for UnitTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for UnitTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for UnitTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UnitTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UnitTypeCodes> for Coding {
    fn from(code: UnitTypeCodes) -> Self {
        CodingInner {
            system: Some(
                "http://terminology.hl7.org/CodeSystem/benefit-unit".to_owned(),
            ),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<UnitTypeCodes> for CodeableConcept {
    fn from(code: UnitTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[UsageContextType](http://hl7.org/fhir/ValueSet/usage-context-type)**. A code that specifies a type of context being specified by a usage context.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum UsageContextType {
    /** **age**

Age Range. The age of the patient. For this context type, the value could be a range that specifies the applicable ages or a code from an appropriate value set such as the MeSH value set http://terminology.hl7.org/ValueSet/v3-AgeGroupObservationValue. */
    Age,
    /** **focus**

Clinical Focus. The clinical concept(s) addressed by the artifact. For example, disease, diagnostic test interpretation, medication ordering as in http://hl7.org/fhir/ValueSet/condition-code. */
    Focus,
    /** **gender**

Gender. The gender of the patient. For this context type, appropriate values can be found in the http://hl7.org/fhir/ValueSet/administrative-gender value set. */
    Gender,
    /** **program**

Program. A program/project of work for which this artifact is applicable. */
    Program,
    /** **species**

Species. The species to which an artifact applies. For example, SNOMED - 387961004 | Kingdom Animalia (organism). */
    Species,
    /** **task**

Workflow Task. The context for the clinical task(s) represented by this artifact. For example, this could be any task context represented by the HL7 ActTaskCode value set http://terminology.hl7.org/ValueSet/v3-ActTaskCode. General categories include: order entry, patient documentation and patient information review. */
    Task,
    /** **user**

User Type. The clinical specialty of the context in which the patient is being treated - For example, PCP, Patient, Cardiologist, Behavioral Professional, Oral Health Professional, Prescriber, etc... taken from a specialty value set such as the NUCC Health Care provider taxonomy value set http://hl7.org/fhir/ValueSet/provider-taxonomy. */
    User,
    /** **venue**

Clinical Venue. The venue in which an artifact could be used. For example, Outpatient, Inpatient, Home, Nursing home. The code value may originate from the HL7 ServiceDeliveryLocationRoleType value set (http://terminology.hl7.org/ValueSet/v3-ServiceDeliveryLocationRoleType). */
    Venue,
    /** **workflow**

Workflow Setting. The settings in which the artifact is intended for use. For example, admission, pre-op, etc. For example, the ActEncounterCode value set http://terminology.hl7.org/ValueSet/v3-ActEncounterCode. */
    Workflow,
}
impl ::core::str::FromStr for UsageContextType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "age" => Ok(Self::Age),
            "focus" => Ok(Self::Focus),
            "gender" => Ok(Self::Gender),
            "program" => Ok(Self::Program),
            "species" => Ok(Self::Species),
            "task" => Ok(Self::Task),
            "user" => Ok(Self::User),
            "venue" => Ok(Self::Venue),
            "workflow" => Ok(Self::Workflow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UsageContextType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Age => "age",
            Self::Focus => "focus",
            Self::Gender => "gender",
            Self::Program => "program",
            Self::Species => "species",
            Self::Task => "task",
            Self::User => "user",
            Self::Venue => "venue",
            Self::Workflow => "workflow",
        }
    }
}
impl ::std::fmt::Debug for UsageContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for UsageContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for UsageContextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UsageContextType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UsageContextType> for Coding {
    fn from(code: UsageContextType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/usage-context-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<UsageContextType> for CodeableConcept {
    fn from(code: UsageContextType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[Use](http://hl7.org/fhir/ValueSet/claim-use)**. The purpose of the Claim: predetermination, preauthorization, claim.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum Use {
    /** **claim**

Claim. The treatment is complete and this represents a Claim for the services. */
    Claim,
    /** **preauthorization**

Preauthorization. The treatment is proposed and this represents a Pre-authorization for the services. */
    Preauthorization,
    /** **predetermination**

Predetermination. The treatment is proposed and this represents a Pre-determination for the services. */
    Predetermination,
}
impl ::core::str::FromStr for Use {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "claim" => Ok(Self::Claim),
            "preauthorization" => Ok(Self::Preauthorization),
            "predetermination" => Ok(Self::Predetermination),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Use {
    fn as_ref(&self) -> &str {
        match self {
            Self::Claim => "claim",
            Self::Preauthorization => "preauthorization",
            Self::Predetermination => "predetermination",
        }
    }
}
impl ::std::fmt::Debug for Use {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for Use {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for Use {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Use {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<Use> for Coding {
    fn from(code: Use) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/claim-use".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<Use> for CodeableConcept {
    fn from(code: Use) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[VisionBase](http://hl7.org/fhir/ValueSet/vision-base-codes)**. A coded concept listing the base codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum VisionBase {
    /** **down**

Down. bottom. */
    Down,
    /** **in**

In. inner edge. */
    In,
    /** **out**

Out. outer edge. */
    Out,
    /** **up**

Up. top. */
    Up,
}
impl ::core::str::FromStr for VisionBase {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "down" => Ok(Self::Down),
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            "up" => Ok(Self::Up),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VisionBase {
    fn as_ref(&self) -> &str {
        match self {
            Self::Down => "down",
            Self::In => "in",
            Self::Out => "out",
            Self::Up => "up",
        }
    }
}
impl ::std::fmt::Debug for VisionBase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for VisionBase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for VisionBase {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VisionBase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<VisionBase> for Coding {
    fn from(code: VisionBase) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/vision-base-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<VisionBase> for CodeableConcept {
    fn from(code: VisionBase) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[VisionEyes](http://hl7.org/fhir/ValueSet/vision-eye-codes)**. A coded concept listing the eye codes.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum VisionEyes {
    /** **left**

Left Eye. Left Eye. */
    Left,
    /** **right**

Right Eye. Right Eye. */
    Right,
}
impl ::core::str::FromStr for VisionEyes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VisionEyes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Left => "left",
            Self::Right => "right",
        }
    }
}
impl ::std::fmt::Debug for VisionEyes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for VisionEyes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for VisionEyes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VisionEyes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<VisionEyes> for Coding {
    fn from(code: VisionEyes) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/vision-eye-codes".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<VisionEyes> for CodeableConcept {
    fn from(code: VisionEyes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[W3cProvenanceActivityType](http://hl7.org/fhir/w3c-provenance-activity-type)**. This value set includes W3C PROV Data Model Activity concepts, which are treated as codes in this valueset.  Some adaptations were made to make these concepts suitable values for the Provenance.activity element. Coded concepts are from PROV-DM and the display names are their counterparts in PROV-N (human readable notation syntax specification).[code system OID: http://www.w3.org/TR/2013/REC-prov-dm-20130430/ and http://www.w3.org/TR/2013/REC-prov-n-20130430/]\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
pub enum W3cProvenanceActivityType {
    /** **Attribution**

wasAttributedTo. Ascribing of an entity (object/document) to an agent. */
    Attribution,
    /** **Collection**

isCollectionOf.  An aggregating activity that results in composition of an entity, which provides a structure to some constituents that must themselves be entities. These constituents are said to be member of the collections. */
    Collection,
    /** **Communication**

wasInformedBy. The exchange of some unspecified entity by two activities, one activity using some entity generated by the other. A communication implies that activity a2 is dependent on another activity, a1, by way of some unspecified entity that is generated by a1 and used by a2. */
    Communication,
    /** **Derivation**

wasDerivedFrom. A transformation of an entity into another, an update of an entity resulting in a new one, or the construction of a new entity based on a pre-existing entity. For an entity to be transformed from, created from, or resulting from an update to another, there must be some underpinning activity or activities performing the necessary action(s) resulting in such a derivation. A derivation can be described at various levels of precision. In its simplest form, derivation relates two entities. Optionally, attributes can be added to represent further information about the derivation. If the derivation is the result of a single known activity, then this activity can also be optionally expressed. To provide a completely accurate description of the derivation, the generation and usage of the generated and used entities, respectively, can be provided, so as to make the derivation path, through usage, activity, and generation, explicit. Optional information such as activity, generation, and usage can be linked to derivations to aid analysis of provenance and to facilitate provenance-based reproducibility. */
    Derivation,
    /** **End**

wasEndedBy. When an activity is deemed to have been ended by an entity, known as trigger. The activity no longer exists after its end. Any usage, generation, or invalidation involving an activity precedes the activity's end. An end may refer to a trigger entity that terminated the activity, or to an activity, known as ender that generated the trigger. */
    End,
    /** **Generation**

wasGeneratedBy. The completion of production of a new entity by an activity. This entity did not exist before generation and becomes available for usage after this generation. Given that a generation is the completion of production of an entity, it is instantaneous. */
    Generation,
    /** **Invalidation**

wasInvalidatedBy. The start of the destruction, cessation, or expiry of an existing entity by an activity. The entity is no longer available for use (or further invalidation) after invalidation. Any generation or usage of an entity precedes its invalidation. Given that an invalidation is the start of destruction, cessation, or expiry, it is instantaneous. */
    Invalidation,
    /** **Primary-Source**

wasPrimarySourceOf. Refers to something produced by some agent with direct experience and knowledge about the topic, at the time of the topic's study, without benefit from hindsight. Because of the directness of primary sources, they 'speak for themselves' in ways that cannot be captured through the filter of secondary sources. As such, it is important for secondary sources to reference those primary sources from which they were derived, so that their reliability can be investigated. It is also important to note that a given entity might be a primary source for one entity but not another. It is the reason why Primary Source is defined as a relation as opposed to a subtype of Entity. */
    PrimarySource,
    /** **Quotation**

wasQuotedFrom. The repeat of (some or all of) an entity, such as text or image, by someone who might or might not be its original author. A quotation relation is a kind of derivation relation, for which an entity was derived from a preceding entity by copying, or 'quoting', some or all of it. */
    Quotation,
    /** **Revision**

wasRevisionOf. A derivation for which the resulting entity is a revised version of some original. The implication here is that the resulting entity contains substantial content from the original. A revision relation is a kind of derivation relation from a revised entity to a preceding entity. */
    Revision,
    /** **Start**

wasStartedBy. When an activity is deemed to have been started by an entity, known as trigger. The activity did not exist before its start. Any usage, generation, or invalidation involving an activity follows the activity's start. A start may refer to a trigger entity that set off the activity, or to an activity, known as starter, that generated the trigger. Given that a start is when an activity is deemed to have started, it is instantaneous. */
    Start,
    /** **Usage**

used. the beginning of utilizing an entity by an activity. Before usage, the activity had not begun to utilize this entity and could not have been affected by the entity.  (Note: This definition is formulated for a given usage; it is permitted for an activity to have used a same entity multiple times.) Given that a usage is the beginning of utilizing an entity, it is instantaneous. */
    Usage,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for W3cProvenanceActivityType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Attribution" => Ok(Self::Attribution),
            "Collection" => Ok(Self::Collection),
            "Communication" => Ok(Self::Communication),
            "Derivation" => Ok(Self::Derivation),
            "End" => Ok(Self::End),
            "Generation" => Ok(Self::Generation),
            "Invalidation" => Ok(Self::Invalidation),
            "Primary-Source" => Ok(Self::PrimarySource),
            "Quotation" => Ok(Self::Quotation),
            "Revision" => Ok(Self::Revision),
            "Start" => Ok(Self::Start),
            "Usage" => Ok(Self::Usage),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for W3cProvenanceActivityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attribution => "Attribution",
            Self::Collection => "Collection",
            Self::Communication => "Communication",
            Self::Derivation => "Derivation",
            Self::End => "End",
            Self::Generation => "Generation",
            Self::Invalidation => "Invalidation",
            Self::PrimarySource => "Primary-Source",
            Self::Quotation => "Quotation",
            Self::Revision => "Revision",
            Self::Start => "Start",
            Self::Usage => "Usage",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Debug for W3cProvenanceActivityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for W3cProvenanceActivityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for W3cProvenanceActivityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for W3cProvenanceActivityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<W3cProvenanceActivityType> for Coding {
    fn from(code: W3cProvenanceActivityType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/w3c-provenance-activity-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<W3cProvenanceActivityType> for CodeableConcept {
    fn from(code: W3cProvenanceActivityType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[WarningType](http://hl7.org/fhir/ValueSet/warning-type)**. Classification of warning type.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum WarningType {
    /** **P313**

Get medical advice/attention.. Get medical advice/attention. */
    P313,
    /** **P314**

Get medical advice/attention if you feel unwell.. Get medical advice/attention if you feel unwell. */
    P314,
    /** **P315**

Get immediate medical advice/attention.. Get immediate medical advice/attention. */
    P315,
    /** **P320**

Specific treatment is urgent (see ... on this label).. Specific treatment is urgent (see ... on this label). */
    P320,
    /** **P321**

Specific treatment (see ... on this label).. Specific treatment (see ... on this label). */
    P321,
    /** **P322**

Specific measures (see ... on this label).. Specific measures (see ... on this label). */
    P322,
    /** **P330**

Rinse mouth.. Rinse mouth. */
    P330,
    /** **P331**

Do NOT induce vomiting.. Do NOT induce vomiting. */
    P331,
    /** **P361**

Remove/Take off immediately all contaminated clothing.. Remove/Take off immediately all contaminated clothing. */
    P361,
    /** **P363**

Wash contaminated clothing before reuse... Wash contaminated clothing before reuse. */
    P363,
}
impl ::core::str::FromStr for WarningType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "P313" => Ok(Self::P313),
            "P314" => Ok(Self::P314),
            "P315" => Ok(Self::P315),
            "P320" => Ok(Self::P320),
            "P321" => Ok(Self::P321),
            "P322" => Ok(Self::P322),
            "P330" => Ok(Self::P330),
            "P331" => Ok(Self::P331),
            "P361" => Ok(Self::P361),
            "P363" => Ok(Self::P363),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for WarningType {
    fn as_ref(&self) -> &str {
        match self {
            Self::P313 => "P313",
            Self::P314 => "P314",
            Self::P315 => "P315",
            Self::P320 => "P320",
            Self::P321 => "P321",
            Self::P322 => "P322",
            Self::P330 => "P330",
            Self::P331 => "P331",
            Self::P361 => "P361",
            Self::P363 => "P363",
        }
    }
}
impl ::std::fmt::Debug for WarningType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for WarningType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for WarningType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for WarningType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<WarningType> for Coding {
    fn from(code: WarningType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/warning-type".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<WarningType> for CodeableConcept {
    fn from(code: WarningType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
#[doc = "**[XPathUsageType](http://hl7.org/fhir/ValueSet/search-xpath-usage)**. How a search parameter relates to the set of elements returned by evaluating its xpath query.\n\nFHIR version: 4.3.0."]
#[derive(PartialEq, Eq, Clone, Hash)]
#[derive(Copy)]
pub enum XPathUsageType {
    /** **distance**

Distance. The search parameter is based on a spatial transform of the selected nodes, using physical distance from the middle. */
    Distance,
    /** **nearby**

Nearby. The search parameter is based on a spatial transform of the selected nodes. */
    Nearby,
    /** **normal**

Normal. The search parameter is derived directly from the selected nodes based on the type definitions. */
    Normal,
    /** **other**

Other. The interpretation of the xpath statement is unknown (and can't be automated). */
    Other,
    /** **phonetic**

Phonetic. The search parameter is derived by a phonetic transform from the selected nodes. */
    Phonetic,
}
impl ::core::str::FromStr for XPathUsageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "distance" => Ok(Self::Distance),
            "nearby" => Ok(Self::Nearby),
            "normal" => Ok(Self::Normal),
            "other" => Ok(Self::Other),
            "phonetic" => Ok(Self::Phonetic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for XPathUsageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Distance => "distance",
            Self::Nearby => "nearby",
            Self::Normal => "normal",
            Self::Other => "other",
            Self::Phonetic => "phonetic",
        }
    }
}
impl ::std::fmt::Debug for XPathUsageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl ::std::fmt::Display for XPathUsageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        f.write_str(self.as_ref())
    }
}
impl<'de> Deserialize<'de> for XPathUsageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for XPathUsageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<XPathUsageType> for Coding {
    fn from(code: XPathUsageType) -> Self {
        CodingInner {
            system: Some("http://hl7.org/fhir/ValueSet/search-xpath-usage".to_owned()),
            code: Some(code.as_ref().to_owned()),
            display: Some(format!("{code}")),
            id: None,
            extension: Vec::new(),
            system_ext: None,
            version: None,
            version_ext: None,
            code_ext: None,
            display_ext: None,
            user_selected: None,
            user_selected_ext: None,
        }
            .into()
    }
}
impl From<XPathUsageType> for CodeableConcept {
    fn from(code: XPathUsageType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConceptInner {
            coding: vec![Some(coding)],
            text: Some(text),
            id: None,
            extension: Vec::new(),
            coding_ext: Vec::new(),
            text_ext: None,
        }
            .into()
    }
}
