//! Generated code! Take a look at the generator-crate for changing this file!
#![allow(clippy::too_many_lines)]
use serde::{Serialize, Deserialize};
use super::super::types::{Coding, CodeableConcept};
#[doc = "**[AccountAggregate](http://hl7.org/fhir/ValueSet/account-aggregate)**. Indicates who is expected to pay a part of the account balance.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AccountAggregate {
    /** **insurance**

Insurance. This (aggregated) balance is expected to be paid by Insurance coverage(s) */
    Insurance,
    /** **patient**

Patient. This (aggregated) balance is expected to be paid by the Patient */
    Patient,
    /** **total**

Total. There is no aggregation on this balance */
    Total,
}
impl ::core::str::FromStr for AccountAggregate {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "insurance" => Ok(Self::Insurance),
            "patient" => Ok(Self::Patient),
            "total" => Ok(Self::Total),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AccountAggregate {
    fn as_ref(&self) -> &str {
        match self {
            Self::Insurance => "insurance",
            Self::Patient => "patient",
            Self::Total => "total",
        }
    }
}
impl ::std::fmt::Display for AccountAggregate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Insurance => "Insurance",
            Self::Patient => "Patient",
            Self::Total => "Total",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AccountAggregate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AccountAggregate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AccountAggregate> for Coding {
    fn from(code: AccountAggregate) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/account-aggregate".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AccountAggregate> for CodeableConcept {
    fn from(code: AccountAggregate) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AccountBalanceTerm](http://hl7.org/fhir/ValueSet/account-payment-terms)**. Indicates the account balance's age\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AccountBalanceTerm {
    /** **120**

120 day. This balance is outstanding over 120 days */
    N120,
    /** **30**

30 day. This balance is outstanding over 30 days */
    N30,
    /** **60**

60 day. This balance is outstanding over 60 days */
    N60,
    /** **90**

90 day. This balance is outstanding over 90 days */
    N90,
    /** **current**

Current. This balance is the current balance */
    Current,
}
impl ::core::str::FromStr for AccountBalanceTerm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "120" => Ok(Self::N120),
            "30" => Ok(Self::N30),
            "60" => Ok(Self::N60),
            "90" => Ok(Self::N90),
            "current" => Ok(Self::Current),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AccountBalanceTerm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N120 => "120",
            Self::N30 => "30",
            Self::N60 => "60",
            Self::N90 => "90",
            Self::Current => "current",
        }
    }
}
impl ::std::fmt::Display for AccountBalanceTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N120 => "120 day",
            Self::N30 => "30 day",
            Self::N60 => "60 day",
            Self::N90 => "90 day",
            Self::Current => "Current",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AccountBalanceTerm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AccountBalanceTerm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AccountBalanceTerm> for Coding {
    fn from(code: AccountBalanceTerm) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/account-payment-terms".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AccountBalanceTerm> for CodeableConcept {
    fn from(code: AccountBalanceTerm) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AccountBillingStatus](http://hl7.org/fhir/ValueSet/account-billing-status)**. Indicates whether the account is available to be used for billing purposes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AccountBillingStatus {
    /** **billing**

Billing. Indicates that all transactions are recorded and the finance system can perform the billing process, including preparing insurance claims, scrubbing charges, invoicing etc. During this time any new charges will not be included in the current billing run/cycle. (account.status is active) */
    Billing,
    /** **carecomplete-notbilled**

CareComplete/Not Billed. The account.status is still active and may have charges recorded against it (only for events in the servicePeriod), however the encounters associated are completed. (Also known as Discharged not billed) This BillingStatus is often not used in ongoing accounts. (account.status is active) */
    CarecompleteNotbilled,
    /** **closed-baddebt**

Closed-Bad Debt. The balance of this debt has not been able to be recovered, and the organization has decided not to persue debt recovery. (account.status is in-active) */
    ClosedBaddebt,
    /** **closed-combined**

Closed-Combined. This account has been merged into another account, all charged have been migrated. This account should no longer be used, and will not be billed. (account.status is i n-active) */
    ClosedCombined,
    /** **closed-completed**

Closed-Completed. The account is closed and all charges are processed and accounted for. (account.status is i n-active) */
    ClosedCompleted,
    /** **closed-voided**

Closed-Voided. The account was not created in error, however the organization has decided that it will not be charging any transactions associated. (account.status is i n-active) */
    ClosedVoided,
    /** **open**

Open. The account is open for charging transactions (account.status is active) */
    Open,
}
impl ::core::str::FromStr for AccountBillingStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "billing" => Ok(Self::Billing),
            "carecomplete-notbilled" => Ok(Self::CarecompleteNotbilled),
            "closed-baddebt" => Ok(Self::ClosedBaddebt),
            "closed-combined" => Ok(Self::ClosedCombined),
            "closed-completed" => Ok(Self::ClosedCompleted),
            "closed-voided" => Ok(Self::ClosedVoided),
            "open" => Ok(Self::Open),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AccountBillingStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Billing => "billing",
            Self::CarecompleteNotbilled => "carecomplete-notbilled",
            Self::ClosedBaddebt => "closed-baddebt",
            Self::ClosedCombined => "closed-combined",
            Self::ClosedCompleted => "closed-completed",
            Self::ClosedVoided => "closed-voided",
            Self::Open => "open",
        }
    }
}
impl ::std::fmt::Display for AccountBillingStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Billing => "Billing",
            Self::CarecompleteNotbilled => "CareComplete/Not Billed",
            Self::ClosedBaddebt => "Closed-Bad Debt",
            Self::ClosedCombined => "Closed-Combined",
            Self::ClosedCompleted => "Closed-Completed",
            Self::ClosedVoided => "Closed-Voided",
            Self::Open => "Open",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AccountBillingStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AccountBillingStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AccountBillingStatus> for Coding {
    fn from(code: AccountBillingStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/account-billing-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AccountBillingStatus> for CodeableConcept {
    fn from(code: AccountBillingStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AccountRelationship](http://hl7.org/fhir/ValueSet/account-relationship)**. Relationship between accounts\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AccountRelationship {
    /** **guarantor**

Guarantor. */
    Guarantor,
    /** **parent**

Parent. */
    Parent,
}
impl ::core::str::FromStr for AccountRelationship {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "guarantor" => Ok(Self::Guarantor),
            "parent" => Ok(Self::Parent),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AccountRelationship {
    fn as_ref(&self) -> &str {
        match self {
            Self::Guarantor => "guarantor",
            Self::Parent => "parent",
        }
    }
}
impl ::std::fmt::Display for AccountRelationship {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Guarantor => "Guarantor",
            Self::Parent => "Parent",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AccountRelationship {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AccountRelationship {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AccountRelationship> for Coding {
    fn from(code: AccountRelationship) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/account-relationship".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AccountRelationship> for CodeableConcept {
    fn from(code: AccountRelationship) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AccountStatus](http://hl7.org/fhir/ValueSet/account-status)**. Indicates whether the account is available to be used.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AccountStatus {
    /** **active**

Active. This account is active and may be used. */
    Active,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **inactive**

Inactive. This account is inactive and should not be used to track financial information. */
    Inactive,
    /** **on-hold**

On Hold. This account is on hold. */
    OnHold,
    /** **unknown**

Unknown. The account status is unknown. */
    Unknown,
}
impl ::core::str::FromStr for AccountStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "on-hold" => Ok(Self::OnHold),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AccountStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::OnHold => "on-hold",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for AccountStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in error",
            Self::Inactive => "Inactive",
            Self::OnHold => "On Hold",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AccountStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AccountStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AccountStatus> for Coding {
    fn from(code: AccountStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/account-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AccountStatus> for CodeableConcept {
    fn from(code: AccountStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionCardinalityBehavior](http://hl7.org/fhir/ValueSet/action-cardinality-behavior)**. Defines behavior for an action or a group for how many times that item may be repeated.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionCardinalityBehavior {
    /** **multiple**

Multiple. The action may be selected multiple times. */
    Multiple,
    /** **single**

Single. The action may only be selected one time. */
    Single,
}
impl ::core::str::FromStr for ActionCardinalityBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "multiple" => Ok(Self::Multiple),
            "single" => Ok(Self::Single),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionCardinalityBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::Multiple => "multiple",
            Self::Single => "single",
        }
    }
}
impl ::std::fmt::Display for ActionCardinalityBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Multiple => "Multiple",
            Self::Single => "Single",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionCardinalityBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionCardinalityBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionCardinalityBehavior> for Coding {
    fn from(code: ActionCardinalityBehavior) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/action-cardinality-behavior".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionCardinalityBehavior> for CodeableConcept {
    fn from(code: ActionCardinalityBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionCode](http://hl7.org/fhir/ValueSet/action-code)**. Provides examples of actions to be performed.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionCode {
    /** **collect-information**

Collect information. The action indicates that information should be collected from a participant in the process. */
    CollectInformation,
    /** **order-service**

Order a service. The action indicates that a particular service should be provided. */
    OrderService,
    /** **prescribe-medication**

Prescribe a medication. The action indicates that a particular medication should be prescribed to the patient. */
    PrescribeMedication,
    /** **propose-diagnosis**

Propose a diagnosis. The action indicates that a particular diagnosis should be proposed. */
    ProposeDiagnosis,
    /** **recommend-immunization**

Recommend an immunization. The action indicates that a particular immunization should be performed. */
    RecommendImmunization,
    /** **record-detected-issue**

Record a detected issue. The action indicates that a particular detected issue should be recorded. */
    RecordDetectedIssue,
    /** **record-inference**

Record an inference. The action indicates that a particular inference should be recorded. */
    RecordInference,
    /** **report-flag**

Report a flag. The action indicates that a particular flag should be reported. */
    ReportFlag,
    /** **send-message**

Send a message. The action indicates that a particular message should be sent to a participant in the process. */
    SendMessage,
}
impl ::core::str::FromStr for ActionCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "collect-information" => Ok(Self::CollectInformation),
            "order-service" => Ok(Self::OrderService),
            "prescribe-medication" => Ok(Self::PrescribeMedication),
            "propose-diagnosis" => Ok(Self::ProposeDiagnosis),
            "recommend-immunization" => Ok(Self::RecommendImmunization),
            "record-detected-issue" => Ok(Self::RecordDetectedIssue),
            "record-inference" => Ok(Self::RecordInference),
            "report-flag" => Ok(Self::ReportFlag),
            "send-message" => Ok(Self::SendMessage),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::CollectInformation => "collect-information",
            Self::OrderService => "order-service",
            Self::PrescribeMedication => "prescribe-medication",
            Self::ProposeDiagnosis => "propose-diagnosis",
            Self::RecommendImmunization => "recommend-immunization",
            Self::RecordDetectedIssue => "record-detected-issue",
            Self::RecordInference => "record-inference",
            Self::ReportFlag => "report-flag",
            Self::SendMessage => "send-message",
        }
    }
}
impl ::std::fmt::Display for ActionCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::CollectInformation => "Collect information",
            Self::OrderService => "Order a service",
            Self::PrescribeMedication => "Prescribe a medication",
            Self::ProposeDiagnosis => "Propose a diagnosis",
            Self::RecommendImmunization => "Recommend an immunization",
            Self::RecordDetectedIssue => "Record a detected issue",
            Self::RecordInference => "Record an inference",
            Self::ReportFlag => "Report a flag",
            Self::SendMessage => "Send a message",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionCode> for Coding {
    fn from(code: ActionCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/action-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionCode> for CodeableConcept {
    fn from(code: ActionCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionConditionKind](http://hl7.org/fhir/ValueSet/action-condition-kind)**. Defines the kinds of conditions that can appear on actions.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionConditionKind {
    /** **applicability**

Applicability. The condition describes whether or not a given action is applicable. */
    Applicability,
    /** **start**

Start. The condition is a starting condition for the action. */
    Start,
    /** **stop**

Stop. The condition is a stop, or exit condition for the action. */
    Stop,
}
impl ::core::str::FromStr for ActionConditionKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "applicability" => Ok(Self::Applicability),
            "start" => Ok(Self::Start),
            "stop" => Ok(Self::Stop),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionConditionKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Applicability => "applicability",
            Self::Start => "start",
            Self::Stop => "stop",
        }
    }
}
impl ::std::fmt::Display for ActionConditionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Applicability => "Applicability",
            Self::Start => "Start",
            Self::Stop => "Stop",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionConditionKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionConditionKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionConditionKind> for Coding {
    fn from(code: ActionConditionKind) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/action-condition-kind".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionConditionKind> for CodeableConcept {
    fn from(code: ActionConditionKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionGroupingBehavior](http://hl7.org/fhir/ValueSet/action-grouping-behavior)**. Defines organization behavior of a group.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionGroupingBehavior {
    /** **logical-group**

Logical Group. A group with this behavior logically groups its sub-elements, and may be shown as a visual group to the end user, but it is not required to do so. */
    LogicalGroup,
    /** **sentence-group**

Sentence Group. A group of related alternative actions is a sentence group if the target referenced by the action is the same in all the actions and each action simply constitutes a different variation on how to specify the details for the target. For example, two actions that could be in a SentenceGroup are "aspirin, 500 mg, 2 times per day" and "aspirin, 300 mg, 3 times per day". In both cases, aspirin is the target referenced by the action, and the two actions represent different options for how aspirin might be ordered for the patient. Note that a SentenceGroup would almost always have an associated selection behavior of "AtMostOne", unless it's a required action, in which case, it would be "ExactlyOne". */
    SentenceGroup,
    /** **visual-group**

Visual Group. Any group marked with this behavior should be displayed as a visual group to the end user. */
    VisualGroup,
}
impl ::core::str::FromStr for ActionGroupingBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "logical-group" => Ok(Self::LogicalGroup),
            "sentence-group" => Ok(Self::SentenceGroup),
            "visual-group" => Ok(Self::VisualGroup),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionGroupingBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::LogicalGroup => "logical-group",
            Self::SentenceGroup => "sentence-group",
            Self::VisualGroup => "visual-group",
        }
    }
}
impl ::std::fmt::Display for ActionGroupingBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::LogicalGroup => "Logical Group",
            Self::SentenceGroup => "Sentence Group",
            Self::VisualGroup => "Visual Group",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionGroupingBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionGroupingBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionGroupingBehavior> for Coding {
    fn from(code: ActionGroupingBehavior) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/action-grouping-behavior".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionGroupingBehavior> for CodeableConcept {
    fn from(code: ActionGroupingBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionParticipantFunction](http://hl7.org/fhir/ValueSet/action-participant-function)**. The function performed by the participant for the action.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionParticipantFunction {
    /** **author**

Author. The participant is the author of the result of the action. */
    Author,
    /** **performer**

Performer. The participant is the performer of the action. */
    Performer,
    /** **reviewer**

Reviewer. The participant is reviewing the result of the action. */
    Reviewer,
    /** **witness**

Witness. The participant is a witness to the action being performed. */
    Witness,
}
impl ::core::str::FromStr for ActionParticipantFunction {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "author" => Ok(Self::Author),
            "performer" => Ok(Self::Performer),
            "reviewer" => Ok(Self::Reviewer),
            "witness" => Ok(Self::Witness),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionParticipantFunction {
    fn as_ref(&self) -> &str {
        match self {
            Self::Author => "author",
            Self::Performer => "performer",
            Self::Reviewer => "reviewer",
            Self::Witness => "witness",
        }
    }
}
impl ::std::fmt::Display for ActionParticipantFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Author => "Author",
            Self::Performer => "Performer",
            Self::Reviewer => "Reviewer",
            Self::Witness => "Witness",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionParticipantFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionParticipantFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionParticipantFunction> for Coding {
    fn from(code: ActionParticipantFunction) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/action-participant-function".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionParticipantFunction> for CodeableConcept {
    fn from(code: ActionParticipantFunction) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionParticipantType](http://hl7.org/fhir/ValueSet/action-participant-type)**. The type of participant for the action.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionParticipantType {
    /** **careteam**

CareTeam. The participant is a care team caring for the patient under evaluation. */
    Careteam,
    /** **device**

Device. The participant is a system or device used in the care of the patient. */
    Device,
    /** **group**

Group. The participant is a group of participants involved in the care of the patient. */
    Group,
    /** **healthcareservice**

HealthcareService. The participant is an institution that can provide the given healthcare service used in the care of the patient. */
    Healthcareservice,
    /** **location**

Location. The participant is a location involved in the care of the patient. */
    Location,
    /** **organization**

Organization. The participant is an organization involved in the care of the patient. */
    Organization,
    /** **patient**

Patient. The participant is the patient under evaluation. */
    Patient,
    /** **practitioner**

Practitioner. The participant is a practitioner involved in the patient's care. */
    Practitioner,
    /** **practitionerrole**

PractitionerRole. The participant is a particular practitioner role involved in the patient's care. */
    Practitionerrole,
    /** **relatedperson**

RelatedPerson. The participant is a person related to the patient. */
    Relatedperson,
}
impl ::core::str::FromStr for ActionParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "careteam" => Ok(Self::Careteam),
            "device" => Ok(Self::Device),
            "group" => Ok(Self::Group),
            "healthcareservice" => Ok(Self::Healthcareservice),
            "location" => Ok(Self::Location),
            "organization" => Ok(Self::Organization),
            "patient" => Ok(Self::Patient),
            "practitioner" => Ok(Self::Practitioner),
            "practitionerrole" => Ok(Self::Practitionerrole),
            "relatedperson" => Ok(Self::Relatedperson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Careteam => "careteam",
            Self::Device => "device",
            Self::Group => "group",
            Self::Healthcareservice => "healthcareservice",
            Self::Location => "location",
            Self::Organization => "organization",
            Self::Patient => "patient",
            Self::Practitioner => "practitioner",
            Self::Practitionerrole => "practitionerrole",
            Self::Relatedperson => "relatedperson",
        }
    }
}
impl ::std::fmt::Display for ActionParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Careteam => "CareTeam",
            Self::Device => "Device",
            Self::Group => "Group",
            Self::Healthcareservice => "HealthcareService",
            Self::Location => "Location",
            Self::Organization => "Organization",
            Self::Patient => "Patient",
            Self::Practitioner => "Practitioner",
            Self::Practitionerrole => "PractitionerRole",
            Self::Relatedperson => "RelatedPerson",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionParticipantType> for Coding {
    fn from(code: ActionParticipantType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/action-participant-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionParticipantType> for CodeableConcept {
    fn from(code: ActionParticipantType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionPrecheckBehavior](http://hl7.org/fhir/ValueSet/action-precheck-behavior)**. Defines selection frequency behavior for an action or group.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionPrecheckBehavior {
    /** **no**

No. An action with this behavior is one of the less frequent actions included by the end user, for the particular context in which the action occurs. The system displaying the actions to the end user would typically not "pre-check" such an action. */
    No,
    /** **yes**

Yes. An action with this behavior is one of the most frequent action that is, or should be, included by an end user, for the particular context in which the action occurs. The system displaying the action to the end user should consider "pre-checking" such an action as a convenience for the user. */
    Yes,
}
impl ::core::str::FromStr for ActionPrecheckBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "no" => Ok(Self::No),
            "yes" => Ok(Self::Yes),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionPrecheckBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::No => "no",
            Self::Yes => "yes",
        }
    }
}
impl ::std::fmt::Display for ActionPrecheckBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::No => "No",
            Self::Yes => "Yes",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionPrecheckBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionPrecheckBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionPrecheckBehavior> for Coding {
    fn from(code: ActionPrecheckBehavior) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/action-precheck-behavior".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionPrecheckBehavior> for CodeableConcept {
    fn from(code: ActionPrecheckBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionReasonCode](http://hl7.org/fhir/ValueSet/action-reason-code)**. Provides examples of reasons for actions to be performed.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionReasonCode {
    /** **care-gap**

Care gap detected. The action should be performed to address a detected care gap. */
    CareGap,
    /** **drug-drug-interaction**

Drug-drug interaction. The action should be performed to address a detected potential drug-drug interaction. */
    DrugDrugInteraction,
    /** **off-pathway**

Off pathway. The action should be performed because the patient was determined to be off pathway. */
    OffPathway,
    /** **quality-measure**

Quality measure. The action should be performed to bring the patient's care in line with a quality measure. */
    QualityMeasure,
    /** **risk-assessment**

Risk assessment. The action should be performed based on a particular risk assessment. */
    RiskAssessment,
}
impl ::core::str::FromStr for ActionReasonCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "care-gap" => Ok(Self::CareGap),
            "drug-drug-interaction" => Ok(Self::DrugDrugInteraction),
            "off-pathway" => Ok(Self::OffPathway),
            "quality-measure" => Ok(Self::QualityMeasure),
            "risk-assessment" => Ok(Self::RiskAssessment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionReasonCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::CareGap => "care-gap",
            Self::DrugDrugInteraction => "drug-drug-interaction",
            Self::OffPathway => "off-pathway",
            Self::QualityMeasure => "quality-measure",
            Self::RiskAssessment => "risk-assessment",
        }
    }
}
impl ::std::fmt::Display for ActionReasonCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::CareGap => "Care gap detected",
            Self::DrugDrugInteraction => "Drug-drug interaction",
            Self::OffPathway => "Off pathway",
            Self::QualityMeasure => "Quality measure",
            Self::RiskAssessment => "Risk assessment",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionReasonCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionReasonCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionReasonCode> for Coding {
    fn from(code: ActionReasonCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/action-reason-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionReasonCode> for CodeableConcept {
    fn from(code: ActionReasonCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionRelationshipType](http://hl7.org/fhir/ValueSet/action-relationship-type)**. Defines the types of relationships between actions.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionRelationshipType {
    /** **after**

After. The action must be performed after the related action. */
    After,
    /** **after-end**

After End. The action must be performed after the end of the related action. */
    AfterEnd,
    /** **after-start**

After Start. The action must be performed after the start of the related action. */
    AfterStart,
    /** **before**

Before. The action must be performed before the related action. */
    Before,
    /** **before-end**

Before End. The action must be performed before the end of the related action. */
    BeforeEnd,
    /** **before-start**

Before Start. The action must be performed before the start of the related action. */
    BeforeStart,
    /** **concurrent**

Concurrent. The action must be performed concurrent with the related action. */
    Concurrent,
    /** **concurrent-with-end**

Concurrent With End. The action must be performed concurrent with the end of the related action. */
    ConcurrentWithEnd,
    /** **concurrent-with-start**

Concurrent With Start. The action must be performed concurrent with the start of the related action. */
    ConcurrentWithStart,
}
impl ::core::str::FromStr for ActionRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "after" => Ok(Self::After),
            "after-end" => Ok(Self::AfterEnd),
            "after-start" => Ok(Self::AfterStart),
            "before" => Ok(Self::Before),
            "before-end" => Ok(Self::BeforeEnd),
            "before-start" => Ok(Self::BeforeStart),
            "concurrent" => Ok(Self::Concurrent),
            "concurrent-with-end" => Ok(Self::ConcurrentWithEnd),
            "concurrent-with-start" => Ok(Self::ConcurrentWithStart),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::After => "after",
            Self::AfterEnd => "after-end",
            Self::AfterStart => "after-start",
            Self::Before => "before",
            Self::BeforeEnd => "before-end",
            Self::BeforeStart => "before-start",
            Self::Concurrent => "concurrent",
            Self::ConcurrentWithEnd => "concurrent-with-end",
            Self::ConcurrentWithStart => "concurrent-with-start",
        }
    }
}
impl ::std::fmt::Display for ActionRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::After => "After",
            Self::AfterEnd => "After End",
            Self::AfterStart => "After Start",
            Self::Before => "Before",
            Self::BeforeEnd => "Before End",
            Self::BeforeStart => "Before Start",
            Self::Concurrent => "Concurrent",
            Self::ConcurrentWithEnd => "Concurrent With End",
            Self::ConcurrentWithStart => "Concurrent With Start",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionRelationshipType> for Coding {
    fn from(code: ActionRelationshipType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/action-relationship-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionRelationshipType> for CodeableConcept {
    fn from(code: ActionRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionRequiredBehavior](http://hl7.org/fhir/ValueSet/action-required-behavior)**. Defines expectations around whether an action or action group is required.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionRequiredBehavior {
    /** **could**

Could. An action with this behavior may be included in the set of actions processed by the end user. */
    Could,
    /** **must**

Must. An action with this behavior must be included in the actions processed by the end user; the end user SHALL NOT choose not to include this action. */
    Must,
    /** **must-unless-documented**

Must Unless Documented. An action with this behavior must be included in the set of actions processed by the end user, unless the end user provides documentation as to why the action was not included. */
    MustUnlessDocumented,
}
impl ::core::str::FromStr for ActionRequiredBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "could" => Ok(Self::Could),
            "must" => Ok(Self::Must),
            "must-unless-documented" => Ok(Self::MustUnlessDocumented),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionRequiredBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::Could => "could",
            Self::Must => "must",
            Self::MustUnlessDocumented => "must-unless-documented",
        }
    }
}
impl ::std::fmt::Display for ActionRequiredBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Could => "Could",
            Self::Must => "Must",
            Self::MustUnlessDocumented => "Must Unless Documented",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionRequiredBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionRequiredBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionRequiredBehavior> for Coding {
    fn from(code: ActionRequiredBehavior) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/action-required-behavior".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionRequiredBehavior> for CodeableConcept {
    fn from(code: ActionRequiredBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ActionSelectionBehavior](http://hl7.org/fhir/ValueSet/action-selection-behavior)**. Defines selection behavior of a group.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionSelectionBehavior {
    /** **all**

All. All the actions in the group must be selected as a single unit. */
    All,
    /** **all-or-none**

All Or None. All the actions in the group are meant to be chosen as a single unit: either all must be selected by the end user, or none may be selected. */
    AllOrNone,
    /** **any**

Any. Any number of the actions in the group may be chosen, from zero to all. */
    Any,
    /** **at-most-one**

At Most One. The end user may choose zero or at most one of the actions in the group. */
    AtMostOne,
    /** **exactly-one**

Exactly One. The end user must choose one and only one of the selectable actions in the group. The user SHALL NOT choose none of the actions in the group. */
    ExactlyOne,
    /** **one-or-more**

One Or More. The end user must choose a minimum of one, and as many additional as desired. */
    OneOrMore,
}
impl ::core::str::FromStr for ActionSelectionBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "all-or-none" => Ok(Self::AllOrNone),
            "any" => Ok(Self::Any),
            "at-most-one" => Ok(Self::AtMostOne),
            "exactly-one" => Ok(Self::ExactlyOne),
            "one-or-more" => Ok(Self::OneOrMore),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionSelectionBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::All => "all",
            Self::AllOrNone => "all-or-none",
            Self::Any => "any",
            Self::AtMostOne => "at-most-one",
            Self::ExactlyOne => "exactly-one",
            Self::OneOrMore => "one-or-more",
        }
    }
}
impl ::std::fmt::Display for ActionSelectionBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::All => "All",
            Self::AllOrNone => "All Or None",
            Self::Any => "Any",
            Self::AtMostOne => "At Most One",
            Self::ExactlyOne => "Exactly One",
            Self::OneOrMore => "One Or More",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ActionSelectionBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionSelectionBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ActionSelectionBehavior> for Coding {
    fn from(code: ActionSelectionBehavior) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/action-selection-behavior".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ActionSelectionBehavior> for CodeableConcept {
    fn from(code: ActionSelectionBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AdditionalBindingPurposeCodes](http://hl7.org/fhir/ValueSet/additional-binding-purpose)**. Additional Binding Purpose\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdditionalBindingPurposeCodes {
    /** **candidate**

Candidate Binding. This value set is a candidate to substitute for the overall conformance value set in some situations; usually these are defined in the documentation */
    Candidate,
    /** **component**

Component Binding. This value set is a component of the base value set. Usually this is called out so that documentation can be written about a portion of the value set */
    Component,
    /** **current**

Current Binding. New records are required to use this value set, but legacy records may use other codes. The definition of 'new record' is difficult, since systems often create new records based on pre-existing data. Usually 'current' bindings are mandated by an external authority that makes clear rules around this */
    Current,
    /** **extensible**

Conformance Binding. This value set is used as an extensible binding (in addition to the base binding (not a replacement), usually in a particular usage context) */
    Extensible,
    /** **maximum**

Maximum Binding. A required binding, for use when the binding strength is 'extensible' or 'preferred' */
    Maximum,
    /** **minimum**

Minimum Binding. The minimum allowable value set - any conformant system SHALL support all these codes */
    Minimum,
    /** **preferred**

Preferred Binding. This is the value set that is preferred in a given context (documentation should explain why) */
    Preferred,
    /** **required**

Required Binding. This value set is used as a required binding (in addition to the base binding (not a replacement), usually in a particular usage context) */
    Required,
    /** **starter**

Starter Binding. This value set is a good set of codes to start with when designing your system */
    Starter,
    /** **ui**

UI Suggested Binding. This value set is provided for user look up in a given context. Typically, these valuesets only include a subset of codes relevant for input in a context */
    Ui,
}
impl ::core::str::FromStr for AdditionalBindingPurposeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "candidate" => Ok(Self::Candidate),
            "component" => Ok(Self::Component),
            "current" => Ok(Self::Current),
            "extensible" => Ok(Self::Extensible),
            "maximum" => Ok(Self::Maximum),
            "minimum" => Ok(Self::Minimum),
            "preferred" => Ok(Self::Preferred),
            "required" => Ok(Self::Required),
            "starter" => Ok(Self::Starter),
            "ui" => Ok(Self::Ui),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdditionalBindingPurposeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Candidate => "candidate",
            Self::Component => "component",
            Self::Current => "current",
            Self::Extensible => "extensible",
            Self::Maximum => "maximum",
            Self::Minimum => "minimum",
            Self::Preferred => "preferred",
            Self::Required => "required",
            Self::Starter => "starter",
            Self::Ui => "ui",
        }
    }
}
impl ::std::fmt::Display for AdditionalBindingPurposeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Candidate => "Candidate Binding",
            Self::Component => "Component Binding",
            Self::Current => "Current Binding",
            Self::Extensible => "Conformance Binding",
            Self::Maximum => "Maximum Binding",
            Self::Minimum => "Minimum Binding",
            Self::Preferred => "Preferred Binding",
            Self::Required => "Required Binding",
            Self::Starter => "Starter Binding",
            Self::Ui => "UI Suggested Binding",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AdditionalBindingPurposeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdditionalBindingPurposeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdditionalBindingPurposeCodes> for Coding {
    fn from(code: AdditionalBindingPurposeCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/additional-binding-purpose".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AdditionalBindingPurposeCodes> for CodeableConcept {
    fn from(code: AdditionalBindingPurposeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AdditionalMonitoring](http://hl7.org/fhir/ValueSet/medicinal-product-additional-monitoring)**. Extra monitoring defined for a Medicinal Product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdditionalMonitoring {
    /** **BlackTriangleMonitoring**

Requirement for Black Triangle Monitoring. Requirement for Black Triangle Monitoring */
    BlackTriangleMonitoring,
}
impl ::core::str::FromStr for AdditionalMonitoring {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BlackTriangleMonitoring" => Ok(Self::BlackTriangleMonitoring),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdditionalMonitoring {
    fn as_ref(&self) -> &str {
        match self {
            Self::BlackTriangleMonitoring => "BlackTriangleMonitoring",
        }
    }
}
impl ::std::fmt::Display for AdditionalMonitoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::BlackTriangleMonitoring => "Requirement for Black Triangle Monitoring",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AdditionalMonitoring {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdditionalMonitoring {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdditionalMonitoring> for Coding {
    fn from(code: AdditionalMonitoring) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicinal-product-additional-monitoring"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AdditionalMonitoring> for CodeableConcept {
    fn from(code: AdditionalMonitoring) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AddressType](http://hl7.org/fhir/ValueSet/address-type)**. The type of an address (physical / postal).\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AddressType {
    /** **both**

Postal & Physical. An address that is both physical and postal. */
    Both,
    /** **physical**

Physical. A physical address that can be visited. */
    Physical,
    /** **postal**

Postal. Mailing addresses - PO Boxes and care-of addresses. */
    Postal,
}
impl ::core::str::FromStr for AddressType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "both" => Ok(Self::Both),
            "physical" => Ok(Self::Physical),
            "postal" => Ok(Self::Postal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AddressType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Both => "both",
            Self::Physical => "physical",
            Self::Postal => "postal",
        }
    }
}
impl ::std::fmt::Display for AddressType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Both => "Postal & Physical",
            Self::Physical => "Physical",
            Self::Postal => "Postal",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AddressType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AddressType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AddressType> for Coding {
    fn from(code: AddressType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/address-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AddressType> for CodeableConcept {
    fn from(code: AddressType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AddressUse](http://hl7.org/fhir/ValueSet/address-use)**. The use of an address.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AddressUse {
    /** **billing**

Billing. An address to be used to send bills, invoices, receipts etc. */
    Billing,
    /** **home**

Home. A communication address at a home. */
    Home,
    /** **old**

Old / Incorrect. This address is no longer in use (or was never correct but retained for records). */
    Old,
    /** **temp**

Temporary. A temporary address. The period can provide more detailed information. */
    Temp,
    /** **work**

Work. An office address. First choice for business related contacts during business hours. */
    Work,
}
impl ::core::str::FromStr for AddressUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "billing" => Ok(Self::Billing),
            "home" => Ok(Self::Home),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "work" => Ok(Self::Work),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AddressUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Billing => "billing",
            Self::Home => "home",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Work => "work",
        }
    }
}
impl ::std::fmt::Display for AddressUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Billing => "Billing",
            Self::Home => "Home",
            Self::Old => "Old / Incorrect",
            Self::Temp => "Temporary",
            Self::Work => "Work",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AddressUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AddressUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AddressUse> for Coding {
    fn from(code: AddressUse) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/address-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AddressUse> for CodeableConcept {
    fn from(code: AddressUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AdministrableDoseForm](http://hl7.org/fhir/ValueSet/administrable-dose-form)**. Dose form for a medication, in the form suitable for administering to the patient, after mixing, where necessary.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdministrableDoseForm {
    /** **100000073362**

Oral suspension. */
    N100000073362,
    /** **100000073363**

Oral gel. */
    N100000073363,
    /** **100000073364**

Powder for oral solution. */
    N100000073364,
    /** **100000073365**

Granules for oral solution. */
    N100000073365,
    /** **100000073367**

Lyophilisate for suspension. */
    N100000073367,
    /** **100000073368**

Powder for syrup. */
    N100000073368,
    /** **100000073369**

Soluble tablet. */
    N100000073369,
    /** **100000073370**

Herbal tea. */
    N100000073370,
    /** **100000073371**

Instant herbal tea. */
    N100000073371,
    /** **100000073372**

Granules. */
    N100000073372,
    /** **100000073373**

Gastro-resistant granules. */
    N100000073373,
    /** **100000073374**

Modified-release granules. */
    N100000073374,
    /** **100000073375**

Capsule, hard. */
    N100000073375,
    /** **100000073376**

Gastro-resistant capsule, hard. */
    N100000073376,
    /** **100000073377**

Chewable capsule, soft. */
    N100000073377,
    /** **100000073378**

Prolonged-release capsule, soft. */
    N100000073378,
    /** **100000073379**

Modified-release capsule, soft. */
    N100000073379,
    /** **100000073380**

Coated tablet. */
    N100000073380,
    /** **100000073642**

Oral drops, solution. */
    N100000073642,
    /** **100000073643**

Oral drops, suspension. */
    N100000073643,
    /** **100000073644**

Oral drops, emulsion. */
    N100000073644,
    /** **100000073645**

Oral liquid. */
    N100000073645,
    /** **100000073646**

Oral solution. */
    N100000073646,
    /** **100000073647**

Oral emulsion. */
    N100000073647,
    /** **100000073648**

Oral paste. */
    N100000073648,
    /** **100000073649**

Powder for oral suspension. */
    N100000073649,
    /** **100000073650**

Granules for oral suspension. */
    N100000073650,
    /** **100000073652**

Syrup. */
    N100000073652,
    /** **100000073653**

Granules for syrup. */
    N100000073653,
    /** **100000073654**

Dispersible tablet. */
    N100000073654,
    /** **100000073655**

Oral powder. */
    N100000073655,
    /** **100000073656**

Effervescent powder. */
    N100000073656,
    /** **100000073657**

Effervescent granules. */
    N100000073657,
    /** **100000073658**

Prolonged-release granules. */
    N100000073658,
    /** **100000073659**

Cachet. */
    N100000073659,
    /** **100000073660**

Capsule, soft. */
    N100000073660,
    /** **100000073661**

Gastro-resistant capsule, soft. */
    N100000073661,
    /** **100000073662**

Prolonged-release capsule, hard. */
    N100000073662,
    /** **100000073663**

Modified-release capsule, hard. */
    N100000073663,
    /** **100000073664**

Tablet. */
    N100000073664,
    /** **100000073665**

Film-coated tablet. */
    N100000073665,
    /** **100000073666**

Orodispersible tablet. */
    N100000073666,
    /** **100000073667**

Gastro-resistant tablet. */
    N100000073667,
    /** **100000073668**

Modified-release tablet. */
    N100000073668,
    /** **100000073669**

Medicated chewing-gum. */
    N100000073669,
    /** **100000073670**

Pillules. */
    N100000073670,
    /** **100000073671**

Pulsatile-release intraruminal device. */
    N100000073671,
    /** **100000073672**

Premix for medicated feeding stuff. */
    N100000073672,
    /** **100000073673**

Gargle. */
    N100000073673,
    /** **100000073674**

Gargle, powder for solution. */
    N100000073674,
    /** **100000073675**

Oromucosal suspension. */
    N100000073675,
    /** **100000073676**

Oromucosal spray. */
    N100000073676,
    /** **100000073677**

Mouthwash. */
    N100000073677,
    /** **100000073678**

Gingival solution. */
    N100000073678,
    /** **100000073679**

Oromucosal paste. */
    N100000073679,
    /** **100000073680**

Gingival gel. */
    N100000073680,
    /** **100000073681**

Effervescent tablet. */
    N100000073681,
    /** **100000073682**

Oral lyophilisate. */
    N100000073682,
    /** **100000073683**

Prolonged-release tablet. */
    N100000073683,
    /** **100000073684**

Chewable tablet. */
    N100000073684,
    /** **100000073685**

Oral gum. */
    N100000073685,
    /** **100000073686**

Continuous-release intraruminal device. */
    N100000073686,
    /** **100000073687**

Lick block. */
    N100000073687,
    /** **100000073688**

Medicated pellets. */
    N100000073688,
    /** **100000073689**

Concentrate for gargle. */
    N100000073689,
    /** **100000073690**

Gargle, tablet for solution. */
    N100000073690,
    /** **100000073691**

Oromucosal solution. */
    N100000073691,
    /** **100000073692**

Oromucosal drops. */
    N100000073692,
    /** **100000073693**

Sublingual spray. */
    N100000073693,
    /** **100000073694**

Mouthwash, tablet for solution. */
    N100000073694,
    /** **100000073695**

Oromucosal gel. */
    N100000073695,
    /** **100000073696**

Oromucosal cream. */
    N100000073696,
    /** **100000073697**

Gingival paste. */
    N100000073697,
    /** **100000073698**

Sublingual tablet. */
    N100000073698,
    /** **100000073699**

Buccal tablet. */
    N100000073699,
    /** **100000073700**

Compressed lozenge. */
    N100000073700,
    /** **100000073701**

Oromucosal capsule. */
    N100000073701,
    /** **100000073702**

Muco-adhesive buccal tablet. */
    N100000073702,
    /** **100000073703**

Lozenge. */
    N100000073703,
    /** **100000073704**

Pastille. */
    N100000073704,
    /** **100000073705**

Dental gel. */
    N100000073705,
    /** **100000073706**

Dental insert. */
    N100000073706,
    /** **100000073707**

Dental powder. */
    N100000073707,
    /** **100000073708**

Dental suspension. */
    N100000073708,
    /** **100000073709**

Toothpaste. */
    N100000073709,
    /** **100000073710**

Periodontal gel. */
    N100000073710,
    /** **100000073711**

Bath additive. */
    N100000073711,
    /** **100000073712**

Cream. */
    N100000073712,
    /** **100000073713**

Ointment. */
    N100000073713,
    /** **100000073714**

Medicated plaster. */
    N100000073714,
    /** **100000073715**

Shampoo. */
    N100000073715,
    /** **100000073716**

Cutaneous spray, suspension. */
    N100000073716,
    /** **100000073717**

Cutaneous liquid. */
    N100000073717,
    /** **100000073718**

Concentrate for cutaneous solution. */
    N100000073718,
    /** **100000073719**

Cutaneous emulsion. */
    N100000073719,
    /** **100000073720**

Cutaneous patch. */
    N100000073720,
    /** **100000073721**

Periodontal powder. */
    N100000073721,
    /** **100000073722**

Dental stick. */
    N100000073722,
    /** **100000073723**

Dental solution. */
    N100000073723,
    /** **100000073724**

Dental emulsion. */
    N100000073724,
    /** **100000073725**

Periodontal insert. */
    N100000073725,
    /** **100000073726**

Gel. */
    N100000073726,
    /** **100000073727**

Cutaneous paste. */
    N100000073727,
    /** **100000073728**

Cutaneous foam. */
    N100000073728,
    /** **100000073729**

Cutaneous spray, solution. */
    N100000073729,
    /** **100000073730**

Cutaneous spray, powder. */
    N100000073730,
    /** **100000073731**

Cutaneous solution. */
    N100000073731,
    /** **100000073732**

Cutaneous suspension. */
    N100000073732,
    /** **100000073733**

Cutaneous powder. */
    N100000073733,
    /** **100000073734**

Solution for iontophoresis. */
    N100000073734,
    /** **100000073735**

Collodion. */
    N100000073735,
    /** **100000073736**

Poultice. */
    N100000073736,
    /** **100000073737**

Cutaneous sponge. */
    N100000073737,
    /** **100000073738**

Collar. */
    N100000073738,
    /** **100000073739**

Ear tag. */
    N100000073739,
    /** **100000073740**

Dip suspension. */
    N100000073740,
    /** **100000073741**

Transdermal patch. */
    N100000073741,
    /** **100000073742**

Medicated nail lacquer. */
    N100000073742,
    /** **100000073743**

Cutaneous stick. */
    N100000073743,
    /** **100000073744**

Impregnated dressing. */
    N100000073744,
    /** **100000073745**

Medicated pendant. */
    N100000073745,
    /** **100000073746**

Dip solution. */
    N100000073746,
    /** **100000073747**

Dip emulsion. */
    N100000073747,
    /** **100000073748**

Concentrate for dip suspension. */
    N100000073748,
    /** **100000073749**

Powder for dip solution. */
    N100000073749,
    /** **100000073750**

Powder for suspension for fish treatment. */
    N100000073750,
    /** **100000073751**

Pour-on suspension. */
    N100000073751,
    /** **100000073752**

Spot-on solution. */
    N100000073752,
    /** **100000073753**

Spot-on emulsion. */
    N100000073753,
    /** **100000073754**

Teat dip suspension. */
    N100000073754,
    /** **100000073755**

Teat spray solution. */
    N100000073755,
    /** **100000073756**

Solution for skin-prick test. */
    N100000073756,
    /** **100000073757**

Plaster for provocation test. */
    N100000073757,
    /** **100000073758**

Eye gel. */
    N100000073758,
    /** **100000073759**

Eye drops, solution. */
    N100000073759,
    /** **100000073760**

Eye drops, suspension. */
    N100000073760,
    /** **100000073761**

Concentrate for dip solution. */
    N100000073761,
    /** **100000073762**

Concentrate for dip emulsion. */
    N100000073762,
    /** **100000073763**

Concentrate for solution for fish treatment. */
    N100000073763,
    /** **100000073764**

Pour-on solution. */
    N100000073764,
    /** **100000073765**

Pour-on emulsion. */
    N100000073765,
    /** **100000073766**

Spot-on suspension. */
    N100000073766,
    /** **100000073767**

Teat dip solution. */
    N100000073767,
    /** **100000073768**

Teat dip emulsion. */
    N100000073768,
    /** **100000073769**

Transdermal system. */
    N100000073769,
    /** **100000073770**

Solution for skin-scratch test. */
    N100000073770,
    /** **100000073771**

Eye cream. */
    N100000073771,
    /** **100000073772**

Eye ointment. */
    N100000073772,
    /** **100000073773**

Eye drops, emulsion. */
    N100000073773,
    /** **100000073775**

Eye drops, solvent for reconstitution. */
    N100000073775,
    /** **100000073776**

Eye lotion. */
    N100000073776,
    /** **100000073777**

Ophthalmic insert. */
    N100000073777,
    /** **100000073778**

Ear cream. */
    N100000073778,
    /** **100000073779**

Ear ointment. */
    N100000073779,
    /** **100000073780**

Ear drops, suspension. */
    N100000073780,
    /** **100000073782**

Eye drops, prolonged-release. */
    N100000073782,
    /** **100000073783**

Eye lotion, solvent for reconstitution. */
    N100000073783,
    /** **100000073784**

Ophthalmic strip. */
    N100000073784,
    /** **100000073785**

Ear gel. */
    N100000073785,
    /** **100000073786**

Ear drops, solution. */
    N100000073786,
    /** **100000073787**

Ear drops, emulsion. */
    N100000073787,
    /** **100000073788**

Ear powder. */
    N100000073788,
    /** **100000073789**

Ear spray, suspension. */
    N100000073789,
    /** **100000073790**

Ear wash, solution. */
    N100000073790,
    /** **100000073791**

Ear tampon. */
    N100000073791,
    /** **100000073792**

Nasal cream. */
    N100000073792,
    /** **100000073793**

Nasal gel. */
    N100000073793,
    /** **100000073794**

Nasal drops, solution. */
    N100000073794,
    /** **100000073795**

Nasal drops, emulsion. */
    N100000073795,
    /** **100000073796**

Nasal spray, solution. */
    N100000073796,
    /** **100000073797**

Nasal spray, emulsion. */
    N100000073797,
    /** **100000073798**

Nasal stick. */
    N100000073798,
    /** **100000073799**

Vaginal gel. */
    N100000073799,
    /** **100000073800**

Vaginal foam. */
    N100000073800,
    /** **100000073802**

Ear spray, solution. */
    N100000073802,
    /** **100000073803**

Ear spray, emulsion. */
    N100000073803,
    /** **100000073804**

Ear wash, emulsion. */
    N100000073804,
    /** **100000073805**

Ear stick. */
    N100000073805,
    /** **100000073806**

Nasal ointment. */
    N100000073806,
    /** **100000073807**

Nasal drops, suspension. */
    N100000073807,
    /** **100000073808**

Nasal powder. */
    N100000073808,
    /** **100000073809**

Nasal spray, suspension. */
    N100000073809,
    /** **100000073810**

Nasal wash. */
    N100000073810,
    /** **100000073811**

Vaginal cream. */
    N100000073811,
    /** **100000073812**

Vaginal ointment. */
    N100000073812,
    /** **100000073813**

Vaginal solution. */
    N100000073813,
    /** **100000073814**

Vaginal emulsion. */
    N100000073814,
    /** **100000073815**

Pessary. */
    N100000073815,
    /** **100000073816**

Vaginal capsule, soft. */
    N100000073816,
    /** **100000073817**

Effervescent vaginal tablet. */
    N100000073817,
    /** **100000073818**

Vaginal delivery system. */
    N100000073818,
    /** **100000073819**

Rectal cream. */
    N100000073819,
    /** **100000073820**

Rectal foam. */
    N100000073820,
    /** **100000073821**

Vaginal suspension. */
    N100000073821,
    /** **100000073822**

Tablet for vaginal solution. */
    N100000073822,
    /** **100000073823**

Vaginal capsule, hard. */
    N100000073823,
    /** **100000073824**

Vaginal tablet. */
    N100000073824,
    /** **100000073825**

Medicated vaginal tampon. */
    N100000073825,
    /** **100000073826**

Vaginal sponge. */
    N100000073826,
    /** **100000073827**

Rectal gel. */
    N100000073827,
    /** **100000073863**

Solution for injection. */
    N100000073863,
}
impl ::core::str::FromStr for AdministrableDoseForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073362" => Ok(Self::N100000073362),
            "100000073363" => Ok(Self::N100000073363),
            "100000073364" => Ok(Self::N100000073364),
            "100000073365" => Ok(Self::N100000073365),
            "100000073367" => Ok(Self::N100000073367),
            "100000073368" => Ok(Self::N100000073368),
            "100000073369" => Ok(Self::N100000073369),
            "100000073370" => Ok(Self::N100000073370),
            "100000073371" => Ok(Self::N100000073371),
            "100000073372" => Ok(Self::N100000073372),
            "100000073373" => Ok(Self::N100000073373),
            "100000073374" => Ok(Self::N100000073374),
            "100000073375" => Ok(Self::N100000073375),
            "100000073376" => Ok(Self::N100000073376),
            "100000073377" => Ok(Self::N100000073377),
            "100000073378" => Ok(Self::N100000073378),
            "100000073379" => Ok(Self::N100000073379),
            "100000073380" => Ok(Self::N100000073380),
            "100000073642" => Ok(Self::N100000073642),
            "100000073643" => Ok(Self::N100000073643),
            "100000073644" => Ok(Self::N100000073644),
            "100000073645" => Ok(Self::N100000073645),
            "100000073646" => Ok(Self::N100000073646),
            "100000073647" => Ok(Self::N100000073647),
            "100000073648" => Ok(Self::N100000073648),
            "100000073649" => Ok(Self::N100000073649),
            "100000073650" => Ok(Self::N100000073650),
            "100000073652" => Ok(Self::N100000073652),
            "100000073653" => Ok(Self::N100000073653),
            "100000073654" => Ok(Self::N100000073654),
            "100000073655" => Ok(Self::N100000073655),
            "100000073656" => Ok(Self::N100000073656),
            "100000073657" => Ok(Self::N100000073657),
            "100000073658" => Ok(Self::N100000073658),
            "100000073659" => Ok(Self::N100000073659),
            "100000073660" => Ok(Self::N100000073660),
            "100000073661" => Ok(Self::N100000073661),
            "100000073662" => Ok(Self::N100000073662),
            "100000073663" => Ok(Self::N100000073663),
            "100000073664" => Ok(Self::N100000073664),
            "100000073665" => Ok(Self::N100000073665),
            "100000073666" => Ok(Self::N100000073666),
            "100000073667" => Ok(Self::N100000073667),
            "100000073668" => Ok(Self::N100000073668),
            "100000073669" => Ok(Self::N100000073669),
            "100000073670" => Ok(Self::N100000073670),
            "100000073671" => Ok(Self::N100000073671),
            "100000073672" => Ok(Self::N100000073672),
            "100000073673" => Ok(Self::N100000073673),
            "100000073674" => Ok(Self::N100000073674),
            "100000073675" => Ok(Self::N100000073675),
            "100000073676" => Ok(Self::N100000073676),
            "100000073677" => Ok(Self::N100000073677),
            "100000073678" => Ok(Self::N100000073678),
            "100000073679" => Ok(Self::N100000073679),
            "100000073680" => Ok(Self::N100000073680),
            "100000073681" => Ok(Self::N100000073681),
            "100000073682" => Ok(Self::N100000073682),
            "100000073683" => Ok(Self::N100000073683),
            "100000073684" => Ok(Self::N100000073684),
            "100000073685" => Ok(Self::N100000073685),
            "100000073686" => Ok(Self::N100000073686),
            "100000073687" => Ok(Self::N100000073687),
            "100000073688" => Ok(Self::N100000073688),
            "100000073689" => Ok(Self::N100000073689),
            "100000073690" => Ok(Self::N100000073690),
            "100000073691" => Ok(Self::N100000073691),
            "100000073692" => Ok(Self::N100000073692),
            "100000073693" => Ok(Self::N100000073693),
            "100000073694" => Ok(Self::N100000073694),
            "100000073695" => Ok(Self::N100000073695),
            "100000073696" => Ok(Self::N100000073696),
            "100000073697" => Ok(Self::N100000073697),
            "100000073698" => Ok(Self::N100000073698),
            "100000073699" => Ok(Self::N100000073699),
            "100000073700" => Ok(Self::N100000073700),
            "100000073701" => Ok(Self::N100000073701),
            "100000073702" => Ok(Self::N100000073702),
            "100000073703" => Ok(Self::N100000073703),
            "100000073704" => Ok(Self::N100000073704),
            "100000073705" => Ok(Self::N100000073705),
            "100000073706" => Ok(Self::N100000073706),
            "100000073707" => Ok(Self::N100000073707),
            "100000073708" => Ok(Self::N100000073708),
            "100000073709" => Ok(Self::N100000073709),
            "100000073710" => Ok(Self::N100000073710),
            "100000073711" => Ok(Self::N100000073711),
            "100000073712" => Ok(Self::N100000073712),
            "100000073713" => Ok(Self::N100000073713),
            "100000073714" => Ok(Self::N100000073714),
            "100000073715" => Ok(Self::N100000073715),
            "100000073716" => Ok(Self::N100000073716),
            "100000073717" => Ok(Self::N100000073717),
            "100000073718" => Ok(Self::N100000073718),
            "100000073719" => Ok(Self::N100000073719),
            "100000073720" => Ok(Self::N100000073720),
            "100000073721" => Ok(Self::N100000073721),
            "100000073722" => Ok(Self::N100000073722),
            "100000073723" => Ok(Self::N100000073723),
            "100000073724" => Ok(Self::N100000073724),
            "100000073725" => Ok(Self::N100000073725),
            "100000073726" => Ok(Self::N100000073726),
            "100000073727" => Ok(Self::N100000073727),
            "100000073728" => Ok(Self::N100000073728),
            "100000073729" => Ok(Self::N100000073729),
            "100000073730" => Ok(Self::N100000073730),
            "100000073731" => Ok(Self::N100000073731),
            "100000073732" => Ok(Self::N100000073732),
            "100000073733" => Ok(Self::N100000073733),
            "100000073734" => Ok(Self::N100000073734),
            "100000073735" => Ok(Self::N100000073735),
            "100000073736" => Ok(Self::N100000073736),
            "100000073737" => Ok(Self::N100000073737),
            "100000073738" => Ok(Self::N100000073738),
            "100000073739" => Ok(Self::N100000073739),
            "100000073740" => Ok(Self::N100000073740),
            "100000073741" => Ok(Self::N100000073741),
            "100000073742" => Ok(Self::N100000073742),
            "100000073743" => Ok(Self::N100000073743),
            "100000073744" => Ok(Self::N100000073744),
            "100000073745" => Ok(Self::N100000073745),
            "100000073746" => Ok(Self::N100000073746),
            "100000073747" => Ok(Self::N100000073747),
            "100000073748" => Ok(Self::N100000073748),
            "100000073749" => Ok(Self::N100000073749),
            "100000073750" => Ok(Self::N100000073750),
            "100000073751" => Ok(Self::N100000073751),
            "100000073752" => Ok(Self::N100000073752),
            "100000073753" => Ok(Self::N100000073753),
            "100000073754" => Ok(Self::N100000073754),
            "100000073755" => Ok(Self::N100000073755),
            "100000073756" => Ok(Self::N100000073756),
            "100000073757" => Ok(Self::N100000073757),
            "100000073758" => Ok(Self::N100000073758),
            "100000073759" => Ok(Self::N100000073759),
            "100000073760" => Ok(Self::N100000073760),
            "100000073761" => Ok(Self::N100000073761),
            "100000073762" => Ok(Self::N100000073762),
            "100000073763" => Ok(Self::N100000073763),
            "100000073764" => Ok(Self::N100000073764),
            "100000073765" => Ok(Self::N100000073765),
            "100000073766" => Ok(Self::N100000073766),
            "100000073767" => Ok(Self::N100000073767),
            "100000073768" => Ok(Self::N100000073768),
            "100000073769" => Ok(Self::N100000073769),
            "100000073770" => Ok(Self::N100000073770),
            "100000073771" => Ok(Self::N100000073771),
            "100000073772" => Ok(Self::N100000073772),
            "100000073773" => Ok(Self::N100000073773),
            "100000073775" => Ok(Self::N100000073775),
            "100000073776" => Ok(Self::N100000073776),
            "100000073777" => Ok(Self::N100000073777),
            "100000073778" => Ok(Self::N100000073778),
            "100000073779" => Ok(Self::N100000073779),
            "100000073780" => Ok(Self::N100000073780),
            "100000073782" => Ok(Self::N100000073782),
            "100000073783" => Ok(Self::N100000073783),
            "100000073784" => Ok(Self::N100000073784),
            "100000073785" => Ok(Self::N100000073785),
            "100000073786" => Ok(Self::N100000073786),
            "100000073787" => Ok(Self::N100000073787),
            "100000073788" => Ok(Self::N100000073788),
            "100000073789" => Ok(Self::N100000073789),
            "100000073790" => Ok(Self::N100000073790),
            "100000073791" => Ok(Self::N100000073791),
            "100000073792" => Ok(Self::N100000073792),
            "100000073793" => Ok(Self::N100000073793),
            "100000073794" => Ok(Self::N100000073794),
            "100000073795" => Ok(Self::N100000073795),
            "100000073796" => Ok(Self::N100000073796),
            "100000073797" => Ok(Self::N100000073797),
            "100000073798" => Ok(Self::N100000073798),
            "100000073799" => Ok(Self::N100000073799),
            "100000073800" => Ok(Self::N100000073800),
            "100000073802" => Ok(Self::N100000073802),
            "100000073803" => Ok(Self::N100000073803),
            "100000073804" => Ok(Self::N100000073804),
            "100000073805" => Ok(Self::N100000073805),
            "100000073806" => Ok(Self::N100000073806),
            "100000073807" => Ok(Self::N100000073807),
            "100000073808" => Ok(Self::N100000073808),
            "100000073809" => Ok(Self::N100000073809),
            "100000073810" => Ok(Self::N100000073810),
            "100000073811" => Ok(Self::N100000073811),
            "100000073812" => Ok(Self::N100000073812),
            "100000073813" => Ok(Self::N100000073813),
            "100000073814" => Ok(Self::N100000073814),
            "100000073815" => Ok(Self::N100000073815),
            "100000073816" => Ok(Self::N100000073816),
            "100000073817" => Ok(Self::N100000073817),
            "100000073818" => Ok(Self::N100000073818),
            "100000073819" => Ok(Self::N100000073819),
            "100000073820" => Ok(Self::N100000073820),
            "100000073821" => Ok(Self::N100000073821),
            "100000073822" => Ok(Self::N100000073822),
            "100000073823" => Ok(Self::N100000073823),
            "100000073824" => Ok(Self::N100000073824),
            "100000073825" => Ok(Self::N100000073825),
            "100000073826" => Ok(Self::N100000073826),
            "100000073827" => Ok(Self::N100000073827),
            "100000073863" => Ok(Self::N100000073863),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdministrableDoseForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073362 => "100000073362",
            Self::N100000073363 => "100000073363",
            Self::N100000073364 => "100000073364",
            Self::N100000073365 => "100000073365",
            Self::N100000073367 => "100000073367",
            Self::N100000073368 => "100000073368",
            Self::N100000073369 => "100000073369",
            Self::N100000073370 => "100000073370",
            Self::N100000073371 => "100000073371",
            Self::N100000073372 => "100000073372",
            Self::N100000073373 => "100000073373",
            Self::N100000073374 => "100000073374",
            Self::N100000073375 => "100000073375",
            Self::N100000073376 => "100000073376",
            Self::N100000073377 => "100000073377",
            Self::N100000073378 => "100000073378",
            Self::N100000073379 => "100000073379",
            Self::N100000073380 => "100000073380",
            Self::N100000073642 => "100000073642",
            Self::N100000073643 => "100000073643",
            Self::N100000073644 => "100000073644",
            Self::N100000073645 => "100000073645",
            Self::N100000073646 => "100000073646",
            Self::N100000073647 => "100000073647",
            Self::N100000073648 => "100000073648",
            Self::N100000073649 => "100000073649",
            Self::N100000073650 => "100000073650",
            Self::N100000073652 => "100000073652",
            Self::N100000073653 => "100000073653",
            Self::N100000073654 => "100000073654",
            Self::N100000073655 => "100000073655",
            Self::N100000073656 => "100000073656",
            Self::N100000073657 => "100000073657",
            Self::N100000073658 => "100000073658",
            Self::N100000073659 => "100000073659",
            Self::N100000073660 => "100000073660",
            Self::N100000073661 => "100000073661",
            Self::N100000073662 => "100000073662",
            Self::N100000073663 => "100000073663",
            Self::N100000073664 => "100000073664",
            Self::N100000073665 => "100000073665",
            Self::N100000073666 => "100000073666",
            Self::N100000073667 => "100000073667",
            Self::N100000073668 => "100000073668",
            Self::N100000073669 => "100000073669",
            Self::N100000073670 => "100000073670",
            Self::N100000073671 => "100000073671",
            Self::N100000073672 => "100000073672",
            Self::N100000073673 => "100000073673",
            Self::N100000073674 => "100000073674",
            Self::N100000073675 => "100000073675",
            Self::N100000073676 => "100000073676",
            Self::N100000073677 => "100000073677",
            Self::N100000073678 => "100000073678",
            Self::N100000073679 => "100000073679",
            Self::N100000073680 => "100000073680",
            Self::N100000073681 => "100000073681",
            Self::N100000073682 => "100000073682",
            Self::N100000073683 => "100000073683",
            Self::N100000073684 => "100000073684",
            Self::N100000073685 => "100000073685",
            Self::N100000073686 => "100000073686",
            Self::N100000073687 => "100000073687",
            Self::N100000073688 => "100000073688",
            Self::N100000073689 => "100000073689",
            Self::N100000073690 => "100000073690",
            Self::N100000073691 => "100000073691",
            Self::N100000073692 => "100000073692",
            Self::N100000073693 => "100000073693",
            Self::N100000073694 => "100000073694",
            Self::N100000073695 => "100000073695",
            Self::N100000073696 => "100000073696",
            Self::N100000073697 => "100000073697",
            Self::N100000073698 => "100000073698",
            Self::N100000073699 => "100000073699",
            Self::N100000073700 => "100000073700",
            Self::N100000073701 => "100000073701",
            Self::N100000073702 => "100000073702",
            Self::N100000073703 => "100000073703",
            Self::N100000073704 => "100000073704",
            Self::N100000073705 => "100000073705",
            Self::N100000073706 => "100000073706",
            Self::N100000073707 => "100000073707",
            Self::N100000073708 => "100000073708",
            Self::N100000073709 => "100000073709",
            Self::N100000073710 => "100000073710",
            Self::N100000073711 => "100000073711",
            Self::N100000073712 => "100000073712",
            Self::N100000073713 => "100000073713",
            Self::N100000073714 => "100000073714",
            Self::N100000073715 => "100000073715",
            Self::N100000073716 => "100000073716",
            Self::N100000073717 => "100000073717",
            Self::N100000073718 => "100000073718",
            Self::N100000073719 => "100000073719",
            Self::N100000073720 => "100000073720",
            Self::N100000073721 => "100000073721",
            Self::N100000073722 => "100000073722",
            Self::N100000073723 => "100000073723",
            Self::N100000073724 => "100000073724",
            Self::N100000073725 => "100000073725",
            Self::N100000073726 => "100000073726",
            Self::N100000073727 => "100000073727",
            Self::N100000073728 => "100000073728",
            Self::N100000073729 => "100000073729",
            Self::N100000073730 => "100000073730",
            Self::N100000073731 => "100000073731",
            Self::N100000073732 => "100000073732",
            Self::N100000073733 => "100000073733",
            Self::N100000073734 => "100000073734",
            Self::N100000073735 => "100000073735",
            Self::N100000073736 => "100000073736",
            Self::N100000073737 => "100000073737",
            Self::N100000073738 => "100000073738",
            Self::N100000073739 => "100000073739",
            Self::N100000073740 => "100000073740",
            Self::N100000073741 => "100000073741",
            Self::N100000073742 => "100000073742",
            Self::N100000073743 => "100000073743",
            Self::N100000073744 => "100000073744",
            Self::N100000073745 => "100000073745",
            Self::N100000073746 => "100000073746",
            Self::N100000073747 => "100000073747",
            Self::N100000073748 => "100000073748",
            Self::N100000073749 => "100000073749",
            Self::N100000073750 => "100000073750",
            Self::N100000073751 => "100000073751",
            Self::N100000073752 => "100000073752",
            Self::N100000073753 => "100000073753",
            Self::N100000073754 => "100000073754",
            Self::N100000073755 => "100000073755",
            Self::N100000073756 => "100000073756",
            Self::N100000073757 => "100000073757",
            Self::N100000073758 => "100000073758",
            Self::N100000073759 => "100000073759",
            Self::N100000073760 => "100000073760",
            Self::N100000073761 => "100000073761",
            Self::N100000073762 => "100000073762",
            Self::N100000073763 => "100000073763",
            Self::N100000073764 => "100000073764",
            Self::N100000073765 => "100000073765",
            Self::N100000073766 => "100000073766",
            Self::N100000073767 => "100000073767",
            Self::N100000073768 => "100000073768",
            Self::N100000073769 => "100000073769",
            Self::N100000073770 => "100000073770",
            Self::N100000073771 => "100000073771",
            Self::N100000073772 => "100000073772",
            Self::N100000073773 => "100000073773",
            Self::N100000073775 => "100000073775",
            Self::N100000073776 => "100000073776",
            Self::N100000073777 => "100000073777",
            Self::N100000073778 => "100000073778",
            Self::N100000073779 => "100000073779",
            Self::N100000073780 => "100000073780",
            Self::N100000073782 => "100000073782",
            Self::N100000073783 => "100000073783",
            Self::N100000073784 => "100000073784",
            Self::N100000073785 => "100000073785",
            Self::N100000073786 => "100000073786",
            Self::N100000073787 => "100000073787",
            Self::N100000073788 => "100000073788",
            Self::N100000073789 => "100000073789",
            Self::N100000073790 => "100000073790",
            Self::N100000073791 => "100000073791",
            Self::N100000073792 => "100000073792",
            Self::N100000073793 => "100000073793",
            Self::N100000073794 => "100000073794",
            Self::N100000073795 => "100000073795",
            Self::N100000073796 => "100000073796",
            Self::N100000073797 => "100000073797",
            Self::N100000073798 => "100000073798",
            Self::N100000073799 => "100000073799",
            Self::N100000073800 => "100000073800",
            Self::N100000073802 => "100000073802",
            Self::N100000073803 => "100000073803",
            Self::N100000073804 => "100000073804",
            Self::N100000073805 => "100000073805",
            Self::N100000073806 => "100000073806",
            Self::N100000073807 => "100000073807",
            Self::N100000073808 => "100000073808",
            Self::N100000073809 => "100000073809",
            Self::N100000073810 => "100000073810",
            Self::N100000073811 => "100000073811",
            Self::N100000073812 => "100000073812",
            Self::N100000073813 => "100000073813",
            Self::N100000073814 => "100000073814",
            Self::N100000073815 => "100000073815",
            Self::N100000073816 => "100000073816",
            Self::N100000073817 => "100000073817",
            Self::N100000073818 => "100000073818",
            Self::N100000073819 => "100000073819",
            Self::N100000073820 => "100000073820",
            Self::N100000073821 => "100000073821",
            Self::N100000073822 => "100000073822",
            Self::N100000073823 => "100000073823",
            Self::N100000073824 => "100000073824",
            Self::N100000073825 => "100000073825",
            Self::N100000073826 => "100000073826",
            Self::N100000073827 => "100000073827",
            Self::N100000073863 => "100000073863",
        }
    }
}
impl ::std::fmt::Display for AdministrableDoseForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000073362 => "Oral suspension",
            Self::N100000073363 => "Oral gel",
            Self::N100000073364 => "Powder for oral solution",
            Self::N100000073365 => "Granules for oral solution",
            Self::N100000073367 => "Lyophilisate for suspension",
            Self::N100000073368 => "Powder for syrup",
            Self::N100000073369 => "Soluble tablet",
            Self::N100000073370 => "Herbal tea",
            Self::N100000073371 => "Instant herbal tea",
            Self::N100000073372 => "Granules",
            Self::N100000073373 => "Gastro-resistant granules",
            Self::N100000073374 => "Modified-release granules",
            Self::N100000073375 => "Capsule, hard",
            Self::N100000073376 => "Gastro-resistant capsule, hard",
            Self::N100000073377 => "Chewable capsule, soft",
            Self::N100000073378 => "Prolonged-release capsule, soft",
            Self::N100000073379 => "Modified-release capsule, soft",
            Self::N100000073380 => "Coated tablet",
            Self::N100000073642 => "Oral drops, solution",
            Self::N100000073643 => "Oral drops, suspension",
            Self::N100000073644 => "Oral drops, emulsion",
            Self::N100000073645 => "Oral liquid",
            Self::N100000073646 => "Oral solution",
            Self::N100000073647 => "Oral emulsion",
            Self::N100000073648 => "Oral paste",
            Self::N100000073649 => "Powder for oral suspension",
            Self::N100000073650 => "Granules for oral suspension",
            Self::N100000073652 => "Syrup",
            Self::N100000073653 => "Granules for syrup",
            Self::N100000073654 => "Dispersible tablet",
            Self::N100000073655 => "Oral powder",
            Self::N100000073656 => "Effervescent powder",
            Self::N100000073657 => "Effervescent granules",
            Self::N100000073658 => "Prolonged-release granules",
            Self::N100000073659 => "Cachet",
            Self::N100000073660 => "Capsule, soft",
            Self::N100000073661 => "Gastro-resistant capsule, soft",
            Self::N100000073662 => "Prolonged-release capsule, hard",
            Self::N100000073663 => "Modified-release capsule, hard",
            Self::N100000073664 => "Tablet",
            Self::N100000073665 => "Film-coated tablet",
            Self::N100000073666 => "Orodispersible tablet",
            Self::N100000073667 => "Gastro-resistant tablet",
            Self::N100000073668 => "Modified-release tablet",
            Self::N100000073669 => "Medicated chewing-gum",
            Self::N100000073670 => "Pillules",
            Self::N100000073671 => "Pulsatile-release intraruminal device",
            Self::N100000073672 => "Premix for medicated feeding stuff",
            Self::N100000073673 => "Gargle",
            Self::N100000073674 => "Gargle, powder for solution",
            Self::N100000073675 => "Oromucosal suspension",
            Self::N100000073676 => "Oromucosal spray",
            Self::N100000073677 => "Mouthwash",
            Self::N100000073678 => "Gingival solution",
            Self::N100000073679 => "Oromucosal paste",
            Self::N100000073680 => "Gingival gel",
            Self::N100000073681 => "Effervescent tablet",
            Self::N100000073682 => "Oral lyophilisate",
            Self::N100000073683 => "Prolonged-release tablet",
            Self::N100000073684 => "Chewable tablet",
            Self::N100000073685 => "Oral gum",
            Self::N100000073686 => "Continuous-release intraruminal device",
            Self::N100000073687 => "Lick block",
            Self::N100000073688 => "Medicated pellets",
            Self::N100000073689 => "Concentrate for gargle",
            Self::N100000073690 => "Gargle, tablet for solution",
            Self::N100000073691 => "Oromucosal solution",
            Self::N100000073692 => "Oromucosal drops",
            Self::N100000073693 => "Sublingual spray",
            Self::N100000073694 => "Mouthwash, tablet for solution",
            Self::N100000073695 => "Oromucosal gel",
            Self::N100000073696 => "Oromucosal cream",
            Self::N100000073697 => "Gingival paste",
            Self::N100000073698 => "Sublingual tablet",
            Self::N100000073699 => "Buccal tablet",
            Self::N100000073700 => "Compressed lozenge",
            Self::N100000073701 => "Oromucosal capsule",
            Self::N100000073702 => "Muco-adhesive buccal tablet",
            Self::N100000073703 => "Lozenge",
            Self::N100000073704 => "Pastille",
            Self::N100000073705 => "Dental gel",
            Self::N100000073706 => "Dental insert",
            Self::N100000073707 => "Dental powder",
            Self::N100000073708 => "Dental suspension",
            Self::N100000073709 => "Toothpaste",
            Self::N100000073710 => "Periodontal gel",
            Self::N100000073711 => "Bath additive",
            Self::N100000073712 => "Cream",
            Self::N100000073713 => "Ointment",
            Self::N100000073714 => "Medicated plaster",
            Self::N100000073715 => "Shampoo",
            Self::N100000073716 => "Cutaneous spray, suspension",
            Self::N100000073717 => "Cutaneous liquid",
            Self::N100000073718 => "Concentrate for cutaneous solution",
            Self::N100000073719 => "Cutaneous emulsion",
            Self::N100000073720 => "Cutaneous patch",
            Self::N100000073721 => "Periodontal powder",
            Self::N100000073722 => "Dental stick",
            Self::N100000073723 => "Dental solution",
            Self::N100000073724 => "Dental emulsion",
            Self::N100000073725 => "Periodontal insert",
            Self::N100000073726 => "Gel",
            Self::N100000073727 => "Cutaneous paste",
            Self::N100000073728 => "Cutaneous foam",
            Self::N100000073729 => "Cutaneous spray, solution",
            Self::N100000073730 => "Cutaneous spray, powder",
            Self::N100000073731 => "Cutaneous solution",
            Self::N100000073732 => "Cutaneous suspension",
            Self::N100000073733 => "Cutaneous powder",
            Self::N100000073734 => "Solution for iontophoresis",
            Self::N100000073735 => "Collodion",
            Self::N100000073736 => "Poultice",
            Self::N100000073737 => "Cutaneous sponge",
            Self::N100000073738 => "Collar",
            Self::N100000073739 => "Ear tag",
            Self::N100000073740 => "Dip suspension",
            Self::N100000073741 => "Transdermal patch",
            Self::N100000073742 => "Medicated nail lacquer",
            Self::N100000073743 => "Cutaneous stick",
            Self::N100000073744 => "Impregnated dressing",
            Self::N100000073745 => "Medicated pendant",
            Self::N100000073746 => "Dip solution",
            Self::N100000073747 => "Dip emulsion",
            Self::N100000073748 => "Concentrate for dip suspension",
            Self::N100000073749 => "Powder for dip solution",
            Self::N100000073750 => "Powder for suspension for fish treatment",
            Self::N100000073751 => "Pour-on suspension",
            Self::N100000073752 => "Spot-on solution",
            Self::N100000073753 => "Spot-on emulsion",
            Self::N100000073754 => "Teat dip suspension",
            Self::N100000073755 => "Teat spray solution",
            Self::N100000073756 => "Solution for skin-prick test",
            Self::N100000073757 => "Plaster for provocation test",
            Self::N100000073758 => "Eye gel",
            Self::N100000073759 => "Eye drops, solution",
            Self::N100000073760 => "Eye drops, suspension",
            Self::N100000073761 => "Concentrate for dip solution",
            Self::N100000073762 => "Concentrate for dip emulsion",
            Self::N100000073763 => "Concentrate for solution for fish treatment",
            Self::N100000073764 => "Pour-on solution",
            Self::N100000073765 => "Pour-on emulsion",
            Self::N100000073766 => "Spot-on suspension",
            Self::N100000073767 => "Teat dip solution",
            Self::N100000073768 => "Teat dip emulsion",
            Self::N100000073769 => "Transdermal system",
            Self::N100000073770 => "Solution for skin-scratch test",
            Self::N100000073771 => "Eye cream",
            Self::N100000073772 => "Eye ointment",
            Self::N100000073773 => "Eye drops, emulsion",
            Self::N100000073775 => "Eye drops, solvent for reconstitution",
            Self::N100000073776 => "Eye lotion",
            Self::N100000073777 => "Ophthalmic insert",
            Self::N100000073778 => "Ear cream",
            Self::N100000073779 => "Ear ointment",
            Self::N100000073780 => "Ear drops, suspension",
            Self::N100000073782 => "Eye drops, prolonged-release",
            Self::N100000073783 => "Eye lotion, solvent for reconstitution",
            Self::N100000073784 => "Ophthalmic strip",
            Self::N100000073785 => "Ear gel",
            Self::N100000073786 => "Ear drops, solution",
            Self::N100000073787 => "Ear drops, emulsion",
            Self::N100000073788 => "Ear powder",
            Self::N100000073789 => "Ear spray, suspension",
            Self::N100000073790 => "Ear wash, solution",
            Self::N100000073791 => "Ear tampon",
            Self::N100000073792 => "Nasal cream",
            Self::N100000073793 => "Nasal gel",
            Self::N100000073794 => "Nasal drops, solution",
            Self::N100000073795 => "Nasal drops, emulsion",
            Self::N100000073796 => "Nasal spray, solution",
            Self::N100000073797 => "Nasal spray, emulsion",
            Self::N100000073798 => "Nasal stick",
            Self::N100000073799 => "Vaginal gel",
            Self::N100000073800 => "Vaginal foam",
            Self::N100000073802 => "Ear spray, solution",
            Self::N100000073803 => "Ear spray, emulsion",
            Self::N100000073804 => "Ear wash, emulsion",
            Self::N100000073805 => "Ear stick",
            Self::N100000073806 => "Nasal ointment",
            Self::N100000073807 => "Nasal drops, suspension",
            Self::N100000073808 => "Nasal powder",
            Self::N100000073809 => "Nasal spray, suspension",
            Self::N100000073810 => "Nasal wash",
            Self::N100000073811 => "Vaginal cream",
            Self::N100000073812 => "Vaginal ointment",
            Self::N100000073813 => "Vaginal solution",
            Self::N100000073814 => "Vaginal emulsion",
            Self::N100000073815 => "Pessary",
            Self::N100000073816 => "Vaginal capsule, soft",
            Self::N100000073817 => "Effervescent vaginal tablet",
            Self::N100000073818 => "Vaginal delivery system",
            Self::N100000073819 => "Rectal cream",
            Self::N100000073820 => "Rectal foam",
            Self::N100000073821 => "Vaginal suspension",
            Self::N100000073822 => "Tablet for vaginal solution",
            Self::N100000073823 => "Vaginal capsule, hard",
            Self::N100000073824 => "Vaginal tablet",
            Self::N100000073825 => "Medicated vaginal tampon",
            Self::N100000073826 => "Vaginal sponge",
            Self::N100000073827 => "Rectal gel",
            Self::N100000073863 => "Solution for injection",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AdministrableDoseForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdministrableDoseForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdministrableDoseForm> for Coding {
    fn from(code: AdministrableDoseForm) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/administrable-dose-form".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AdministrableDoseForm> for CodeableConcept {
    fn from(code: AdministrableDoseForm) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AdministrationSubPotentReason](http://hl7.org/fhir/CodeSystem/administration-subpotent-reason)**. This value set is provided as an example. The value set to instantiate this attribute should be drawn from a robust terminology code system that consists of or contains concepts to support the medication administration process.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AdministrationSubPotentReason {
    /** **adversestorage**

Adverse Storage. The medication experienced adverse storage conditions. */
    Adversestorage,
    /** **coldchainbreak**

Cold Chain Break. The medication experienced a cold chain break. */
    Coldchainbreak,
    /** **expired**

Expired Product. The medication was expired at the time of administration. */
    Expired,
    /** **partialdose**

Partial Dose. The full amount of the dose was not administered to the patient. */
    Partialdose,
    /** **recall**

Manufacturer Recall. The medication was recalled by the manufacturer. */
    Recall,
    /** **vomited**

Vomited. The patient vomited part of the dose. */
    Vomited,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AdministrationSubPotentReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "adversestorage" => Ok(Self::Adversestorage),
            "coldchainbreak" => Ok(Self::Coldchainbreak),
            "expired" => Ok(Self::Expired),
            "partialdose" => Ok(Self::Partialdose),
            "recall" => Ok(Self::Recall),
            "vomited" => Ok(Self::Vomited),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AdministrationSubPotentReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adversestorage => "adversestorage",
            Self::Coldchainbreak => "coldchainbreak",
            Self::Expired => "expired",
            Self::Partialdose => "partialdose",
            Self::Recall => "recall",
            Self::Vomited => "vomited",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for AdministrationSubPotentReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Adversestorage => "Adverse Storage",
            Self::Coldchainbreak => "Cold Chain Break",
            Self::Expired => "Expired Product",
            Self::Partialdose => "Partial Dose",
            Self::Recall => "Manufacturer Recall",
            Self::Vomited => "Vomited",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AdministrationSubPotentReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdministrationSubPotentReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdministrationSubPotentReason> for Coding {
    fn from(code: AdministrationSubPotentReason) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/CodeSystem/administration-subpotent-reason"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AdministrationSubPotentReason> for CodeableConcept {
    fn from(code: AdministrationSubPotentReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AdministrativeGender](http://hl7.org/fhir/ValueSet/administrative-gender)**. The gender of a person used for administrative purposes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdministrativeGender {
    /** **female**

Female. Female. */
    Female,
    /** **male**

Male. Male. */
    Male,
    /** **other**

Other. Other. */
    Other,
    /** **unknown**

Unknown. Unknown. */
    Unknown,
}
impl ::core::str::FromStr for AdministrativeGender {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "female" => Ok(Self::Female),
            "male" => Ok(Self::Male),
            "other" => Ok(Self::Other),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdministrativeGender {
    fn as_ref(&self) -> &str {
        match self {
            Self::Female => "female",
            Self::Male => "male",
            Self::Other => "other",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for AdministrativeGender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Female => "Female",
            Self::Male => "Male",
            Self::Other => "Other",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AdministrativeGender {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdministrativeGender {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdministrativeGender> for Coding {
    fn from(code: AdministrativeGender) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/administrative-gender".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AdministrativeGender> for CodeableConcept {
    fn from(code: AdministrativeGender) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AdverseEventActuality](http://hl7.org/fhir/ValueSet/adverse-event-actuality)**. Overall nature of the adverse event, e.g. real or potential.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdverseEventActuality {
    /** **actual**

Adverse Event. The adverse event actually happened regardless of whether anyone was affected or harmed. */
    Actual,
    /** **potential**

Potential Adverse Event. A potential adverse event. */
    Potential,
}
impl ::core::str::FromStr for AdverseEventActuality {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "actual" => Ok(Self::Actual),
            "potential" => Ok(Self::Potential),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventActuality {
    fn as_ref(&self) -> &str {
        match self {
            Self::Actual => "actual",
            Self::Potential => "potential",
        }
    }
}
impl ::std::fmt::Display for AdverseEventActuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Actual => "Adverse Event",
            Self::Potential => "Potential Adverse Event",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AdverseEventActuality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventActuality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AdverseEventActuality> for Coding {
    fn from(code: AdverseEventActuality) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/adverse-event-actuality".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AdverseEventActuality> for CodeableConcept {
    fn from(code: AdverseEventActuality) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AggregationMode](http://hl7.org/fhir/ValueSet/resource-aggregation-mode)**. How resource references can be aggregated.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AggregationMode {
    /** **bundled**

Bundled. When the resource is in a Bundle, the resource the reference points to will be found in the same bundle as the resource that includes the reference. */
    Bundled,
    /** **contained**

Contained. The reference is a local reference to a contained resource. */
    Contained,
    /** **referenced**

Referenced. The reference to a resource that has to be resolved externally to the resource that includes the reference. */
    Referenced,
}
impl ::core::str::FromStr for AggregationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bundled" => Ok(Self::Bundled),
            "contained" => Ok(Self::Contained),
            "referenced" => Ok(Self::Referenced),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AggregationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bundled => "bundled",
            Self::Contained => "contained",
            Self::Referenced => "referenced",
        }
    }
}
impl ::std::fmt::Display for AggregationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Bundled => "Bundled",
            Self::Contained => "Contained",
            Self::Referenced => "Referenced",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AggregationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AggregationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AggregationMode> for Coding {
    fn from(code: AggregationMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/resource-aggregation-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AggregationMode> for CodeableConcept {
    fn from(code: AggregationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AllergyIntoleranceCategory](http://hl7.org/fhir/ValueSet/allergy-intolerance-category)**. Category of an identified substance associated with allergies or intolerances.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceCategory {
    /** **biologic**

Biologic. A preparation that is synthesized from living organisms or their products, especially a human or animal protein, such as a hormone or antitoxin, that is used as a diagnostic, preventive, or therapeutic agent. Examples of biologic medications include: vaccines; allergenic extracts, which are used for both diagnosis and treatment (for example, allergy shots); gene therapies; cellular therapies.  There are other biologic products, such as tissues, which are not typically associated with allergies. */
    Biologic,
    /** **environment**

Environment. Any substances that are encountered in the environment, including any substance not already classified as food, medication, or biologic. */
    Environment,
    /** **food**

Food. Any substance consumed to provide nutritional support for the body. */
    Food,
    /** **medication**

Medication. Substances administered to achieve a physiological effect. */
    Medication,
}
impl ::core::str::FromStr for AllergyIntoleranceCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "biologic" => Ok(Self::Biologic),
            "environment" => Ok(Self::Environment),
            "food" => Ok(Self::Food),
            "medication" => Ok(Self::Medication),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Biologic => "biologic",
            Self::Environment => "environment",
            Self::Food => "food",
            Self::Medication => "medication",
        }
    }
}
impl ::std::fmt::Display for AllergyIntoleranceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Biologic => "Biologic",
            Self::Environment => "Environment",
            Self::Food => "Food",
            Self::Medication => "Medication",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceCategory> for Coding {
    fn from(code: AllergyIntoleranceCategory) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/allergy-intolerance-category".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AllergyIntoleranceCategory> for CodeableConcept {
    fn from(code: AllergyIntoleranceCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AllergyIntoleranceCriticality](http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality)**. Estimate of the potential clinical harm, or seriousness, of a reaction to an identified substance.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceCriticality {
    /** **high**

High Risk. Worst case result of a future exposure is assessed to be life-threatening or having high potential for organ system failure. */
    High,
    /** **low**

Low Risk. Worst case result of a future exposure is not assessed to be life-threatening or having high potential for organ system failure. */
    Low,
    /** **unable-to-assess**

Unable to Assess Risk. Unable to assess the worst case result of a future exposure. */
    UnableToAssess,
}
impl ::core::str::FromStr for AllergyIntoleranceCriticality {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "unable-to-assess" => Ok(Self::UnableToAssess),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCriticality {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::UnableToAssess => "unable-to-assess",
        }
    }
}
impl ::std::fmt::Display for AllergyIntoleranceCriticality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::High => "High Risk",
            Self::Low => "Low Risk",
            Self::UnableToAssess => "Unable to Assess Risk",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCriticality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCriticality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceCriticality> for Coding {
    fn from(code: AllergyIntoleranceCriticality) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AllergyIntoleranceCriticality> for CodeableConcept {
    fn from(code: AllergyIntoleranceCriticality) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AllergyIntoleranceSeverity](http://hl7.org/fhir/ValueSet/reaction-event-severity)**. Clinical assessment of the severity of a reaction event as a whole, potentially considering multiple different manifestations.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceSeverity {
    /** **mild**

Mild. Causes mild physiological effects. */
    Mild,
    /** **moderate**

Moderate. Causes moderate physiological effects. */
    Moderate,
    /** **severe**

Severe. Causes severe physiological effects. */
    Severe,
}
impl ::core::str::FromStr for AllergyIntoleranceSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mild" => Ok(Self::Mild),
            "moderate" => Ok(Self::Moderate),
            "severe" => Ok(Self::Severe),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mild => "mild",
            Self::Moderate => "moderate",
            Self::Severe => "severe",
        }
    }
}
impl ::std::fmt::Display for AllergyIntoleranceSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Mild => "Mild",
            Self::Moderate => "Moderate",
            Self::Severe => "Severe",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceSeverity> for Coding {
    fn from(code: AllergyIntoleranceSeverity) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/reaction-event-severity".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AllergyIntoleranceSeverity> for CodeableConcept {
    fn from(code: AllergyIntoleranceSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AllergyIntoleranceType](http://hl7.org/fhir/ValueSet/allergy-intolerance-type)**. Identification of the underlying physiological mechanism for a Reaction Risk.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceType {
    /** **allergy**

Allergy. A propensity for hypersensitive reaction(s) to a substance.  These reactions are most typically type I hypersensitivity, plus other "allergy-like" reactions, including pseudoallergy. */
    Allergy,
    /** **intolerance**

Intolerance. A propensity for adverse reactions to a substance that is judged to be not allergic or "allergy-like".  These reactions are typically (but not necessarily) non-immune.  They are to some degree idiosyncratic and/or patient-specific (i.e. are not a reaction that is expected to occur with most or all patients given similar circumstances). */
    Intolerance,
}
impl ::core::str::FromStr for AllergyIntoleranceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "allergy" => Ok(Self::Allergy),
            "intolerance" => Ok(Self::Intolerance),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Allergy => "allergy",
            Self::Intolerance => "intolerance",
        }
    }
}
impl ::std::fmt::Display for AllergyIntoleranceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Allergy => "Allergy",
            Self::Intolerance => "Intolerance",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AllergyIntoleranceType> for Coding {
    fn from(code: AllergyIntoleranceType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/allergy-intolerance-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AllergyIntoleranceType> for CodeableConcept {
    fn from(code: AllergyIntoleranceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AnimalTissueType](http://hl7.org/fhir/ValueSet/animal-tissue-type)**. A tissue type of an animal.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AnimalTissueType {
    /** **100000072091**

All relevant tissues. */
    N100000072091,
    /** **100000072092**

Fat. */
    N100000072092,
    /** **100000072093**

Honey. */
    N100000072093,
    /** **100000072094**

Liver. */
    N100000072094,
    /** **100000072095**

Fresh Milk. */
    N100000072095,
    /** **100000072096**

Muscle and skin in natural proportions. */
    N100000072096,
    /** **100000072104**

Eggs. */
    N100000072104,
    /** **100000072105**

Skin and fat. */
    N100000072105,
    /** **100000072106**

Kidney. */
    N100000072106,
    /** **100000072107**

Meat and offal. */
    N100000072107,
    /** **100000072108**

Muscle. */
    N100000072108,
    /** **100000072109**

Unspecified. */
    N100000072109,
    /** **100000111053**

Adipose tissue. */
    N100000111053,
    /** **100000111054**

Adrenal. */
    N100000111054,
    /** **100000111055**

Blood vessels. */
    N100000111055,
    /** **100000111056**

Bone. */
    N100000111056,
    /** **100000111057**

Bone marrow. */
    N100000111057,
    /** **100000111058**

Brain. */
    N100000111058,
    /** **100000111059**

Connective tissue. */
    N100000111059,
    /** **100000111060**

Cornea. */
    N100000111060,
    /** **100000111061**

Dental pulp. */
    N100000111061,
    /** **100000111062**

Duodenum. */
    N100000111062,
    /** **100000111063**

Dura mater. */
    N100000111063,
    /** **100000111064**

Egg, embryonated. */
    N100000111064,
    /** **100000111065**

Egg. */
    N100000111065,
    /** **100000111066**

Egg white. */
    N100000111066,
    /** **100000111067**

Egg yolk. */
    N100000111067,
    /** **100000111068**

Embryos. */
    N100000111068,
    /** **100000111069**

Enteric plexuses. */
    N100000111069,
    /** **100000111070**

Esophagus. */
    N100000111070,
    /** **100000111071**

Feathers. */
    N100000111071,
    /** **100000111072**

Foetus. */
    N100000111072,
    /** **100000111073**

Fore-stomach (ruminants only). */
    N100000111073,
    /** **100000111074**

Gingival tissue. */
    N100000111074,
    /** **100000111075**

Hair. */
    N100000111075,
    /** **100000111076**

Heart/pericardium. */
    N100000111076,
    /** **100000111077**

Hide. */
    N100000111077,
    /** **100000111078**

Hooves. */
    N100000111078,
    /** **100000111079**

Ileum. */
    N100000111079,
    /** **100000111080**

Jejunum. */
    N100000111080,
    /** **100000111081**

Kidney. */
    N100000111081,
    /** **100000111082**

Lard/lard oil. */
    N100000111082,
    /** **100000111083**

Large intestine. */
    N100000111083,
    /** **100000111084**

Liver. */
    N100000111084,
    /** **100000111085**

Lung. */
    N100000111085,
    /** **100000111086**

Lymph nodes. */
    N100000111086,
    /** **100000111087**

Mammary gland. */
    N100000111087,
    /** **100000111088**

Udder. */
    N100000111088,
    /** **100000111089**

Mammary tumour. */
    N100000111089,
    /** **100000111090**

Meat extract. */
    N100000111090,
    /** **100000111091**

Nasopharyngeal. */
    N100000111091,
    /** **100000111092**

Nictitating membrane. */
    N100000111092,
    /** **100000111093**

Nasal mucosa. */
    N100000111093,
    /** **100000111094**

Ovary. */
    N100000111094,
    /** **100000111095**

Pancreas. */
    N100000111095,
    /** **100000111096**

Peripheral nerves. */
    N100000111096,
    /** **100000111097**

Pituitary gland. */
    N100000111097,
    /** **100000111098**

Placenta. */
    N100000111098,
    /** **100000111099**

Prostate. */
    N100000111099,
    /** **100000111100**

Epididymis. */
    N100000111100,
    /** **100000111101**

Seminal vesicle. */
    N100000111101,
    /** **100000111102**

Rennet, calf. */
    N100000111102,
    /** **100000111103**

Retina. */
    N100000111103,
    /** **100000111104**

Optic nerve. */
    N100000111104,
    /** **100000111105**

Salivary gland. */
    N100000111105,
    /** **100000111106**

Shank. */
    N100000111106,
    /** **100000111107**

Skeletal muscle. */
    N100000111107,
    /** **100000111108**

Skin. */
    N100000111108,
    /** **100000111109**

Spinal ganglia. */
    N100000111109,
    /** **100000111110**

Spinal cord. */
    N100000111110,
    /** **100000111111**

Spleen. */
    N100000111111,
    /** **100000111112**

Stomach. */
    N100000111112,
    /** **100000111113**

Abomasum. */
    N100000111113,
    /** **100000111114**

Submaxillary glands. */
    N100000111114,
    /** **100000111115**

Tallow. */
    N100000111115,
    /** **100000111116**

Tendon. */
    N100000111116,
    /** **100000111117**

Testis. */
    N100000111117,
    /** **100000111118**

Thymus. */
    N100000111118,
    /** **100000111119**

Thyroid gland. */
    N100000111119,
    /** **100000111120**

Tongue. */
    N100000111120,
    /** **100000111121**

Tonsil. */
    N100000111121,
    /** **100000111122**

Trachea. */
    N100000111122,
    /** **100000111123**

Trigeminal ganglia. */
    N100000111123,
    /** **100000111124**

Tripe. */
    N100000111124,
    /** **100000111125**

Uterus (Non-gravid). */
    N100000111125,
    /** **100000111126**

Wool. */
    N100000111126,
    /** **100000111127**

Ascites fluid. */
    N100000111127,
    /** **100000111128**

Bile. */
    N100000111128,
    /** **100000111129**

Blood1. */
    N100000111129,
    /** **100000111130**

Blood, foetal. */
    N100000111130,
    /** **100000111131**

Colostrum. */
    N100000111131,
    /** **100000111132**

Cord blood. */
    N100000111132,
    /** **100000111133**

CSF. */
    N100000111133,
    /** **100000111134**

Faeces. */
    N100000111134,
    /** **100000111135**

Milk. */
    N100000111135,
    /** **100000111136**

Nasal mucus. */
    N100000111136,
    /** **100000111137**

Placenta fluids. */
    N100000111137,
    /** **100000111138**

Plasma. */
    N100000111138,
    /** **100000111139**

Saliva. */
    N100000111139,
    /** **100000111140**

Secretion from bees. */
    N100000111140,
    /** **100000111141**

Semen. */
    N100000111141,
    /** **100000111142**

Serum, calf. */
    N100000111142,
    /** **100000111143**

Serum, donor adult bovine. */
    N100000111143,
    /** **100000111144**

Serum, donor calf. */
    N100000111144,
    /** **100000111145**

Serum, foetal bovine. */
    N100000111145,
    /** **100000111146**

Serum, newborn calf. */
    N100000111146,
    /** **100000111147**

Serum/plasma derivate, adult bovine. */
    N100000111147,
    /** **100000111148**

Serum/plasma, adult bovine. */
    N100000111148,
    /** **100000111149**

Sweat. */
    N100000111149,
    /** **100000111150**

Tears. */
    N100000111150,
    /** **100000111151**

Urine. */
    N100000111151,
    /** **100000111152**

Venom. */
    N100000111152,
    /** **100000111153**

Whey. */
    N100000111153,
    /** **100000111154**

Casein. */
    N100000111154,
    /** **100000111155**

Fermentation products. */
    N100000111155,
    /** **100000111156**

Gelatin. */
    N100000111156,
    /** **100000111157**

Lactose. */
    N100000111157,
    /** **100000111158**

Protein. */
    N100000111158,
    /** **100000111159**

Insulin. */
    N100000111159,
    /** **100000111160**

Collagen. */
    N100000111160,
    /** **100000111161**

Animal Charcoal. */
    N100000111161,
    /** **100000111162**

Peptones. */
    N100000111162,
    /** **100000111163**

Fatty acids. */
    N100000111163,
    /** **100000111164**

Glycerol. */
    N100000111164,
    /** **100000125717**

Not applicable. */
    N100000125717,
    /** **100000136180**

Meat and offal, milk. */
    N100000136180,
    /** **100000136181**

Agar blood. */
    N100000136181,
    /** **100000136182**

Casamino acid. */
    N100000136182,
    /** **100000136183**

Casein, hydrolysate. */
    N100000136183,
    /** **100000136184**

Casein, pancreatic digest. */
    N100000136184,
    /** **100000136185**

Casein, peptides N3. */
    N100000136185,
    /** **100000136186**

Cells. */
    N100000136186,
    /** **100000136187**

Cells, BHK21. */
    N100000136187,
    /** **100000136188**

Cells, CHO. */
    N100000136188,
    /** **100000136189**

Cells, CRFK. */
    N100000136189,
    /** **100000136190**

Cells, embryo SPF. */
    N100000136190,
    /** **100000136191**

Cells, IRC5. */
    N100000136191,
    /** **100000136192**

Cells, kidney. */
    N100000136192,
    /** **100000136193**

Cells, MDCK. */
    N100000136193,
    /** **100000136194**

Cells, red blood. */
    N100000136194,
    /** **100000136195**

Collagen, hydrolysate. */
    N100000136195,
    /** **100000136196**

Cholesterol. */
    N100000136196,
    /** **100000136197**

Egg, SPF embryonated. */
    N100000136197,
    /** **100000136198**

Enzyme. */
    N100000136198,
    /** **100000136199**

Enzyme, pancreatic enzymes. */
    N100000136199,
    /** **100000136200**

Enzyme, pancreatin 6NF. */
    N100000136200,
    /** **100000136201**

Enzyme, pepsin. */
    N100000136201,
    /** **100000136202**

Enzyme, pronase. */
    N100000136202,
    /** **100000136203**

Enzyme, trypsin. */
    N100000136203,
    /** **100000136204**

Heart, digest. */
    N100000136204,
    /** **100000136205**

Heart, extract. */
    N100000136205,
    /** **100000136206**

Intestinal mucosae. */
    N100000136206,
    /** **100000136207**

Lactalbumin hydrolysate. */
    N100000136207,
    /** **100000136208**

Liver, digest. */
    N100000136208,
    /** **100000136209**

Lymphocytes. */
    N100000136209,
    /** **100000136210**

Meat. */
    N100000136210,
    /** **100000136211**

Meat, enzymic hydrolysate. */
    N100000136211,
    /** **100000136212**

Medium, cooked meat. */
    N100000136212,
    /** **100000136213**

Medium, F10-199 medium. */
    N100000136213,
    /** **100000136214**

Medium, FMD culture medium. */
    N100000136214,
    /** **100000136215**

Medium, Glasgow MEM culture. */
    N100000136215,
    /** **100000136216**

Medium, LB Agar Lennox. */
    N100000136216,
    /** **100000136217**

Medium, LB Broth Lennox. */
    N100000136217,
    /** **100000136218**

Medium, modified thioglycolate medium. */
    N100000136218,
    /** **100000136219**

Medium, trypticase soy broth. */
    N100000136219,
    /** **100000136220**

Medium, tryptose phosphate broth. */
    N100000136220,
    /** **100000136221**

Milk, skimmed. */
    N100000136221,
    /** **100000136222**

Pancreas, extract. */
    N100000136222,
    /** **100000136223**

Peptones, casein hydrochloric peptone. */
    N100000136223,
    /** **100000136224**

Peptones, casein tryptic peptone. */
    N100000136224,
    /** **100000136225**

Pituitary extract. */
    N100000136225,
    /** **100000136226**

Rennet. */
    N100000136226,
    /** **100000136227**

Medium, nutrient broth. */
    N100000136227,
    /** **100000136228**

Medium, NZ-Amine. */
    N100000136228,
    /** **100000136229**

Medium, thioglycolate medium. */
    N100000136229,
    /** **100000136230**

Peptones, proteose peptone. */
    N100000136230,
    /** **100000136231**

Serum. */
    N100000136231,
    /** **100000136232**

Serum, albumin. */
    N100000136232,
    /** **100000136233**

Serum, Iron fortified calf. */
    N100000136233,
    /** **100000136234**

Skin, connective tissue and bone. */
    N100000136234,
    /** **100000136235**

Sperm. */
    N100000136235,
    /** **100000136236**

Tryptone. */
    N100000136236,
    /** **100000136237**

Meat, extract desiccated. */
    N100000136237,
    /** **100000136247**

Stomach mucosa. */
    N100000136247,
    /** **100000136248**

Transferin. */
    N100000136248,
    /** **100000136554**

Non-neural. */
    N100000136554,
    /** **100000136555**

Not specified. */
    N100000136555,
    /** **100000136556**

Organ tissue. */
    N100000136556,
    /** **100000142485**

Skin and fat in natural proportions. */
    N100000142485,
}
impl ::core::str::FromStr for AnimalTissueType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000072091" => Ok(Self::N100000072091),
            "100000072092" => Ok(Self::N100000072092),
            "100000072093" => Ok(Self::N100000072093),
            "100000072094" => Ok(Self::N100000072094),
            "100000072095" => Ok(Self::N100000072095),
            "100000072096" => Ok(Self::N100000072096),
            "100000072104" => Ok(Self::N100000072104),
            "100000072105" => Ok(Self::N100000072105),
            "100000072106" => Ok(Self::N100000072106),
            "100000072107" => Ok(Self::N100000072107),
            "100000072108" => Ok(Self::N100000072108),
            "100000072109" => Ok(Self::N100000072109),
            "100000111053" => Ok(Self::N100000111053),
            "100000111054" => Ok(Self::N100000111054),
            "100000111055" => Ok(Self::N100000111055),
            "100000111056" => Ok(Self::N100000111056),
            "100000111057" => Ok(Self::N100000111057),
            "100000111058" => Ok(Self::N100000111058),
            "100000111059" => Ok(Self::N100000111059),
            "100000111060" => Ok(Self::N100000111060),
            "100000111061" => Ok(Self::N100000111061),
            "100000111062" => Ok(Self::N100000111062),
            "100000111063" => Ok(Self::N100000111063),
            "100000111064" => Ok(Self::N100000111064),
            "100000111065" => Ok(Self::N100000111065),
            "100000111066" => Ok(Self::N100000111066),
            "100000111067" => Ok(Self::N100000111067),
            "100000111068" => Ok(Self::N100000111068),
            "100000111069" => Ok(Self::N100000111069),
            "100000111070" => Ok(Self::N100000111070),
            "100000111071" => Ok(Self::N100000111071),
            "100000111072" => Ok(Self::N100000111072),
            "100000111073" => Ok(Self::N100000111073),
            "100000111074" => Ok(Self::N100000111074),
            "100000111075" => Ok(Self::N100000111075),
            "100000111076" => Ok(Self::N100000111076),
            "100000111077" => Ok(Self::N100000111077),
            "100000111078" => Ok(Self::N100000111078),
            "100000111079" => Ok(Self::N100000111079),
            "100000111080" => Ok(Self::N100000111080),
            "100000111081" => Ok(Self::N100000111081),
            "100000111082" => Ok(Self::N100000111082),
            "100000111083" => Ok(Self::N100000111083),
            "100000111084" => Ok(Self::N100000111084),
            "100000111085" => Ok(Self::N100000111085),
            "100000111086" => Ok(Self::N100000111086),
            "100000111087" => Ok(Self::N100000111087),
            "100000111088" => Ok(Self::N100000111088),
            "100000111089" => Ok(Self::N100000111089),
            "100000111090" => Ok(Self::N100000111090),
            "100000111091" => Ok(Self::N100000111091),
            "100000111092" => Ok(Self::N100000111092),
            "100000111093" => Ok(Self::N100000111093),
            "100000111094" => Ok(Self::N100000111094),
            "100000111095" => Ok(Self::N100000111095),
            "100000111096" => Ok(Self::N100000111096),
            "100000111097" => Ok(Self::N100000111097),
            "100000111098" => Ok(Self::N100000111098),
            "100000111099" => Ok(Self::N100000111099),
            "100000111100" => Ok(Self::N100000111100),
            "100000111101" => Ok(Self::N100000111101),
            "100000111102" => Ok(Self::N100000111102),
            "100000111103" => Ok(Self::N100000111103),
            "100000111104" => Ok(Self::N100000111104),
            "100000111105" => Ok(Self::N100000111105),
            "100000111106" => Ok(Self::N100000111106),
            "100000111107" => Ok(Self::N100000111107),
            "100000111108" => Ok(Self::N100000111108),
            "100000111109" => Ok(Self::N100000111109),
            "100000111110" => Ok(Self::N100000111110),
            "100000111111" => Ok(Self::N100000111111),
            "100000111112" => Ok(Self::N100000111112),
            "100000111113" => Ok(Self::N100000111113),
            "100000111114" => Ok(Self::N100000111114),
            "100000111115" => Ok(Self::N100000111115),
            "100000111116" => Ok(Self::N100000111116),
            "100000111117" => Ok(Self::N100000111117),
            "100000111118" => Ok(Self::N100000111118),
            "100000111119" => Ok(Self::N100000111119),
            "100000111120" => Ok(Self::N100000111120),
            "100000111121" => Ok(Self::N100000111121),
            "100000111122" => Ok(Self::N100000111122),
            "100000111123" => Ok(Self::N100000111123),
            "100000111124" => Ok(Self::N100000111124),
            "100000111125" => Ok(Self::N100000111125),
            "100000111126" => Ok(Self::N100000111126),
            "100000111127" => Ok(Self::N100000111127),
            "100000111128" => Ok(Self::N100000111128),
            "100000111129" => Ok(Self::N100000111129),
            "100000111130" => Ok(Self::N100000111130),
            "100000111131" => Ok(Self::N100000111131),
            "100000111132" => Ok(Self::N100000111132),
            "100000111133" => Ok(Self::N100000111133),
            "100000111134" => Ok(Self::N100000111134),
            "100000111135" => Ok(Self::N100000111135),
            "100000111136" => Ok(Self::N100000111136),
            "100000111137" => Ok(Self::N100000111137),
            "100000111138" => Ok(Self::N100000111138),
            "100000111139" => Ok(Self::N100000111139),
            "100000111140" => Ok(Self::N100000111140),
            "100000111141" => Ok(Self::N100000111141),
            "100000111142" => Ok(Self::N100000111142),
            "100000111143" => Ok(Self::N100000111143),
            "100000111144" => Ok(Self::N100000111144),
            "100000111145" => Ok(Self::N100000111145),
            "100000111146" => Ok(Self::N100000111146),
            "100000111147" => Ok(Self::N100000111147),
            "100000111148" => Ok(Self::N100000111148),
            "100000111149" => Ok(Self::N100000111149),
            "100000111150" => Ok(Self::N100000111150),
            "100000111151" => Ok(Self::N100000111151),
            "100000111152" => Ok(Self::N100000111152),
            "100000111153" => Ok(Self::N100000111153),
            "100000111154" => Ok(Self::N100000111154),
            "100000111155" => Ok(Self::N100000111155),
            "100000111156" => Ok(Self::N100000111156),
            "100000111157" => Ok(Self::N100000111157),
            "100000111158" => Ok(Self::N100000111158),
            "100000111159" => Ok(Self::N100000111159),
            "100000111160" => Ok(Self::N100000111160),
            "100000111161" => Ok(Self::N100000111161),
            "100000111162" => Ok(Self::N100000111162),
            "100000111163" => Ok(Self::N100000111163),
            "100000111164" => Ok(Self::N100000111164),
            "100000125717" => Ok(Self::N100000125717),
            "100000136180" => Ok(Self::N100000136180),
            "100000136181" => Ok(Self::N100000136181),
            "100000136182" => Ok(Self::N100000136182),
            "100000136183" => Ok(Self::N100000136183),
            "100000136184" => Ok(Self::N100000136184),
            "100000136185" => Ok(Self::N100000136185),
            "100000136186" => Ok(Self::N100000136186),
            "100000136187" => Ok(Self::N100000136187),
            "100000136188" => Ok(Self::N100000136188),
            "100000136189" => Ok(Self::N100000136189),
            "100000136190" => Ok(Self::N100000136190),
            "100000136191" => Ok(Self::N100000136191),
            "100000136192" => Ok(Self::N100000136192),
            "100000136193" => Ok(Self::N100000136193),
            "100000136194" => Ok(Self::N100000136194),
            "100000136195" => Ok(Self::N100000136195),
            "100000136196" => Ok(Self::N100000136196),
            "100000136197" => Ok(Self::N100000136197),
            "100000136198" => Ok(Self::N100000136198),
            "100000136199" => Ok(Self::N100000136199),
            "100000136200" => Ok(Self::N100000136200),
            "100000136201" => Ok(Self::N100000136201),
            "100000136202" => Ok(Self::N100000136202),
            "100000136203" => Ok(Self::N100000136203),
            "100000136204" => Ok(Self::N100000136204),
            "100000136205" => Ok(Self::N100000136205),
            "100000136206" => Ok(Self::N100000136206),
            "100000136207" => Ok(Self::N100000136207),
            "100000136208" => Ok(Self::N100000136208),
            "100000136209" => Ok(Self::N100000136209),
            "100000136210" => Ok(Self::N100000136210),
            "100000136211" => Ok(Self::N100000136211),
            "100000136212" => Ok(Self::N100000136212),
            "100000136213" => Ok(Self::N100000136213),
            "100000136214" => Ok(Self::N100000136214),
            "100000136215" => Ok(Self::N100000136215),
            "100000136216" => Ok(Self::N100000136216),
            "100000136217" => Ok(Self::N100000136217),
            "100000136218" => Ok(Self::N100000136218),
            "100000136219" => Ok(Self::N100000136219),
            "100000136220" => Ok(Self::N100000136220),
            "100000136221" => Ok(Self::N100000136221),
            "100000136222" => Ok(Self::N100000136222),
            "100000136223" => Ok(Self::N100000136223),
            "100000136224" => Ok(Self::N100000136224),
            "100000136225" => Ok(Self::N100000136225),
            "100000136226" => Ok(Self::N100000136226),
            "100000136227" => Ok(Self::N100000136227),
            "100000136228" => Ok(Self::N100000136228),
            "100000136229" => Ok(Self::N100000136229),
            "100000136230" => Ok(Self::N100000136230),
            "100000136231" => Ok(Self::N100000136231),
            "100000136232" => Ok(Self::N100000136232),
            "100000136233" => Ok(Self::N100000136233),
            "100000136234" => Ok(Self::N100000136234),
            "100000136235" => Ok(Self::N100000136235),
            "100000136236" => Ok(Self::N100000136236),
            "100000136237" => Ok(Self::N100000136237),
            "100000136247" => Ok(Self::N100000136247),
            "100000136248" => Ok(Self::N100000136248),
            "100000136554" => Ok(Self::N100000136554),
            "100000136555" => Ok(Self::N100000136555),
            "100000136556" => Ok(Self::N100000136556),
            "100000142485" => Ok(Self::N100000142485),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AnimalTissueType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000072091 => "100000072091",
            Self::N100000072092 => "100000072092",
            Self::N100000072093 => "100000072093",
            Self::N100000072094 => "100000072094",
            Self::N100000072095 => "100000072095",
            Self::N100000072096 => "100000072096",
            Self::N100000072104 => "100000072104",
            Self::N100000072105 => "100000072105",
            Self::N100000072106 => "100000072106",
            Self::N100000072107 => "100000072107",
            Self::N100000072108 => "100000072108",
            Self::N100000072109 => "100000072109",
            Self::N100000111053 => "100000111053",
            Self::N100000111054 => "100000111054",
            Self::N100000111055 => "100000111055",
            Self::N100000111056 => "100000111056",
            Self::N100000111057 => "100000111057",
            Self::N100000111058 => "100000111058",
            Self::N100000111059 => "100000111059",
            Self::N100000111060 => "100000111060",
            Self::N100000111061 => "100000111061",
            Self::N100000111062 => "100000111062",
            Self::N100000111063 => "100000111063",
            Self::N100000111064 => "100000111064",
            Self::N100000111065 => "100000111065",
            Self::N100000111066 => "100000111066",
            Self::N100000111067 => "100000111067",
            Self::N100000111068 => "100000111068",
            Self::N100000111069 => "100000111069",
            Self::N100000111070 => "100000111070",
            Self::N100000111071 => "100000111071",
            Self::N100000111072 => "100000111072",
            Self::N100000111073 => "100000111073",
            Self::N100000111074 => "100000111074",
            Self::N100000111075 => "100000111075",
            Self::N100000111076 => "100000111076",
            Self::N100000111077 => "100000111077",
            Self::N100000111078 => "100000111078",
            Self::N100000111079 => "100000111079",
            Self::N100000111080 => "100000111080",
            Self::N100000111081 => "100000111081",
            Self::N100000111082 => "100000111082",
            Self::N100000111083 => "100000111083",
            Self::N100000111084 => "100000111084",
            Self::N100000111085 => "100000111085",
            Self::N100000111086 => "100000111086",
            Self::N100000111087 => "100000111087",
            Self::N100000111088 => "100000111088",
            Self::N100000111089 => "100000111089",
            Self::N100000111090 => "100000111090",
            Self::N100000111091 => "100000111091",
            Self::N100000111092 => "100000111092",
            Self::N100000111093 => "100000111093",
            Self::N100000111094 => "100000111094",
            Self::N100000111095 => "100000111095",
            Self::N100000111096 => "100000111096",
            Self::N100000111097 => "100000111097",
            Self::N100000111098 => "100000111098",
            Self::N100000111099 => "100000111099",
            Self::N100000111100 => "100000111100",
            Self::N100000111101 => "100000111101",
            Self::N100000111102 => "100000111102",
            Self::N100000111103 => "100000111103",
            Self::N100000111104 => "100000111104",
            Self::N100000111105 => "100000111105",
            Self::N100000111106 => "100000111106",
            Self::N100000111107 => "100000111107",
            Self::N100000111108 => "100000111108",
            Self::N100000111109 => "100000111109",
            Self::N100000111110 => "100000111110",
            Self::N100000111111 => "100000111111",
            Self::N100000111112 => "100000111112",
            Self::N100000111113 => "100000111113",
            Self::N100000111114 => "100000111114",
            Self::N100000111115 => "100000111115",
            Self::N100000111116 => "100000111116",
            Self::N100000111117 => "100000111117",
            Self::N100000111118 => "100000111118",
            Self::N100000111119 => "100000111119",
            Self::N100000111120 => "100000111120",
            Self::N100000111121 => "100000111121",
            Self::N100000111122 => "100000111122",
            Self::N100000111123 => "100000111123",
            Self::N100000111124 => "100000111124",
            Self::N100000111125 => "100000111125",
            Self::N100000111126 => "100000111126",
            Self::N100000111127 => "100000111127",
            Self::N100000111128 => "100000111128",
            Self::N100000111129 => "100000111129",
            Self::N100000111130 => "100000111130",
            Self::N100000111131 => "100000111131",
            Self::N100000111132 => "100000111132",
            Self::N100000111133 => "100000111133",
            Self::N100000111134 => "100000111134",
            Self::N100000111135 => "100000111135",
            Self::N100000111136 => "100000111136",
            Self::N100000111137 => "100000111137",
            Self::N100000111138 => "100000111138",
            Self::N100000111139 => "100000111139",
            Self::N100000111140 => "100000111140",
            Self::N100000111141 => "100000111141",
            Self::N100000111142 => "100000111142",
            Self::N100000111143 => "100000111143",
            Self::N100000111144 => "100000111144",
            Self::N100000111145 => "100000111145",
            Self::N100000111146 => "100000111146",
            Self::N100000111147 => "100000111147",
            Self::N100000111148 => "100000111148",
            Self::N100000111149 => "100000111149",
            Self::N100000111150 => "100000111150",
            Self::N100000111151 => "100000111151",
            Self::N100000111152 => "100000111152",
            Self::N100000111153 => "100000111153",
            Self::N100000111154 => "100000111154",
            Self::N100000111155 => "100000111155",
            Self::N100000111156 => "100000111156",
            Self::N100000111157 => "100000111157",
            Self::N100000111158 => "100000111158",
            Self::N100000111159 => "100000111159",
            Self::N100000111160 => "100000111160",
            Self::N100000111161 => "100000111161",
            Self::N100000111162 => "100000111162",
            Self::N100000111163 => "100000111163",
            Self::N100000111164 => "100000111164",
            Self::N100000125717 => "100000125717",
            Self::N100000136180 => "100000136180",
            Self::N100000136181 => "100000136181",
            Self::N100000136182 => "100000136182",
            Self::N100000136183 => "100000136183",
            Self::N100000136184 => "100000136184",
            Self::N100000136185 => "100000136185",
            Self::N100000136186 => "100000136186",
            Self::N100000136187 => "100000136187",
            Self::N100000136188 => "100000136188",
            Self::N100000136189 => "100000136189",
            Self::N100000136190 => "100000136190",
            Self::N100000136191 => "100000136191",
            Self::N100000136192 => "100000136192",
            Self::N100000136193 => "100000136193",
            Self::N100000136194 => "100000136194",
            Self::N100000136195 => "100000136195",
            Self::N100000136196 => "100000136196",
            Self::N100000136197 => "100000136197",
            Self::N100000136198 => "100000136198",
            Self::N100000136199 => "100000136199",
            Self::N100000136200 => "100000136200",
            Self::N100000136201 => "100000136201",
            Self::N100000136202 => "100000136202",
            Self::N100000136203 => "100000136203",
            Self::N100000136204 => "100000136204",
            Self::N100000136205 => "100000136205",
            Self::N100000136206 => "100000136206",
            Self::N100000136207 => "100000136207",
            Self::N100000136208 => "100000136208",
            Self::N100000136209 => "100000136209",
            Self::N100000136210 => "100000136210",
            Self::N100000136211 => "100000136211",
            Self::N100000136212 => "100000136212",
            Self::N100000136213 => "100000136213",
            Self::N100000136214 => "100000136214",
            Self::N100000136215 => "100000136215",
            Self::N100000136216 => "100000136216",
            Self::N100000136217 => "100000136217",
            Self::N100000136218 => "100000136218",
            Self::N100000136219 => "100000136219",
            Self::N100000136220 => "100000136220",
            Self::N100000136221 => "100000136221",
            Self::N100000136222 => "100000136222",
            Self::N100000136223 => "100000136223",
            Self::N100000136224 => "100000136224",
            Self::N100000136225 => "100000136225",
            Self::N100000136226 => "100000136226",
            Self::N100000136227 => "100000136227",
            Self::N100000136228 => "100000136228",
            Self::N100000136229 => "100000136229",
            Self::N100000136230 => "100000136230",
            Self::N100000136231 => "100000136231",
            Self::N100000136232 => "100000136232",
            Self::N100000136233 => "100000136233",
            Self::N100000136234 => "100000136234",
            Self::N100000136235 => "100000136235",
            Self::N100000136236 => "100000136236",
            Self::N100000136237 => "100000136237",
            Self::N100000136247 => "100000136247",
            Self::N100000136248 => "100000136248",
            Self::N100000136554 => "100000136554",
            Self::N100000136555 => "100000136555",
            Self::N100000136556 => "100000136556",
            Self::N100000142485 => "100000142485",
        }
    }
}
impl ::std::fmt::Display for AnimalTissueType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000072091 => "All relevant tissues",
            Self::N100000072092 => "Fat",
            Self::N100000072093 => "Honey",
            Self::N100000072094 => "Liver",
            Self::N100000072095 => "Fresh Milk",
            Self::N100000072096 => "Muscle and skin in natural proportions",
            Self::N100000072104 => "Eggs",
            Self::N100000072105 => "Skin and fat",
            Self::N100000072106 => "Kidney",
            Self::N100000072107 => "Meat and offal",
            Self::N100000072108 => "Muscle",
            Self::N100000072109 => "Unspecified",
            Self::N100000111053 => "Adipose tissue",
            Self::N100000111054 => "Adrenal",
            Self::N100000111055 => "Blood vessels",
            Self::N100000111056 => "Bone",
            Self::N100000111057 => "Bone marrow",
            Self::N100000111058 => "Brain",
            Self::N100000111059 => "Connective tissue",
            Self::N100000111060 => "Cornea",
            Self::N100000111061 => "Dental pulp",
            Self::N100000111062 => "Duodenum",
            Self::N100000111063 => "Dura mater",
            Self::N100000111064 => "Egg, embryonated",
            Self::N100000111065 => "Egg",
            Self::N100000111066 => "Egg white",
            Self::N100000111067 => "Egg yolk",
            Self::N100000111068 => "Embryos",
            Self::N100000111069 => "Enteric plexuses",
            Self::N100000111070 => "Esophagus",
            Self::N100000111071 => "Feathers",
            Self::N100000111072 => "Foetus",
            Self::N100000111073 => "Fore-stomach (ruminants only)",
            Self::N100000111074 => "Gingival tissue",
            Self::N100000111075 => "Hair",
            Self::N100000111076 => "Heart/pericardium",
            Self::N100000111077 => "Hide",
            Self::N100000111078 => "Hooves",
            Self::N100000111079 => "Ileum",
            Self::N100000111080 => "Jejunum",
            Self::N100000111081 => "Kidney",
            Self::N100000111082 => "Lard/lard oil",
            Self::N100000111083 => "Large intestine",
            Self::N100000111084 => "Liver",
            Self::N100000111085 => "Lung",
            Self::N100000111086 => "Lymph nodes",
            Self::N100000111087 => "Mammary gland",
            Self::N100000111088 => "Udder",
            Self::N100000111089 => "Mammary tumour",
            Self::N100000111090 => "Meat extract",
            Self::N100000111091 => "Nasopharyngeal",
            Self::N100000111092 => "Nictitating membrane",
            Self::N100000111093 => "Nasal mucosa",
            Self::N100000111094 => "Ovary",
            Self::N100000111095 => "Pancreas",
            Self::N100000111096 => "Peripheral nerves",
            Self::N100000111097 => "Pituitary gland",
            Self::N100000111098 => "Placenta",
            Self::N100000111099 => "Prostate",
            Self::N100000111100 => "Epididymis",
            Self::N100000111101 => "Seminal vesicle",
            Self::N100000111102 => "Rennet, calf",
            Self::N100000111103 => "Retina",
            Self::N100000111104 => "Optic nerve",
            Self::N100000111105 => "Salivary gland",
            Self::N100000111106 => "Shank",
            Self::N100000111107 => "Skeletal muscle",
            Self::N100000111108 => "Skin",
            Self::N100000111109 => "Spinal ganglia",
            Self::N100000111110 => "Spinal cord",
            Self::N100000111111 => "Spleen",
            Self::N100000111112 => "Stomach",
            Self::N100000111113 => "Abomasum",
            Self::N100000111114 => "Submaxillary glands",
            Self::N100000111115 => "Tallow",
            Self::N100000111116 => "Tendon",
            Self::N100000111117 => "Testis",
            Self::N100000111118 => "Thymus",
            Self::N100000111119 => "Thyroid gland",
            Self::N100000111120 => "Tongue",
            Self::N100000111121 => "Tonsil",
            Self::N100000111122 => "Trachea",
            Self::N100000111123 => "Trigeminal ganglia",
            Self::N100000111124 => "Tripe",
            Self::N100000111125 => "Uterus (Non-gravid)",
            Self::N100000111126 => "Wool",
            Self::N100000111127 => "Ascites fluid",
            Self::N100000111128 => "Bile",
            Self::N100000111129 => "Blood1",
            Self::N100000111130 => "Blood, foetal",
            Self::N100000111131 => "Colostrum",
            Self::N100000111132 => "Cord blood",
            Self::N100000111133 => "CSF",
            Self::N100000111134 => "Faeces",
            Self::N100000111135 => "Milk",
            Self::N100000111136 => "Nasal mucus",
            Self::N100000111137 => "Placenta fluids",
            Self::N100000111138 => "Plasma",
            Self::N100000111139 => "Saliva",
            Self::N100000111140 => "Secretion from bees",
            Self::N100000111141 => "Semen",
            Self::N100000111142 => "Serum, calf",
            Self::N100000111143 => "Serum, donor adult bovine",
            Self::N100000111144 => "Serum, donor calf",
            Self::N100000111145 => "Serum, foetal bovine",
            Self::N100000111146 => "Serum, newborn calf",
            Self::N100000111147 => "Serum/plasma derivate, adult bovine",
            Self::N100000111148 => "Serum/plasma, adult bovine",
            Self::N100000111149 => "Sweat",
            Self::N100000111150 => "Tears",
            Self::N100000111151 => "Urine",
            Self::N100000111152 => "Venom",
            Self::N100000111153 => "Whey",
            Self::N100000111154 => "Casein",
            Self::N100000111155 => "Fermentation products",
            Self::N100000111156 => "Gelatin",
            Self::N100000111157 => "Lactose",
            Self::N100000111158 => "Protein",
            Self::N100000111159 => "Insulin",
            Self::N100000111160 => "Collagen",
            Self::N100000111161 => "Animal Charcoal",
            Self::N100000111162 => "Peptones",
            Self::N100000111163 => "Fatty acids",
            Self::N100000111164 => "Glycerol",
            Self::N100000125717 => "Not applicable",
            Self::N100000136180 => "Meat and offal, milk",
            Self::N100000136181 => "Agar blood",
            Self::N100000136182 => "Casamino acid",
            Self::N100000136183 => "Casein, hydrolysate",
            Self::N100000136184 => "Casein, pancreatic digest",
            Self::N100000136185 => "Casein, peptides N3",
            Self::N100000136186 => "Cells",
            Self::N100000136187 => "Cells, BHK21",
            Self::N100000136188 => "Cells, CHO",
            Self::N100000136189 => "Cells, CRFK",
            Self::N100000136190 => "Cells, embryo SPF",
            Self::N100000136191 => "Cells, IRC5",
            Self::N100000136192 => "Cells, kidney",
            Self::N100000136193 => "Cells, MDCK",
            Self::N100000136194 => "Cells, red blood",
            Self::N100000136195 => "Collagen, hydrolysate",
            Self::N100000136196 => "Cholesterol",
            Self::N100000136197 => "Egg, SPF embryonated",
            Self::N100000136198 => "Enzyme",
            Self::N100000136199 => "Enzyme, pancreatic enzymes",
            Self::N100000136200 => "Enzyme, pancreatin 6NF",
            Self::N100000136201 => "Enzyme, pepsin",
            Self::N100000136202 => "Enzyme, pronase",
            Self::N100000136203 => "Enzyme, trypsin",
            Self::N100000136204 => "Heart, digest",
            Self::N100000136205 => "Heart, extract",
            Self::N100000136206 => "Intestinal mucosae",
            Self::N100000136207 => "Lactalbumin hydrolysate",
            Self::N100000136208 => "Liver, digest",
            Self::N100000136209 => "Lymphocytes",
            Self::N100000136210 => "Meat",
            Self::N100000136211 => "Meat, enzymic hydrolysate",
            Self::N100000136212 => "Medium, cooked meat",
            Self::N100000136213 => "Medium, F10-199 medium",
            Self::N100000136214 => "Medium, FMD culture medium",
            Self::N100000136215 => "Medium, Glasgow MEM culture",
            Self::N100000136216 => "Medium, LB Agar Lennox",
            Self::N100000136217 => "Medium, LB Broth Lennox",
            Self::N100000136218 => "Medium, modified thioglycolate medium",
            Self::N100000136219 => "Medium, trypticase soy broth",
            Self::N100000136220 => "Medium, tryptose phosphate broth",
            Self::N100000136221 => "Milk, skimmed",
            Self::N100000136222 => "Pancreas, extract",
            Self::N100000136223 => "Peptones, casein hydrochloric peptone",
            Self::N100000136224 => "Peptones, casein tryptic peptone",
            Self::N100000136225 => "Pituitary extract",
            Self::N100000136226 => "Rennet",
            Self::N100000136227 => "Medium, nutrient broth",
            Self::N100000136228 => "Medium, NZ-Amine",
            Self::N100000136229 => "Medium, thioglycolate medium",
            Self::N100000136230 => "Peptones, proteose peptone",
            Self::N100000136231 => "Serum",
            Self::N100000136232 => "Serum, albumin",
            Self::N100000136233 => "Serum, Iron fortified calf",
            Self::N100000136234 => "Skin, connective tissue and bone",
            Self::N100000136235 => "Sperm",
            Self::N100000136236 => "Tryptone",
            Self::N100000136237 => "Meat, extract desiccated",
            Self::N100000136247 => "Stomach mucosa",
            Self::N100000136248 => "Transferin",
            Self::N100000136554 => "Non-neural",
            Self::N100000136555 => "Not specified",
            Self::N100000136556 => "Organ tissue",
            Self::N100000142485 => "Skin and fat in natural proportions",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AnimalTissueType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AnimalTissueType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AnimalTissueType> for Coding {
    fn from(code: AnimalTissueType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/animal-tissue-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AnimalTissueType> for CodeableConcept {
    fn from(code: AnimalTissueType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AppointmentStatus](http://hl7.org/fhir/ValueSet/appointmentstatus)**. The free/busy status of an appointment.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AppointmentStatus {
    /** **arrived**

Arrived. The patient/patients has/have arrived and is/are waiting to be seen. */
    Arrived,
    /** **booked**

Booked. All participant(s) have been considered and the appointment is confirmed to go ahead at the date/times specified. */
    Booked,
    /** **cancelled**

Cancelled. The appointment has been cancelled. */
    Cancelled,
    /** **checked-in**

Checked In. When checked in, all pre-encounter administrative work is complete, and the encounter may begin. (where multiple patients are involved, they are all present). */
    CheckedIn,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **fulfilled**

Fulfilled. The planning stages of the appointment are now complete, the encounter resource will exist and will track further status changes. Note that an encounter may exist before the appointment status is fulfilled for many reasons. */
    Fulfilled,
    /** **noshow**

No Show. Some or all of the participant(s) have not/did not appear for the appointment (usually the patient). */
    Noshow,
    /** **pending**

Pending. Some or all of the participant(s) have not finalized their acceptance of the appointment request. */
    Pending,
    /** **proposed**

Proposed. None of the participant(s) have finalized their acceptance of the appointment request, and the start/end time might not be set yet. */
    Proposed,
    /** **waitlist**

Waitlisted. The appointment has been placed on a waitlist, to be scheduled/confirmed in the future when a slot/service is available.
A specific time might or might not be pre-allocated. */
    Waitlist,
}
impl ::core::str::FromStr for AppointmentStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "arrived" => Ok(Self::Arrived),
            "booked" => Ok(Self::Booked),
            "cancelled" => Ok(Self::Cancelled),
            "checked-in" => Ok(Self::CheckedIn),
            "entered-in-error" => Ok(Self::EnteredInError),
            "fulfilled" => Ok(Self::Fulfilled),
            "noshow" => Ok(Self::Noshow),
            "pending" => Ok(Self::Pending),
            "proposed" => Ok(Self::Proposed),
            "waitlist" => Ok(Self::Waitlist),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AppointmentStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Arrived => "arrived",
            Self::Booked => "booked",
            Self::Cancelled => "cancelled",
            Self::CheckedIn => "checked-in",
            Self::EnteredInError => "entered-in-error",
            Self::Fulfilled => "fulfilled",
            Self::Noshow => "noshow",
            Self::Pending => "pending",
            Self::Proposed => "proposed",
            Self::Waitlist => "waitlist",
        }
    }
}
impl ::std::fmt::Display for AppointmentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Arrived => "Arrived",
            Self::Booked => "Booked",
            Self::Cancelled => "Cancelled",
            Self::CheckedIn => "Checked In",
            Self::EnteredInError => "Entered in error",
            Self::Fulfilled => "Fulfilled",
            Self::Noshow => "No Show",
            Self::Pending => "Pending",
            Self::Proposed => "Proposed",
            Self::Waitlist => "Waitlisted",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AppointmentStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AppointmentStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AppointmentStatus> for Coding {
    fn from(code: AppointmentStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/appointmentstatus".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AppointmentStatus> for CodeableConcept {
    fn from(code: AppointmentStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ArtifactAssessmentDisposition](http://hl7.org/fhir/ValueSet/artifactassessment-disposition)**. Possible values for the disposition of a comment or change request, typically used for comments and change requests, to indicate the disposition of the responsible party towards the changes suggested by the comment or change request.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArtifactAssessmentDisposition {
    /** **not-persuasive**

Not Persuasive. The comment is not persuasive (rejected in full) */
    NotPersuasive,
    /** **not-persuasive-with-modification**

Not Persuasive with Modification. The comment is not persuasive with modification (partially rejected) */
    NotPersuasiveWithModification,
    /** **persuasive**

Persuasive. The comment is persuasive (accepted in full) */
    Persuasive,
    /** **persuasive-with-modification**

Persuasive with Modification. The comment is persuasive with modification (partially accepted) */
    PersuasiveWithModification,
    /** **unresolved**

Unresolved. The comment is unresolved */
    Unresolved,
}
impl ::core::str::FromStr for ArtifactAssessmentDisposition {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "not-persuasive" => Ok(Self::NotPersuasive),
            "not-persuasive-with-modification" => Ok(Self::NotPersuasiveWithModification),
            "persuasive" => Ok(Self::Persuasive),
            "persuasive-with-modification" => Ok(Self::PersuasiveWithModification),
            "unresolved" => Ok(Self::Unresolved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactAssessmentDisposition {
    fn as_ref(&self) -> &str {
        match self {
            Self::NotPersuasive => "not-persuasive",
            Self::NotPersuasiveWithModification => "not-persuasive-with-modification",
            Self::Persuasive => "persuasive",
            Self::PersuasiveWithModification => "persuasive-with-modification",
            Self::Unresolved => "unresolved",
        }
    }
}
impl ::std::fmt::Display for ArtifactAssessmentDisposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::NotPersuasive => "Not Persuasive",
            Self::NotPersuasiveWithModification => "Not Persuasive with Modification",
            Self::Persuasive => "Persuasive",
            Self::PersuasiveWithModification => "Persuasive with Modification",
            Self::Unresolved => "Unresolved",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ArtifactAssessmentDisposition {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactAssessmentDisposition {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArtifactAssessmentDisposition> for Coding {
    fn from(code: ArtifactAssessmentDisposition) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/artifactassessment-disposition".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ArtifactAssessmentDisposition> for CodeableConcept {
    fn from(code: ArtifactAssessmentDisposition) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ArtifactAssessmentInformationType](http://hl7.org/fhir/ValueSet/artifactassessment-information-type)**. The type of information contained in a component of an artifact assessment.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArtifactAssessmentInformationType {
    /** **change-request**

Change Request. A change request for the artifact */
    ChangeRequest,
    /** **classifier**

Classifier. A classifier of the artifact */
    Classifier,
    /** **comment**

Comment. A comment on the artifact */
    Comment,
    /** **container**

Container. A container for multiple components */
    Container,
    /** **rating**

Rating. A rating of the artifact */
    Rating,
    /** **response**

Response. A response to a comment */
    Response,
}
impl ::core::str::FromStr for ArtifactAssessmentInformationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "change-request" => Ok(Self::ChangeRequest),
            "classifier" => Ok(Self::Classifier),
            "comment" => Ok(Self::Comment),
            "container" => Ok(Self::Container),
            "rating" => Ok(Self::Rating),
            "response" => Ok(Self::Response),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactAssessmentInformationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ChangeRequest => "change-request",
            Self::Classifier => "classifier",
            Self::Comment => "comment",
            Self::Container => "container",
            Self::Rating => "rating",
            Self::Response => "response",
        }
    }
}
impl ::std::fmt::Display for ArtifactAssessmentInformationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ChangeRequest => "Change Request",
            Self::Classifier => "Classifier",
            Self::Comment => "Comment",
            Self::Container => "Container",
            Self::Rating => "Rating",
            Self::Response => "Response",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ArtifactAssessmentInformationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactAssessmentInformationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArtifactAssessmentInformationType> for Coding {
    fn from(code: ArtifactAssessmentInformationType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/artifactassessment-information-type"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ArtifactAssessmentInformationType> for CodeableConcept {
    fn from(code: ArtifactAssessmentInformationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ArtifactAssessmentWorkflowStatus](http://hl7.org/fhir/ValueSet/artifactassessment-workflow-status)**. Possible values for the workflow status of the comment or assessment, typically used to coordinate workflow around the process of accepting and rejecting changes and comments on the artifact.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArtifactAssessmentWorkflowStatus {
    /** **applied**

Applied. The comment is resolved and any necessary changes have been applied */
    Applied,
    /** **deferred**

Deferred. The comment is acceptable, but resolution of the comment and application of any associated changes have been deferred */
    Deferred,
    /** **duplicate**

Duplicate. The comment is a duplicate of another comment already received */
    Duplicate,
    /** **entered-in-error**

Entered in Error. The assessment was entered in error */
    EnteredInError,
    /** **published**

Published. The necessary changes to the artifact have been published in a new version of the artifact */
    Published,
    /** **resolved-change-required**

Resolved - Change Required. The comment has been resolved and changes are required to address the comment */
    ResolvedChangeRequired,
    /** **resolved-no-change**

Resolved - No Change. The comment has been resolved and no changes resulted from the resolution */
    ResolvedNoChange,
    /** **submitted**

Submitted. The comment has been submitted, but the responsible party has not yet been determined, or the responsible party has not yet determined the next steps to be taken. */
    Submitted,
    /** **triaged**

Triaged. The comment has been triaged, meaning the responsible party has been determined and next steps have been identified to address the comment. */
    Triaged,
    /** **waiting-for-input**

Waiting for Input. The comment is waiting for input from a specific party before next steps can be taken. */
    WaitingForInput,
}
impl ::core::str::FromStr for ArtifactAssessmentWorkflowStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "applied" => Ok(Self::Applied),
            "deferred" => Ok(Self::Deferred),
            "duplicate" => Ok(Self::Duplicate),
            "entered-in-error" => Ok(Self::EnteredInError),
            "published" => Ok(Self::Published),
            "resolved-change-required" => Ok(Self::ResolvedChangeRequired),
            "resolved-no-change" => Ok(Self::ResolvedNoChange),
            "submitted" => Ok(Self::Submitted),
            "triaged" => Ok(Self::Triaged),
            "waiting-for-input" => Ok(Self::WaitingForInput),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactAssessmentWorkflowStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Applied => "applied",
            Self::Deferred => "deferred",
            Self::Duplicate => "duplicate",
            Self::EnteredInError => "entered-in-error",
            Self::Published => "published",
            Self::ResolvedChangeRequired => "resolved-change-required",
            Self::ResolvedNoChange => "resolved-no-change",
            Self::Submitted => "submitted",
            Self::Triaged => "triaged",
            Self::WaitingForInput => "waiting-for-input",
        }
    }
}
impl ::std::fmt::Display for ArtifactAssessmentWorkflowStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Applied => "Applied",
            Self::Deferred => "Deferred",
            Self::Duplicate => "Duplicate",
            Self::EnteredInError => "Entered in Error",
            Self::Published => "Published",
            Self::ResolvedChangeRequired => "Resolved - Change Required",
            Self::ResolvedNoChange => "Resolved - No Change",
            Self::Submitted => "Submitted",
            Self::Triaged => "Triaged",
            Self::WaitingForInput => "Waiting for Input",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ArtifactAssessmentWorkflowStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactAssessmentWorkflowStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArtifactAssessmentWorkflowStatus> for Coding {
    fn from(code: ArtifactAssessmentWorkflowStatus) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/artifactassessment-workflow-status"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ArtifactAssessmentWorkflowStatus> for CodeableConcept {
    fn from(code: ArtifactAssessmentWorkflowStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ArtifactContributionInstanceType](http://hl7.org/fhir/ValueSet/artifact-contribution-instance-type)**. Artifact Contribution Instance Type\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArtifactContributionInstanceType {
    /** **approved**

Approved. Approved */
    Approved,
    /** **edited**

Edited. Edited */
    Edited,
    /** **reviewed**

Reviewed. Reviewed */
    Reviewed,
}
impl ::core::str::FromStr for ArtifactContributionInstanceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "approved" => Ok(Self::Approved),
            "edited" => Ok(Self::Edited),
            "reviewed" => Ok(Self::Reviewed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactContributionInstanceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Approved => "approved",
            Self::Edited => "edited",
            Self::Reviewed => "reviewed",
        }
    }
}
impl ::std::fmt::Display for ArtifactContributionInstanceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Approved => "Approved",
            Self::Edited => "Edited",
            Self::Reviewed => "Reviewed",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ArtifactContributionInstanceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactContributionInstanceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArtifactContributionInstanceType> for Coding {
    fn from(code: ArtifactContributionInstanceType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/artifact-contribution-instance-type"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ArtifactContributionInstanceType> for CodeableConcept {
    fn from(code: ArtifactContributionInstanceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ArtifactContributionType](http://hl7.org/fhir/ValueSet/artifact-contribution-type)**. Citation contribution.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArtifactContributionType {
    /** **conceptualization**

Conceptualization. Conceptualization (see https://jats4r.org/credit-taxonomy). */
    Conceptualization,
    /** **data-curation**

Data curation. Data curation (see https://jats4r.org/credit-taxonomy). */
    DataCuration,
    /** **formal-analysis**

Formal analysis. Formal analysis (see https://jats4r.org/credit-taxonomy). */
    FormalAnalysis,
    /** **funding-acquisition**

Funding acquisition. Funding acquisition (see https://jats4r.org/credit-taxonomy). */
    FundingAcquisition,
    /** **investigation**

Investigation. Investigation (see https://jats4r.org/credit-taxonomy). */
    Investigation,
    /** **methodology**

Methodology. Methodology (see https://jats4r.org/credit-taxonomy). */
    Methodology,
    /** **project-administration**

Project administration. Project administration (see https://jats4r.org/credit-taxonomy). */
    ProjectAdministration,
    /** **resources**

Resources. Resources (see https://jats4r.org/credit-taxonomy). */
    Resources,
    /** **software**

Software. Software (see https://jats4r.org/credit-taxonomy). */
    Software,
    /** **supervision**

Supervision. Supervision (see https://jats4r.org/credit-taxonomy). */
    Supervision,
    /** **validation**

Validation. Validation (see https://jats4r.org/credit-taxonomy). */
    Validation,
    /** **visualization**

Visualization. Visualization (see https://jats4r.org/credit-taxonomy). */
    Visualization,
    /** **writing-original-draft**

Writing - original draft. Writing - original draft (see https://jats4r.org/credit-taxonomy). */
    WritingOriginalDraft,
    /** **writing-review-editing**

Writing - review & editing. Writing - review & editing (see https://jats4r.org/credit-taxonomy). */
    WritingReviewEditing,
}
impl ::core::str::FromStr for ArtifactContributionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "conceptualization" => Ok(Self::Conceptualization),
            "data-curation" => Ok(Self::DataCuration),
            "formal-analysis" => Ok(Self::FormalAnalysis),
            "funding-acquisition" => Ok(Self::FundingAcquisition),
            "investigation" => Ok(Self::Investigation),
            "methodology" => Ok(Self::Methodology),
            "project-administration" => Ok(Self::ProjectAdministration),
            "resources" => Ok(Self::Resources),
            "software" => Ok(Self::Software),
            "supervision" => Ok(Self::Supervision),
            "validation" => Ok(Self::Validation),
            "visualization" => Ok(Self::Visualization),
            "writing-original-draft" => Ok(Self::WritingOriginalDraft),
            "writing-review-editing" => Ok(Self::WritingReviewEditing),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactContributionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Conceptualization => "conceptualization",
            Self::DataCuration => "data-curation",
            Self::FormalAnalysis => "formal-analysis",
            Self::FundingAcquisition => "funding-acquisition",
            Self::Investigation => "investigation",
            Self::Methodology => "methodology",
            Self::ProjectAdministration => "project-administration",
            Self::Resources => "resources",
            Self::Software => "software",
            Self::Supervision => "supervision",
            Self::Validation => "validation",
            Self::Visualization => "visualization",
            Self::WritingOriginalDraft => "writing-original-draft",
            Self::WritingReviewEditing => "writing-review-editing",
        }
    }
}
impl ::std::fmt::Display for ArtifactContributionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Conceptualization => "Conceptualization",
            Self::DataCuration => "Data curation",
            Self::FormalAnalysis => "Formal analysis",
            Self::FundingAcquisition => "Funding acquisition",
            Self::Investigation => "Investigation",
            Self::Methodology => "Methodology",
            Self::ProjectAdministration => "Project administration",
            Self::Resources => "Resources",
            Self::Software => "Software",
            Self::Supervision => "Supervision",
            Self::Validation => "Validation",
            Self::Visualization => "Visualization",
            Self::WritingOriginalDraft => "Writing - original draft",
            Self::WritingReviewEditing => "Writing - review & editing",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ArtifactContributionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactContributionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArtifactContributionType> for Coding {
    fn from(code: ArtifactContributionType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/artifact-contribution-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ArtifactContributionType> for CodeableConcept {
    fn from(code: ArtifactContributionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ArtifactUrlClassifier](http://hl7.org/fhir/ValueSet/artifact-url-classifier)**. Code the reason for different URLs, eg abstract and full-text.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArtifactUrlClassifier {
    /** **abstract**

Abstract. The URL will reach a brief summary for the article. */
    Abstract,
    /** **code-repository**

Code repository. File archive and web hosting facility for source code of software, documentation, web pages, and other works. */
    CodeRepository,
    /** **compressed-file**

Compressed file. Compressed archive file (e.g. a zip file) that contains multiple files */
    CompressedFile,
    /** **computable-resource**

Computable resource. The URL will reach content that is machine-interpretable. */
    ComputableResource,
    /** **doi-based**

DOI Based. The URL is derived from the Digital Object Identifier (DOI). */
    DoiBased,
    /** **file-directory**

File directory. The URL will reach a file directory. */
    FileDirectory,
    /** **full-text**

Full-Text. The URL will reach the full-text of the article. */
    FullText,
    /** **json**

JSON. The URL will reach content in JSON format. */
    Json,
    /** **not-specified**

Not Specified. Used when URL classifier is not specified but expected in a system. */
    NotSpecified,
    /** **pdf**

PDF. The URL will reach content in PDF form. */
    Pdf,
    /** **restricted**

Restricted. The URL content has restricted access (e.g. subcription required). */
    Restricted,
    /** **supplement**

Supplement. The URL will reach a supplement, appendix, or additional supporting information for the article. */
    Supplement,
    /** **version-specific**

Version Specific. The URL will reach content that is a specific version of the article. */
    VersionSpecific,
    /** **webpage**

Webpage. The URL will reach a webpage related to the article, where the content is not easily classified as abstract, full-text or supplement. */
    Webpage,
    /** **xml**

XML. The URL will reach content in XML format. */
    Xml,
}
impl ::core::str::FromStr for ArtifactUrlClassifier {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abstract" => Ok(Self::Abstract),
            "code-repository" => Ok(Self::CodeRepository),
            "compressed-file" => Ok(Self::CompressedFile),
            "computable-resource" => Ok(Self::ComputableResource),
            "doi-based" => Ok(Self::DoiBased),
            "file-directory" => Ok(Self::FileDirectory),
            "full-text" => Ok(Self::FullText),
            "json" => Ok(Self::Json),
            "not-specified" => Ok(Self::NotSpecified),
            "pdf" => Ok(Self::Pdf),
            "restricted" => Ok(Self::Restricted),
            "supplement" => Ok(Self::Supplement),
            "version-specific" => Ok(Self::VersionSpecific),
            "webpage" => Ok(Self::Webpage),
            "xml" => Ok(Self::Xml),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactUrlClassifier {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abstract => "abstract",
            Self::CodeRepository => "code-repository",
            Self::CompressedFile => "compressed-file",
            Self::ComputableResource => "computable-resource",
            Self::DoiBased => "doi-based",
            Self::FileDirectory => "file-directory",
            Self::FullText => "full-text",
            Self::Json => "json",
            Self::NotSpecified => "not-specified",
            Self::Pdf => "pdf",
            Self::Restricted => "restricted",
            Self::Supplement => "supplement",
            Self::VersionSpecific => "version-specific",
            Self::Webpage => "webpage",
            Self::Xml => "xml",
        }
    }
}
impl ::std::fmt::Display for ArtifactUrlClassifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Abstract => "Abstract",
            Self::CodeRepository => "Code repository",
            Self::CompressedFile => "Compressed file",
            Self::ComputableResource => "Computable resource",
            Self::DoiBased => "DOI Based",
            Self::FileDirectory => "File directory",
            Self::FullText => "Full-Text",
            Self::Json => "JSON",
            Self::NotSpecified => "Not Specified",
            Self::Pdf => "PDF",
            Self::Restricted => "Restricted",
            Self::Supplement => "Supplement",
            Self::VersionSpecific => "Version Specific",
            Self::Webpage => "Webpage",
            Self::Xml => "XML",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ArtifactUrlClassifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactUrlClassifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ArtifactUrlClassifier> for Coding {
    fn from(code: ArtifactUrlClassifier) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/artifact-url-classifier".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ArtifactUrlClassifier> for CodeableConcept {
    fn from(code: ArtifactUrlClassifier) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AssertionDirectionType](http://hl7.org/fhir/ValueSet/assert-direction-codes)**. The type of direction to use for assertion.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AssertionDirectionType {
    /** **request**

request. The assertion is evaluated on the request. */
    Request,
    /** **response**

response. The assertion is evaluated on the response. This is the default value. */
    Response,
}
impl ::core::str::FromStr for AssertionDirectionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "request" => Ok(Self::Request),
            "response" => Ok(Self::Response),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionDirectionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Request => "request",
            Self::Response => "response",
        }
    }
}
impl ::std::fmt::Display for AssertionDirectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Request => "request",
            Self::Response => "response",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AssertionDirectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionDirectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionDirectionType> for Coding {
    fn from(code: AssertionDirectionType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/assert-direction-codes".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AssertionDirectionType> for CodeableConcept {
    fn from(code: AssertionDirectionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AssertionManualCompletionType](http://hl7.org/fhir/ValueSet/assert-manual-completion-codes)**. The type of manual completion to use for assertion.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AssertionManualCompletionType {
    /** **fail**

Fail. Mark the currently waiting test failed and proceed with the next assert if the stopTestOnFail is false or the next test in the TestScript if the stopTestOnFail is true. */
    Fail,
    /** **pass**

Pass. Mark the currently waiting test passed (if the test is not failed already) and proceed with the next action in the TestScript. */
    Pass,
    /** **skip**

Skip. Mark this assert as skipped and proceed with the next action in the TestScript. */
    Skip,
    /** **stop**

Stop. Stop execution of this TestScript. The overall status of this TestScript is evaluated based on the status of the completed tests. */
    Stop,
}
impl ::core::str::FromStr for AssertionManualCompletionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fail" => Ok(Self::Fail),
            "pass" => Ok(Self::Pass),
            "skip" => Ok(Self::Skip),
            "stop" => Ok(Self::Stop),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionManualCompletionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fail => "fail",
            Self::Pass => "pass",
            Self::Skip => "skip",
            Self::Stop => "stop",
        }
    }
}
impl ::std::fmt::Display for AssertionManualCompletionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Fail => "Fail",
            Self::Pass => "Pass",
            Self::Skip => "Skip",
            Self::Stop => "Stop",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AssertionManualCompletionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionManualCompletionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionManualCompletionType> for Coding {
    fn from(code: AssertionManualCompletionType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/assert-manual-completion-codes".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AssertionManualCompletionType> for CodeableConcept {
    fn from(code: AssertionManualCompletionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AssertionOperatorType](http://hl7.org/fhir/ValueSet/assert-operator-codes)**. The type of operator to use for assertion.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AssertionOperatorType {
    /** **contains**

contains. Compare value string contains a known value. */
    Contains,
    /** **empty**

empty. Compare value is empty. */
    Empty,
    /** **equals**

equals. Default value. Equals comparison. */
    Equals,
    /** **eval**

evaluate. Evaluate the FHIRPath expression as a boolean condition. */
    Eval,
    /** **greaterThan**

greaterThan. Compare value to be greater than a known value. */
    GreaterThan,
    /** **in**

in. Compare value within a known set of values. */
    In,
    /** **lessThan**

lessThan. Compare value to be less than a known value. */
    LessThan,
    /** **manualEval**

manualEvaluate. Manually evaluate the condition described by this assert. The test engine SHALL pause and provide an input mechanism to set the outcome of this assert to 'pass', 'fail', 'skip' or 'stop'. */
    ManualEval,
    /** **notContains**

notContains. Compare value string does not contain a known value. */
    NotContains,
    /** **notEmpty**

notEmpty. Compare value is not empty. */
    NotEmpty,
    /** **notEquals**

notEquals. Not equals comparison. */
    NotEquals,
    /** **notIn**

notIn. Compare value not within a known set of values. */
    NotIn,
}
impl ::core::str::FromStr for AssertionOperatorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contains" => Ok(Self::Contains),
            "empty" => Ok(Self::Empty),
            "equals" => Ok(Self::Equals),
            "eval" => Ok(Self::Eval),
            "greaterThan" => Ok(Self::GreaterThan),
            "in" => Ok(Self::In),
            "lessThan" => Ok(Self::LessThan),
            "manualEval" => Ok(Self::ManualEval),
            "notContains" => Ok(Self::NotContains),
            "notEmpty" => Ok(Self::NotEmpty),
            "notEquals" => Ok(Self::NotEquals),
            "notIn" => Ok(Self::NotIn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionOperatorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contains => "contains",
            Self::Empty => "empty",
            Self::Equals => "equals",
            Self::Eval => "eval",
            Self::GreaterThan => "greaterThan",
            Self::In => "in",
            Self::LessThan => "lessThan",
            Self::ManualEval => "manualEval",
            Self::NotContains => "notContains",
            Self::NotEmpty => "notEmpty",
            Self::NotEquals => "notEquals",
            Self::NotIn => "notIn",
        }
    }
}
impl ::std::fmt::Display for AssertionOperatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Contains => "contains",
            Self::Empty => "empty",
            Self::Equals => "equals",
            Self::Eval => "evaluate",
            Self::GreaterThan => "greaterThan",
            Self::In => "in",
            Self::LessThan => "lessThan",
            Self::ManualEval => "manualEvaluate",
            Self::NotContains => "notContains",
            Self::NotEmpty => "notEmpty",
            Self::NotEquals => "notEquals",
            Self::NotIn => "notIn",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AssertionOperatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionOperatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionOperatorType> for Coding {
    fn from(code: AssertionOperatorType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/assert-operator-codes".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AssertionOperatorType> for CodeableConcept {
    fn from(code: AssertionOperatorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AssertionResponseTypes](http://hl7.org/fhir/ValueSet/assert-response-code-types)**. The type of response code to use for assertion.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AssertionResponseTypes {
    /** **accepted**

Accepted. Response code is 202. */
    Accepted,
    /** **badGateway**

Bad Gateway. Response code is 502. */
    BadGateway,
    /** **badRequest**

Bad Request. Response code is 400. */
    BadRequest,
    /** **conflict**

Conflict. Response code is 409. */
    Conflict,
    /** **contentTooLarge**

Content Too Large. Response code is 413. */
    ContentTooLarge,
    /** **continue**

Continue. Response code is 100. */
    Continue,
    /** **created**

Created. Response code is 201. */
    Created,
    /** **expectationFailed**

Expectation Failed. Response code is 417. */
    ExpectationFailed,
    /** **forbidden**

Forbidden. Response code is 403. */
    Forbidden,
    /** **found**

Found. Response code is 302. */
    Found,
    /** **gatewayTimeout**

Gateway Timeout. Response code is 504. */
    GatewayTimeout,
    /** **gone**

Gone. Response code is 410. */
    Gone,
    /** **httpVersionNotSupported**

HTTP Version Not Supported. Response code is 505. */
    HttpVersionNotSupported,
    /** **internalServerError**

Internal Server Error. Response code is 500. */
    InternalServerError,
    /** **lengthRequired**

Length Required. Response code is 411. */
    LengthRequired,
    /** **methodNotAllowed**

Method Not Allowed. Response code is 405. */
    MethodNotAllowed,
    /** **misdirectedRequest**

Misdirected Request. Response code is 421. */
    MisdirectedRequest,
    /** **movedPermanently**

Moved Permanently. Response code is 301. */
    MovedPermanently,
    /** **multipleChoices**

Multiple Choices. Response code is 300. */
    MultipleChoices,
    /** **noContent**

No Content. Response code is 204. */
    NoContent,
    /** **nonAuthoritativeInformation**

Non-Authoritative Information. Response code is 203. */
    NonAuthoritativeInformation,
    /** **notAcceptable**

Not Acceptable. Response code is 406. */
    NotAcceptable,
    /** **notFound**

Not Found. Response code is 404. */
    NotFound,
    /** **notImplemented**

Not Implemented. Response code is 501. */
    NotImplemented,
    /** **notModified**

Not Modified. Response code is 304. */
    NotModified,
    /** **okay**

OK. Response code is 200. */
    Okay,
    /** **partialContent**

Partial Content. Response code is 206. */
    PartialContent,
    /** **paymentRequired**

Payment Required. Response code is 402. */
    PaymentRequired,
    /** **permanentRedirect**

Permanent Redirect. Response code is 308. */
    PermanentRedirect,
    /** **preconditionFailed**

Precondition Failed. Response code is 412. */
    PreconditionFailed,
    /** **proxyAuthenticationRequired**

Proxy Authentication Required. Response code is 407. */
    ProxyAuthenticationRequired,
    /** **rangeNotSatisfiable**

Range Not Satisfiable. Response code is 416. */
    RangeNotSatisfiable,
    /** **requestTimeout**

Request Timeout. Response code is 408. */
    RequestTimeout,
    /** **resetContent**

Reset Content. Response code is 205. */
    ResetContent,
    /** **seeOther**

See Other. Response code is 303. */
    SeeOther,
    /** **serviceUnavailable**

Service Unavailable. Response code is 503. */
    ServiceUnavailable,
    /** **switchingProtocols**

Switching Protocols. Response code is 101. */
    SwitchingProtocols,
    /** **temporaryRedirect**

Temporary Redirect. Response code is 307. */
    TemporaryRedirect,
    /** **unauthorized**

Unauthorized. Response code is 401. */
    Unauthorized,
    /** **unprocessableContent**

Unprocessable Content. Response code is 422. */
    UnprocessableContent,
    /** **unsupportedMediaType**

Unsupported Media Type. Response code is 415. */
    UnsupportedMediaType,
    /** **upgradeRequired**

Upgrade Required. Response code is 426. */
    UpgradeRequired,
    /** **uriTooLong**

URI Too Long. Response code is 414. */
    UriTooLong,
    /** **useProxy**

Use Proxy. Response code is 305. */
    UseProxy,
}
impl ::core::str::FromStr for AssertionResponseTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "badGateway" => Ok(Self::BadGateway),
            "badRequest" => Ok(Self::BadRequest),
            "conflict" => Ok(Self::Conflict),
            "contentTooLarge" => Ok(Self::ContentTooLarge),
            "continue" => Ok(Self::Continue),
            "created" => Ok(Self::Created),
            "expectationFailed" => Ok(Self::ExpectationFailed),
            "forbidden" => Ok(Self::Forbidden),
            "found" => Ok(Self::Found),
            "gatewayTimeout" => Ok(Self::GatewayTimeout),
            "gone" => Ok(Self::Gone),
            "httpVersionNotSupported" => Ok(Self::HttpVersionNotSupported),
            "internalServerError" => Ok(Self::InternalServerError),
            "lengthRequired" => Ok(Self::LengthRequired),
            "methodNotAllowed" => Ok(Self::MethodNotAllowed),
            "misdirectedRequest" => Ok(Self::MisdirectedRequest),
            "movedPermanently" => Ok(Self::MovedPermanently),
            "multipleChoices" => Ok(Self::MultipleChoices),
            "noContent" => Ok(Self::NoContent),
            "nonAuthoritativeInformation" => Ok(Self::NonAuthoritativeInformation),
            "notAcceptable" => Ok(Self::NotAcceptable),
            "notFound" => Ok(Self::NotFound),
            "notImplemented" => Ok(Self::NotImplemented),
            "notModified" => Ok(Self::NotModified),
            "okay" => Ok(Self::Okay),
            "partialContent" => Ok(Self::PartialContent),
            "paymentRequired" => Ok(Self::PaymentRequired),
            "permanentRedirect" => Ok(Self::PermanentRedirect),
            "preconditionFailed" => Ok(Self::PreconditionFailed),
            "proxyAuthenticationRequired" => Ok(Self::ProxyAuthenticationRequired),
            "rangeNotSatisfiable" => Ok(Self::RangeNotSatisfiable),
            "requestTimeout" => Ok(Self::RequestTimeout),
            "resetContent" => Ok(Self::ResetContent),
            "seeOther" => Ok(Self::SeeOther),
            "serviceUnavailable" => Ok(Self::ServiceUnavailable),
            "switchingProtocols" => Ok(Self::SwitchingProtocols),
            "temporaryRedirect" => Ok(Self::TemporaryRedirect),
            "unauthorized" => Ok(Self::Unauthorized),
            "unprocessableContent" => Ok(Self::UnprocessableContent),
            "unsupportedMediaType" => Ok(Self::UnsupportedMediaType),
            "upgradeRequired" => Ok(Self::UpgradeRequired),
            "uriTooLong" => Ok(Self::UriTooLong),
            "useProxy" => Ok(Self::UseProxy),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionResponseTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::BadGateway => "badGateway",
            Self::BadRequest => "badRequest",
            Self::Conflict => "conflict",
            Self::ContentTooLarge => "contentTooLarge",
            Self::Continue => "continue",
            Self::Created => "created",
            Self::ExpectationFailed => "expectationFailed",
            Self::Forbidden => "forbidden",
            Self::Found => "found",
            Self::GatewayTimeout => "gatewayTimeout",
            Self::Gone => "gone",
            Self::HttpVersionNotSupported => "httpVersionNotSupported",
            Self::InternalServerError => "internalServerError",
            Self::LengthRequired => "lengthRequired",
            Self::MethodNotAllowed => "methodNotAllowed",
            Self::MisdirectedRequest => "misdirectedRequest",
            Self::MovedPermanently => "movedPermanently",
            Self::MultipleChoices => "multipleChoices",
            Self::NoContent => "noContent",
            Self::NonAuthoritativeInformation => "nonAuthoritativeInformation",
            Self::NotAcceptable => "notAcceptable",
            Self::NotFound => "notFound",
            Self::NotImplemented => "notImplemented",
            Self::NotModified => "notModified",
            Self::Okay => "okay",
            Self::PartialContent => "partialContent",
            Self::PaymentRequired => "paymentRequired",
            Self::PermanentRedirect => "permanentRedirect",
            Self::PreconditionFailed => "preconditionFailed",
            Self::ProxyAuthenticationRequired => "proxyAuthenticationRequired",
            Self::RangeNotSatisfiable => "rangeNotSatisfiable",
            Self::RequestTimeout => "requestTimeout",
            Self::ResetContent => "resetContent",
            Self::SeeOther => "seeOther",
            Self::ServiceUnavailable => "serviceUnavailable",
            Self::SwitchingProtocols => "switchingProtocols",
            Self::TemporaryRedirect => "temporaryRedirect",
            Self::Unauthorized => "unauthorized",
            Self::UnprocessableContent => "unprocessableContent",
            Self::UnsupportedMediaType => "unsupportedMediaType",
            Self::UpgradeRequired => "upgradeRequired",
            Self::UriTooLong => "uriTooLong",
            Self::UseProxy => "useProxy",
        }
    }
}
impl ::std::fmt::Display for AssertionResponseTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Accepted => "Accepted",
            Self::BadGateway => "Bad Gateway",
            Self::BadRequest => "Bad Request",
            Self::Conflict => "Conflict",
            Self::ContentTooLarge => "Content Too Large",
            Self::Continue => "Continue",
            Self::Created => "Created",
            Self::ExpectationFailed => "Expectation Failed",
            Self::Forbidden => "Forbidden",
            Self::Found => "Found",
            Self::GatewayTimeout => "Gateway Timeout",
            Self::Gone => "Gone",
            Self::HttpVersionNotSupported => "HTTP Version Not Supported",
            Self::InternalServerError => "Internal Server Error",
            Self::LengthRequired => "Length Required",
            Self::MethodNotAllowed => "Method Not Allowed",
            Self::MisdirectedRequest => "Misdirected Request",
            Self::MovedPermanently => "Moved Permanently",
            Self::MultipleChoices => "Multiple Choices",
            Self::NoContent => "No Content",
            Self::NonAuthoritativeInformation => "Non-Authoritative Information",
            Self::NotAcceptable => "Not Acceptable",
            Self::NotFound => "Not Found",
            Self::NotImplemented => "Not Implemented",
            Self::NotModified => "Not Modified",
            Self::Okay => "OK",
            Self::PartialContent => "Partial Content",
            Self::PaymentRequired => "Payment Required",
            Self::PermanentRedirect => "Permanent Redirect",
            Self::PreconditionFailed => "Precondition Failed",
            Self::ProxyAuthenticationRequired => "Proxy Authentication Required",
            Self::RangeNotSatisfiable => "Range Not Satisfiable",
            Self::RequestTimeout => "Request Timeout",
            Self::ResetContent => "Reset Content",
            Self::SeeOther => "See Other",
            Self::ServiceUnavailable => "Service Unavailable",
            Self::SwitchingProtocols => "Switching Protocols",
            Self::TemporaryRedirect => "Temporary Redirect",
            Self::Unauthorized => "Unauthorized",
            Self::UnprocessableContent => "Unprocessable Content",
            Self::UnsupportedMediaType => "Unsupported Media Type",
            Self::UpgradeRequired => "Upgrade Required",
            Self::UriTooLong => "URI Too Long",
            Self::UseProxy => "Use Proxy",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AssertionResponseTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionResponseTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AssertionResponseTypes> for Coding {
    fn from(code: AssertionResponseTypes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/assert-response-code-types".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AssertionResponseTypes> for CodeableConcept {
    fn from(code: AssertionResponseTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AuditEventAction](http://hl7.org/fhir/ValueSet/audit-event-action)**. Indicator for type of action performed during the event that generated the event.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AuditEventAction {
    /** **C**

Create. Create a new database object, such as placing an order. */
    C,
    /** **D**

Delete. Delete items, such as a doctor master file record. */
    D,
    /** **E**

Execute. Perform a system or application function such as log-on, program execution or use of an object's method, or perform a query/search operation. */
    E,
    /** **R**

Read. Read data, such as to print or display to a doctor. */
    R,
    /** **U**

Update. Update data, such as revise patient information. */
    U,
}
impl ::core::str::FromStr for AuditEventAction {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "C" => Ok(Self::C),
            "D" => Ok(Self::D),
            "E" => Ok(Self::E),
            "R" => Ok(Self::R),
            "U" => Ok(Self::U),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventAction {
    fn as_ref(&self) -> &str {
        match self {
            Self::C => "C",
            Self::D => "D",
            Self::E => "E",
            Self::R => "R",
            Self::U => "U",
        }
    }
}
impl ::std::fmt::Display for AuditEventAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::C => "Create",
            Self::D => "Delete",
            Self::E => "Execute",
            Self::R => "Read",
            Self::U => "Update",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AuditEventAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventAction> for Coding {
    fn from(code: AuditEventAction) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/audit-event-action".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AuditEventAction> for CodeableConcept {
    fn from(code: AuditEventAction) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[AuditEventSeverity](http://hl7.org/fhir/ValueSet/audit-event-severity)**. The severity of the audit entry.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AuditEventSeverity {
    /** **alert**

Alert. Notification should be sent to trigger action be taken. e.g., Loss of the primary network connection needing attention. */
    Alert,
    /** **critical**

Critical. Critical conditions. e.g., A failure in the system's primary application that will reset automatically. */
    Critical,
    /** **debug**

Debug. Debug-level messages. Information useful to developers for debugging the application. */
    Debug,
    /** **emergency**

Emergency. System is unusable. e.g., This level should only be reported by infrastructure and should not be used by applications. */
    Emergency,
    /** **error**

Error. Error conditions. e.g., An application has exceeded its file storage limit and attempts to write are failing.  */
    Error,
    /** **informational**

Informational. Normal operational messages that require no action. e.g., An application has started, paused, or ended successfully. */
    Informational,
    /** **notice**

Notice. Notice messages. Normal but significant condition. Events that are unusual, but not error conditions. */
    Notice,
    /** **warning**

Warning. Warning conditions. May indicate that an error will occur if action is not taken. e.g., A non-root file system has only 2GB remaining. */
    Warning,
}
impl ::core::str::FromStr for AuditEventSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alert" => Ok(Self::Alert),
            "critical" => Ok(Self::Critical),
            "debug" => Ok(Self::Debug),
            "emergency" => Ok(Self::Emergency),
            "error" => Ok(Self::Error),
            "informational" => Ok(Self::Informational),
            "notice" => Ok(Self::Notice),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alert => "alert",
            Self::Critical => "critical",
            Self::Debug => "debug",
            Self::Emergency => "emergency",
            Self::Error => "error",
            Self::Informational => "informational",
            Self::Notice => "notice",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Display for AuditEventSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Alert => "Alert",
            Self::Critical => "Critical",
            Self::Debug => "Debug",
            Self::Emergency => "Emergency",
            Self::Error => "Error",
            Self::Informational => "Informational",
            Self::Notice => "Notice",
            Self::Warning => "Warning",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for AuditEventSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<AuditEventSeverity> for Coding {
    fn from(code: AuditEventSeverity) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/audit-event-severity".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<AuditEventSeverity> for CodeableConcept {
    fn from(code: AuditEventSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BeneficiaryRelationshipCodes](http://hl7.org/fhir/ValueSet/relationship)**. This value set includes the Patient to subscriber relationship codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BeneficiaryRelationshipCodes {
    /** **1**

Self. The patient is the subscriber (policy holder) */
    N1,
    /** **2**

Spouse. The patient is the spouse or equivalent of the subscriber (policy holder) */
    N2,
    /** **3**

Child. The patient is the child of the subscriber (policy holder) */
    N3,
    /** **4**

Common Law Spouse. The patient is the common law spouse of the subscriber (policy holder) */
    N4,
    /** **5**

Other. The patient has some other relationship, such as parent, to the subscriber (policy holder) */
    N5,
}
impl ::core::str::FromStr for BeneficiaryRelationshipCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "2" => Ok(Self::N2),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BeneficiaryRelationshipCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N2 => "2",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::N5 => "5",
        }
    }
}
impl ::std::fmt::Display for BeneficiaryRelationshipCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N1 => "Self",
            Self::N2 => "Spouse",
            Self::N3 => "Child",
            Self::N4 => "Common Law Spouse",
            Self::N5 => "Other",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BeneficiaryRelationshipCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BeneficiaryRelationshipCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BeneficiaryRelationshipCodes> for Coding {
    fn from(code: BeneficiaryRelationshipCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/relationship".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BeneficiaryRelationshipCodes> for CodeableConcept {
    fn from(code: BeneficiaryRelationshipCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BindingStrength](http://hl7.org/fhir/ValueSet/binding-strength)**. Indication of the degree of conformance expectations associated with a binding.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BindingStrength {
    /** **example**

Example. Instances are not expected or even encouraged to draw from the specified value set.  The value set merely provides examples of the types of concepts intended to be included. */
    Example,
    /** **extensible**

Extensible. To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated.  If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead. */
    Extensible,
    /** **preferred**

Preferred. Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. */
    Preferred,
    /** **required**

Required. To be conformant, the concept in this element SHALL be from the specified value set. */
    Required,
}
impl ::core::str::FromStr for BindingStrength {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "example" => Ok(Self::Example),
            "extensible" => Ok(Self::Extensible),
            "preferred" => Ok(Self::Preferred),
            "required" => Ok(Self::Required),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BindingStrength {
    fn as_ref(&self) -> &str {
        match self {
            Self::Example => "example",
            Self::Extensible => "extensible",
            Self::Preferred => "preferred",
            Self::Required => "required",
        }
    }
}
impl ::std::fmt::Display for BindingStrength {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Example => "Example",
            Self::Extensible => "Extensible",
            Self::Preferred => "Preferred",
            Self::Required => "Required",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BindingStrength {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BindingStrength {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BindingStrength> for Coding {
    fn from(code: BindingStrength) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/binding-strength".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BindingStrength> for CodeableConcept {
    fn from(code: BindingStrength) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BiologicallyDerivedProductCategory](http://hl7.org/fhir/ValueSet/product-category)**. Biologically Derived Product Category.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductCategory {
    /** **biologicalAgent**

BiologicalAgent. Biological agent of unspecified type. */
    BiologicalAgent,
    /** **cells**

Cells. Collection of cells. */
    Cells,
    /** **fluid**

Fluid. Body fluid. */
    Fluid,
    /** **organ**

Organ. A collection of tissues joined in a structural unit to serve a common function. */
    Organ,
    /** **tissue**

Tissue. An ensemble of similar cells and their extracellular matrix from the same origin that together carry out a specific function. */
    Tissue,
}
impl ::core::str::FromStr for BiologicallyDerivedProductCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "biologicalAgent" => Ok(Self::BiologicalAgent),
            "cells" => Ok(Self::Cells),
            "fluid" => Ok(Self::Fluid),
            "organ" => Ok(Self::Organ),
            "tissue" => Ok(Self::Tissue),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::BiologicalAgent => "biologicalAgent",
            Self::Cells => "cells",
            Self::Fluid => "fluid",
            Self::Organ => "organ",
            Self::Tissue => "tissue",
        }
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::BiologicalAgent => "BiologicalAgent",
            Self::Cells => "Cells",
            Self::Fluid => "Fluid",
            Self::Organ => "Organ",
            Self::Tissue => "Tissue",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductCategory> for Coding {
    fn from(code: BiologicallyDerivedProductCategory) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/product-category".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BiologicallyDerivedProductCategory> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BiologicallyDerivedProductCodes](http://hl7.org/fhir/ValueSet/biologicallyderived-productcodes)**. This code system is a subset of ISBT 128 Product Description Codes© published by ICCBBA as a part of the ISBT 128 standard. These codes support characterization and classification of medical products of human origin inclusive of processing conditions such as additives, volumes and handling conditions.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductCodes {
    /** **e0398**

RED BLOOD CELLS|CPD>AS5/450mL/refg|Irr|ResLeu. RED BLOOD CELLS|CPD>AS5/450mL/refg|Irr|ResLeu */
    E0398,
    /** **e4377**

Apheresis RED BLOOD CELLS|ACD-A/XX/refg|Irradiated|1st container. RED BLOOD CELLS Apheresis product, ACD-A, Irradiated,1st container, stored at refrigeration temperatures */
    E4377,
    /** **s1128**

HPC, APHERESIS/Citrate/XX/refg/Mobilized. HPC, APHERESIS/Citrate/XX/refg/Mobilized */
    S1128,
    /** **s1194**

HPC, APHERESIS|NS/XX/<=-120C|10% DMSO|Cryopreserved|Mobilized. HPC, Apheresis product, 10% DMSO, mobilized, cryopreserved at <=-120C */
    S1194,
    /** **s1195**

HPC, APHERESIS|NS/XX/<=-120C|5% DMSO|Cryopreserved|Mobilized. HPC, Apheresis product, 5% DMSO, mobilized, cryopreserved at <=-120C */
    S1195,
    /** **s1310**

HPC, APHERESIS|None/XX/refg|3rd Party Comp:Yes|Other Additives:Yes|Mobilized|CD34 enriched. HPC, Apheresis product, third party components added, other additives added, mobilized, CD34 enriched, stored at refrigeration temperatures */
    S1310,
    /** **s1398**

HPC, MARROW|NS/XX/rt|Plasma reduced. HPC, Marrow, plasma reduced, stored at room temperature */
    S1398,
    /** **s2598**

HPC, MARROW|NS/XX/<=-150C|10% DMSO|3rd Party Comp:Yes|Cryopreserved|RBC reduced. HPC, MARROW|NS/XX/<=-150C|10% DMSO|3rd Party Comp:Yes|Cryopreserved|RBC reduced */
    S2598,
    /** **t1396**

BONE, FEMUR|Frozen|Right|Radiation sterilization. BONE, FEMUR, Right, sterilized by radiation, stored at frozen temperatures */
    T1396,
}
impl ::core::str::FromStr for BiologicallyDerivedProductCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "e0398" => Ok(Self::E0398),
            "e4377" => Ok(Self::E4377),
            "s1128" => Ok(Self::S1128),
            "s1194" => Ok(Self::S1194),
            "s1195" => Ok(Self::S1195),
            "s1310" => Ok(Self::S1310),
            "s1398" => Ok(Self::S1398),
            "s2598" => Ok(Self::S2598),
            "t1396" => Ok(Self::T1396),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::E0398 => "e0398",
            Self::E4377 => "e4377",
            Self::S1128 => "s1128",
            Self::S1194 => "s1194",
            Self::S1195 => "s1195",
            Self::S1310 => "s1310",
            Self::S1398 => "s1398",
            Self::S2598 => "s2598",
            Self::T1396 => "t1396",
        }
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::E0398 => "RED BLOOD CELLS|CPD>AS5/450mL/refg|Irr|ResLeu",
            Self::E4377 => {
                "Apheresis RED BLOOD CELLS|ACD-A/XX/refg|Irradiated|1st container"
            }
            Self::S1128 => "HPC, APHERESIS/Citrate/XX/refg/Mobilized",
            Self::S1194 => {
                "HPC, APHERESIS|NS/XX/<=-120C|10% DMSO|Cryopreserved|Mobilized"
            }
            Self::S1195 => "HPC, APHERESIS|NS/XX/<=-120C|5% DMSO|Cryopreserved|Mobilized",
            Self::S1310 => {
                "HPC, APHERESIS|None/XX/refg|3rd Party Comp:Yes|Other Additives:Yes|Mobilized|CD34 enriched"
            }
            Self::S1398 => "HPC, MARROW|NS/XX/rt|Plasma reduced",
            Self::S2598 => {
                "HPC, MARROW|NS/XX/<=-150C|10% DMSO|3rd Party Comp:Yes|Cryopreserved|RBC reduced"
            }
            Self::T1396 => "BONE, FEMUR|Frozen|Right|Radiation sterilization",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductCodes> for Coding {
    fn from(code: BiologicallyDerivedProductCodes) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/biologicallyderived-productcodes"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BiologicallyDerivedProductCodes> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BiologicallyDerivedProductDispense](http://hl7.org/fhir/ValueSet/biologicallyderivedproductdispense-status)**. BiologicallyDerivedProductDispense Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductDispense {
    /** **allocated**

Allocated. The requested product has been allocated and is ready for transport. */
    Allocated,
    /** **entered-in-error**

Entered in Error. The dispense was entered in error and therefore nullified. */
    EnteredInError,
    /** **in-progress**

In Progress. The dispense process is in progress. */
    InProgress,
    /** **issued**

Issued. The dispensed product has been picked up. */
    Issued,
    /** **preparation**

Preparation. The dispense process has started but not yet completed. */
    Preparation,
    /** **returned**

Returned. The dispensed product was returned. */
    Returned,
    /** **unfulfilled**

Unfulfilled. The dispense could not be completed. */
    Unfulfilled,
    /** **unknown**

Unknown. The authoring system does not know which of the status values applies for this dispense. Note: this concept is not to be used for other - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for BiologicallyDerivedProductDispense {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "allocated" => Ok(Self::Allocated),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "issued" => Ok(Self::Issued),
            "preparation" => Ok(Self::Preparation),
            "returned" => Ok(Self::Returned),
            "unfulfilled" => Ok(Self::Unfulfilled),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductDispense {
    fn as_ref(&self) -> &str {
        match self {
            Self::Allocated => "allocated",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Issued => "issued",
            Self::Preparation => "preparation",
            Self::Returned => "returned",
            Self::Unfulfilled => "unfulfilled",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductDispense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Allocated => "Allocated",
            Self::EnteredInError => "Entered in Error",
            Self::InProgress => "In Progress",
            Self::Issued => "Issued",
            Self::Preparation => "Preparation",
            Self::Returned => "Returned",
            Self::Unfulfilled => "Unfulfilled",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductDispense {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductDispense {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductDispense> for Coding {
    fn from(code: BiologicallyDerivedProductDispense) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/biologicallyderivedproductdispense-status"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BiologicallyDerivedProductDispense> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductDispense) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BiologicallyDerivedProductDispenseMatchStatus](http://hl7.org/fhir/ValueSet/biologicallyderivedproductdispense-match-status)**. Biologically derived product dispense - match status\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductDispenseMatchStatus {
    /** **crossmatched**

Crossmatched. The product has been serologically or electronically crossmatched for the recipient */
    Crossmatched,
    /** **least-incompatible**

Least incompatible. The product has been selected through crossmatching as least incompatible */
    LeastIncompatible,
    /** **selected**

Selected. The product has been selected for the specific use of the recipient */
    Selected,
    /** **unmatched**

Unmatched. No specific matching has been carried out */
    Unmatched,
}
impl ::core::str::FromStr for BiologicallyDerivedProductDispenseMatchStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "crossmatched" => Ok(Self::Crossmatched),
            "least-incompatible" => Ok(Self::LeastIncompatible),
            "selected" => Ok(Self::Selected),
            "unmatched" => Ok(Self::Unmatched),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductDispenseMatchStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Crossmatched => "crossmatched",
            Self::LeastIncompatible => "least-incompatible",
            Self::Selected => "selected",
            Self::Unmatched => "unmatched",
        }
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductDispenseMatchStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Crossmatched => "Crossmatched",
            Self::LeastIncompatible => "Least incompatible",
            Self::Selected => "Selected",
            Self::Unmatched => "Unmatched",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductDispenseMatchStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductDispenseMatchStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductDispenseMatchStatus> for Coding {
    fn from(code: BiologicallyDerivedProductDispenseMatchStatus) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/biologicallyderivedproductdispense-match-status"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BiologicallyDerivedProductDispenseMatchStatus> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductDispenseMatchStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BiologicallyDerivedProductDispenseOriginRelationship](http://hl7.org/fhir/ValueSet/biologicallyderivedproductdispense-origin-relationship)**. Biologically derived product dispense - origin relationship\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductDispenseOriginRelationship {
    /** **allogeneic**

Allogeneic. The donor and the recipient are unrelated */
    Allogeneic,
    /** **autologous**

Autologous. The product was pre-donated by the recipient */
    Autologous,
    /** **directed**

Directed. The donor has been specifically selected to provide product for the recipient */
    Directed,
    /** **related**

Related. The product is from a blood relation of the recipient */
    Related,
    /** **xenogenic**

Xenogenic. The product is from a different species to the recipient */
    Xenogenic,
}
impl ::core::str::FromStr for BiologicallyDerivedProductDispenseOriginRelationship {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "allogeneic" => Ok(Self::Allogeneic),
            "autologous" => Ok(Self::Autologous),
            "directed" => Ok(Self::Directed),
            "related" => Ok(Self::Related),
            "xenogenic" => Ok(Self::Xenogenic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductDispenseOriginRelationship {
    fn as_ref(&self) -> &str {
        match self {
            Self::Allogeneic => "allogeneic",
            Self::Autologous => "autologous",
            Self::Directed => "directed",
            Self::Related => "related",
            Self::Xenogenic => "xenogenic",
        }
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductDispenseOriginRelationship {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Allogeneic => "Allogeneic",
            Self::Autologous => "Autologous",
            Self::Directed => "Directed",
            Self::Related => "Related",
            Self::Xenogenic => "Xenogenic",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductDispenseOriginRelationship {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductDispenseOriginRelationship {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductDispenseOriginRelationship> for Coding {
    fn from(code: BiologicallyDerivedProductDispenseOriginRelationship) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/biologicallyderivedproductdispense-origin-relationship"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BiologicallyDerivedProductDispenseOriginRelationship> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductDispenseOriginRelationship) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BiologicallyDerivedProductDispensePerformerFunction](http://hl7.org/fhir/ValueSet/biologicallyderivedproductdispense-performer-function)**. Biologically derived product dispense - performer function\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductDispensePerformerFunction {
    /** **antibody-identification**

Antibody Identification. Antibody identification procedure */
    AntibodyIdentification,
    /** **antibody-screen**

Antibody Screen. Antibody screening procedure */
    AntibodyScreen,
    /** **crossmatch**

Crossmatch. Serological or electronic crossmatch procedure */
    Crossmatch,
    /** **group-and-type**

Group and Type. ABO and RhD blood grouping procedure */
    GroupAndType,
    /** **receipt**

Receipt. Receipt of product for clinical application */
    Receipt,
    /** **release**

Release. Approval for release for clinical application */
    Release,
    /** **transport**

Transport. Transfer of product from the supply department to the site of clinical use */
    Transport,
}
impl ::core::str::FromStr for BiologicallyDerivedProductDispensePerformerFunction {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "antibody-identification" => Ok(Self::AntibodyIdentification),
            "antibody-screen" => Ok(Self::AntibodyScreen),
            "crossmatch" => Ok(Self::Crossmatch),
            "group-and-type" => Ok(Self::GroupAndType),
            "receipt" => Ok(Self::Receipt),
            "release" => Ok(Self::Release),
            "transport" => Ok(Self::Transport),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductDispensePerformerFunction {
    fn as_ref(&self) -> &str {
        match self {
            Self::AntibodyIdentification => "antibody-identification",
            Self::AntibodyScreen => "antibody-screen",
            Self::Crossmatch => "crossmatch",
            Self::GroupAndType => "group-and-type",
            Self::Receipt => "receipt",
            Self::Release => "release",
            Self::Transport => "transport",
        }
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductDispensePerformerFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AntibodyIdentification => "Antibody Identification",
            Self::AntibodyScreen => "Antibody Screen",
            Self::Crossmatch => "Crossmatch",
            Self::GroupAndType => "Group and Type",
            Self::Receipt => "Receipt",
            Self::Release => "Release",
            Self::Transport => "Transport",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductDispensePerformerFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductDispensePerformerFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductDispensePerformerFunction> for Coding {
    fn from(code: BiologicallyDerivedProductDispensePerformerFunction) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/biologicallyderivedproductdispense-performer-function"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BiologicallyDerivedProductDispensePerformerFunction> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductDispensePerformerFunction) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BiologicallyDerivedProductStatus](http://hl7.org/fhir/ValueSet/biologicallyderived-product-status)**. Biologically Derived Product Status.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductStatus {
    /** **available**

Available. Product is currently available for use. */
    Available,
    /** **unavailable**

Unavailable. Product is not currently available for use. */
    Unavailable,
}
impl ::core::str::FromStr for BiologicallyDerivedProductStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "unavailable" => Ok(Self::Unavailable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::Unavailable => "unavailable",
        }
    }
}
impl ::std::fmt::Display for BiologicallyDerivedProductStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Available => "Available",
            Self::Unavailable => "Unavailable",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BiologicallyDerivedProductStatus> for Coding {
    fn from(code: BiologicallyDerivedProductStatus) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/biologicallyderived-product-status"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BiologicallyDerivedProductStatus> for CodeableConcept {
    fn from(code: BiologicallyDerivedProductStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[BundleType](http://hl7.org/fhir/ValueSet/bundle-type)**. Indicates the purpose of a bundle - how it is intended to be used.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BundleType {
    /** **batch**

Batch. The bundle is a set of actions - intended to be processed by a server as a group of independent actions. */
    Batch,
    /** **batch-response**

Batch Response. The bundle is a batch response. Note that as a batch, some responses may indicate failure and others success. */
    BatchResponse,
    /** **collection**

Collection. The bundle is a set of resources collected into a single package for ease of distribution that imposes no processing obligations or behavioral rules beyond persistence. */
    Collection,
    /** **document**

Document. The bundle is a document. The first resource is a Composition. */
    Document,
    /** **history**

History List. The bundle is a list of resources from a history interaction on a server. */
    History,
    /** **message**

Message. The bundle is a message. The first resource is a MessageHeader. */
    Message,
    /** **searchset**

Search Results. The bundle is a list of resources returned as a result of a search/query interaction, operation, or message. */
    Searchset,
    /** **subscription-notification**

Subscription Notification. The bundle has been generated by a Subscription to communicate information to a client. */
    SubscriptionNotification,
    /** **transaction**

Transaction. The bundle is a transaction - intended to be processed by a server as an atomic commit. */
    Transaction,
    /** **transaction-response**

Transaction Response. The bundle is a transaction response. Because the response is a transaction response, the transaction has succeeded, and all responses are error free. */
    TransactionResponse,
}
impl ::core::str::FromStr for BundleType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "batch" => Ok(Self::Batch),
            "batch-response" => Ok(Self::BatchResponse),
            "collection" => Ok(Self::Collection),
            "document" => Ok(Self::Document),
            "history" => Ok(Self::History),
            "message" => Ok(Self::Message),
            "searchset" => Ok(Self::Searchset),
            "subscription-notification" => Ok(Self::SubscriptionNotification),
            "transaction" => Ok(Self::Transaction),
            "transaction-response" => Ok(Self::TransactionResponse),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BundleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Batch => "batch",
            Self::BatchResponse => "batch-response",
            Self::Collection => "collection",
            Self::Document => "document",
            Self::History => "history",
            Self::Message => "message",
            Self::Searchset => "searchset",
            Self::SubscriptionNotification => "subscription-notification",
            Self::Transaction => "transaction",
            Self::TransactionResponse => "transaction-response",
        }
    }
}
impl ::std::fmt::Display for BundleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Batch => "Batch",
            Self::BatchResponse => "Batch Response",
            Self::Collection => "Collection",
            Self::Document => "Document",
            Self::History => "History List",
            Self::Message => "Message",
            Self::Searchset => "Search Results",
            Self::SubscriptionNotification => "Subscription Notification",
            Self::Transaction => "Transaction",
            Self::TransactionResponse => "Transaction Response",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for BundleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BundleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<BundleType> for Coding {
    fn from(code: BundleType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/bundle-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<BundleType> for CodeableConcept {
    fn from(code: BundleType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CapabilityStatementKind](http://hl7.org/fhir/ValueSet/capability-statement-kind)**. How a capability statement is intended to be used.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CapabilityStatementKind {
    /** **capability**

Capability. The CapabilityStatement instance represents the capabilities of a system or piece of software, independent of a particular installation. */
    Capability,
    /** **instance**

Instance. The CapabilityStatement instance represents the present capabilities of a specific system instance.  This is the kind returned by /metadata for a FHIR server end-point. */
    Instance,
    /** **requirements**

Requirements. The CapabilityStatement instance represents a set of requirements for other systems to meet; e.g. as part of an implementation guide or 'request for proposal'. */
    Requirements,
}
impl ::core::str::FromStr for CapabilityStatementKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "capability" => Ok(Self::Capability),
            "instance" => Ok(Self::Instance),
            "requirements" => Ok(Self::Requirements),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CapabilityStatementKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Capability => "capability",
            Self::Instance => "instance",
            Self::Requirements => "requirements",
        }
    }
}
impl ::std::fmt::Display for CapabilityStatementKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Capability => "Capability",
            Self::Instance => "Instance",
            Self::Requirements => "Requirements",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CapabilityStatementKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CapabilityStatementKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CapabilityStatementKind> for Coding {
    fn from(code: CapabilityStatementKind) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/capability-statement-kind".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CapabilityStatementKind> for CodeableConcept {
    fn from(code: CapabilityStatementKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CareTeamStatus](http://hl7.org/fhir/ValueSet/care-team-status)**. Indicates the status of the care team.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CareTeamStatus {
    /** **active**

Active. The care team is currently participating in the coordination and delivery of care. */
    Active,
    /** **entered-in-error**

Entered in Error. The care team should have never existed. */
    EnteredInError,
    /** **inactive**

Inactive. The care team was, but is no longer, participating in the coordination and delivery of care. */
    Inactive,
    /** **proposed**

Proposed. The care team has been drafted and proposed, but not yet participating in the coordination and delivery of patient care. */
    Proposed,
    /** **suspended**

Suspended. The care team is temporarily on hold or suspended and not participating in the coordination and delivery of care. */
    Suspended,
}
impl ::core::str::FromStr for CareTeamStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "proposed" => Ok(Self::Proposed),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CareTeamStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Proposed => "proposed",
            Self::Suspended => "suspended",
        }
    }
}
impl ::std::fmt::Display for CareTeamStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in Error",
            Self::Inactive => "Inactive",
            Self::Proposed => "Proposed",
            Self::Suspended => "Suspended",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CareTeamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CareTeamStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CareTeamStatus> for Coding {
    fn from(code: CareTeamStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/care-team-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CareTeamStatus> for CodeableConcept {
    fn from(code: CareTeamStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CatalogType](http://hl7.org/fhir/catalogType)**. CatalogType\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CatalogType {
    /** **device**

Device Catalog. Device Catalog. */
    Device,
    /** **medication**

Medication Catalog. Medication Catalog. */
    Medication,
    /** **protocol**

Protocol List. Protocol List. */
    Protocol,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CatalogType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "device" => Ok(Self::Device),
            "medication" => Ok(Self::Medication),
            "protocol" => Ok(Self::Protocol),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CatalogType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "device",
            Self::Medication => "medication",
            Self::Protocol => "protocol",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for CatalogType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Device => "Device Catalog",
            Self::Medication => "Medication Catalog",
            Self::Protocol => "Protocol List",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CatalogType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CatalogType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CatalogType> for Coding {
    fn from(code: CatalogType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/catalogType".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CatalogType> for CodeableConcept {
    fn from(code: CatalogType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CharacteristicCombination](http://hl7.org/fhir/ValueSet/characteristic-combination)**. Logical grouping of characteristics.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CharacteristicCombination {
    /** **all-of**

All of. Combine characteristics with AND. */
    AllOf,
    /** **any-of**

Any of. Combine characteristics with OR. */
    AnyOf,
    /** **at-least**

At least. Meet at least the threshold number of characteristics for definition. */
    AtLeast,
    /** **at-most**

At most. Meet at most the threshold number of characteristics for definition. */
    AtMost,
    /** **dataset**

Dataset. Combine characteristics as a collection used as the dataset. */
    Dataset,
    /** **net-effect**

Net effect. Combine characteristics by addition of benefits and subtraction of harms. */
    NetEffect,
    /** **statistical**

Statistical. Combine characteristics statistically. Use method to specify the statistical method. */
    Statistical,
}
impl ::core::str::FromStr for CharacteristicCombination {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all-of" => Ok(Self::AllOf),
            "any-of" => Ok(Self::AnyOf),
            "at-least" => Ok(Self::AtLeast),
            "at-most" => Ok(Self::AtMost),
            "dataset" => Ok(Self::Dataset),
            "net-effect" => Ok(Self::NetEffect),
            "statistical" => Ok(Self::Statistical),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CharacteristicCombination {
    fn as_ref(&self) -> &str {
        match self {
            Self::AllOf => "all-of",
            Self::AnyOf => "any-of",
            Self::AtLeast => "at-least",
            Self::AtMost => "at-most",
            Self::Dataset => "dataset",
            Self::NetEffect => "net-effect",
            Self::Statistical => "statistical",
        }
    }
}
impl ::std::fmt::Display for CharacteristicCombination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AllOf => "All of",
            Self::AnyOf => "Any of",
            Self::AtLeast => "At least",
            Self::AtMost => "At most",
            Self::Dataset => "Dataset",
            Self::NetEffect => "Net effect",
            Self::Statistical => "Statistical",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CharacteristicCombination {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CharacteristicCombination {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CharacteristicCombination> for Coding {
    fn from(code: CharacteristicCombination) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/characteristic-combination".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CharacteristicCombination> for CodeableConcept {
    fn from(code: CharacteristicCombination) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CharacteristicOffset](http://hl7.org/fhir/ValueSet/characteristic-offset)**. Reference point for characteristic.valueQuantity.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CharacteristicOffset {
    /** **LNL**

Lower Normal Limit. The lower bound of the reference range. */
    Lnl,
    /** **UNL**

Upper Normal Limit. The upper bound of the reference range. */
    Unl,
}
impl ::core::str::FromStr for CharacteristicOffset {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "LNL" => Ok(Self::Lnl),
            "UNL" => Ok(Self::Unl),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CharacteristicOffset {
    fn as_ref(&self) -> &str {
        match self {
            Self::Lnl => "LNL",
            Self::Unl => "UNL",
        }
    }
}
impl ::std::fmt::Display for CharacteristicOffset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Lnl => "Lower Normal Limit",
            Self::Unl => "Upper Normal Limit",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CharacteristicOffset {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CharacteristicOffset {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CharacteristicOffset> for Coding {
    fn from(code: CharacteristicOffset) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/characteristic-offset".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CharacteristicOffset> for CodeableConcept {
    fn from(code: CharacteristicOffset) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ChargeItemStatus](http://hl7.org/fhir/ValueSet/chargeitem-status)**. Codes identifying the lifecycle stage of a ChargeItem.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ChargeItemStatus {
    /** **aborted**

Aborted. The processing of the charge was aborted. */
    Aborted,
    /** **billable**

Billable. The charge item is ready for billing. */
    Billable,
    /** **billed**

Billed. The charge item has been billed (e.g. a billing engine has generated financial transactions by applying the associated ruled for the charge item to the context of the Encounter, and placed them into Claims/Invoices. */
    Billed,
    /** **entered-in-error**

Entered in Error. The charge item has been entered in error and should not be processed for billing. */
    EnteredInError,
    /** **not-billable**

Not billable. The charge item has been determined to be not billable (e.g. due to rules associated with the billing code). */
    NotBillable,
    /** **planned**

Planned. The charge item has been entered, but the charged service is not  yet complete, so it shall not be billed yet but might be used in the context of pre-authorization. */
    Planned,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this charge item  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for ChargeItemStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aborted" => Ok(Self::Aborted),
            "billable" => Ok(Self::Billable),
            "billed" => Ok(Self::Billed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "not-billable" => Ok(Self::NotBillable),
            "planned" => Ok(Self::Planned),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ChargeItemStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aborted => "aborted",
            Self::Billable => "billable",
            Self::Billed => "billed",
            Self::EnteredInError => "entered-in-error",
            Self::NotBillable => "not-billable",
            Self::Planned => "planned",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for ChargeItemStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Aborted => "Aborted",
            Self::Billable => "Billable",
            Self::Billed => "Billed",
            Self::EnteredInError => "Entered in Error",
            Self::NotBillable => "Not billable",
            Self::Planned => "Planned",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ChargeItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ChargeItemStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ChargeItemStatus> for Coding {
    fn from(code: ChargeItemStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/chargeitem-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ChargeItemStatus> for CodeableConcept {
    fn from(code: ChargeItemStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CitationArtifactClassifier](http://hl7.org/fhir/ValueSet/citation-artifact-classifier)**. Citation artifact classifier\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitationArtifactClassifier {
    /** **D000076942**

Preprint. Scientific manuscript made available prior to PEER REVIEW. */
    D000076942,
    /** **D001877**

Book. Non-periodical written or printed works consisting of sheets of pages fastened or bound together within covers. */
    D001877,
    /** **D016420**

Comment. Comment */
    D016420,
    /** **D016422**

Letter. Letter */
    D016422,
    /** **D016425**

Published Erratum. Published Erratum */
    D016425,
    /** **D016428**

Journal Article. Journal Article */
    D016428,
    /** **D019991**

Database. A structured file of information or a set of logically related data stored and retrieved using computer-based means. */
    D019991,
    /** **D059040**

Video-Audio Media. Used with articles which include video files or clips, or for articles which are entirely video. */
    D059040,
    /** **D064886**

Dataset. Works consisting of organized collections of data, which have been stored permanently in a formalized manner suitable for communication, interpretation, or processing. */
    D064886,
    /** **Electronic**

Electronic. the journal is published in electronic format only */
    Electronic,
    /** **Electronic-Print**

Electronic-Print. the journal is published first in electronic format followed by print (this value is currently used for just one journal, Nucleic Acids Research) */
    ElectronicPrint,
    /** **Electronic-eCollection**

Electronic-eCollection. used for electronic-only journals that publish individual articles first and then later collect them into an "issue" date that is typically called an eCollection. */
    ElectronicECollection,
    /** **Print**

Print. the journal is published in print format only */
    Print,
    /** **Print-Electronic**

Print Electronic. the journal is published in both print and electronic format */
    PrintElectronic,
    /** **audio**

Audio file. The article cited is an audio file. */
    Audio,
    /** **cds-artifact**

Clinical Decision Support Artifact. The artifact is used for decision support for healthcare decisions. */
    CdsArtifact,
    /** **common-share**

Common Share. Citation Resource containing value added data that is openly shared */
    CommonShare,
    /** **dataset-unpublished**

Dataset Unpublished. An organized collection of data that is not stored permanently for communication. */
    DatasetUnpublished,
    /** **executable-app**

Executable app. Executable app */
    ExecutableApp,
    /** **fhir-resource**

FHIR Resource. The article cited is a FHIR resource. */
    FhirResource,
    /** **image**

Image file. The article cited is an image file. */
    Image,
    /** **interactive-form**

Interactive Form. A user interface that supports data entry and data display. */
    InteractiveForm,
    /** **machine-code**

Machine code. The article cited is machine code. */
    MachineCode,
    /** **medline-base**

Medline Base. Citation Resource containing only data from Medline */
    MedlineBase,
    /** **prediction-model**

Prediction Model. A formula or expression used to calculate an outcome representing a predicted result. */
    PredictionModel,
    /** **project-specific**

Project Specific. Citation Resource containing value added data specific to a project */
    ProjectSpecific,
    /** **protocol**

Protocol. The article cited is the protocol of an activity and not the results or findings. */
    Protocol,
    /** **pseudocode**

PseudoCode. A non-executable, human-readable representation of software code. */
    Pseudocode,
    /** **standard-specification**

Standard Specification. An explicit set of requirements for an item, material, component, system or service, often used to define a technical standard which is an established norm or requirement for a repeatable technical task. */
    StandardSpecification,
    /** **terminology**

Terminology. A structured set of codes and display values, which may be subtyped as a code system, value set, taxonomy, or ontology. */
    Terminology,
    /** **webpage**

Webpage. Webpage */
    Webpage,
}
impl ::core::str::FromStr for CitationArtifactClassifier {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "D000076942" => Ok(Self::D000076942),
            "D001877" => Ok(Self::D001877),
            "D016420" => Ok(Self::D016420),
            "D016422" => Ok(Self::D016422),
            "D016425" => Ok(Self::D016425),
            "D016428" => Ok(Self::D016428),
            "D019991" => Ok(Self::D019991),
            "D059040" => Ok(Self::D059040),
            "D064886" => Ok(Self::D064886),
            "Electronic" => Ok(Self::Electronic),
            "Electronic-Print" => Ok(Self::ElectronicPrint),
            "Electronic-eCollection" => Ok(Self::ElectronicECollection),
            "Print" => Ok(Self::Print),
            "Print-Electronic" => Ok(Self::PrintElectronic),
            "audio" => Ok(Self::Audio),
            "cds-artifact" => Ok(Self::CdsArtifact),
            "common-share" => Ok(Self::CommonShare),
            "dataset-unpublished" => Ok(Self::DatasetUnpublished),
            "executable-app" => Ok(Self::ExecutableApp),
            "fhir-resource" => Ok(Self::FhirResource),
            "image" => Ok(Self::Image),
            "interactive-form" => Ok(Self::InteractiveForm),
            "machine-code" => Ok(Self::MachineCode),
            "medline-base" => Ok(Self::MedlineBase),
            "prediction-model" => Ok(Self::PredictionModel),
            "project-specific" => Ok(Self::ProjectSpecific),
            "protocol" => Ok(Self::Protocol),
            "pseudocode" => Ok(Self::Pseudocode),
            "standard-specification" => Ok(Self::StandardSpecification),
            "terminology" => Ok(Self::Terminology),
            "webpage" => Ok(Self::Webpage),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationArtifactClassifier {
    fn as_ref(&self) -> &str {
        match self {
            Self::D000076942 => "D000076942",
            Self::D001877 => "D001877",
            Self::D016420 => "D016420",
            Self::D016422 => "D016422",
            Self::D016425 => "D016425",
            Self::D016428 => "D016428",
            Self::D019991 => "D019991",
            Self::D059040 => "D059040",
            Self::D064886 => "D064886",
            Self::Electronic => "Electronic",
            Self::ElectronicPrint => "Electronic-Print",
            Self::ElectronicECollection => "Electronic-eCollection",
            Self::Print => "Print",
            Self::PrintElectronic => "Print-Electronic",
            Self::Audio => "audio",
            Self::CdsArtifact => "cds-artifact",
            Self::CommonShare => "common-share",
            Self::DatasetUnpublished => "dataset-unpublished",
            Self::ExecutableApp => "executable-app",
            Self::FhirResource => "fhir-resource",
            Self::Image => "image",
            Self::InteractiveForm => "interactive-form",
            Self::MachineCode => "machine-code",
            Self::MedlineBase => "medline-base",
            Self::PredictionModel => "prediction-model",
            Self::ProjectSpecific => "project-specific",
            Self::Protocol => "protocol",
            Self::Pseudocode => "pseudocode",
            Self::StandardSpecification => "standard-specification",
            Self::Terminology => "terminology",
            Self::Webpage => "webpage",
        }
    }
}
impl ::std::fmt::Display for CitationArtifactClassifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::D000076942 => "Preprint",
            Self::D001877 => "Book",
            Self::D016420 => "Comment",
            Self::D016422 => "Letter",
            Self::D016425 => "Published Erratum",
            Self::D016428 => "Journal Article",
            Self::D019991 => "Database",
            Self::D059040 => "Video-Audio Media",
            Self::D064886 => "Dataset",
            Self::Electronic => "Electronic",
            Self::ElectronicPrint => "Electronic-Print",
            Self::ElectronicECollection => "Electronic-eCollection",
            Self::Print => "Print",
            Self::PrintElectronic => "Print Electronic",
            Self::Audio => "Audio file",
            Self::CdsArtifact => "Clinical Decision Support Artifact",
            Self::CommonShare => "Common Share",
            Self::DatasetUnpublished => "Dataset Unpublished",
            Self::ExecutableApp => "Executable app",
            Self::FhirResource => "FHIR Resource",
            Self::Image => "Image file",
            Self::InteractiveForm => "Interactive Form",
            Self::MachineCode => "Machine code",
            Self::MedlineBase => "Medline Base",
            Self::PredictionModel => "Prediction Model",
            Self::ProjectSpecific => "Project Specific",
            Self::Protocol => "Protocol",
            Self::Pseudocode => "PseudoCode",
            Self::StandardSpecification => "Standard Specification",
            Self::Terminology => "Terminology",
            Self::Webpage => "Webpage",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CitationArtifactClassifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationArtifactClassifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitationArtifactClassifier> for Coding {
    fn from(code: CitationArtifactClassifier) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/citation-artifact-classifier".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CitationArtifactClassifier> for CodeableConcept {
    fn from(code: CitationArtifactClassifier) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CitationClassificationType](http://hl7.org/fhir/ValueSet/citation-classification-type)**. Citation classification type\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitationClassificationType {
    /** **citation-source**

Citation Source. Citation repository where this citation was created or copied from */
    CitationSource,
    /** **fevir-platform-use**

FEvIR Platform Use. Used for Citation sharing on the Fast Evidence Interoperability Resources (FEvIR) Platform */
    FevirPlatformUse,
    /** **medline-owner**

MEDLINE Citation Owner. The party responsible for creating and validating the MEDLINE citation */
    MedlineOwner,
}
impl ::core::str::FromStr for CitationClassificationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "citation-source" => Ok(Self::CitationSource),
            "fevir-platform-use" => Ok(Self::FevirPlatformUse),
            "medline-owner" => Ok(Self::MedlineOwner),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationClassificationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::CitationSource => "citation-source",
            Self::FevirPlatformUse => "fevir-platform-use",
            Self::MedlineOwner => "medline-owner",
        }
    }
}
impl ::std::fmt::Display for CitationClassificationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::CitationSource => "Citation Source",
            Self::FevirPlatformUse => "FEvIR Platform Use",
            Self::MedlineOwner => "MEDLINE Citation Owner",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CitationClassificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationClassificationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitationClassificationType> for Coding {
    fn from(code: CitationClassificationType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/citation-classification-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CitationClassificationType> for CodeableConcept {
    fn from(code: CitationClassificationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CitationStatusType](http://hl7.org/fhir/ValueSet/citation-status-type)**. Citation status type\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitationStatusType {
    /** **medline-completed**

Medline Citation Status of Completed. Medline Citation Status of Completed */
    MedlineCompleted,
    /** **medline-in-data-review**

Medline Citation Status of In-Data-Review. Medline Citation Status of In-Data-Review */
    MedlineInDataReview,
    /** **medline-in-process**

Medline Citation Status of In-Process. Medline Citation Status of In-Process */
    MedlineInProcess,
    /** **medline-medline**

Medline Citation Status of MEDLINE. Medline Citation Status of MEDLINE */
    MedlineMedline,
    /** **medline-oldmedline**

Medline Citation Status of OLDMEDLINE. Medline Citation Status of OLDMEDLINE */
    MedlineOldmedline,
    /** **medline-publisher**

Medline Citation Status of Publisher. Medline Citation Status of Publisher */
    MedlinePublisher,
    /** **medline-pubmed-not-medline**

Medline Citation Status of PubMed-not-MEDLINE. Medline Citation Status of PubMed-not-MEDLINE */
    MedlinePubmedNotMedline,
    /** **pubmed-publication-status-aheadofprint**

PubMed PublicationStatus of aheadofprint. electronically published, but followed by print */
    PubmedPublicationStatusAheadofprint,
    /** **pubmed-publication-status-epublish**

PubMed PublicationStatus of epublish. electronically published only, never published in print */
    PubmedPublicationStatusEpublish,
    /** **pubmed-publication-status-ppublish**

PubMed PublicationStatus of ppublish. published in print */
    PubmedPublicationStatusPpublish,
    /** **pubmed-pubstatus-accepted**

PubMed Pubstatus of Accepted. PubMed Pubstatus of Accepted */
    PubmedPubstatusAccepted,
    /** **pubmed-pubstatus-aheadofprint**

PubMed Pubstatus of aheadofprint. PubMed Pubstatus of aheadofprint */
    PubmedPubstatusAheadofprint,
    /** **pubmed-pubstatus-ecollection**

PubMed Pubstatus of Ecollection. PubMed Pubstatus of Ecollection */
    PubmedPubstatusEcollection,
    /** **pubmed-pubstatus-entrez**

PubMed Pubstatus of Entrez. PubMed Pubstatus of Entrez */
    PubmedPubstatusEntrez,
    /** **pubmed-pubstatus-epublish**

PubMed Pubstatus of Epublish. PubMed Pubstatus of Epublish */
    PubmedPubstatusEpublish,
    /** **pubmed-pubstatus-medline**

PubMed Pubstatus of Medline. PubMed Pubstatus of Medline */
    PubmedPubstatusMedline,
    /** **pubmed-pubstatus-medliner**

PubMed Pubstatus of Medliner. PubMed Pubstatus of Medliner */
    PubmedPubstatusMedliner,
    /** **pubmed-pubstatus-pmc**

PubMed Pubstatus of PMC. PubMed Pubstatus of PMC */
    PubmedPubstatusPmc,
    /** **pubmed-pubstatus-pmc-release**

PubMed Pubstatus of PMC release. PubMed Pubstatus of PMC release */
    PubmedPubstatusPmcRelease,
    /** **pubmed-pubstatus-pmcr**

PubMed Pubstatus of PMCr. PubMed Pubstatus of PMCr */
    PubmedPubstatusPmcr,
    /** **pubmed-pubstatus-ppublish**

PubMed Pubstatus of Ppublish. PubMed Pubstatus of Ppublish */
    PubmedPubstatusPpublish,
    /** **pubmed-pubstatus-premedline**

PubMed Pubstatus of Premedline. PubMed Pubstatus of Premedline */
    PubmedPubstatusPremedline,
    /** **pubmed-pubstatus-pubmed**

PubMed Pubstatus of PubMed. PubMed Pubstatus of PubMed */
    PubmedPubstatusPubmed,
    /** **pubmed-pubstatus-pubmedr**

PubMed Pubstatus of PubMedr. PubMed Pubstatus of PubMedr */
    PubmedPubstatusPubmedr,
    /** **pubmed-pubstatus-received**

PubMed Pubstatus of Received. PubMed Pubstatus of Received */
    PubmedPubstatusReceived,
    /** **pubmed-pubstatus-retracted**

PubMed Pubstatus of Retracted. PubMed Pubstatus of Retracted */
    PubmedPubstatusRetracted,
    /** **pubmed-pubstatus-revised**

PubMed Pubstatus of Revised. PubMed Pubstatus of Revised */
    PubmedPubstatusRevised,
}
impl ::core::str::FromStr for CitationStatusType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "medline-completed" => Ok(Self::MedlineCompleted),
            "medline-in-data-review" => Ok(Self::MedlineInDataReview),
            "medline-in-process" => Ok(Self::MedlineInProcess),
            "medline-medline" => Ok(Self::MedlineMedline),
            "medline-oldmedline" => Ok(Self::MedlineOldmedline),
            "medline-publisher" => Ok(Self::MedlinePublisher),
            "medline-pubmed-not-medline" => Ok(Self::MedlinePubmedNotMedline),
            "pubmed-publication-status-aheadofprint" => {
                Ok(Self::PubmedPublicationStatusAheadofprint)
            }
            "pubmed-publication-status-epublish" => {
                Ok(Self::PubmedPublicationStatusEpublish)
            }
            "pubmed-publication-status-ppublish" => {
                Ok(Self::PubmedPublicationStatusPpublish)
            }
            "pubmed-pubstatus-accepted" => Ok(Self::PubmedPubstatusAccepted),
            "pubmed-pubstatus-aheadofprint" => Ok(Self::PubmedPubstatusAheadofprint),
            "pubmed-pubstatus-ecollection" => Ok(Self::PubmedPubstatusEcollection),
            "pubmed-pubstatus-entrez" => Ok(Self::PubmedPubstatusEntrez),
            "pubmed-pubstatus-epublish" => Ok(Self::PubmedPubstatusEpublish),
            "pubmed-pubstatus-medline" => Ok(Self::PubmedPubstatusMedline),
            "pubmed-pubstatus-medliner" => Ok(Self::PubmedPubstatusMedliner),
            "pubmed-pubstatus-pmc" => Ok(Self::PubmedPubstatusPmc),
            "pubmed-pubstatus-pmc-release" => Ok(Self::PubmedPubstatusPmcRelease),
            "pubmed-pubstatus-pmcr" => Ok(Self::PubmedPubstatusPmcr),
            "pubmed-pubstatus-ppublish" => Ok(Self::PubmedPubstatusPpublish),
            "pubmed-pubstatus-premedline" => Ok(Self::PubmedPubstatusPremedline),
            "pubmed-pubstatus-pubmed" => Ok(Self::PubmedPubstatusPubmed),
            "pubmed-pubstatus-pubmedr" => Ok(Self::PubmedPubstatusPubmedr),
            "pubmed-pubstatus-received" => Ok(Self::PubmedPubstatusReceived),
            "pubmed-pubstatus-retracted" => Ok(Self::PubmedPubstatusRetracted),
            "pubmed-pubstatus-revised" => Ok(Self::PubmedPubstatusRevised),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationStatusType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MedlineCompleted => "medline-completed",
            Self::MedlineInDataReview => "medline-in-data-review",
            Self::MedlineInProcess => "medline-in-process",
            Self::MedlineMedline => "medline-medline",
            Self::MedlineOldmedline => "medline-oldmedline",
            Self::MedlinePublisher => "medline-publisher",
            Self::MedlinePubmedNotMedline => "medline-pubmed-not-medline",
            Self::PubmedPublicationStatusAheadofprint => {
                "pubmed-publication-status-aheadofprint"
            }
            Self::PubmedPublicationStatusEpublish => "pubmed-publication-status-epublish",
            Self::PubmedPublicationStatusPpublish => "pubmed-publication-status-ppublish",
            Self::PubmedPubstatusAccepted => "pubmed-pubstatus-accepted",
            Self::PubmedPubstatusAheadofprint => "pubmed-pubstatus-aheadofprint",
            Self::PubmedPubstatusEcollection => "pubmed-pubstatus-ecollection",
            Self::PubmedPubstatusEntrez => "pubmed-pubstatus-entrez",
            Self::PubmedPubstatusEpublish => "pubmed-pubstatus-epublish",
            Self::PubmedPubstatusMedline => "pubmed-pubstatus-medline",
            Self::PubmedPubstatusMedliner => "pubmed-pubstatus-medliner",
            Self::PubmedPubstatusPmc => "pubmed-pubstatus-pmc",
            Self::PubmedPubstatusPmcRelease => "pubmed-pubstatus-pmc-release",
            Self::PubmedPubstatusPmcr => "pubmed-pubstatus-pmcr",
            Self::PubmedPubstatusPpublish => "pubmed-pubstatus-ppublish",
            Self::PubmedPubstatusPremedline => "pubmed-pubstatus-premedline",
            Self::PubmedPubstatusPubmed => "pubmed-pubstatus-pubmed",
            Self::PubmedPubstatusPubmedr => "pubmed-pubstatus-pubmedr",
            Self::PubmedPubstatusReceived => "pubmed-pubstatus-received",
            Self::PubmedPubstatusRetracted => "pubmed-pubstatus-retracted",
            Self::PubmedPubstatusRevised => "pubmed-pubstatus-revised",
        }
    }
}
impl ::std::fmt::Display for CitationStatusType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::MedlineCompleted => "Medline Citation Status of Completed",
            Self::MedlineInDataReview => "Medline Citation Status of In-Data-Review",
            Self::MedlineInProcess => "Medline Citation Status of In-Process",
            Self::MedlineMedline => "Medline Citation Status of MEDLINE",
            Self::MedlineOldmedline => "Medline Citation Status of OLDMEDLINE",
            Self::MedlinePublisher => "Medline Citation Status of Publisher",
            Self::MedlinePubmedNotMedline => {
                "Medline Citation Status of PubMed-not-MEDLINE"
            }
            Self::PubmedPublicationStatusAheadofprint => {
                "PubMed PublicationStatus of aheadofprint"
            }
            Self::PubmedPublicationStatusEpublish => {
                "PubMed PublicationStatus of epublish"
            }
            Self::PubmedPublicationStatusPpublish => {
                "PubMed PublicationStatus of ppublish"
            }
            Self::PubmedPubstatusAccepted => "PubMed Pubstatus of Accepted",
            Self::PubmedPubstatusAheadofprint => "PubMed Pubstatus of aheadofprint",
            Self::PubmedPubstatusEcollection => "PubMed Pubstatus of Ecollection",
            Self::PubmedPubstatusEntrez => "PubMed Pubstatus of Entrez",
            Self::PubmedPubstatusEpublish => "PubMed Pubstatus of Epublish",
            Self::PubmedPubstatusMedline => "PubMed Pubstatus of Medline",
            Self::PubmedPubstatusMedliner => "PubMed Pubstatus of Medliner",
            Self::PubmedPubstatusPmc => "PubMed Pubstatus of PMC",
            Self::PubmedPubstatusPmcRelease => "PubMed Pubstatus of PMC release",
            Self::PubmedPubstatusPmcr => "PubMed Pubstatus of PMCr",
            Self::PubmedPubstatusPpublish => "PubMed Pubstatus of Ppublish",
            Self::PubmedPubstatusPremedline => "PubMed Pubstatus of Premedline",
            Self::PubmedPubstatusPubmed => "PubMed Pubstatus of PubMed",
            Self::PubmedPubstatusPubmedr => "PubMed Pubstatus of PubMedr",
            Self::PubmedPubstatusReceived => "PubMed Pubstatus of Received",
            Self::PubmedPubstatusRetracted => "PubMed Pubstatus of Retracted",
            Self::PubmedPubstatusRevised => "PubMed Pubstatus of Revised",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CitationStatusType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationStatusType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitationStatusType> for Coding {
    fn from(code: CitationStatusType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/citation-status-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CitationStatusType> for CodeableConcept {
    fn from(code: CitationStatusType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CitationSummaryStyle](http://hl7.org/fhir/ValueSet/citation-summary-style)**. The format for display of the citation.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitationSummaryStyle {
    /** **acs**

American Chemical Society. Chemistry. */
    Acs,
    /** **ama11**

American Medical Association 11th edition. Medicine. */
    Ama11,
    /** **apa6**

American Psychological Association 6th edition. APA 6th edition used by Education, Psychology and Sciences. */
    Apa6,
    /** **apa7**

American Psychological Association 7th edition. APA 7th edition (October 2019) used by Education, Psychology and Sciences. */
    Apa7,
    /** **asa6**

American Sociological Association 6th edition. Sociology. */
    Asa6,
    /** **chicago-a-17**

Chicago Style Version 17 Author Date. Used by Business, History and the Fine Arts. */
    ChicagoA17,
    /** **chicago-b-17**

Chicago Style Version 17 Full note. Used by Business, History and the Fine Arts. */
    ChicagoB17,
    /** **cochrane**

Cochrane Style. Used by Cochrane reviews, example: Huang, M, Tang T, Pang, P, Li, M, Ma R, Lu, J, et al. Treating COVID-19 with Chloroquine. J Mol Cell Biol 2020; 12(4):322–5. */
    Cochrane,
    /** **comppub**

Computable Publishing. Citation style to report human-readable and/or machine-readable access paths, example: Alper BS, Dehnbostel J, Shahin K. 14-day mortality remdesivir vs placebo meta-analysis (ACTT-1, Wang et al, WHO SOLIDARITY).  Fast Evidence Interoperability Resources (FEvIR) Platform, entry 55, version 4. Created 2020 Dec 17. Revised 2020 Dec 21. Accessed 2021 Mar 13. Computable resource at: https://fevir.net/resources/Evidence/55. */
    Comppub,
    /** **elsevier-harvard**

Elsevier-Harvard Style. Biology ecology. */
    ElsevierHarvard,
    /** **ieee**

Institute of Electrical and Electronics Engineers. IT, Engineering. */
    Ieee,
    /** **mla8**

Modern Language Association 8th edition. MLA 8th edition used by the Humanities. */
    Mla8,
    /** **nature**

Nature Referencing style. Biology. */
    Nature,
    /** **vancouver**

Vancouver style. Citation style used by International Committee of Medical Journal Editors and maintained by US National Library of Medicine. */
    Vancouver,
}
impl ::core::str::FromStr for CitationSummaryStyle {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acs" => Ok(Self::Acs),
            "ama11" => Ok(Self::Ama11),
            "apa6" => Ok(Self::Apa6),
            "apa7" => Ok(Self::Apa7),
            "asa6" => Ok(Self::Asa6),
            "chicago-a-17" => Ok(Self::ChicagoA17),
            "chicago-b-17" => Ok(Self::ChicagoB17),
            "cochrane" => Ok(Self::Cochrane),
            "comppub" => Ok(Self::Comppub),
            "elsevier-harvard" => Ok(Self::ElsevierHarvard),
            "ieee" => Ok(Self::Ieee),
            "mla8" => Ok(Self::Mla8),
            "nature" => Ok(Self::Nature),
            "vancouver" => Ok(Self::Vancouver),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationSummaryStyle {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acs => "acs",
            Self::Ama11 => "ama11",
            Self::Apa6 => "apa6",
            Self::Apa7 => "apa7",
            Self::Asa6 => "asa6",
            Self::ChicagoA17 => "chicago-a-17",
            Self::ChicagoB17 => "chicago-b-17",
            Self::Cochrane => "cochrane",
            Self::Comppub => "comppub",
            Self::ElsevierHarvard => "elsevier-harvard",
            Self::Ieee => "ieee",
            Self::Mla8 => "mla8",
            Self::Nature => "nature",
            Self::Vancouver => "vancouver",
        }
    }
}
impl ::std::fmt::Display for CitationSummaryStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Acs => "American Chemical Society",
            Self::Ama11 => "American Medical Association 11th edition",
            Self::Apa6 => "American Psychological Association 6th edition",
            Self::Apa7 => "American Psychological Association 7th edition",
            Self::Asa6 => "American Sociological Association 6th edition",
            Self::ChicagoA17 => "Chicago Style Version 17 Author Date",
            Self::ChicagoB17 => "Chicago Style Version 17 Full note",
            Self::Cochrane => "Cochrane Style",
            Self::Comppub => "Computable Publishing",
            Self::ElsevierHarvard => "Elsevier-Harvard Style",
            Self::Ieee => "Institute of Electrical and Electronics Engineers",
            Self::Mla8 => "Modern Language Association 8th edition",
            Self::Nature => "Nature Referencing style",
            Self::Vancouver => "Vancouver style",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CitationSummaryStyle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationSummaryStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitationSummaryStyle> for Coding {
    fn from(code: CitationSummaryStyle) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/citation-summary-style".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CitationSummaryStyle> for CodeableConcept {
    fn from(code: CitationSummaryStyle) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CitedArtifactAbstractType](http://hl7.org/fhir/ValueSet/cited-artifact-abstract-type)**. Used to express the reason and specific aspect for the variant abstract, such as language and specific language\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedArtifactAbstractType {
    /** **autotranslated**

Different language derived from autotranslation. Machine translated form of abstract in a different language, language element codes the language into which it was translated by machine */
    Autotranslated,
    /** **different-publisher**

Different publisher for abstract. Abstract produced by a different publisher than the cited artifact */
    DifferentPublisher,
    /** **duplicate-pmid**

Different text in additional Medline entry. Alternative form of abstract in two or more Medline entries */
    DuplicatePmid,
    /** **earlier-abstract**

Different text in an earlier version. Alternative form of abstract in an earlier version such as epub ahead of print */
    EarlierAbstract,
    /** **language**

Different language. Additional form of abstract in a different language */
    Language,
    /** **long-abstract**

Long abstract. Long version of the abstract, for use when abstracts are provided in different sizes or lengths */
    LongAbstract,
    /** **plain-language**

Plain language. Additional form of abstract written for the general public */
    PlainLanguage,
    /** **primary-human-use**

Primary human use. Human-friendly main or official abstract */
    PrimaryHumanUse,
    /** **primary-machine-use**

Primary machine use. Machine-friendly main or official abstract */
    PrimaryMachineUse,
    /** **short-abstract**

Short abstract. Brief abstract, for use when abstracts are provided in different sizes or lengths */
    ShortAbstract,
    /** **truncated**

Truncated. Truncated abstract */
    Truncated,
}
impl ::core::str::FromStr for CitedArtifactAbstractType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "autotranslated" => Ok(Self::Autotranslated),
            "different-publisher" => Ok(Self::DifferentPublisher),
            "duplicate-pmid" => Ok(Self::DuplicatePmid),
            "earlier-abstract" => Ok(Self::EarlierAbstract),
            "language" => Ok(Self::Language),
            "long-abstract" => Ok(Self::LongAbstract),
            "plain-language" => Ok(Self::PlainLanguage),
            "primary-human-use" => Ok(Self::PrimaryHumanUse),
            "primary-machine-use" => Ok(Self::PrimaryMachineUse),
            "short-abstract" => Ok(Self::ShortAbstract),
            "truncated" => Ok(Self::Truncated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactAbstractType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Autotranslated => "autotranslated",
            Self::DifferentPublisher => "different-publisher",
            Self::DuplicatePmid => "duplicate-pmid",
            Self::EarlierAbstract => "earlier-abstract",
            Self::Language => "language",
            Self::LongAbstract => "long-abstract",
            Self::PlainLanguage => "plain-language",
            Self::PrimaryHumanUse => "primary-human-use",
            Self::PrimaryMachineUse => "primary-machine-use",
            Self::ShortAbstract => "short-abstract",
            Self::Truncated => "truncated",
        }
    }
}
impl ::std::fmt::Display for CitedArtifactAbstractType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Autotranslated => "Different language derived from autotranslation",
            Self::DifferentPublisher => "Different publisher for abstract",
            Self::DuplicatePmid => "Different text in additional Medline entry",
            Self::EarlierAbstract => "Different text in an earlier version",
            Self::Language => "Different language",
            Self::LongAbstract => "Long abstract",
            Self::PlainLanguage => "Plain language",
            Self::PrimaryHumanUse => "Primary human use",
            Self::PrimaryMachineUse => "Primary machine use",
            Self::ShortAbstract => "Short abstract",
            Self::Truncated => "Truncated",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CitedArtifactAbstractType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactAbstractType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedArtifactAbstractType> for Coding {
    fn from(code: CitedArtifactAbstractType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/cited-artifact-abstract-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CitedArtifactAbstractType> for CodeableConcept {
    fn from(code: CitedArtifactAbstractType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CitedArtifactClassificationType](http://hl7.org/fhir/ValueSet/cited-artifact-classification-type)**. Cited Artifact Classification Type\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedArtifactClassificationType {
    /** **chemical**

Chemical. Chemical */
    Chemical,
    /** **citation-subset**

Citation subset. Citation subset */
    CitationSubset,
    /** **coverage**

Coverage. The spatial or temporal topic of the resource, spatial applicability of the resource, or jurisdiction under which the resource is relevant */
    Coverage,
    /** **keyword**

Keyword. Keyword */
    Keyword,
    /** **knowledge-artifact-type**

Knowledge Artifact Type. Knowledge Artifact Type */
    KnowledgeArtifactType,
    /** **mesh-heading**

MeSH heading. MeSH heading */
    MeshHeading,
    /** **publication-type**

Publication type. Publication type */
    PublicationType,
    /** **publishing-model**

Publishing Model. Used for PubModel attribute in Medline */
    PublishingModel,
    /** **supplemental-mesh-disease**

Supplemental MeSH for Disease. Supplemental MeSH for Disease */
    SupplementalMeshDisease,
    /** **supplemental-mesh-organism**

Supplemental MeSH for Organism. Supplemental MeSH for Organism */
    SupplementalMeshOrganism,
    /** **supplemental-mesh-protocol**

Supplemental MeSH for Protocol. Supplemental MeSH for Protocol */
    SupplementalMeshProtocol,
}
impl ::core::str::FromStr for CitedArtifactClassificationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "chemical" => Ok(Self::Chemical),
            "citation-subset" => Ok(Self::CitationSubset),
            "coverage" => Ok(Self::Coverage),
            "keyword" => Ok(Self::Keyword),
            "knowledge-artifact-type" => Ok(Self::KnowledgeArtifactType),
            "mesh-heading" => Ok(Self::MeshHeading),
            "publication-type" => Ok(Self::PublicationType),
            "publishing-model" => Ok(Self::PublishingModel),
            "supplemental-mesh-disease" => Ok(Self::SupplementalMeshDisease),
            "supplemental-mesh-organism" => Ok(Self::SupplementalMeshOrganism),
            "supplemental-mesh-protocol" => Ok(Self::SupplementalMeshProtocol),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactClassificationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Chemical => "chemical",
            Self::CitationSubset => "citation-subset",
            Self::Coverage => "coverage",
            Self::Keyword => "keyword",
            Self::KnowledgeArtifactType => "knowledge-artifact-type",
            Self::MeshHeading => "mesh-heading",
            Self::PublicationType => "publication-type",
            Self::PublishingModel => "publishing-model",
            Self::SupplementalMeshDisease => "supplemental-mesh-disease",
            Self::SupplementalMeshOrganism => "supplemental-mesh-organism",
            Self::SupplementalMeshProtocol => "supplemental-mesh-protocol",
        }
    }
}
impl ::std::fmt::Display for CitedArtifactClassificationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Chemical => "Chemical",
            Self::CitationSubset => "Citation subset",
            Self::Coverage => "Coverage",
            Self::Keyword => "Keyword",
            Self::KnowledgeArtifactType => "Knowledge Artifact Type",
            Self::MeshHeading => "MeSH heading",
            Self::PublicationType => "Publication type",
            Self::PublishingModel => "Publishing Model",
            Self::SupplementalMeshDisease => "Supplemental MeSH for Disease",
            Self::SupplementalMeshOrganism => "Supplemental MeSH for Organism",
            Self::SupplementalMeshProtocol => "Supplemental MeSH for Protocol",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CitedArtifactClassificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactClassificationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedArtifactClassificationType> for Coding {
    fn from(code: CitedArtifactClassificationType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/cited-artifact-classification-type"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CitedArtifactClassificationType> for CodeableConcept {
    fn from(code: CitedArtifactClassificationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CitedArtifactPartType](http://hl7.org/fhir/ValueSet/cited-artifact-part-type)**. To describe the reason for the variant citation, such as version number or subpart specification.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedArtifactPartType {
    /** **article-set**

Part of an article set. Used to distinguish an individual article within an article set where the article set is a base citation. */
    ArticleSet,
    /** **figures**

figures. Denotes specific figure or figures of an article or artifact. */
    Figures,
    /** **lines**

lines. Denotes specific line or lines of an article or artifact. */
    Lines,
    /** **pages**

pages. Denotes specific page or pages of an article or artifact. */
    Pages,
    /** **paragraphs**

paragraphs. Denotes specific paragraph or paragraphs of an article or artifact. */
    Paragraphs,
    /** **sections**

sections. Denotes specific section or sections of an article or artifact. */
    Sections,
    /** **supplement**

Supplement or Appendix. Used to denote a supplementary file, appendix, or additional part that is not a subpart of the primary article. */
    Supplement,
    /** **supplement-subpart**

Supplement or Appendix Subpart. Used to denote a subpart within a supplementary file or appendix. */
    SupplementSubpart,
    /** **tables**

tables. Denotes specific table or tables of an article or artifact. */
    Tables,
}
impl ::core::str::FromStr for CitedArtifactPartType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "article-set" => Ok(Self::ArticleSet),
            "figures" => Ok(Self::Figures),
            "lines" => Ok(Self::Lines),
            "pages" => Ok(Self::Pages),
            "paragraphs" => Ok(Self::Paragraphs),
            "sections" => Ok(Self::Sections),
            "supplement" => Ok(Self::Supplement),
            "supplement-subpart" => Ok(Self::SupplementSubpart),
            "tables" => Ok(Self::Tables),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactPartType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ArticleSet => "article-set",
            Self::Figures => "figures",
            Self::Lines => "lines",
            Self::Pages => "pages",
            Self::Paragraphs => "paragraphs",
            Self::Sections => "sections",
            Self::Supplement => "supplement",
            Self::SupplementSubpart => "supplement-subpart",
            Self::Tables => "tables",
        }
    }
}
impl ::std::fmt::Display for CitedArtifactPartType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ArticleSet => "Part of an article set",
            Self::Figures => "figures",
            Self::Lines => "lines",
            Self::Pages => "pages",
            Self::Paragraphs => "paragraphs",
            Self::Sections => "sections",
            Self::Supplement => "Supplement or Appendix",
            Self::SupplementSubpart => "Supplement or Appendix Subpart",
            Self::Tables => "tables",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CitedArtifactPartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactPartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedArtifactPartType> for Coding {
    fn from(code: CitedArtifactPartType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/cited-artifact-part-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CitedArtifactPartType> for CodeableConcept {
    fn from(code: CitedArtifactPartType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CitedArtifactStatusType](http://hl7.org/fhir/ValueSet/cited-artifact-status-type)**. Cited Artifact Status Type\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedArtifactStatusType {
    /** **accepted**

Accepted. The content that was not published yet has been approved for publication by the publisher and/or editor. */
    Accepted,
    /** **active**

Active. The content is considered complete for its current state by the content creator. */
    Active,
    /** **approved**

Approved. The content has been approved for a state transition, with the focus of approval described in the text associated with this coding. */
    Approved,
    /** **archived**

Archived. The content is retired or considered no longer current but still available as part of the public record. */
    Archived,
    /** **created**

Created. The content was originally constructed or composed. */
    Created,
    /** **draft**

Draft. The content is considered unfinished or incomplete and not representative of the current state desired by the content creator. */
    Draft,
    /** **post-review-pre-published**

Post review pre published. The content is in a state between the review(s) being completed and being published. */
    PostReviewPrePublished,
    /** **pre-review**

Pre review. The content is awaiting assignment and delivery to reviewer(s). */
    PreReview,
    /** **published-early-form**

Published early form. The content is published but future changes to the published version are expected. */
    PublishedEarlyForm,
    /** **published-final-form**

Published final form. The content is published and further changes to the content are not expected. */
    PublishedFinalForm,
    /** **rejected**

Rejected. The content that was not published has been removed from consideration for publishing by a publisher or editor. */
    Rejected,
    /** **retracted**

Retracted. The content that was published is removed from publication and should no longer be considered part of the public record. */
    Retracted,
    /** **submitted**

Submitted. The content was sent to the publisher for consideration of publication. */
    Submitted,
    /** **under-review**

Under review. The content is in a state of being reviewed. */
    UnderReview,
    /** **unknown**

Unknown. The status of the content is not recorded in the metadata. */
    Unknown,
    /** **withdrawn**

Withdrawn. The content that was not published has been removed from consideration for publishing by the submitter. */
    Withdrawn,
}
impl ::core::str::FromStr for CitedArtifactStatusType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "active" => Ok(Self::Active),
            "approved" => Ok(Self::Approved),
            "archived" => Ok(Self::Archived),
            "created" => Ok(Self::Created),
            "draft" => Ok(Self::Draft),
            "post-review-pre-published" => Ok(Self::PostReviewPrePublished),
            "pre-review" => Ok(Self::PreReview),
            "published-early-form" => Ok(Self::PublishedEarlyForm),
            "published-final-form" => Ok(Self::PublishedFinalForm),
            "rejected" => Ok(Self::Rejected),
            "retracted" => Ok(Self::Retracted),
            "submitted" => Ok(Self::Submitted),
            "under-review" => Ok(Self::UnderReview),
            "unknown" => Ok(Self::Unknown),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactStatusType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Active => "active",
            Self::Approved => "approved",
            Self::Archived => "archived",
            Self::Created => "created",
            Self::Draft => "draft",
            Self::PostReviewPrePublished => "post-review-pre-published",
            Self::PreReview => "pre-review",
            Self::PublishedEarlyForm => "published-early-form",
            Self::PublishedFinalForm => "published-final-form",
            Self::Rejected => "rejected",
            Self::Retracted => "retracted",
            Self::Submitted => "submitted",
            Self::UnderReview => "under-review",
            Self::Unknown => "unknown",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Display for CitedArtifactStatusType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Accepted => "Accepted",
            Self::Active => "Active",
            Self::Approved => "Approved",
            Self::Archived => "Archived",
            Self::Created => "Created",
            Self::Draft => "Draft",
            Self::PostReviewPrePublished => "Post review pre published",
            Self::PreReview => "Pre review",
            Self::PublishedEarlyForm => "Published early form",
            Self::PublishedFinalForm => "Published final form",
            Self::Rejected => "Rejected",
            Self::Retracted => "Retracted",
            Self::Submitted => "Submitted",
            Self::UnderReview => "Under review",
            Self::Unknown => "Unknown",
            Self::Withdrawn => "Withdrawn",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CitedArtifactStatusType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactStatusType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedArtifactStatusType> for Coding {
    fn from(code: CitedArtifactStatusType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/cited-artifact-status-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CitedArtifactStatusType> for CodeableConcept {
    fn from(code: CitedArtifactStatusType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CitedMedium](http://hl7.org/fhir/ValueSet/cited-medium)**. NLM codes Internet or Print.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedMedium {
    /** **internet**

Internet. Online publication in a periodic release. Used to match NLM JournalIssue CitedMedium code for online version. */
    Internet,
    /** **internet-without-issue**

Internet without issue. Online publication without any periodic release. Used for article specific publication date which could be the same as or different from journal issue publication date. */
    InternetWithoutIssue,
    /** **offline-digital-storage**

Offline Digital Storage. Publication in a physical device for electronic data storage, organized in issues for periodic release. */
    OfflineDigitalStorage,
    /** **offline-digital-storage-without-issue**

Offline Digital Storage without issue. Publication in a physical device for electronic data storage, without any periodic release. */
    OfflineDigitalStorageWithoutIssue,
    /** **print**

Print. Print publication in a periodic release. Used to match NLM JournalIssue CitedMedium code for print version. */
    Print,
    /** **print-without-issue**

Print without issue. Print publication without any periodic release. */
    PrintWithoutIssue,
}
impl ::core::str::FromStr for CitedMedium {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "internet" => Ok(Self::Internet),
            "internet-without-issue" => Ok(Self::InternetWithoutIssue),
            "offline-digital-storage" => Ok(Self::OfflineDigitalStorage),
            "offline-digital-storage-without-issue" => {
                Ok(Self::OfflineDigitalStorageWithoutIssue)
            }
            "print" => Ok(Self::Print),
            "print-without-issue" => Ok(Self::PrintWithoutIssue),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedMedium {
    fn as_ref(&self) -> &str {
        match self {
            Self::Internet => "internet",
            Self::InternetWithoutIssue => "internet-without-issue",
            Self::OfflineDigitalStorage => "offline-digital-storage",
            Self::OfflineDigitalStorageWithoutIssue => {
                "offline-digital-storage-without-issue"
            }
            Self::Print => "print",
            Self::PrintWithoutIssue => "print-without-issue",
        }
    }
}
impl ::std::fmt::Display for CitedMedium {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Internet => "Internet",
            Self::InternetWithoutIssue => "Internet without issue",
            Self::OfflineDigitalStorage => "Offline Digital Storage",
            Self::OfflineDigitalStorageWithoutIssue => {
                "Offline Digital Storage without issue"
            }
            Self::Print => "Print",
            Self::PrintWithoutIssue => "Print without issue",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CitedMedium {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedMedium {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CitedMedium> for Coding {
    fn from(code: CitedMedium) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/cited-medium".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CitedMedium> for CodeableConcept {
    fn from(code: CitedMedium) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ClaimAdjudicationDecisionCodes](http://hl7.org/fhir/claim-decision)**. This value set provides Claim Adjudication Decision codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClaimAdjudicationDecisionCodes {
    /** **approved**

Approved. The claim, or individual services, are approved as submitted. */
    Approved,
    /** **denied**

Denied. The claim, or individual services, are not approved for any payment. This may also be known as 'rejected'. */
    Denied,
    /** **partial**

Partial. The claim, or individual services, are approved at an amount less than as submitted. */
    Partial,
    /** **pending**

Pending. The adjudication processing is not complete. This may be due to requiring manual review or receipt of additional information. */
    Pending,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ClaimAdjudicationDecisionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "approved" => Ok(Self::Approved),
            "denied" => Ok(Self::Denied),
            "partial" => Ok(Self::Partial),
            "pending" => Ok(Self::Pending),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ClaimAdjudicationDecisionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Approved => "approved",
            Self::Denied => "denied",
            Self::Partial => "partial",
            Self::Pending => "pending",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ClaimAdjudicationDecisionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Approved => "Approved",
            Self::Denied => "Denied",
            Self::Partial => "Partial",
            Self::Pending => "Pending",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ClaimAdjudicationDecisionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimAdjudicationDecisionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClaimAdjudicationDecisionCodes> for Coding {
    fn from(code: ClaimAdjudicationDecisionCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/claim-decision".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ClaimAdjudicationDecisionCodes> for CodeableConcept {
    fn from(code: ClaimAdjudicationDecisionCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ClaimAdjudicationDecisionReasonCodes](http://hl7.org/fhir/claim-decision-reason)**. This value set provides example Claim Adjudication Decision Reason codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClaimAdjudicationDecisionReasonCodes {
    /** **0001**

Not medically necessary. The payer has determined this product, service, or procedure as not medically necessary. */
    N0001,
    /** **0002**

Prior authorization not obtained. Prior authorization was not obtained prior to providing the product, service, or procedure. */
    N0002,
    /** **0003**

Provider out-of-network. This provider is considered out-of-network by the payer for this plan. */
    N0003,
    /** **0004**

Service inconsistent with patient age. The payer has determined this product, service, or procedure is not consistent with the patient's age. */
    N0004,
    /** **0005**

Benefit limits exceeded. The patient or subscriber benefit's have been exceeded. */
    N0005,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ClaimAdjudicationDecisionReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0001" => Ok(Self::N0001),
            "0002" => Ok(Self::N0002),
            "0003" => Ok(Self::N0003),
            "0004" => Ok(Self::N0004),
            "0005" => Ok(Self::N0005),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ClaimAdjudicationDecisionReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0001 => "0001",
            Self::N0002 => "0002",
            Self::N0003 => "0003",
            Self::N0004 => "0004",
            Self::N0005 => "0005",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ClaimAdjudicationDecisionReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N0001 => "Not medically necessary",
            Self::N0002 => "Prior authorization not obtained",
            Self::N0003 => "Provider out-of-network",
            Self::N0004 => "Service inconsistent with patient age",
            Self::N0005 => "Benefit limits exceeded",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ClaimAdjudicationDecisionReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimAdjudicationDecisionReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClaimAdjudicationDecisionReasonCodes> for Coding {
    fn from(code: ClaimAdjudicationDecisionReasonCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/claim-decision-reason".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ClaimAdjudicationDecisionReasonCodes> for CodeableConcept {
    fn from(code: ClaimAdjudicationDecisionReasonCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ClaimProcessingCodes](http://hl7.org/fhir/ValueSet/eligibility-outcome)**. This value set includes Claim Processing Outcome codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ClaimProcessingCodes {
    /** **complete**

Processing Complete. The processing has completed without errors */
    Complete,
    /** **error**

Error. One or more errors have been detected in the Claim */
    Error,
    /** **partial**

Partial Processing. No errors have been detected in the Claim and some of the adjudication has been performed. */
    Partial,
    /** **queued**

Queued. The Claim/Pre-authorization/Pre-determination has been received but processing has not begun. */
    Queued,
}
impl ::core::str::FromStr for ClaimProcessingCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "error" => Ok(Self::Error),
            "partial" => Ok(Self::Partial),
            "queued" => Ok(Self::Queued),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClaimProcessingCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Error => "error",
            Self::Partial => "partial",
            Self::Queued => "queued",
        }
    }
}
impl ::std::fmt::Display for ClaimProcessingCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Complete => "Processing Complete",
            Self::Error => "Error",
            Self::Partial => "Partial Processing",
            Self::Queued => "Queued",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ClaimProcessingCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimProcessingCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClaimProcessingCodes> for Coding {
    fn from(code: ClaimProcessingCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/eligibility-outcome".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ClaimProcessingCodes> for CodeableConcept {
    fn from(code: ClaimProcessingCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ClaimProcessingOutcomeCodes](http://hl7.org/fhir/claim-outcome)**. This value set includes Claim Processing Outcome codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClaimProcessingOutcomeCodes {
    /** **complete**

Processing Complete. The processing has completed without errors */
    Complete,
    /** **error**

Error. One or more errors have been detected in the Claim */
    Error,
    /** **partial**

Partial Processing. No errors have been detected in the Claim and some of the adjudication has been performed. */
    Partial,
    /** **queued**

Queued. The Claim/Pre-authorization/Pre-determination has been received but processing has not begun. */
    Queued,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ClaimProcessingOutcomeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "error" => Ok(Self::Error),
            "partial" => Ok(Self::Partial),
            "queued" => Ok(Self::Queued),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ClaimProcessingOutcomeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Error => "error",
            Self::Partial => "partial",
            Self::Queued => "queued",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ClaimProcessingOutcomeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Complete => "Processing Complete",
            Self::Error => "Error",
            Self::Partial => "Partial Processing",
            Self::Queued => "Queued",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ClaimProcessingOutcomeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimProcessingOutcomeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClaimProcessingOutcomeCodes> for Coding {
    fn from(code: ClaimProcessingOutcomeCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/claim-outcome".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ClaimProcessingOutcomeCodes> for CodeableConcept {
    fn from(code: ClaimProcessingOutcomeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ClinicalUseDefinitionCategory](http://hl7.org/fhir/ValueSet/clinical-use-definition-category)**. ClinicalUseDefinitionCategory\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ClinicalUseDefinitionCategory {
    /** **DriveAndMachines**

Effects on Ability to Drive and Use Machines. */
    DriveAndMachines,
    /** **Overdose**

Overdose. */
    Overdose,
    /** **Pregnancy**

Pregnancy and Lactation. */
    Pregnancy,
}
impl ::core::str::FromStr for ClinicalUseDefinitionCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "DriveAndMachines" => Ok(Self::DriveAndMachines),
            "Overdose" => Ok(Self::Overdose),
            "Pregnancy" => Ok(Self::Pregnancy),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClinicalUseDefinitionCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::DriveAndMachines => "DriveAndMachines",
            Self::Overdose => "Overdose",
            Self::Pregnancy => "Pregnancy",
        }
    }
}
impl ::std::fmt::Display for ClinicalUseDefinitionCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::DriveAndMachines => "Effects on Ability to Drive and Use Machines",
            Self::Overdose => "Overdose",
            Self::Pregnancy => "Pregnancy and Lactation",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ClinicalUseDefinitionCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClinicalUseDefinitionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClinicalUseDefinitionCategory> for Coding {
    fn from(code: ClinicalUseDefinitionCategory) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/clinical-use-definition-category"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ClinicalUseDefinitionCategory> for CodeableConcept {
    fn from(code: ClinicalUseDefinitionCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ClinicalUseDefinitionType](http://hl7.org/fhir/ValueSet/clinical-use-definition-type)**. Overall defining type of this clinical use definition.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ClinicalUseDefinitionType {
    /** **contraindication**

Contraindication. A reason for not giving the medication. */
    Contraindication,
    /** **indication**

Indication. A reason for giving the medication. */
    Indication,
    /** **interaction**

Interaction. Interactions between the medication and other substances. */
    Interaction,
    /** **undesirable-effect**

Undesirable Effect. Side effects or adverse effects associated with the medication. */
    UndesirableEffect,
    /** **warning**

Warning. A general warning or issue that is not specifically one of the other types. */
    Warning,
}
impl ::core::str::FromStr for ClinicalUseDefinitionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contraindication" => Ok(Self::Contraindication),
            "indication" => Ok(Self::Indication),
            "interaction" => Ok(Self::Interaction),
            "undesirable-effect" => Ok(Self::UndesirableEffect),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClinicalUseDefinitionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contraindication => "contraindication",
            Self::Indication => "indication",
            Self::Interaction => "interaction",
            Self::UndesirableEffect => "undesirable-effect",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Display for ClinicalUseDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Contraindication => "Contraindication",
            Self::Indication => "Indication",
            Self::Interaction => "Interaction",
            Self::UndesirableEffect => "Undesirable Effect",
            Self::Warning => "Warning",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ClinicalUseDefinitionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClinicalUseDefinitionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ClinicalUseDefinitionType> for Coding {
    fn from(code: ClinicalUseDefinitionType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/clinical-use-definition-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ClinicalUseDefinitionType> for CodeableConcept {
    fn from(code: ClinicalUseDefinitionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CodeSearchSupport](http://hl7.org/fhir/ValueSet/code-search-support)**. The degree to which the server supports the code search parameter on ValueSet, if it is supported.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CodeSearchSupport {
    /** **in-compose**

In Compose. The search for code on ValueSet returns ValueSet resources where the code is included in the extensional definition of the ValueSet. */
    InCompose,
    /** **in-compose-or-expansion**

In Compose Or Expansion. The search for code on ValueSet returns ValueSet resources where the code is included in the extensional definition or contained in the ValueSet expansion. */
    InComposeOrExpansion,
    /** **in-expansion**

In Expansion. The search for code on ValueSet returns ValueSet resources where the code is contained in the  ValueSet expansion. */
    InExpansion,
}
impl ::core::str::FromStr for CodeSearchSupport {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "in-compose" => Ok(Self::InCompose),
            "in-compose-or-expansion" => Ok(Self::InComposeOrExpansion),
            "in-expansion" => Ok(Self::InExpansion),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSearchSupport {
    fn as_ref(&self) -> &str {
        match self {
            Self::InCompose => "in-compose",
            Self::InComposeOrExpansion => "in-compose-or-expansion",
            Self::InExpansion => "in-expansion",
        }
    }
}
impl ::std::fmt::Display for CodeSearchSupport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::InCompose => "In Compose",
            Self::InComposeOrExpansion => "In Compose Or Expansion",
            Self::InExpansion => "In Expansion",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CodeSearchSupport {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSearchSupport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CodeSearchSupport> for Coding {
    fn from(code: CodeSearchSupport) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/code-search-support".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CodeSearchSupport> for CodeableConcept {
    fn from(code: CodeSearchSupport) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CodeSystemContentMode](http://hl7.org/fhir/ValueSet/codesystem-content-mode)**. The extent of the content of the code system (the concepts and codes it defines) are represented in a code system resource.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CodeSystemContentMode {
    /** **complete**

Complete. All the concepts defined by the code system are included in the code system resource. */
    Complete,
    /** **example**

Example. A subset of the valid externally defined concepts are included in the code system resource. There is no specific purpose or documented intent other than for illustrative purposes. */
    Example,
    /** **fragment**

Fragment. A subset of the code system concepts are included in the code system resource. This is a curated subset released for a specific purpose under the governance of the code system steward, and that the intent, bounds and consequences of the fragmentation are clearly defined in the fragment or the code system documentation. Fragments are also known as partitions. */
    Fragment,
    /** **not-present**

Not Present. None of the concepts defined by the code system are included in the code system resource. */
    NotPresent,
    /** **supplement**

Supplement. The resource doesn't define any new concepts; it just provides additional designations and properties to another code system. */
    Supplement,
}
impl ::core::str::FromStr for CodeSystemContentMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "example" => Ok(Self::Example),
            "fragment" => Ok(Self::Fragment),
            "not-present" => Ok(Self::NotPresent),
            "supplement" => Ok(Self::Supplement),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSystemContentMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Example => "example",
            Self::Fragment => "fragment",
            Self::NotPresent => "not-present",
            Self::Supplement => "supplement",
        }
    }
}
impl ::std::fmt::Display for CodeSystemContentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Complete => "Complete",
            Self::Example => "Example",
            Self::Fragment => "Fragment",
            Self::NotPresent => "Not Present",
            Self::Supplement => "Supplement",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CodeSystemContentMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSystemContentMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CodeSystemContentMode> for Coding {
    fn from(code: CodeSystemContentMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/codesystem-content-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CodeSystemContentMode> for CodeableConcept {
    fn from(code: CodeSystemContentMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CodeSystemHierarchyMeaning](http://hl7.org/fhir/ValueSet/codesystem-hierarchy-meaning)**. The meaning of the hierarchy of concepts in a code system.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CodeSystemHierarchyMeaning {
    /** **classified-with**

Classified With. Child concepts in the hierarchy may have only one parent, and there is a presumption that the code system is a "closed world" meaning all things must be in the hierarchy. This results in concepts such as "not otherwise classified.". */
    ClassifiedWith,
    /** **grouped-by**

Grouped By. No particular relationship between the concepts can be assumed, except what can be determined by inspection of the definitions of the elements (possible reasons to use this: importing from a source where this is not defined, or where various parts of the hierarchy have different meanings). */
    GroupedBy,
    /** **is-a**

Is-A. A hierarchy where the child concepts have an IS-A relationship with the parents - that is, all the properties of the parent are also true for its child concepts. Not that is-a is a property of the concepts, so additional subsumption relationships may be defined using properties. */
    IsA,
    /** **part-of**

Part Of. Child elements list the individual parts of a composite whole (e.g. body site). */
    PartOf,
}
impl ::core::str::FromStr for CodeSystemHierarchyMeaning {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "classified-with" => Ok(Self::ClassifiedWith),
            "grouped-by" => Ok(Self::GroupedBy),
            "is-a" => Ok(Self::IsA),
            "part-of" => Ok(Self::PartOf),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSystemHierarchyMeaning {
    fn as_ref(&self) -> &str {
        match self {
            Self::ClassifiedWith => "classified-with",
            Self::GroupedBy => "grouped-by",
            Self::IsA => "is-a",
            Self::PartOf => "part-of",
        }
    }
}
impl ::std::fmt::Display for CodeSystemHierarchyMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ClassifiedWith => "Classified With",
            Self::GroupedBy => "Grouped By",
            Self::IsA => "Is-A",
            Self::PartOf => "Part Of",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CodeSystemHierarchyMeaning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSystemHierarchyMeaning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CodeSystemHierarchyMeaning> for Coding {
    fn from(code: CodeSystemHierarchyMeaning) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/codesystem-hierarchy-meaning".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CodeSystemHierarchyMeaning> for CodeableConcept {
    fn from(code: CodeSystemHierarchyMeaning) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ColorCodes](http://hl7.org/fhir/color-names)**. This code system represents that named RGB colors found in the [CSS4 specification](https://www.w3.org/TR/css-color-4/). The names are not case sensitive and different cases are encountered in common use (e.g. AliceBlue vs aliceblue.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ColorCodes {
    /** **aliceblue**

aliceblue. */
    Aliceblue,
    /** **antiquewhite**

antiquewhite. */
    Antiquewhite,
    /** **aqua**

aqua. */
    Aqua,
    /** **aquamarine**

aquamarine. */
    Aquamarine,
    /** **azure**

azure. */
    Azure,
    /** **beige**

beige. */
    Beige,
    /** **bisque**

bisque. */
    Bisque,
    /** **black**

black. */
    Black,
    /** **blanchedalmond**

blanchedalmond. */
    Blanchedalmond,
    /** **blue**

blue. */
    Blue,
    /** **blueviolet**

blueviolet. */
    Blueviolet,
    /** **brown**

brown. */
    Brown,
    /** **burlywood**

burlywood. */
    Burlywood,
    /** **cadetblue**

cadetblue. */
    Cadetblue,
    /** **chartreuse**

chartreuse. */
    Chartreuse,
    /** **chocolate**

chocolate. */
    Chocolate,
    /** **coral**

coral. */
    Coral,
    /** **cornflowerblue**

cornflowerblue. */
    Cornflowerblue,
    /** **cornsilk**

cornsilk. */
    Cornsilk,
    /** **crimson**

crimson. */
    Crimson,
    /** **cyan**

cyan. */
    Cyan,
    /** **darkblue**

darkblue. */
    Darkblue,
    /** **darkcyan**

darkcyan. */
    Darkcyan,
    /** **darkgoldenrod**

darkgoldenrod. */
    Darkgoldenrod,
    /** **darkgray**

darkgray. */
    Darkgray,
    /** **darkgreen**

darkgreen. */
    Darkgreen,
    /** **darkgrey**

darkgrey. */
    Darkgrey,
    /** **darkkhaki**

darkkhaki. */
    Darkkhaki,
    /** **darkmagenta**

darkmagenta. */
    Darkmagenta,
    /** **darkolivegreen**

darkolivegreen. */
    Darkolivegreen,
    /** **darkorange**

darkorange. */
    Darkorange,
    /** **darkorchid**

darkorchid. */
    Darkorchid,
    /** **darkred**

darkred. */
    Darkred,
    /** **darksalmon**

darksalmon. */
    Darksalmon,
    /** **darkseagreen**

darkseagreen. */
    Darkseagreen,
    /** **darkslateblue**

darkslateblue. */
    Darkslateblue,
    /** **darkslategray**

darkslategray. */
    Darkslategray,
    /** **darkslategrey**

darkslategrey. */
    Darkslategrey,
    /** **darkturquoise**

darkturquoise. */
    Darkturquoise,
    /** **darkviolet**

darkviolet. */
    Darkviolet,
    /** **deeppink**

deeppink. */
    Deeppink,
    /** **deepskyblue**

deepskyblue. */
    Deepskyblue,
    /** **dimgray**

dimgray. */
    Dimgray,
    /** **dimgrey**

dimgrey. */
    Dimgrey,
    /** **dodgerblue**

dodgerblue. */
    Dodgerblue,
    /** **firebrick**

firebrick. */
    Firebrick,
    /** **floralwhite**

floralwhite. */
    Floralwhite,
    /** **forestgreen**

forestgreen. */
    Forestgreen,
    /** **fuchsia**

fuchsia. */
    Fuchsia,
    /** **gainsboro**

gainsboro. */
    Gainsboro,
    /** **ghostwhite**

ghostwhite. */
    Ghostwhite,
    /** **gold**

gold. */
    Gold,
    /** **goldenrod**

goldenrod. */
    Goldenrod,
    /** **gray**

gray. */
    Gray,
    /** **green**

green. */
    Green,
    /** **greenyellow**

greenyellow. */
    Greenyellow,
    /** **grey**

grey. */
    Grey,
    /** **honeydew**

honeydew. */
    Honeydew,
    /** **hotpink**

hotpink. */
    Hotpink,
    /** **indianred**

indianred. */
    Indianred,
    /** **indigo**

indigo. */
    Indigo,
    /** **ivory**

ivory. */
    Ivory,
    /** **khaki**

khaki. */
    Khaki,
    /** **lavender**

lavender. */
    Lavender,
    /** **lavenderblush**

lavenderblush. */
    Lavenderblush,
    /** **lawngreen**

lawngreen. */
    Lawngreen,
    /** **lemonchiffon**

lemonchiffon. */
    Lemonchiffon,
    /** **lightblue**

lightblue. */
    Lightblue,
    /** **lightcoral**

lightcoral. */
    Lightcoral,
    /** **lightcyan**

lightcyan. */
    Lightcyan,
    /** **lightgoldenrodyellow**

lightgoldenrodyellow. */
    Lightgoldenrodyellow,
    /** **lightgray**

lightgray. */
    Lightgray,
    /** **lightgreen**

lightgreen. */
    Lightgreen,
    /** **lightgrey**

lightgrey. */
    Lightgrey,
    /** **lightpink**

lightpink. */
    Lightpink,
    /** **lightsalmon**

lightsalmon. */
    Lightsalmon,
    /** **lightseagreen**

lightseagreen. */
    Lightseagreen,
    /** **lightskyblue**

lightskyblue. */
    Lightskyblue,
    /** **lightslategray**

lightslategray. */
    Lightslategray,
    /** **lightslategrey**

lightslategrey. */
    Lightslategrey,
    /** **lightsteelblue**

lightsteelblue. */
    Lightsteelblue,
    /** **lightyellow**

lightyellow. */
    Lightyellow,
    /** **lime**

lime. */
    Lime,
    /** **limegreen**

limegreen. */
    Limegreen,
    /** **linen**

linen. */
    Linen,
    /** **magenta**

magenta. */
    Magenta,
    /** **maroon**

maroon. */
    Maroon,
    /** **mediumaquamarine**

mediumaquamarine. */
    Mediumaquamarine,
    /** **mediumblue**

mediumblue. */
    Mediumblue,
    /** **mediumorchid**

mediumorchid. */
    Mediumorchid,
    /** **mediumpurple**

mediumpurple. */
    Mediumpurple,
    /** **mediumseagreen**

mediumseagreen. */
    Mediumseagreen,
    /** **mediumslateblue**

mediumslateblue. */
    Mediumslateblue,
    /** **mediumspringgreen**

mediumspringgreen. */
    Mediumspringgreen,
    /** **mediumturquoise**

mediumturquoise. */
    Mediumturquoise,
    /** **mediumvioletred**

mediumvioletred. */
    Mediumvioletred,
    /** **midnightblue**

midnightblue. */
    Midnightblue,
    /** **mintcream**

mintcream. */
    Mintcream,
    /** **mistyrose**

mistyrose. */
    Mistyrose,
    /** **moccasin**

moccasin. */
    Moccasin,
    /** **navajowhite**

navajowhite. */
    Navajowhite,
    /** **navy**

navy. */
    Navy,
    /** **oldlace**

oldlace. */
    Oldlace,
    /** **olive**

olive. */
    Olive,
    /** **olivedrab**

olivedrab. */
    Olivedrab,
    /** **orange**

orange. */
    Orange,
    /** **orangered**

orangered. */
    Orangered,
    /** **orchid**

orchid. */
    Orchid,
    /** **palegoldenrod**

palegoldenrod. */
    Palegoldenrod,
    /** **palegreen**

palegreen. */
    Palegreen,
    /** **paleturquoise**

paleturquoise. */
    Paleturquoise,
    /** **palevioletred**

palevioletred. */
    Palevioletred,
    /** **papayawhip**

papayawhip. */
    Papayawhip,
    /** **peachpuff**

peachpuff. */
    Peachpuff,
    /** **peru**

peru. */
    Peru,
    /** **pink**

pink. */
    Pink,
    /** **plum**

plum. */
    Plum,
    /** **powderblue**

powderblue. */
    Powderblue,
    /** **purple**

purple. */
    Purple,
    /** **rebeccapurple**

rebeccapurple. */
    Rebeccapurple,
    /** **red**

red. */
    Red,
    /** **rosybrown**

rosybrown. */
    Rosybrown,
    /** **royalblue**

royalblue. */
    Royalblue,
    /** **saddlebrown**

saddlebrown. */
    Saddlebrown,
    /** **salmon**

salmon. */
    Salmon,
    /** **sandybrown**

sandybrown. */
    Sandybrown,
    /** **seagreen**

seagreen. */
    Seagreen,
    /** **seashell**

seashell. */
    Seashell,
    /** **sienna**

sienna. */
    Sienna,
    /** **silver**

silver. */
    Silver,
    /** **skyblue**

skyblue. */
    Skyblue,
    /** **slateblue**

slateblue. */
    Slateblue,
    /** **slategray**

slategray. */
    Slategray,
    /** **slategrey**

slategrey. */
    Slategrey,
    /** **snow**

snow. */
    Snow,
    /** **springgreen**

springgreen. */
    Springgreen,
    /** **steelblue**

steelblue. */
    Steelblue,
    /** **tan**

tan. */
    Tan,
    /** **teal**

teal. */
    Teal,
    /** **thistle**

thistle. */
    Thistle,
    /** **tomato**

tomato. */
    Tomato,
    /** **turquoise**

turquoise. */
    Turquoise,
    /** **violet**

violet. */
    Violet,
    /** **wheat**

wheat. */
    Wheat,
    /** **white**

white. */
    White,
    /** **whitesmoke**

whitesmoke. */
    Whitesmoke,
    /** **yellow**

yellow. */
    Yellow,
    /** **yellowgreen**

yellowgreen. */
    Yellowgreen,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ColorCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "aliceblue" => Ok(Self::Aliceblue),
            "antiquewhite" => Ok(Self::Antiquewhite),
            "aqua" => Ok(Self::Aqua),
            "aquamarine" => Ok(Self::Aquamarine),
            "azure" => Ok(Self::Azure),
            "beige" => Ok(Self::Beige),
            "bisque" => Ok(Self::Bisque),
            "black" => Ok(Self::Black),
            "blanchedalmond" => Ok(Self::Blanchedalmond),
            "blue" => Ok(Self::Blue),
            "blueviolet" => Ok(Self::Blueviolet),
            "brown" => Ok(Self::Brown),
            "burlywood" => Ok(Self::Burlywood),
            "cadetblue" => Ok(Self::Cadetblue),
            "chartreuse" => Ok(Self::Chartreuse),
            "chocolate" => Ok(Self::Chocolate),
            "coral" => Ok(Self::Coral),
            "cornflowerblue" => Ok(Self::Cornflowerblue),
            "cornsilk" => Ok(Self::Cornsilk),
            "crimson" => Ok(Self::Crimson),
            "cyan" => Ok(Self::Cyan),
            "darkblue" => Ok(Self::Darkblue),
            "darkcyan" => Ok(Self::Darkcyan),
            "darkgoldenrod" => Ok(Self::Darkgoldenrod),
            "darkgray" => Ok(Self::Darkgray),
            "darkgreen" => Ok(Self::Darkgreen),
            "darkgrey" => Ok(Self::Darkgrey),
            "darkkhaki" => Ok(Self::Darkkhaki),
            "darkmagenta" => Ok(Self::Darkmagenta),
            "darkolivegreen" => Ok(Self::Darkolivegreen),
            "darkorange" => Ok(Self::Darkorange),
            "darkorchid" => Ok(Self::Darkorchid),
            "darkred" => Ok(Self::Darkred),
            "darksalmon" => Ok(Self::Darksalmon),
            "darkseagreen" => Ok(Self::Darkseagreen),
            "darkslateblue" => Ok(Self::Darkslateblue),
            "darkslategray" => Ok(Self::Darkslategray),
            "darkslategrey" => Ok(Self::Darkslategrey),
            "darkturquoise" => Ok(Self::Darkturquoise),
            "darkviolet" => Ok(Self::Darkviolet),
            "deeppink" => Ok(Self::Deeppink),
            "deepskyblue" => Ok(Self::Deepskyblue),
            "dimgray" => Ok(Self::Dimgray),
            "dimgrey" => Ok(Self::Dimgrey),
            "dodgerblue" => Ok(Self::Dodgerblue),
            "firebrick" => Ok(Self::Firebrick),
            "floralwhite" => Ok(Self::Floralwhite),
            "forestgreen" => Ok(Self::Forestgreen),
            "fuchsia" => Ok(Self::Fuchsia),
            "gainsboro" => Ok(Self::Gainsboro),
            "ghostwhite" => Ok(Self::Ghostwhite),
            "gold" => Ok(Self::Gold),
            "goldenrod" => Ok(Self::Goldenrod),
            "gray" => Ok(Self::Gray),
            "green" => Ok(Self::Green),
            "greenyellow" => Ok(Self::Greenyellow),
            "grey" => Ok(Self::Grey),
            "honeydew" => Ok(Self::Honeydew),
            "hotpink" => Ok(Self::Hotpink),
            "indianred" => Ok(Self::Indianred),
            "indigo" => Ok(Self::Indigo),
            "ivory" => Ok(Self::Ivory),
            "khaki" => Ok(Self::Khaki),
            "lavender" => Ok(Self::Lavender),
            "lavenderblush" => Ok(Self::Lavenderblush),
            "lawngreen" => Ok(Self::Lawngreen),
            "lemonchiffon" => Ok(Self::Lemonchiffon),
            "lightblue" => Ok(Self::Lightblue),
            "lightcoral" => Ok(Self::Lightcoral),
            "lightcyan" => Ok(Self::Lightcyan),
            "lightgoldenrodyellow" => Ok(Self::Lightgoldenrodyellow),
            "lightgray" => Ok(Self::Lightgray),
            "lightgreen" => Ok(Self::Lightgreen),
            "lightgrey" => Ok(Self::Lightgrey),
            "lightpink" => Ok(Self::Lightpink),
            "lightsalmon" => Ok(Self::Lightsalmon),
            "lightseagreen" => Ok(Self::Lightseagreen),
            "lightskyblue" => Ok(Self::Lightskyblue),
            "lightslategray" => Ok(Self::Lightslategray),
            "lightslategrey" => Ok(Self::Lightslategrey),
            "lightsteelblue" => Ok(Self::Lightsteelblue),
            "lightyellow" => Ok(Self::Lightyellow),
            "lime" => Ok(Self::Lime),
            "limegreen" => Ok(Self::Limegreen),
            "linen" => Ok(Self::Linen),
            "magenta" => Ok(Self::Magenta),
            "maroon" => Ok(Self::Maroon),
            "mediumaquamarine" => Ok(Self::Mediumaquamarine),
            "mediumblue" => Ok(Self::Mediumblue),
            "mediumorchid" => Ok(Self::Mediumorchid),
            "mediumpurple" => Ok(Self::Mediumpurple),
            "mediumseagreen" => Ok(Self::Mediumseagreen),
            "mediumslateblue" => Ok(Self::Mediumslateblue),
            "mediumspringgreen" => Ok(Self::Mediumspringgreen),
            "mediumturquoise" => Ok(Self::Mediumturquoise),
            "mediumvioletred" => Ok(Self::Mediumvioletred),
            "midnightblue" => Ok(Self::Midnightblue),
            "mintcream" => Ok(Self::Mintcream),
            "mistyrose" => Ok(Self::Mistyrose),
            "moccasin" => Ok(Self::Moccasin),
            "navajowhite" => Ok(Self::Navajowhite),
            "navy" => Ok(Self::Navy),
            "oldlace" => Ok(Self::Oldlace),
            "olive" => Ok(Self::Olive),
            "olivedrab" => Ok(Self::Olivedrab),
            "orange" => Ok(Self::Orange),
            "orangered" => Ok(Self::Orangered),
            "orchid" => Ok(Self::Orchid),
            "palegoldenrod" => Ok(Self::Palegoldenrod),
            "palegreen" => Ok(Self::Palegreen),
            "paleturquoise" => Ok(Self::Paleturquoise),
            "palevioletred" => Ok(Self::Palevioletred),
            "papayawhip" => Ok(Self::Papayawhip),
            "peachpuff" => Ok(Self::Peachpuff),
            "peru" => Ok(Self::Peru),
            "pink" => Ok(Self::Pink),
            "plum" => Ok(Self::Plum),
            "powderblue" => Ok(Self::Powderblue),
            "purple" => Ok(Self::Purple),
            "rebeccapurple" => Ok(Self::Rebeccapurple),
            "red" => Ok(Self::Red),
            "rosybrown" => Ok(Self::Rosybrown),
            "royalblue" => Ok(Self::Royalblue),
            "saddlebrown" => Ok(Self::Saddlebrown),
            "salmon" => Ok(Self::Salmon),
            "sandybrown" => Ok(Self::Sandybrown),
            "seagreen" => Ok(Self::Seagreen),
            "seashell" => Ok(Self::Seashell),
            "sienna" => Ok(Self::Sienna),
            "silver" => Ok(Self::Silver),
            "skyblue" => Ok(Self::Skyblue),
            "slateblue" => Ok(Self::Slateblue),
            "slategray" => Ok(Self::Slategray),
            "slategrey" => Ok(Self::Slategrey),
            "snow" => Ok(Self::Snow),
            "springgreen" => Ok(Self::Springgreen),
            "steelblue" => Ok(Self::Steelblue),
            "tan" => Ok(Self::Tan),
            "teal" => Ok(Self::Teal),
            "thistle" => Ok(Self::Thistle),
            "tomato" => Ok(Self::Tomato),
            "turquoise" => Ok(Self::Turquoise),
            "violet" => Ok(Self::Violet),
            "wheat" => Ok(Self::Wheat),
            "white" => Ok(Self::White),
            "whitesmoke" => Ok(Self::Whitesmoke),
            "yellow" => Ok(Self::Yellow),
            "yellowgreen" => Ok(Self::Yellowgreen),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ColorCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aliceblue => "aliceblue",
            Self::Antiquewhite => "antiquewhite",
            Self::Aqua => "aqua",
            Self::Aquamarine => "aquamarine",
            Self::Azure => "azure",
            Self::Beige => "beige",
            Self::Bisque => "bisque",
            Self::Black => "black",
            Self::Blanchedalmond => "blanchedalmond",
            Self::Blue => "blue",
            Self::Blueviolet => "blueviolet",
            Self::Brown => "brown",
            Self::Burlywood => "burlywood",
            Self::Cadetblue => "cadetblue",
            Self::Chartreuse => "chartreuse",
            Self::Chocolate => "chocolate",
            Self::Coral => "coral",
            Self::Cornflowerblue => "cornflowerblue",
            Self::Cornsilk => "cornsilk",
            Self::Crimson => "crimson",
            Self::Cyan => "cyan",
            Self::Darkblue => "darkblue",
            Self::Darkcyan => "darkcyan",
            Self::Darkgoldenrod => "darkgoldenrod",
            Self::Darkgray => "darkgray",
            Self::Darkgreen => "darkgreen",
            Self::Darkgrey => "darkgrey",
            Self::Darkkhaki => "darkkhaki",
            Self::Darkmagenta => "darkmagenta",
            Self::Darkolivegreen => "darkolivegreen",
            Self::Darkorange => "darkorange",
            Self::Darkorchid => "darkorchid",
            Self::Darkred => "darkred",
            Self::Darksalmon => "darksalmon",
            Self::Darkseagreen => "darkseagreen",
            Self::Darkslateblue => "darkslateblue",
            Self::Darkslategray => "darkslategray",
            Self::Darkslategrey => "darkslategrey",
            Self::Darkturquoise => "darkturquoise",
            Self::Darkviolet => "darkviolet",
            Self::Deeppink => "deeppink",
            Self::Deepskyblue => "deepskyblue",
            Self::Dimgray => "dimgray",
            Self::Dimgrey => "dimgrey",
            Self::Dodgerblue => "dodgerblue",
            Self::Firebrick => "firebrick",
            Self::Floralwhite => "floralwhite",
            Self::Forestgreen => "forestgreen",
            Self::Fuchsia => "fuchsia",
            Self::Gainsboro => "gainsboro",
            Self::Ghostwhite => "ghostwhite",
            Self::Gold => "gold",
            Self::Goldenrod => "goldenrod",
            Self::Gray => "gray",
            Self::Green => "green",
            Self::Greenyellow => "greenyellow",
            Self::Grey => "grey",
            Self::Honeydew => "honeydew",
            Self::Hotpink => "hotpink",
            Self::Indianred => "indianred",
            Self::Indigo => "indigo",
            Self::Ivory => "ivory",
            Self::Khaki => "khaki",
            Self::Lavender => "lavender",
            Self::Lavenderblush => "lavenderblush",
            Self::Lawngreen => "lawngreen",
            Self::Lemonchiffon => "lemonchiffon",
            Self::Lightblue => "lightblue",
            Self::Lightcoral => "lightcoral",
            Self::Lightcyan => "lightcyan",
            Self::Lightgoldenrodyellow => "lightgoldenrodyellow",
            Self::Lightgray => "lightgray",
            Self::Lightgreen => "lightgreen",
            Self::Lightgrey => "lightgrey",
            Self::Lightpink => "lightpink",
            Self::Lightsalmon => "lightsalmon",
            Self::Lightseagreen => "lightseagreen",
            Self::Lightskyblue => "lightskyblue",
            Self::Lightslategray => "lightslategray",
            Self::Lightslategrey => "lightslategrey",
            Self::Lightsteelblue => "lightsteelblue",
            Self::Lightyellow => "lightyellow",
            Self::Lime => "lime",
            Self::Limegreen => "limegreen",
            Self::Linen => "linen",
            Self::Magenta => "magenta",
            Self::Maroon => "maroon",
            Self::Mediumaquamarine => "mediumaquamarine",
            Self::Mediumblue => "mediumblue",
            Self::Mediumorchid => "mediumorchid",
            Self::Mediumpurple => "mediumpurple",
            Self::Mediumseagreen => "mediumseagreen",
            Self::Mediumslateblue => "mediumslateblue",
            Self::Mediumspringgreen => "mediumspringgreen",
            Self::Mediumturquoise => "mediumturquoise",
            Self::Mediumvioletred => "mediumvioletred",
            Self::Midnightblue => "midnightblue",
            Self::Mintcream => "mintcream",
            Self::Mistyrose => "mistyrose",
            Self::Moccasin => "moccasin",
            Self::Navajowhite => "navajowhite",
            Self::Navy => "navy",
            Self::Oldlace => "oldlace",
            Self::Olive => "olive",
            Self::Olivedrab => "olivedrab",
            Self::Orange => "orange",
            Self::Orangered => "orangered",
            Self::Orchid => "orchid",
            Self::Palegoldenrod => "palegoldenrod",
            Self::Palegreen => "palegreen",
            Self::Paleturquoise => "paleturquoise",
            Self::Palevioletred => "palevioletred",
            Self::Papayawhip => "papayawhip",
            Self::Peachpuff => "peachpuff",
            Self::Peru => "peru",
            Self::Pink => "pink",
            Self::Plum => "plum",
            Self::Powderblue => "powderblue",
            Self::Purple => "purple",
            Self::Rebeccapurple => "rebeccapurple",
            Self::Red => "red",
            Self::Rosybrown => "rosybrown",
            Self::Royalblue => "royalblue",
            Self::Saddlebrown => "saddlebrown",
            Self::Salmon => "salmon",
            Self::Sandybrown => "sandybrown",
            Self::Seagreen => "seagreen",
            Self::Seashell => "seashell",
            Self::Sienna => "sienna",
            Self::Silver => "silver",
            Self::Skyblue => "skyblue",
            Self::Slateblue => "slateblue",
            Self::Slategray => "slategray",
            Self::Slategrey => "slategrey",
            Self::Snow => "snow",
            Self::Springgreen => "springgreen",
            Self::Steelblue => "steelblue",
            Self::Tan => "tan",
            Self::Teal => "teal",
            Self::Thistle => "thistle",
            Self::Tomato => "tomato",
            Self::Turquoise => "turquoise",
            Self::Violet => "violet",
            Self::Wheat => "wheat",
            Self::White => "white",
            Self::Whitesmoke => "whitesmoke",
            Self::Yellow => "yellow",
            Self::Yellowgreen => "yellowgreen",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ColorCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Aliceblue => "aliceblue",
            Self::Antiquewhite => "antiquewhite",
            Self::Aqua => "aqua",
            Self::Aquamarine => "aquamarine",
            Self::Azure => "azure",
            Self::Beige => "beige",
            Self::Bisque => "bisque",
            Self::Black => "black",
            Self::Blanchedalmond => "blanchedalmond",
            Self::Blue => "blue",
            Self::Blueviolet => "blueviolet",
            Self::Brown => "brown",
            Self::Burlywood => "burlywood",
            Self::Cadetblue => "cadetblue",
            Self::Chartreuse => "chartreuse",
            Self::Chocolate => "chocolate",
            Self::Coral => "coral",
            Self::Cornflowerblue => "cornflowerblue",
            Self::Cornsilk => "cornsilk",
            Self::Crimson => "crimson",
            Self::Cyan => "cyan",
            Self::Darkblue => "darkblue",
            Self::Darkcyan => "darkcyan",
            Self::Darkgoldenrod => "darkgoldenrod",
            Self::Darkgray => "darkgray",
            Self::Darkgreen => "darkgreen",
            Self::Darkgrey => "darkgrey",
            Self::Darkkhaki => "darkkhaki",
            Self::Darkmagenta => "darkmagenta",
            Self::Darkolivegreen => "darkolivegreen",
            Self::Darkorange => "darkorange",
            Self::Darkorchid => "darkorchid",
            Self::Darkred => "darkred",
            Self::Darksalmon => "darksalmon",
            Self::Darkseagreen => "darkseagreen",
            Self::Darkslateblue => "darkslateblue",
            Self::Darkslategray => "darkslategray",
            Self::Darkslategrey => "darkslategrey",
            Self::Darkturquoise => "darkturquoise",
            Self::Darkviolet => "darkviolet",
            Self::Deeppink => "deeppink",
            Self::Deepskyblue => "deepskyblue",
            Self::Dimgray => "dimgray",
            Self::Dimgrey => "dimgrey",
            Self::Dodgerblue => "dodgerblue",
            Self::Firebrick => "firebrick",
            Self::Floralwhite => "floralwhite",
            Self::Forestgreen => "forestgreen",
            Self::Fuchsia => "fuchsia",
            Self::Gainsboro => "gainsboro",
            Self::Ghostwhite => "ghostwhite",
            Self::Gold => "gold",
            Self::Goldenrod => "goldenrod",
            Self::Gray => "gray",
            Self::Green => "green",
            Self::Greenyellow => "greenyellow",
            Self::Grey => "grey",
            Self::Honeydew => "honeydew",
            Self::Hotpink => "hotpink",
            Self::Indianred => "indianred",
            Self::Indigo => "indigo",
            Self::Ivory => "ivory",
            Self::Khaki => "khaki",
            Self::Lavender => "lavender",
            Self::Lavenderblush => "lavenderblush",
            Self::Lawngreen => "lawngreen",
            Self::Lemonchiffon => "lemonchiffon",
            Self::Lightblue => "lightblue",
            Self::Lightcoral => "lightcoral",
            Self::Lightcyan => "lightcyan",
            Self::Lightgoldenrodyellow => "lightgoldenrodyellow",
            Self::Lightgray => "lightgray",
            Self::Lightgreen => "lightgreen",
            Self::Lightgrey => "lightgrey",
            Self::Lightpink => "lightpink",
            Self::Lightsalmon => "lightsalmon",
            Self::Lightseagreen => "lightseagreen",
            Self::Lightskyblue => "lightskyblue",
            Self::Lightslategray => "lightslategray",
            Self::Lightslategrey => "lightslategrey",
            Self::Lightsteelblue => "lightsteelblue",
            Self::Lightyellow => "lightyellow",
            Self::Lime => "lime",
            Self::Limegreen => "limegreen",
            Self::Linen => "linen",
            Self::Magenta => "magenta",
            Self::Maroon => "maroon",
            Self::Mediumaquamarine => "mediumaquamarine",
            Self::Mediumblue => "mediumblue",
            Self::Mediumorchid => "mediumorchid",
            Self::Mediumpurple => "mediumpurple",
            Self::Mediumseagreen => "mediumseagreen",
            Self::Mediumslateblue => "mediumslateblue",
            Self::Mediumspringgreen => "mediumspringgreen",
            Self::Mediumturquoise => "mediumturquoise",
            Self::Mediumvioletred => "mediumvioletred",
            Self::Midnightblue => "midnightblue",
            Self::Mintcream => "mintcream",
            Self::Mistyrose => "mistyrose",
            Self::Moccasin => "moccasin",
            Self::Navajowhite => "navajowhite",
            Self::Navy => "navy",
            Self::Oldlace => "oldlace",
            Self::Olive => "olive",
            Self::Olivedrab => "olivedrab",
            Self::Orange => "orange",
            Self::Orangered => "orangered",
            Self::Orchid => "orchid",
            Self::Palegoldenrod => "palegoldenrod",
            Self::Palegreen => "palegreen",
            Self::Paleturquoise => "paleturquoise",
            Self::Palevioletred => "palevioletred",
            Self::Papayawhip => "papayawhip",
            Self::Peachpuff => "peachpuff",
            Self::Peru => "peru",
            Self::Pink => "pink",
            Self::Plum => "plum",
            Self::Powderblue => "powderblue",
            Self::Purple => "purple",
            Self::Rebeccapurple => "rebeccapurple",
            Self::Red => "red",
            Self::Rosybrown => "rosybrown",
            Self::Royalblue => "royalblue",
            Self::Saddlebrown => "saddlebrown",
            Self::Salmon => "salmon",
            Self::Sandybrown => "sandybrown",
            Self::Seagreen => "seagreen",
            Self::Seashell => "seashell",
            Self::Sienna => "sienna",
            Self::Silver => "silver",
            Self::Skyblue => "skyblue",
            Self::Slateblue => "slateblue",
            Self::Slategray => "slategray",
            Self::Slategrey => "slategrey",
            Self::Snow => "snow",
            Self::Springgreen => "springgreen",
            Self::Steelblue => "steelblue",
            Self::Tan => "tan",
            Self::Teal => "teal",
            Self::Thistle => "thistle",
            Self::Tomato => "tomato",
            Self::Turquoise => "turquoise",
            Self::Violet => "violet",
            Self::Wheat => "wheat",
            Self::White => "white",
            Self::Whitesmoke => "whitesmoke",
            Self::Yellow => "yellow",
            Self::Yellowgreen => "yellowgreen",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ColorCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ColorCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ColorCodes> for Coding {
    fn from(code: ColorCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/color-names".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ColorCodes> for CodeableConcept {
    fn from(code: ColorCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CombinedDoseForm](http://hl7.org/fhir/ValueSet/combined-dose-form)**. Dose forms for a product as a whole, considering all individual parts, but before any mixing\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CombinedDoseForm {
    /** **100000073366**

Powder and solvent for oral solution. */
    N100000073366,
    /** **100000073651**

Powder and solvent for oral suspension. */
    N100000073651,
    /** **100000073774**

Eye drops, powder and solvent for solution. */
    N100000073774,
    /** **100000073781**

Eye drops, powder and solvent for suspension. */
    N100000073781,
    /** **100000073801**

Ear drops, powder and solvent for suspension. */
    N100000073801,
    /** **100000073860**

Powder and solvent for solution for infusion. */
    N100000073860,
    /** **100000073868**

Powder and solvent for solution for injection. */
    N100000073868,
    /** **100000073869**

Powder and solvent for suspension for injection. */
    N100000073869,
    /** **100000073884**

Powder and solvent for implantation paste. */
    N100000073884,
    /** **100000073891**

Endotracheopulmonary instillation, powder and solvent for solution. */
    N100000073891,
    /** **100000073892**

Powder and solvent for endocervical gel. */
    N100000073892,
    /** **100000073941**

Powder and solvent for sealant. */
    N100000073941,
    /** **100000073972**

Concentrate and solvent for concentrate for solution for infusion. */
    N100000073972,
    /** **100000073973**

Concentrate and solvent for cutaneous use. */
    N100000073973,
    /** **100000073974**

Concentrate and solvent for injection. */
    N100000073974,
    /** **100000073975**

Concentrate and solvent for solution for infusion. */
    N100000073975,
    /** **100000073987**

Concentrate and diluent for solution for infusion. */
    N100000073987,
    /** **100000073988**

Concentrate and solvent for cutaneous solution. */
    N100000073988,
    /** **100000073989**

Concentrate and solvent for solution for injection. */
    N100000073989,
    /** **100000073990**

Concentrate and solvent for suspension for injection. */
    N100000073990,
    /** **100000073999**

Granules and solvent for suspension for injection. */
    N100000073999,
    /** **100000074015**

Powder and solvent for concentrate for solution for infusion. */
    N100000074015,
    /** **100000074016**

Powder and solvent for cutaneous solution. */
    N100000074016,
    /** **100000074017**

Powder and solvent for gingival gel. */
    N100000074017,
    /** **100000074018**

Powder and solvent for prolonged-release suspension for injection. */
    N100000074018,
    /** **100000074030**

Powder and solvent for endosinusial solution. */
    N100000074030,
    /** **100000074031**

Powder and solvent for intraocular instillation solution. */
    N100000074031,
    /** **100000074032**

Powder and suspension for suspension for injection. */
    N100000074032,
    /** **100000074048**

Suspension and effervescent granules for oral suspension. */
    N100000074048,
    /** **100000074051**

Tablet and solvent for rectal suspension. */
    N100000074051,
    /** **100000074053**

Powder and solvent for dental gel. */
    N100000074053,
    /** **100000074056**

Gas and solvent for dispersion for injection/infusion. */
    N100000074056,
    /** **100000074057**

Powder and solvent for solution for injection/infusion. */
    N100000074057,
    /** **100000074061**

Suspension and solution for spray. */
    N100000074061,
    /** **100000074064**

Tablet and powder for oral solution. */
    N100000074064,
    /** **100000075580**

Emulsion and suspension for emulsion for injection. */
    N100000075580,
    /** **100000075584**

Powder and solvent for dispersion for injection. */
    N100000075584,
    /** **100000075587**

Powder for mouth wash. */
    N100000075587,
    /** **100000116137**

Lyophilisate and solvent for solution for injection. */
    N100000116137,
    /** **100000116141**

Fibrin sealant-powder and solvent for fibrin sealant. */
    N100000116141,
    /** **100000116155**

Granules and solvent for oral suspension. */
    N100000116155,
    /** **100000116160**

Lyophilisate and solvent for suspension for injection. */
    N100000116160,
    /** **100000116172**

Powder and gel for gel. */
    N100000116172,
    /** **100000116173**

Powder and solution for solution for injection. */
    N100000116173,
    /** **100000116174**

Powder and solvent for epilesional solution. */
    N100000116174,
    /** **100000116175**

Powder and solvent for intravesical solution. */
    N100000116175,
    /** **100000116176**

Powder and solvent for intravesical suspension. */
    N100000116176,
    /** **100000116177**

Powder and solvent for nebuliser solution. */
    N100000116177,
    /** **100000116179**

Powder, dispersion and solvent for concentrate for dispersion for infusion. */
    N100000116179,
    /** **100000125746**

Powder and solvent for emulsion for injection. */
    N100000125746,
    /** **100000125747**

Nasal drops, powder and solvent for solution. */
    N100000125747,
    /** **100000125777**

Suspension and solvent for suspension for injection. */
    N100000125777,
    /** **100000136318**

Concentrate and solvent for solution for injection/infusion. */
    N100000136318,
    /** **100000136325**

Powder and solvent for solution for injection/skin-prick test. */
    N100000136325,
    /** **100000136558**

Lyophilisate and solvent for suspension for nasal administration. */
    N100000136558,
    /** **100000136560**

Powder and solvent for solution for sealant. */
    N100000136560,
    /** **100000136907**

Solution for dispersion for injection/infusion. */
    N100000136907,
    /** **100000143502**

Powder and solution for dental cement. */
    N100000143502,
    /** **100000143546**

Endotracheopulmonary instillation, powder and solvent for suspension. */
    N100000143546,
    /** **100000143552**

Powder, solvent and matrix for implantation matrix. */
    N100000143552,
    /** **100000156068**

Nasal drops, lyophilisate and solvent for suspension. */
    N100000156068,
    /** **100000157796**

Lyophilisate and suspension for suspension for injection. */
    N100000157796,
    /** **100000164467**

Powder for concentrate and solution for solution for infusion. */
    N100000164467,
    /** **100000169997**

Powder and solution for bee-hive solution. */
    N100000169997,
    /** **100000170588**

Suspension and solvent for oral spray. */
    N100000170588,
    /** **100000171127**

Lyophilisate and solvent for oral suspension. */
    N100000171127,
    /** **100000171193**

Concentrate and solvent for concentrate for oral spray, suspension. */
    N100000171193,
    /** **100000171238**

Lyophilisate and solvent for oculonasal suspension. */
    N100000171238,
    /** **100000171935**

Emulsion and lyophilisate for suspension for injection. */
    N100000171935,
    /** **100000174065**

Powder and solvent for syrup. */
    N100000174065,
    /** **200000002161**

Nasal spray, lyophilisate and solvent for suspension. */
    N200000002161,
    /** **200000002287**

Powder and solution for bee-hive dispersion. */
    N200000002287,
    /** **200000004201**

Solution and dispersion for nebuliser dispersion. */
    N200000004201,
    /** **200000004819**

Effervescent powder and powder for oral suspension. */
    N200000004819,
    /** **200000004820**

Lyophilisate and solvent for emulsion for injection. */
    N200000004820,
    /** **200000005547**

Powder and solution for suspension for injection. */
    N200000005547,
    /** **200000010382**

Lyophilisate and solvent for suspension for nasal spray or injection. */
    N200000010382,
}
impl ::core::str::FromStr for CombinedDoseForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073366" => Ok(Self::N100000073366),
            "100000073651" => Ok(Self::N100000073651),
            "100000073774" => Ok(Self::N100000073774),
            "100000073781" => Ok(Self::N100000073781),
            "100000073801" => Ok(Self::N100000073801),
            "100000073860" => Ok(Self::N100000073860),
            "100000073868" => Ok(Self::N100000073868),
            "100000073869" => Ok(Self::N100000073869),
            "100000073884" => Ok(Self::N100000073884),
            "100000073891" => Ok(Self::N100000073891),
            "100000073892" => Ok(Self::N100000073892),
            "100000073941" => Ok(Self::N100000073941),
            "100000073972" => Ok(Self::N100000073972),
            "100000073973" => Ok(Self::N100000073973),
            "100000073974" => Ok(Self::N100000073974),
            "100000073975" => Ok(Self::N100000073975),
            "100000073987" => Ok(Self::N100000073987),
            "100000073988" => Ok(Self::N100000073988),
            "100000073989" => Ok(Self::N100000073989),
            "100000073990" => Ok(Self::N100000073990),
            "100000073999" => Ok(Self::N100000073999),
            "100000074015" => Ok(Self::N100000074015),
            "100000074016" => Ok(Self::N100000074016),
            "100000074017" => Ok(Self::N100000074017),
            "100000074018" => Ok(Self::N100000074018),
            "100000074030" => Ok(Self::N100000074030),
            "100000074031" => Ok(Self::N100000074031),
            "100000074032" => Ok(Self::N100000074032),
            "100000074048" => Ok(Self::N100000074048),
            "100000074051" => Ok(Self::N100000074051),
            "100000074053" => Ok(Self::N100000074053),
            "100000074056" => Ok(Self::N100000074056),
            "100000074057" => Ok(Self::N100000074057),
            "100000074061" => Ok(Self::N100000074061),
            "100000074064" => Ok(Self::N100000074064),
            "100000075580" => Ok(Self::N100000075580),
            "100000075584" => Ok(Self::N100000075584),
            "100000075587" => Ok(Self::N100000075587),
            "100000116137" => Ok(Self::N100000116137),
            "100000116141" => Ok(Self::N100000116141),
            "100000116155" => Ok(Self::N100000116155),
            "100000116160" => Ok(Self::N100000116160),
            "100000116172" => Ok(Self::N100000116172),
            "100000116173" => Ok(Self::N100000116173),
            "100000116174" => Ok(Self::N100000116174),
            "100000116175" => Ok(Self::N100000116175),
            "100000116176" => Ok(Self::N100000116176),
            "100000116177" => Ok(Self::N100000116177),
            "100000116179" => Ok(Self::N100000116179),
            "100000125746" => Ok(Self::N100000125746),
            "100000125747" => Ok(Self::N100000125747),
            "100000125777" => Ok(Self::N100000125777),
            "100000136318" => Ok(Self::N100000136318),
            "100000136325" => Ok(Self::N100000136325),
            "100000136558" => Ok(Self::N100000136558),
            "100000136560" => Ok(Self::N100000136560),
            "100000136907" => Ok(Self::N100000136907),
            "100000143502" => Ok(Self::N100000143502),
            "100000143546" => Ok(Self::N100000143546),
            "100000143552" => Ok(Self::N100000143552),
            "100000156068" => Ok(Self::N100000156068),
            "100000157796" => Ok(Self::N100000157796),
            "100000164467" => Ok(Self::N100000164467),
            "100000169997" => Ok(Self::N100000169997),
            "100000170588" => Ok(Self::N100000170588),
            "100000171127" => Ok(Self::N100000171127),
            "100000171193" => Ok(Self::N100000171193),
            "100000171238" => Ok(Self::N100000171238),
            "100000171935" => Ok(Self::N100000171935),
            "100000174065" => Ok(Self::N100000174065),
            "200000002161" => Ok(Self::N200000002161),
            "200000002287" => Ok(Self::N200000002287),
            "200000004201" => Ok(Self::N200000004201),
            "200000004819" => Ok(Self::N200000004819),
            "200000004820" => Ok(Self::N200000004820),
            "200000005547" => Ok(Self::N200000005547),
            "200000010382" => Ok(Self::N200000010382),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CombinedDoseForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073366 => "100000073366",
            Self::N100000073651 => "100000073651",
            Self::N100000073774 => "100000073774",
            Self::N100000073781 => "100000073781",
            Self::N100000073801 => "100000073801",
            Self::N100000073860 => "100000073860",
            Self::N100000073868 => "100000073868",
            Self::N100000073869 => "100000073869",
            Self::N100000073884 => "100000073884",
            Self::N100000073891 => "100000073891",
            Self::N100000073892 => "100000073892",
            Self::N100000073941 => "100000073941",
            Self::N100000073972 => "100000073972",
            Self::N100000073973 => "100000073973",
            Self::N100000073974 => "100000073974",
            Self::N100000073975 => "100000073975",
            Self::N100000073987 => "100000073987",
            Self::N100000073988 => "100000073988",
            Self::N100000073989 => "100000073989",
            Self::N100000073990 => "100000073990",
            Self::N100000073999 => "100000073999",
            Self::N100000074015 => "100000074015",
            Self::N100000074016 => "100000074016",
            Self::N100000074017 => "100000074017",
            Self::N100000074018 => "100000074018",
            Self::N100000074030 => "100000074030",
            Self::N100000074031 => "100000074031",
            Self::N100000074032 => "100000074032",
            Self::N100000074048 => "100000074048",
            Self::N100000074051 => "100000074051",
            Self::N100000074053 => "100000074053",
            Self::N100000074056 => "100000074056",
            Self::N100000074057 => "100000074057",
            Self::N100000074061 => "100000074061",
            Self::N100000074064 => "100000074064",
            Self::N100000075580 => "100000075580",
            Self::N100000075584 => "100000075584",
            Self::N100000075587 => "100000075587",
            Self::N100000116137 => "100000116137",
            Self::N100000116141 => "100000116141",
            Self::N100000116155 => "100000116155",
            Self::N100000116160 => "100000116160",
            Self::N100000116172 => "100000116172",
            Self::N100000116173 => "100000116173",
            Self::N100000116174 => "100000116174",
            Self::N100000116175 => "100000116175",
            Self::N100000116176 => "100000116176",
            Self::N100000116177 => "100000116177",
            Self::N100000116179 => "100000116179",
            Self::N100000125746 => "100000125746",
            Self::N100000125747 => "100000125747",
            Self::N100000125777 => "100000125777",
            Self::N100000136318 => "100000136318",
            Self::N100000136325 => "100000136325",
            Self::N100000136558 => "100000136558",
            Self::N100000136560 => "100000136560",
            Self::N100000136907 => "100000136907",
            Self::N100000143502 => "100000143502",
            Self::N100000143546 => "100000143546",
            Self::N100000143552 => "100000143552",
            Self::N100000156068 => "100000156068",
            Self::N100000157796 => "100000157796",
            Self::N100000164467 => "100000164467",
            Self::N100000169997 => "100000169997",
            Self::N100000170588 => "100000170588",
            Self::N100000171127 => "100000171127",
            Self::N100000171193 => "100000171193",
            Self::N100000171238 => "100000171238",
            Self::N100000171935 => "100000171935",
            Self::N100000174065 => "100000174065",
            Self::N200000002161 => "200000002161",
            Self::N200000002287 => "200000002287",
            Self::N200000004201 => "200000004201",
            Self::N200000004819 => "200000004819",
            Self::N200000004820 => "200000004820",
            Self::N200000005547 => "200000005547",
            Self::N200000010382 => "200000010382",
        }
    }
}
impl ::std::fmt::Display for CombinedDoseForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000073366 => "Powder and solvent for oral solution",
            Self::N100000073651 => "Powder and solvent for oral suspension",
            Self::N100000073774 => "Eye drops, powder and solvent for solution",
            Self::N100000073781 => "Eye drops, powder and solvent for suspension",
            Self::N100000073801 => "Ear drops, powder and solvent for suspension",
            Self::N100000073860 => "Powder and solvent for solution for infusion",
            Self::N100000073868 => "Powder and solvent for solution for injection",
            Self::N100000073869 => "Powder and solvent for suspension for injection",
            Self::N100000073884 => "Powder and solvent for implantation paste",
            Self::N100000073891 => {
                "Endotracheopulmonary instillation, powder and solvent for solution"
            }
            Self::N100000073892 => "Powder and solvent for endocervical gel",
            Self::N100000073941 => "Powder and solvent for sealant",
            Self::N100000073972 => {
                "Concentrate and solvent for concentrate for solution for infusion"
            }
            Self::N100000073973 => "Concentrate and solvent for cutaneous use",
            Self::N100000073974 => "Concentrate and solvent for injection",
            Self::N100000073975 => "Concentrate and solvent for solution for infusion",
            Self::N100000073987 => "Concentrate and diluent for solution for infusion",
            Self::N100000073988 => "Concentrate and solvent for cutaneous solution",
            Self::N100000073989 => "Concentrate and solvent for solution for injection",
            Self::N100000073990 => "Concentrate and solvent for suspension for injection",
            Self::N100000073999 => "Granules and solvent for suspension for injection",
            Self::N100000074015 => {
                "Powder and solvent for concentrate for solution for infusion"
            }
            Self::N100000074016 => "Powder and solvent for cutaneous solution",
            Self::N100000074017 => "Powder and solvent for gingival gel",
            Self::N100000074018 => {
                "Powder and solvent for prolonged-release suspension for injection"
            }
            Self::N100000074030 => "Powder and solvent for endosinusial solution",
            Self::N100000074031 => {
                "Powder and solvent for intraocular instillation solution"
            }
            Self::N100000074032 => "Powder and suspension for suspension for injection",
            Self::N100000074048 => {
                "Suspension and effervescent granules for oral suspension"
            }
            Self::N100000074051 => "Tablet and solvent for rectal suspension",
            Self::N100000074053 => "Powder and solvent for dental gel",
            Self::N100000074056 => {
                "Gas and solvent for dispersion for injection/infusion"
            }
            Self::N100000074057 => {
                "Powder and solvent for solution for injection/infusion"
            }
            Self::N100000074061 => "Suspension and solution for spray",
            Self::N100000074064 => "Tablet and powder for oral solution",
            Self::N100000075580 => "Emulsion and suspension for emulsion for injection",
            Self::N100000075584 => "Powder and solvent for dispersion for injection",
            Self::N100000075587 => "Powder for mouth wash",
            Self::N100000116137 => "Lyophilisate and solvent for solution for injection",
            Self::N100000116141 => "Fibrin sealant-powder and solvent for fibrin sealant",
            Self::N100000116155 => "Granules and solvent for oral suspension",
            Self::N100000116160 => {
                "Lyophilisate and solvent for suspension for injection"
            }
            Self::N100000116172 => "Powder and gel for gel",
            Self::N100000116173 => "Powder and solution for solution for injection",
            Self::N100000116174 => "Powder and solvent for epilesional solution",
            Self::N100000116175 => "Powder and solvent for intravesical solution",
            Self::N100000116176 => "Powder and solvent for intravesical suspension",
            Self::N100000116177 => "Powder and solvent for nebuliser solution",
            Self::N100000116179 => {
                "Powder, dispersion and solvent for concentrate for dispersion for infusion"
            }
            Self::N100000125746 => "Powder and solvent for emulsion for injection",
            Self::N100000125747 => "Nasal drops, powder and solvent for solution",
            Self::N100000125777 => "Suspension and solvent for suspension for injection",
            Self::N100000136318 => {
                "Concentrate and solvent for solution for injection/infusion"
            }
            Self::N100000136325 => {
                "Powder and solvent for solution for injection/skin-prick test"
            }
            Self::N100000136558 => {
                "Lyophilisate and solvent for suspension for nasal administration"
            }
            Self::N100000136560 => "Powder and solvent for solution for sealant",
            Self::N100000136907 => "Solution for dispersion for injection/infusion",
            Self::N100000143502 => "Powder and solution for dental cement",
            Self::N100000143546 => {
                "Endotracheopulmonary instillation, powder and solvent for suspension"
            }
            Self::N100000143552 => "Powder, solvent and matrix for implantation matrix",
            Self::N100000156068 => "Nasal drops, lyophilisate and solvent for suspension",
            Self::N100000157796 => {
                "Lyophilisate and suspension for suspension for injection"
            }
            Self::N100000164467 => {
                "Powder for concentrate and solution for solution for infusion"
            }
            Self::N100000169997 => "Powder and solution for bee-hive solution",
            Self::N100000170588 => "Suspension and solvent for oral spray",
            Self::N100000171127 => "Lyophilisate and solvent for oral suspension",
            Self::N100000171193 => {
                "Concentrate and solvent for concentrate for oral spray, suspension"
            }
            Self::N100000171238 => "Lyophilisate and solvent for oculonasal suspension",
            Self::N100000171935 => {
                "Emulsion and lyophilisate for suspension for injection"
            }
            Self::N100000174065 => "Powder and solvent for syrup",
            Self::N200000002161 => "Nasal spray, lyophilisate and solvent for suspension",
            Self::N200000002287 => "Powder and solution for bee-hive dispersion",
            Self::N200000004201 => "Solution and dispersion for nebuliser dispersion",
            Self::N200000004819 => "Effervescent powder and powder for oral suspension",
            Self::N200000004820 => "Lyophilisate and solvent for emulsion for injection",
            Self::N200000005547 => "Powder and solution for suspension for injection",
            Self::N200000010382 => {
                "Lyophilisate and solvent for suspension for nasal spray or injection"
            }
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CombinedDoseForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CombinedDoseForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CombinedDoseForm> for Coding {
    fn from(code: CombinedDoseForm) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/combined-dose-form".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CombinedDoseForm> for CodeableConcept {
    fn from(code: CombinedDoseForm) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CompartmentType](http://hl7.org/fhir/ValueSet/compartment-type)**. Which type a compartment definition describes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CompartmentType {
    /** **Device**

Device. The compartment definition is for the device compartment. */
    Device,
    /** **Encounter**

Encounter. The compartment definition is for the encounter compartment. */
    Encounter,
    /** **EpisodeOfCare**

EpisodeOfCare. The compartment definition is for the episodeofcare compartment. */
    EpisodeOfCare,
    /** **Patient**

Patient. The compartment definition is for the patient compartment. */
    Patient,
    /** **Practitioner**

Practitioner. The compartment definition is for the practitioner compartment. */
    Practitioner,
    /** **RelatedPerson**

RelatedPerson. The compartment definition is for the related-person compartment. */
    RelatedPerson,
}
impl ::core::str::FromStr for CompartmentType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Device" => Ok(Self::Device),
            "Encounter" => Ok(Self::Encounter),
            "EpisodeOfCare" => Ok(Self::EpisodeOfCare),
            "Patient" => Ok(Self::Patient),
            "Practitioner" => Ok(Self::Practitioner),
            "RelatedPerson" => Ok(Self::RelatedPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompartmentType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "Device",
            Self::Encounter => "Encounter",
            Self::EpisodeOfCare => "EpisodeOfCare",
            Self::Patient => "Patient",
            Self::Practitioner => "Practitioner",
            Self::RelatedPerson => "RelatedPerson",
        }
    }
}
impl ::std::fmt::Display for CompartmentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Device => "Device",
            Self::Encounter => "Encounter",
            Self::EpisodeOfCare => "EpisodeOfCare",
            Self::Patient => "Patient",
            Self::Practitioner => "Practitioner",
            Self::RelatedPerson => "RelatedPerson",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CompartmentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompartmentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompartmentType> for Coding {
    fn from(code: CompartmentType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/compartment-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CompartmentType> for CodeableConcept {
    fn from(code: CompartmentType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CompositionAttestationMode](http://hl7.org/fhir/ValueSet/composition-attestation-mode)**. The way in which a person authenticated a composition.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CompositionAttestationMode {
    /** **legal**

Legal. The person authenticated the content and accepted legal responsibility for its content. */
    Legal,
    /** **official**

Official. The organization authenticated the content as consistent with their policies and procedures. */
    Official,
    /** **personal**

Personal. The person authenticated the content in their personal capacity. */
    Personal,
    /** **professional**

Professional. The person authenticated the content in their professional capacity. */
    Professional,
}
impl ::core::str::FromStr for CompositionAttestationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "legal" => Ok(Self::Legal),
            "official" => Ok(Self::Official),
            "personal" => Ok(Self::Personal),
            "professional" => Ok(Self::Professional),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositionAttestationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Legal => "legal",
            Self::Official => "official",
            Self::Personal => "personal",
            Self::Professional => "professional",
        }
    }
}
impl ::std::fmt::Display for CompositionAttestationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Legal => "Legal",
            Self::Official => "Official",
            Self::Personal => "Personal",
            Self::Professional => "Professional",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CompositionAttestationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositionAttestationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompositionAttestationMode> for Coding {
    fn from(code: CompositionAttestationMode) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/composition-attestation-mode".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CompositionAttestationMode> for CodeableConcept {
    fn from(code: CompositionAttestationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CompositionStatus](http://hl7.org/fhir/ValueSet/composition-status)**. The workflow/clinical status of the composition.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CompositionStatus {
    /** **amended**

Amended. The composition content or the referenced resources have been modified (edited or added to) subsequent to being released as "final" and the composition is complete and verified by an authorized person. */
    Amended,
    /** **appended**

Appended. Subsequent to being final, the composition content has been modified by adding new content. The existing content is unchanged. */
    Appended,
    /** **cancelled**

Cancelled. The composition is unavailable because the measurement was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **corrected**

Corrected. Subsequent to being final, the composition content has been modified to correct an error in the composition or referenced results. */
    Corrected,
    /** **deprecated**

Deprecated. This composition has been withdrawn or superseded and should no longer be used. */
    Deprecated,
    /** **entered-in-error**

Entered in Error. The composition or document was originally created/issued in error, and this is an amendment that marks that the entire series should not be considered as valid. */
    EnteredInError,
    /** **final**

Final. This version of the composition is complete and verified by an appropriate person and no further work is planned. Any subsequent updates would be on a new version of the composition. */
    Final,
    /** **partial**

Partial. This is a partial (e.g. initial, interim or preliminary) composition: data in the composition may be incomplete or unverified. */
    Partial,
    /** **preliminary**

Preliminary. Verified early results are available, but not all results are final. */
    Preliminary,
    /** **registered**

Registered. The existence of the composition is registered, but there is nothing yet available. */
    Registered,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for CompositionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "corrected" => Ok(Self::Corrected),
            "deprecated" => Ok(Self::Deprecated),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "partial" => Ok(Self::Partial),
            "preliminary" => Ok(Self::Preliminary),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Corrected => "corrected",
            Self::Deprecated => "deprecated",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Partial => "partial",
            Self::Preliminary => "preliminary",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for CompositionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Amended => "Amended",
            Self::Appended => "Appended",
            Self::Cancelled => "Cancelled",
            Self::Corrected => "Corrected",
            Self::Deprecated => "Deprecated",
            Self::EnteredInError => "Entered in Error",
            Self::Final => "Final",
            Self::Partial => "Partial",
            Self::Preliminary => "Preliminary",
            Self::Registered => "Registered",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CompositionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CompositionStatus> for Coding {
    fn from(code: CompositionStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/composition-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CompositionStatus> for CodeableConcept {
    fn from(code: CompositionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConceptMapAttributeType](http://hl7.org/fhir/ValueSet/conceptmap-attribute-type)**. The type of a ConceptMap map attribute value.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConceptMapAttributeType {
    /** **Coding**

Coding. The attribute value is a code defined in a code system. */
    Coding,
    /** **Quantity**

Quantity. The attribute is a Quantity (may represent an integer or a decimal with no units). */
    Quantity,
    /** **boolean**

boolean. The attribute value is a boolean true | false. */
    Boolean,
    /** **code**

code. The attribute value is a code defined in the code system in context. */
    Code,
    /** **string**

string. The attribute value is a string. */
    String,
}
impl ::core::str::FromStr for ConceptMapAttributeType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Coding" => Ok(Self::Coding),
            "Quantity" => Ok(Self::Quantity),
            "boolean" => Ok(Self::Boolean),
            "code" => Ok(Self::Code),
            "string" => Ok(Self::String),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapAttributeType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Coding => "Coding",
            Self::Quantity => "Quantity",
            Self::Boolean => "boolean",
            Self::Code => "code",
            Self::String => "string",
        }
    }
}
impl ::std::fmt::Display for ConceptMapAttributeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Coding => "Coding",
            Self::Quantity => "Quantity",
            Self::Boolean => "boolean",
            Self::Code => "code",
            Self::String => "string",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConceptMapAttributeType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapAttributeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptMapAttributeType> for Coding {
    fn from(code: ConceptMapAttributeType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/conceptmap-attribute-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConceptMapAttributeType> for CodeableConcept {
    fn from(code: ConceptMapAttributeType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConceptMapGroupUnmappedMode](http://hl7.org/fhir/ValueSet/conceptmap-unmapped-mode)**. Defines which action to take if there is no match in the group.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConceptMapGroupUnmappedMode {
    /** **fixed**

Fixed Code. Use the code(s) explicitly provided in the group.unmapped 'code' or 'valueSet' element. */
    Fixed,
    /** **other-map**

Other Map. Use the map identified by the canonical URL in the url element. */
    OtherMap,
    /** **use-source-code**

Use Provided Source Code. Use the code as provided in the $translate request in one of the following input parameters: sourceCode, sourceCoding, sourceCodeableConcept. */
    UseSourceCode,
}
impl ::core::str::FromStr for ConceptMapGroupUnmappedMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fixed" => Ok(Self::Fixed),
            "other-map" => Ok(Self::OtherMap),
            "use-source-code" => Ok(Self::UseSourceCode),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapGroupUnmappedMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fixed => "fixed",
            Self::OtherMap => "other-map",
            Self::UseSourceCode => "use-source-code",
        }
    }
}
impl ::std::fmt::Display for ConceptMapGroupUnmappedMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Fixed => "Fixed Code",
            Self::OtherMap => "Other Map",
            Self::UseSourceCode => "Use Provided Source Code",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConceptMapGroupUnmappedMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapGroupUnmappedMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptMapGroupUnmappedMode> for Coding {
    fn from(code: ConceptMapGroupUnmappedMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/conceptmap-unmapped-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConceptMapGroupUnmappedMode> for CodeableConcept {
    fn from(code: ConceptMapGroupUnmappedMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConceptMapProperties](http://hl7.org/fhir/conceptmap-properties)**. A set of common concept properties for use on ConceptMap\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConceptMapProperties {
    /** **relationshipRefinement**

Relationship Refinement. Property of type coding that indicates a specific refined relationship such as categorized by or grouped */
    RelationshipRefinement,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConceptMapProperties {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "relationshipRefinement" => Ok(Self::RelationshipRefinement),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConceptMapProperties {
    fn as_ref(&self) -> &str {
        match self {
            Self::RelationshipRefinement => "relationshipRefinement",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ConceptMapProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::RelationshipRefinement => "Relationship Refinement",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConceptMapProperties {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapProperties {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptMapProperties> for Coding {
    fn from(code: ConceptMapProperties) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/conceptmap-properties".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConceptMapProperties> for CodeableConcept {
    fn from(code: ConceptMapProperties) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConceptMapPropertyType](http://hl7.org/fhir/ValueSet/conceptmap-property-type)**. The type of a ConceptMap mapping property value.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConceptMapPropertyType {
    /** **Coding**

Coding (external reference). The property  value is a code defined in an external code system. This may be used for translations, but is not the intent. */
    Coding,
    /** **boolean**

boolean. The property value is a boolean true | false. */
    Boolean,
    /** **code**

code. The property value is a code as defined in the CodeSystem in ConceptMap.property.system. */
    Code,
    /** **dateTime**

dateTime. The property is a date or a date + time. */
    DateTime,
    /** **decimal**

decimal. The property value is a decimal number. */
    Decimal,
    /** **integer**

integer. The property value is an integer (often used to assign ranking values to concepts for supporting score assessments). */
    Integer,
    /** **string**

string. The property value is a string. */
    String,
}
impl ::core::str::FromStr for ConceptMapPropertyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Coding" => Ok(Self::Coding),
            "boolean" => Ok(Self::Boolean),
            "code" => Ok(Self::Code),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "integer" => Ok(Self::Integer),
            "string" => Ok(Self::String),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapPropertyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Coding => "Coding",
            Self::Boolean => "boolean",
            Self::Code => "code",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Integer => "integer",
            Self::String => "string",
        }
    }
}
impl ::std::fmt::Display for ConceptMapPropertyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Coding => "Coding (external reference)",
            Self::Boolean => "boolean",
            Self::Code => "code",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Integer => "integer",
            Self::String => "string",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConceptMapPropertyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapPropertyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptMapPropertyType> for Coding {
    fn from(code: ConceptMapPropertyType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/conceptmap-property-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConceptMapPropertyType> for CodeableConcept {
    fn from(code: ConceptMapPropertyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConceptMapRelationship](http://hl7.org/fhir/ValueSet/concept-map-relationship)**. The relationship between concepts.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConceptMapRelationship {
    /** **equivalent**

Equivalent. The definitions of the concepts mean the same thing. */
    Equivalent,
    /** **not-related-to**

Not Related To. This is an explicit assertion that the target concept is not related to the source concept. */
    NotRelatedTo,
    /** **related-to**

Related To. The concepts are related to each other, but the exact relationship is not known. */
    RelatedTo,
    /** **source-is-broader-than-target**

Source Is Broader Than Target. The source concept is broader in meaning than the target concept. */
    SourceIsBroaderThanTarget,
    /** **source-is-narrower-than-target**

Source Is Narrower Than Target. The source concept is narrower in meaning than the target concept. */
    SourceIsNarrowerThanTarget,
}
impl ::core::str::FromStr for ConceptMapRelationship {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "equivalent" => Ok(Self::Equivalent),
            "not-related-to" => Ok(Self::NotRelatedTo),
            "related-to" => Ok(Self::RelatedTo),
            "source-is-broader-than-target" => Ok(Self::SourceIsBroaderThanTarget),
            "source-is-narrower-than-target" => Ok(Self::SourceIsNarrowerThanTarget),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapRelationship {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equivalent => "equivalent",
            Self::NotRelatedTo => "not-related-to",
            Self::RelatedTo => "related-to",
            Self::SourceIsBroaderThanTarget => "source-is-broader-than-target",
            Self::SourceIsNarrowerThanTarget => "source-is-narrower-than-target",
        }
    }
}
impl ::std::fmt::Display for ConceptMapRelationship {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Equivalent => "Equivalent",
            Self::NotRelatedTo => "Not Related To",
            Self::RelatedTo => "Related To",
            Self::SourceIsBroaderThanTarget => "Source Is Broader Than Target",
            Self::SourceIsNarrowerThanTarget => "Source Is Narrower Than Target",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConceptMapRelationship {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapRelationship {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptMapRelationship> for Coding {
    fn from(code: ConceptMapRelationship) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/concept-map-relationship".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConceptMapRelationship> for CodeableConcept {
    fn from(code: ConceptMapRelationship) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConceptProperties](http://hl7.org/fhir/ValueSet/concept-properties)**. A set of common concept properties for use on coded systems throughout the FHIR eco-system.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConceptProperties {
    /** **child**

Child. The concept identified in this property is a child of the concept on which it is a property. The property type will be 'code'. The meaning of 'child' is defined by the hierarchyMeaning attribute */
    Child,
    /** **comment**

Comment. A string that provides additional detail pertinent to the use or understanding of the concept */
    Comment,
    /** **deprecated**

Deprecated. The date at which a concept was deprecated. Concepts that are deprecated but not inactive can still be used, but their use is discouraged, and they should be expected to be made inactive in a future release. Property type is dateTime. Note that the status property may also be used to indicate that a concept is deprecated */
    Deprecated,
    /** **deprecationDate**

Deprecation Date. The date at which a concept was deprecated. Concepts that are deprecated but not inactive can still be used, but their use is discouraged, and they should be expected to be made inactive in a future release. Property type is dateTime. Note that the status property may also be used to indicate that a concept is deprecated */
    DeprecationDate,
    /** **effectiveDate**

effectiveDate. The date at which the concept status was last changed */
    EffectiveDate,
    /** **inactive**

Inactive. True if the concept is not considered active - e.g. not a valid concept any more. Property type is boolean, default value is false. Note that the status property may also be used to indicate that a concept is inactive */
    Inactive,
    /** **itemWeight**

itemWeight. A numeric value that allows the comparison (less than, greater than) or other numerical manipulation of a concept (e.g. Adding up components of a score). Scores are usually a whole number, but occasionally decimals are encountered in scores. In questionnaires, the item weight may be represented using the [[[http://hl7.org/fhir/StructureDefinition/itemWeight]]] extension */
    ItemWeight,
    /** **notSelectable**

Not Selectable. The concept is not intended to be chosen by the user - only intended to be used as a selector for other concepts. Note, though, that the interpretation of this is highly contextual; all concepts are selectable in some context. Property type is boolean */
    NotSelectable,
    /** **parent**

Parent. The concept identified in this property is a parent of the concept on which it is a property. The property type will be 'code'. The meaning of 'parent' is defined by the hierarchyMeaning attribute */
    Parent,
    /** **partOf**

Part Of. The concept identified in this property (by its code) contains this concept as a component (i.e. a part-of relationship rather than a subsumption relationship such as elbow is part-of arm */
    PartOf,
    /** **retirementDate**

Retirement Date. The date at which a concept was retired */
    RetirementDate,
    /** **status**

Status. A code that indicates the status of the concept. Typical values are active, experimental, deprecated, and retired */
    Status,
    /** **synonym**

Synonym. This property contains an alternative code that may be used to identify this concept instead of the primary code */
    Synonym,
}
impl ::core::str::FromStr for ConceptProperties {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "child" => Ok(Self::Child),
            "comment" => Ok(Self::Comment),
            "deprecated" => Ok(Self::Deprecated),
            "deprecationDate" => Ok(Self::DeprecationDate),
            "effectiveDate" => Ok(Self::EffectiveDate),
            "inactive" => Ok(Self::Inactive),
            "itemWeight" => Ok(Self::ItemWeight),
            "notSelectable" => Ok(Self::NotSelectable),
            "parent" => Ok(Self::Parent),
            "partOf" => Ok(Self::PartOf),
            "retirementDate" => Ok(Self::RetirementDate),
            "status" => Ok(Self::Status),
            "synonym" => Ok(Self::Synonym),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptProperties {
    fn as_ref(&self) -> &str {
        match self {
            Self::Child => "child",
            Self::Comment => "comment",
            Self::Deprecated => "deprecated",
            Self::DeprecationDate => "deprecationDate",
            Self::EffectiveDate => "effectiveDate",
            Self::Inactive => "inactive",
            Self::ItemWeight => "itemWeight",
            Self::NotSelectable => "notSelectable",
            Self::Parent => "parent",
            Self::PartOf => "partOf",
            Self::RetirementDate => "retirementDate",
            Self::Status => "status",
            Self::Synonym => "synonym",
        }
    }
}
impl ::std::fmt::Display for ConceptProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Child => "Child",
            Self::Comment => "Comment",
            Self::Deprecated => "Deprecated",
            Self::DeprecationDate => "Deprecation Date",
            Self::EffectiveDate => "effectiveDate",
            Self::Inactive => "Inactive",
            Self::ItemWeight => "itemWeight",
            Self::NotSelectable => "Not Selectable",
            Self::Parent => "Parent",
            Self::PartOf => "Part Of",
            Self::RetirementDate => "Retirement Date",
            Self::Status => "Status",
            Self::Synonym => "Synonym",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConceptProperties {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptProperties {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptProperties> for Coding {
    fn from(code: ConceptProperties) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/concept-properties".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConceptProperties> for CodeableConcept {
    fn from(code: ConceptProperties) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConceptSubsumptionOutcome](http://hl7.org/fhir/concept-subsumption-outcome)**. Codes indicating the results of a subsumption check between codes. In the context of this CodeSystem, subsumption is defined in the FHIR specification under Resource Types - CodeSystem.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConceptSubsumptionOutcome {
    /** **equivalent**

Equivalent. A equivalent to B if A subsumes B and B subsumes A */
    Equivalent,
    /** **not-subsumed**

Not-Subsumed. Neither A subsumes B nor B subsumes A */
    NotSubsumed,
    /** **subsumed-by**

Subsumed-By. A subsumed by B if B subsumes A */
    SubsumedBy,
    /** **subsumes**

Subsumes. A subsumes B if there is a subsumption relationship between A and B */
    Subsumes,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConceptSubsumptionOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "equivalent" => Ok(Self::Equivalent),
            "not-subsumed" => Ok(Self::NotSubsumed),
            "subsumed-by" => Ok(Self::SubsumedBy),
            "subsumes" => Ok(Self::Subsumes),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConceptSubsumptionOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equivalent => "equivalent",
            Self::NotSubsumed => "not-subsumed",
            Self::SubsumedBy => "subsumed-by",
            Self::Subsumes => "subsumes",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ConceptSubsumptionOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Equivalent => "Equivalent",
            Self::NotSubsumed => "Not-Subsumed",
            Self::SubsumedBy => "Subsumed-By",
            Self::Subsumes => "Subsumes",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConceptSubsumptionOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptSubsumptionOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConceptSubsumptionOutcome> for Coding {
    fn from(code: ConceptSubsumptionOutcome) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/concept-subsumption-outcome".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConceptSubsumptionOutcome> for CodeableConcept {
    fn from(code: ConceptSubsumptionOutcome) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConditionPreconditionType](http://hl7.org/fhir/ValueSet/condition-precondition-type)**. Kind of precondition for the condition.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConditionPreconditionType {
    /** **sensitive**

Sensitive. The observation is very sensitive for the condition, but may also indicate other conditions. */
    Sensitive,
    /** **specific**

Specific. The observation is very specific for this condition, but not particularly sensitive. */
    Specific,
}
impl ::core::str::FromStr for ConditionPreconditionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "sensitive" => Ok(Self::Sensitive),
            "specific" => Ok(Self::Specific),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionPreconditionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Sensitive => "sensitive",
            Self::Specific => "specific",
        }
    }
}
impl ::std::fmt::Display for ConditionPreconditionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Sensitive => "Sensitive",
            Self::Specific => "Specific",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConditionPreconditionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionPreconditionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionPreconditionType> for Coding {
    fn from(code: ConditionPreconditionType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/condition-precondition-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConditionPreconditionType> for CodeableConcept {
    fn from(code: ConditionPreconditionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConditionQuestionnairePurpose](http://hl7.org/fhir/ValueSet/condition-questionnaire-purpose)**. The use of a questionnaire.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConditionQuestionnairePurpose {
    /** **diff-diagnosis**

Diff Diagnosis. A questionnaire that helps with diferential diagnosis. */
    DiffDiagnosis,
    /** **outcome**

Outcome. A questionnaire to check on outcomes for the patient. */
    Outcome,
    /** **preadmit**

Pre-admit. A pre-admit questionnaire. */
    Preadmit,
}
impl ::core::str::FromStr for ConditionQuestionnairePurpose {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "diff-diagnosis" => Ok(Self::DiffDiagnosis),
            "outcome" => Ok(Self::Outcome),
            "preadmit" => Ok(Self::Preadmit),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionQuestionnairePurpose {
    fn as_ref(&self) -> &str {
        match self {
            Self::DiffDiagnosis => "diff-diagnosis",
            Self::Outcome => "outcome",
            Self::Preadmit => "preadmit",
        }
    }
}
impl ::std::fmt::Display for ConditionQuestionnairePurpose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::DiffDiagnosis => "Diff Diagnosis",
            Self::Outcome => "Outcome",
            Self::Preadmit => "Pre-admit",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConditionQuestionnairePurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionQuestionnairePurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionQuestionnairePurpose> for Coding {
    fn from(code: ConditionQuestionnairePurpose) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/condition-questionnaire-purpose".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConditionQuestionnairePurpose> for CodeableConcept {
    fn from(code: ConditionQuestionnairePurpose) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConditionalDeleteStatus](http://hl7.org/fhir/ValueSet/conditional-delete-status)**. A code that indicates how the server supports conditional delete.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConditionalDeleteStatus {
    /** **multiple**

Multiple Deletes Supported. Conditional deletes are supported, and multiple resources can be deleted in a single interaction. */
    Multiple,
    /** **not-supported**

Not Supported. No support for conditional deletes. */
    NotSupported,
    /** **single**

Single Deletes Supported. Conditional deletes are supported, but only single resources at a time. */
    Single,
}
impl ::core::str::FromStr for ConditionalDeleteStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "multiple" => Ok(Self::Multiple),
            "not-supported" => Ok(Self::NotSupported),
            "single" => Ok(Self::Single),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionalDeleteStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Multiple => "multiple",
            Self::NotSupported => "not-supported",
            Self::Single => "single",
        }
    }
}
impl ::std::fmt::Display for ConditionalDeleteStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Multiple => "Multiple Deletes Supported",
            Self::NotSupported => "Not Supported",
            Self::Single => "Single Deletes Supported",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConditionalDeleteStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionalDeleteStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionalDeleteStatus> for Coding {
    fn from(code: ConditionalDeleteStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/conditional-delete-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConditionalDeleteStatus> for CodeableConcept {
    fn from(code: ConditionalDeleteStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConditionalReadStatus](http://hl7.org/fhir/ValueSet/conditional-read-status)**. A code that indicates how the server supports conditional read.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConditionalReadStatus {
    /** **full-support**

Full Support. Conditional reads are supported, with both If-Modified-Since and If-None-Match HTTP Headers. */
    FullSupport,
    /** **modified-since**

If-Modified-Since. Conditional reads are supported, but only with the If-Modified-Since HTTP Header. */
    ModifiedSince,
    /** **not-match**

If-None-Match. Conditional reads are supported, but only with the If-None-Match HTTP Header. */
    NotMatch,
    /** **not-supported**

Not Supported. No support for conditional reads. */
    NotSupported,
}
impl ::core::str::FromStr for ConditionalReadStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "full-support" => Ok(Self::FullSupport),
            "modified-since" => Ok(Self::ModifiedSince),
            "not-match" => Ok(Self::NotMatch),
            "not-supported" => Ok(Self::NotSupported),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionalReadStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::FullSupport => "full-support",
            Self::ModifiedSince => "modified-since",
            Self::NotMatch => "not-match",
            Self::NotSupported => "not-supported",
        }
    }
}
impl ::std::fmt::Display for ConditionalReadStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::FullSupport => "Full Support",
            Self::ModifiedSince => "If-Modified-Since",
            Self::NotMatch => "If-None-Match",
            Self::NotSupported => "Not Supported",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConditionalReadStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionalReadStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConditionalReadStatus> for Coding {
    fn from(code: ConditionalReadStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/conditional-read-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConditionalReadStatus> for CodeableConcept {
    fn from(code: ConditionalReadStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConformanceExpectation](http://hl7.org/fhir/ValueSet/conformance-expectation)**. ConformanceExpectation\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConformanceExpectation {
    /** **MAY**

MAY. Support for the specified capability is not necessary to be considered conformant, and the requirement should be considered strictly optional. */
    May,
    /** **SHALL**

SHALL. Support for the specified capability is required to be considered conformant. */
    Shall,
    /** **SHOULD**

SHOULD. Support for the specified capability is strongly encouraged, and failure to support it should only occur after careful consideration. */
    Should,
    /** **SHOULD-NOT**

SHOULD-NOT. Support for the specified capability is strongly discouraged and should occur only after careful consideration. */
    ShouldNot,
}
impl ::core::str::FromStr for ConformanceExpectation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "MAY" => Ok(Self::May),
            "SHALL" => Ok(Self::Shall),
            "SHOULD" => Ok(Self::Should),
            "SHOULD-NOT" => Ok(Self::ShouldNot),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConformanceExpectation {
    fn as_ref(&self) -> &str {
        match self {
            Self::May => "MAY",
            Self::Shall => "SHALL",
            Self::Should => "SHOULD",
            Self::ShouldNot => "SHOULD-NOT",
        }
    }
}
impl ::std::fmt::Display for ConformanceExpectation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::May => "MAY",
            Self::Shall => "SHALL",
            Self::Should => "SHOULD",
            Self::ShouldNot => "SHOULD-NOT",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConformanceExpectation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConformanceExpectation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConformanceExpectation> for Coding {
    fn from(code: ConformanceExpectation) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/conformance-expectation".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConformanceExpectation> for CodeableConcept {
    fn from(code: ConformanceExpectation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConsentDataMeaning](http://hl7.org/fhir/ValueSet/consent-data-meaning)**. How a resource reference is interpreted when testing consent restrictions.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConsentDataMeaning {
    /** **authoredby**

AuthoredBy. The consent applies to instances of resources that are authored by. */
    Authoredby,
    /** **dependents**

Dependents. The consent applies directly to the instance of the resource and instances that refer to it. */
    Dependents,
    /** **instance**

Instance. The consent applies directly to the instance of the resource. */
    Instance,
    /** **related**

Related. The consent applies directly to the instance of the resource and instances it refers to. */
    Related,
}
impl ::core::str::FromStr for ConsentDataMeaning {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "authoredby" => Ok(Self::Authoredby),
            "dependents" => Ok(Self::Dependents),
            "instance" => Ok(Self::Instance),
            "related" => Ok(Self::Related),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentDataMeaning {
    fn as_ref(&self) -> &str {
        match self {
            Self::Authoredby => "authoredby",
            Self::Dependents => "dependents",
            Self::Instance => "instance",
            Self::Related => "related",
        }
    }
}
impl ::std::fmt::Display for ConsentDataMeaning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Authoredby => "AuthoredBy",
            Self::Dependents => "Dependents",
            Self::Instance => "Instance",
            Self::Related => "Related",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConsentDataMeaning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentDataMeaning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentDataMeaning> for Coding {
    fn from(code: ConsentDataMeaning) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/consent-data-meaning".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConsentDataMeaning> for CodeableConcept {
    fn from(code: ConsentDataMeaning) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConsentProvisionType](http://hl7.org/fhir/ValueSet/consent-provision-type)**. How a rule statement is applied, such as adding additional consent or removing consent.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConsentProvisionType {
    /** **deny**

Deny. Consent is denied for actions meeting these rules. */
    Deny,
    /** **permit**

Permit. Consent is provided for actions meeting these rules. */
    Permit,
}
impl ::core::str::FromStr for ConsentProvisionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deny" => Ok(Self::Deny),
            "permit" => Ok(Self::Permit),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentProvisionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deny => "deny",
            Self::Permit => "permit",
        }
    }
}
impl ::std::fmt::Display for ConsentProvisionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Deny => "Deny",
            Self::Permit => "Permit",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConsentProvisionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentProvisionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentProvisionType> for Coding {
    fn from(code: ConsentProvisionType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/consent-provision-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConsentProvisionType> for CodeableConcept {
    fn from(code: ConsentProvisionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConsentState](http://hl7.org/fhir/ValueSet/consent-state-codes)**. Indicates the state of the consent.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConsentState {
    /** **active**

Active. The consent is to be followed and enforced. */
    Active,
    /** **draft**

Pending. The consent is in development or awaiting use but is not yet intended to be acted upon. */
    Draft,
    /** **entered-in-error**

Entered in Error. The consent was created wrongly (e.g. wrong patient) and should be ignored. */
    EnteredInError,
    /** **inactive**

Inactive. The consent is terminated or replaced. */
    Inactive,
    /** **not-done**

Abandoned. The consent development has been terminated prior to completion. */
    NotDone,
    /** **unknown**

Unknown. The resource is in an indeterminate state. */
    Unknown,
}
impl ::core::str::FromStr for ConsentState {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "not-done" => Ok(Self::NotDone),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::NotDone => "not-done",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for ConsentState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Draft => "Pending",
            Self::EnteredInError => "Entered in Error",
            Self::Inactive => "Inactive",
            Self::NotDone => "Abandoned",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConsentState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConsentState> for Coding {
    fn from(code: ConsentState) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/consent-state-codes".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConsentState> for CodeableConcept {
    fn from(code: ConsentState) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ConstraintSeverity](http://hl7.org/fhir/ValueSet/constraint-severity)**. SHALL applications comply with this constraint?\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConstraintSeverity {
    /** **error**

Error. If the constraint is violated, the resource is not conformant. */
    Error,
    /** **warning**

Warning. If the constraint is violated, the resource is conformant, but it is not necessarily following best practice. */
    Warning,
}
impl ::core::str::FromStr for ConstraintSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConstraintSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Display for ConstraintSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Error => "Error",
            Self::Warning => "Warning",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ConstraintSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConstraintSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ConstraintSeverity> for Coding {
    fn from(code: ConstraintSeverity) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/constraint-severity".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ConstraintSeverity> for CodeableConcept {
    fn from(code: ConstraintSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContactPointSystem](http://hl7.org/fhir/ValueSet/contact-point-system)**. Telecommunications form for contact point.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContactPointSystem {
    /** **email**

Email. The value is an email address. */
    Email,
    /** **fax**

Fax. The value is a fax machine. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required. */
    Fax,
    /** **other**

Other. A contact that is not a phone, fax, page or email address and is not expressible as a URL.  E.g. Internal mail address.  This SHOULD NOT be used for contacts that are expressible as a URL (e.g. Skype, Twitter, Facebook, etc.)  Extensions may be used to distinguish "other" contact types. */
    Other,
    /** **pager**

Pager. The value is a pager number. These may be local pager numbers that are only usable on a particular pager system. */
    Pager,
    /** **phone**

Phone. The value is a telephone number used for voice calls. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required. */
    Phone,
    /** **sms**

SMS. A contact that can be used for sending a sms message (e.g. mobile phones, some landlines). */
    Sms,
    /** **url**

URL. A contact that is not a phone, fax, pager or email address and is expressed as a URL.  This is intended for various institutional or personal contacts including web sites, blogs, Skype, Twitter, Facebook, etc. Do not use for email addresses. */
    Url,
}
impl ::core::str::FromStr for ContactPointSystem {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "email" => Ok(Self::Email),
            "fax" => Ok(Self::Fax),
            "other" => Ok(Self::Other),
            "pager" => Ok(Self::Pager),
            "phone" => Ok(Self::Phone),
            "sms" => Ok(Self::Sms),
            "url" => Ok(Self::Url),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContactPointSystem {
    fn as_ref(&self) -> &str {
        match self {
            Self::Email => "email",
            Self::Fax => "fax",
            Self::Other => "other",
            Self::Pager => "pager",
            Self::Phone => "phone",
            Self::Sms => "sms",
            Self::Url => "url",
        }
    }
}
impl ::std::fmt::Display for ContactPointSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Email => "Email",
            Self::Fax => "Fax",
            Self::Other => "Other",
            Self::Pager => "Pager",
            Self::Phone => "Phone",
            Self::Sms => "SMS",
            Self::Url => "URL",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContactPointSystem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactPointSystem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContactPointSystem> for Coding {
    fn from(code: ContactPointSystem) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/contact-point-system".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContactPointSystem> for CodeableConcept {
    fn from(code: ContactPointSystem) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContactPointUse](http://hl7.org/fhir/ValueSet/contact-point-use)**. Use of contact point.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContactPointUse {
    /** **home**

Home. A communication contact point at a home; attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available. */
    Home,
    /** **mobile**

Mobile. A telecommunication device that moves and stays with its owner. May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business. */
    Mobile,
    /** **old**

Old. This contact point is no longer in use (or was never correct, but retained for records). */
    Old,
    /** **temp**

Temp. A temporary contact point. The period can provide more detailed information. */
    Temp,
    /** **work**

Work. An office contact point. First choice for business related contacts during business hours. */
    Work,
}
impl ::core::str::FromStr for ContactPointUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "home" => Ok(Self::Home),
            "mobile" => Ok(Self::Mobile),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "work" => Ok(Self::Work),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContactPointUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Home => "home",
            Self::Mobile => "mobile",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Work => "work",
        }
    }
}
impl ::std::fmt::Display for ContactPointUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Home => "Home",
            Self::Mobile => "Mobile",
            Self::Old => "Old",
            Self::Temp => "Temp",
            Self::Work => "Work",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContactPointUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactPointUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContactPointUse> for Coding {
    fn from(code: ContactPointUse) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/contact-point-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContactPointUse> for CodeableConcept {
    fn from(code: ContactPointUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractActionStatus](http://hl7.org/fhir/contract-action-status)**. This CodeSystem contains FHIR-defined contract action status types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractActionStatus {
    /** **complete**

Complete. To be completed */
    Complete,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractActionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractActionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractActionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Complete => "Complete",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractActionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractActionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractActionStatus> for Coding {
    fn from(code: ContractActionStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-action-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractActionStatus> for CodeableConcept {
    fn from(code: ContractActionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractAssetAvailability](http://hl7.org/fhir/asset-availability)**. This CodeSystem contains FHIR-defined contract asset availability types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetAvailability {
    /** **lease**

Lease. To be completed */
    Lease,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetAvailability {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "lease" => Ok(Self::Lease),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetAvailability {
    fn as_ref(&self) -> &str {
        match self {
            Self::Lease => "lease",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractAssetAvailability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Lease => "Lease",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractAssetAvailability {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetAvailability {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetAvailability> for Coding {
    fn from(code: ContractAssetAvailability) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/asset-availability".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractAssetAvailability> for CodeableConcept {
    fn from(code: ContractAssetAvailability) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractAssetContext](http://hl7.org/fhir/contract-asset-context)**. This CodeSystem contains FHIR-defined contract asset context types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetContext {
    /** **custodian**

Custodian. To be completed */
    Custodian,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetContext {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "custodian" => Ok(Self::Custodian),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetContext {
    fn as_ref(&self) -> &str {
        match self {
            Self::Custodian => "custodian",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractAssetContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Custodian => "Custodian",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractAssetContext {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetContext {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetContext> for Coding {
    fn from(code: ContractAssetContext) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-asset-context".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractAssetContext> for CodeableConcept {
    fn from(code: ContractAssetContext) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractAssetScope](http://hl7.org/fhir/contract-asset-scope)**. This CodeSystem contains FHIR-defined contract asset scope types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetScope {
    /** **thing**

Thing. To be completed */
    Thing,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetScope {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "thing" => Ok(Self::Thing),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetScope {
    fn as_ref(&self) -> &str {
        match self {
            Self::Thing => "thing",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractAssetScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Thing => "Thing",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractAssetScope {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetScope {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetScope> for Coding {
    fn from(code: ContractAssetScope) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-asset-scope".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractAssetScope> for CodeableConcept {
    fn from(code: ContractAssetScope) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractAssetSubtype](http://hl7.org/fhir/contract-asset-subtype)**. This CodeSystem contains FHIR-defined contract asset type sub-types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetSubtype {
    /** **participation**

Participation. To be completed */
    Participation,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetSubtype {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "participation" => Ok(Self::Participation),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetSubtype {
    fn as_ref(&self) -> &str {
        match self {
            Self::Participation => "participation",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractAssetSubtype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Participation => "Participation",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractAssetSubtype {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetSubtype {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetSubtype> for Coding {
    fn from(code: ContractAssetSubtype) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-asset-subtype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractAssetSubtype> for CodeableConcept {
    fn from(code: ContractAssetSubtype) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractAssetType](http://hl7.org/fhir/contract-asset-type)**. This CodeSystem contains FHIR-defined contract asset type types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetType {
    /** **participation**

Participation. To be completed */
    Participation,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "participation" => Ok(Self::Participation),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Participation => "participation",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractAssetType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Participation => "Participation",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractAssetType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractAssetType> for Coding {
    fn from(code: ContractAssetType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-asset-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractAssetType> for CodeableConcept {
    fn from(code: ContractAssetType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractDecisionMode](http://hl7.org/fhir/contract-decision-mode)**. This CodeSystem contains FHIR-defined contract decision mode types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractDecisionMode {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractDecisionMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractDecisionMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractDecisionMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Policy => "Policy",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractDecisionMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractDecisionMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractDecisionMode> for Coding {
    fn from(code: ContractDecisionMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-decision-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractDecisionMode> for CodeableConcept {
    fn from(code: ContractDecisionMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractDefinitionSubtype](http://hl7.org/fhir/contract-definition-subtype)**. This CodeSystem contains FHIR-defined contract definition subtypes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractDefinitionSubtype {
    /** **temp**

Temporary Value. To be completed */
    Temp,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractDefinitionSubtype {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "temp" => Ok(Self::Temp),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractDefinitionSubtype {
    fn as_ref(&self) -> &str {
        match self {
            Self::Temp => "temp",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractDefinitionSubtype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Temp => "Temporary Value",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractDefinitionSubtype {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractDefinitionSubtype {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractDefinitionSubtype> for Coding {
    fn from(code: ContractDefinitionSubtype) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-definition-subtype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractDefinitionSubtype> for CodeableConcept {
    fn from(code: ContractDefinitionSubtype) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractDefinitionType](http://hl7.org/fhir/contract-definition-type)**. This CodeSystem contains FHIR-defined contract definition types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractDefinitionType {
    /** **temp**

Temporary Value. To be completed */
    Temp,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractDefinitionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "temp" => Ok(Self::Temp),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractDefinitionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Temp => "temp",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractDefinitionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Temp => "Temporary Value",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractDefinitionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractDefinitionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractDefinitionType> for Coding {
    fn from(code: ContractDefinitionType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-definition-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractDefinitionType> for CodeableConcept {
    fn from(code: ContractDefinitionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractExpirationType](http://hl7.org/fhir/contract-expiration-type)**. This CodeSystem contains FHIR-defined contract Expiration types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractExpirationType {
    /** **breach**

Breach. To be completed */
    Breach,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractExpirationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "breach" => Ok(Self::Breach),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractExpirationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Breach => "breach",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractExpirationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Breach => "Breach",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractExpirationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractExpirationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractExpirationType> for Coding {
    fn from(code: ContractExpirationType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-expiration-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractExpirationType> for CodeableConcept {
    fn from(code: ContractExpirationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractLegalState](http://hl7.org/fhir/contract-legalstate)**. This CodeSystem contains FHIR-defined contract status types. Each definition includes usage notes explaining the precedence order in contract lifecycle - i.e., while only some stages are required, the order in which they may occur is deterministic; and a map to comparable FHIR and v.3 status codes. It follows guidance about use of status codes in FHIR in the [Status Codes Grid](sc.html).\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractLegalState {
    /** **amended**

Amended. Contract is augmented with additional information to correct errors in a predecessor or to updated values in a predecessor. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: revised; replaced. */
    Amended,
    /** **appended**

Appended. Contract is augmented with additional information that was missing from a predecessor Contract. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: updated, replaced. */
    Appended,
    /** **cancelled**

Cancelled. Contract is terminated due to failure of the Grantor and/or the Grantee to fulfil one or more contract provisions. Usage: Abnormal contract termination. Precedence Order = 10. Comparable FHIR and v.3 status codes: stopped; failed; aborted. */
    Cancelled,
    /** **disputed**

Disputed. Contract is pended to rectify failure of the Grantor or the Grantee to fulfil contract provision(s). E.g., Grantee complaint about Grantor's failure to comply with contract provisions. Usage: Contract pended. Precedence Order = 7. Comparable FHIR and v.3 status codes: on hold; pended; suspended. */
    Disputed,
    /** **entered-in-error**

Entered in Error. Contract was created in error. No Precedence Order.  Status may be applied to a Contract with any status. */
    EnteredInError,
    /** **executable**

Executable. Contract execution pending; may be executed when either the Grantor or the Grantee accepts the contract provisions by signing. I.e., where either the Grantor or the Grantee has signed, but not both. E.g., when an insurance applicant signs the insurers application, which references the policy. Usage: Optional first step of contract execution activity.  May be skipped and contracting activity moves directly to executed state. Precedence Order = 3. Comparable FHIR and v.3 status codes: draft; preliminary; planned; intended; active. */
    Executable,
    /** **executed**

Executed. Contract is activated for period stipulated when both the Grantor and Grantee have signed it. Usage: Required state for normal completion of contracting activity.  Precedence Order = 6. Comparable FHIR and v.3 status codes: accepted; completed. */
    Executed,
    /** **negotiable**

Negotiable. Contract execution is suspended while either or both the Grantor and Grantee propose and consider new or revised contract provisions. I.e., where the party which has not signed proposes changes to the terms.  E .g., a life insurer declines to agree to the signed application because the life insurer has evidence that the applicant, who asserted to being younger or a non-smoker to get a lower premium rate - but offers instead to agree to a higher premium based on the applicants actual age or smoking status. Usage: Optional contract activity between executable and executed state. Precedence Order = 4. Comparable FHIR and v.3 status codes: in progress; review; held. */
    Negotiable,
    /** **offered**

Offered. Contract is a proposal by either the Grantor or the Grantee. Aka - A Contract hard copy or electronic 'template', 'form' or 'application'. E.g., health insurance application; consent directive form. Usage: Beginning of contract negotiation, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 2. Comparable FHIR and v.3 status codes: requested; new. */
    Offered,
    /** **policy**

Policy. Contract template is available as the basis for an application or offer by the Grantor or Grantee. E.g., health insurance policy; consent directive policy.  Usage: Required initial contract activity, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 1. Comparable FHIR and v.3 status codes: proposed; intended. */
    Policy,
    /** **rejected**

Rejected.  Execution of the Contract is not completed because either or both the Grantor and Grantee decline to accept some or all of the contract provisions. Usage: Optional contract activity between executable and abnormal termination. Precedence Order = 5. Comparable FHIR and v.3 status codes:  stopped; cancelled. */
    Rejected,
    /** **renewed**

Renewed. Beginning of a successor Contract at the termination of predecessor Contract lifecycle. Usage: Follows termination of a preceding Contract that has reached its expiry date. Precedence Order = 13. Comparable FHIR and v.3 status codes: superseded. */
    Renewed,
    /** **resolved**

Resolved. Contract is reactivated after being pended because of faulty execution. *E.g., competency of the signer(s), or where the policy is substantially different from and did not accompany the application/form so that the applicant could not compare them. Aka - ''reactivated''. Usage: Optional stage where a pended contract is reactivated. Precedence Order = 8. Comparable FHIR and v.3 status codes: reactivated. */
    Resolved,
    /** **revoked**

Revoked. A Contract that is rescinded.  May be required prior to replacing with an updated Contract. Comparable FHIR and v.3 status codes: nullified. */
    Revoked,
    /** **terminated**

Terminated. Contract reaches its expiry date. It might or might not be renewed or renegotiated. Usage: Normal end of contract period. Precedence Order = 12. Comparable FHIR and v.3 status codes: Obsoleted. */
    Terminated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractLegalState {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "disputed" => Ok(Self::Disputed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "executable" => Ok(Self::Executable),
            "executed" => Ok(Self::Executed),
            "negotiable" => Ok(Self::Negotiable),
            "offered" => Ok(Self::Offered),
            "policy" => Ok(Self::Policy),
            "rejected" => Ok(Self::Rejected),
            "renewed" => Ok(Self::Renewed),
            "resolved" => Ok(Self::Resolved),
            "revoked" => Ok(Self::Revoked),
            "terminated" => Ok(Self::Terminated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractLegalState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Disputed => "disputed",
            Self::EnteredInError => "entered-in-error",
            Self::Executable => "executable",
            Self::Executed => "executed",
            Self::Negotiable => "negotiable",
            Self::Offered => "offered",
            Self::Policy => "policy",
            Self::Rejected => "rejected",
            Self::Renewed => "renewed",
            Self::Resolved => "resolved",
            Self::Revoked => "revoked",
            Self::Terminated => "terminated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractLegalState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Amended => "Amended",
            Self::Appended => "Appended",
            Self::Cancelled => "Cancelled",
            Self::Disputed => "Disputed",
            Self::EnteredInError => "Entered in Error",
            Self::Executable => "Executable",
            Self::Executed => "Executed",
            Self::Negotiable => "Negotiable",
            Self::Offered => "Offered",
            Self::Policy => "Policy",
            Self::Rejected => "Rejected",
            Self::Renewed => "Renewed",
            Self::Resolved => "Resolved",
            Self::Revoked => "Revoked",
            Self::Terminated => "Terminated",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractLegalState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractLegalState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractLegalState> for Coding {
    fn from(code: ContractLegalState) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-legalstate".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractLegalState> for CodeableConcept {
    fn from(code: ContractLegalState) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractPartyRole](http://hl7.org/fhir/contract-party-role)**. This CodeSystem contains FHIR-defined contract party role types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractPartyRole {
    /** **flunky**

FLunky. To be completed */
    Flunky,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractPartyRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "flunky" => Ok(Self::Flunky),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractPartyRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Flunky => "flunky",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractPartyRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Flunky => "FLunky",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractPartyRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractPartyRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractPartyRole> for Coding {
    fn from(code: ContractPartyRole) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-party-role".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractPartyRole> for CodeableConcept {
    fn from(code: ContractPartyRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractPublicationStatus](http://hl7.org/fhir/contract-publicationstatus)**. This CodeSystem contains FHIR-defined contract publication status types. Each definition includes usage notes explaining the precedence order in contract publication lifecycle - i.e., while only some stages are required, the order in which they may occur is deterministic.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractPublicationStatus {
    /** **amended**

Amended. Contract is augmented with additional information to correct errors in a predecessor or to updated values in a predecessor. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: revised; replaced. */
    Amended,
    /** **appended**

Appended. Contract is augmented with additional information that was missing from a predecessor Contract. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: updated, replaced. */
    Appended,
    /** **cancelled**

Cancelled. Contract is terminated due to failure of the Grantor and/or the Grantee to fulfil one or more contract provisions. Usage: Abnormal contract termination. Precedence Order = 10. Comparable FHIR and v.3 status codes: stopped; failed; aborted. */
    Cancelled,
    /** **disputed**

Disputed. Contract is pended to rectify failure of the Grantor or the Grantee to fulfil contract provision(s). E.g., Grantee complaint about Grantor's failure to comply with contract provisions. Usage: Contract pended. Precedence Order = 7. Comparable FHIR and v.3 status codes: on hold; pended; suspended. */
    Disputed,
    /** **entered-in-error**

Entered in Error. Contract was created in error. No Precedence Order.  Status may be applied to a Contract with any status. */
    EnteredInError,
    /** **executable**

Executable. Contract execution pending; may be executed when either the Grantor or the Grantee accepts the contract provisions by signing. I.e., where either the Grantor or the Grantee has signed, but not both. E.g., when an insurance applicant signs the insurers application, which references the policy. Usage: Optional first step of contract execution activity.  May be skipped and contracting activity moves directly to executed state. Precedence Order = 3. Comparable FHIR and v.3 status codes: draft; preliminary; planned; intended; active. */
    Executable,
    /** **executed**

Executed. Contract is activated for period stipulated when both the Grantor and Grantee have signed it. Usage: Required state for normal completion of contracting activity.  Precedence Order = 6. Comparable FHIR and v.3 status codes: accepted; completed. */
    Executed,
    /** **negotiable**

Negotiable. Contract execution is suspended while either or both the Grantor and Grantee propose and consider new or revised contract provisions. I.e., where the party which has not signed proposes changes to the terms.  E .g., a life insurer declines to agree to the signed application because the life insurer has evidence that the applicant, who asserted to being younger or a non-smoker to get a lower premium rate - but offers instead to agree to a higher premium based on the applicants actual age or smoking status. Usage: Optional contract activity between executable and executed state. Precedence Order = 4. Comparable FHIR and v.3 status codes: in progress; review; held. */
    Negotiable,
    /** **offered**

Offered. Contract is a proposal by either the Grantor or the Grantee. Aka - A Contract hard copy or electronic 'template', 'form' or 'application'. E.g., health insurance application; consent directive form. Usage: Beginning of contract negotiation, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 2. Comparable FHIR and v.3 status codes: requested; new. */
    Offered,
    /** **policy**

Policy. Contract template is available as the basis for an application or offer by the Grantor or Grantee. E.g., health insurance policy; consent directive policy.  Usage: Required initial contract activity, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 1. Comparable FHIR and v.3 status codes: proposed; intended. */
    Policy,
    /** **rejected**

Rejected.  Execution of the Contract is not completed because either or both the Grantor and Grantee decline to accept some or all of the contract provisions. Usage: Optional contract activity between executable and abnormal termination. Precedence Order = 5. Comparable FHIR and v.3 status codes:  stopped; cancelled. */
    Rejected,
    /** **renewed**

Renewed. Beginning of a successor Contract at the termination of predecessor Contract lifecycle. Usage: Follows termination of a preceding Contract that has reached its expiry date. Precedence Order = 13. Comparable FHIR and v.3 status codes: superseded. */
    Renewed,
    /** **resolved**

Resolved. Contract is reactivated after being pended because of faulty execution. *E.g., competency of the signer(s), or where the policy is substantially different from and did not accompany the application/form so that the applicant could not compare them. Aka - ''reactivated''. Usage: Optional stage where a pended contract is reactivated. Precedence Order = 8. Comparable FHIR and v.3 status codes: reactivated. */
    Resolved,
    /** **revoked**

Revoked. A Contract that is rescinded.  May be required prior to replacing with an updated Contract. Comparable FHIR and v.3 status codes: nullified. */
    Revoked,
    /** **terminated**

Terminated. Contract reaches its expiry date. It might or might not be renewed or renegotiated. Usage: Normal end of contract period. Precedence Order = 12. Comparable FHIR and v.3 status codes: Obsoleted. */
    Terminated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractPublicationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "disputed" => Ok(Self::Disputed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "executable" => Ok(Self::Executable),
            "executed" => Ok(Self::Executed),
            "negotiable" => Ok(Self::Negotiable),
            "offered" => Ok(Self::Offered),
            "policy" => Ok(Self::Policy),
            "rejected" => Ok(Self::Rejected),
            "renewed" => Ok(Self::Renewed),
            "resolved" => Ok(Self::Resolved),
            "revoked" => Ok(Self::Revoked),
            "terminated" => Ok(Self::Terminated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractPublicationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Disputed => "disputed",
            Self::EnteredInError => "entered-in-error",
            Self::Executable => "executable",
            Self::Executed => "executed",
            Self::Negotiable => "negotiable",
            Self::Offered => "offered",
            Self::Policy => "policy",
            Self::Rejected => "rejected",
            Self::Renewed => "renewed",
            Self::Resolved => "resolved",
            Self::Revoked => "revoked",
            Self::Terminated => "terminated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractPublicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Amended => "Amended",
            Self::Appended => "Appended",
            Self::Cancelled => "Cancelled",
            Self::Disputed => "Disputed",
            Self::EnteredInError => "Entered in Error",
            Self::Executable => "Executable",
            Self::Executed => "Executed",
            Self::Negotiable => "Negotiable",
            Self::Offered => "Offered",
            Self::Policy => "Policy",
            Self::Rejected => "Rejected",
            Self::Renewed => "Renewed",
            Self::Resolved => "Resolved",
            Self::Revoked => "Revoked",
            Self::Terminated => "Terminated",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractPublicationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractPublicationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractPublicationStatus> for Coding {
    fn from(code: ContractPublicationStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-publicationstatus".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractPublicationStatus> for CodeableConcept {
    fn from(code: ContractPublicationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractScope](http://hl7.org/fhir/contract-scope)**. This CodeSystem contains FHIR-defined contract Expiration types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractScope {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractScope {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractScope {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Policy => "Policy",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractScope {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractScope {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractScope> for Coding {
    fn from(code: ContractScope) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-scope".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractScope> for CodeableConcept {
    fn from(code: ContractScope) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractSecurityCategory](http://hl7.org/fhir/contract-security-category)**. This CodeSystem contains FHIR-defined contract security category types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractSecurityCategory {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSecurityCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSecurityCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractSecurityCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Policy => "Policy",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractSecurityCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSecurityCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractSecurityCategory> for Coding {
    fn from(code: ContractSecurityCategory) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-security-category".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractSecurityCategory> for CodeableConcept {
    fn from(code: ContractSecurityCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractSecurityClassification](http://hl7.org/fhir/contract-security-classification)**. This CodeSystem contains FHIR-defined contract security classification types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractSecurityClassification {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSecurityClassification {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSecurityClassification {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractSecurityClassification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Policy => "Policy",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractSecurityClassification {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSecurityClassification {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractSecurityClassification> for Coding {
    fn from(code: ContractSecurityClassification) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-security-classification".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractSecurityClassification> for CodeableConcept {
    fn from(code: ContractSecurityClassification) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractSecurityControl](http://hl7.org/fhir/contract-security-control)**. This CodeSystem contains FHIR-defined contract security control types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractSecurityControl {
    /** **policy**

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSecurityControl {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSecurityControl {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractSecurityControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Policy => "Policy",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractSecurityControl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSecurityControl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractSecurityControl> for Coding {
    fn from(code: ContractSecurityControl) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-security-control".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractSecurityControl> for CodeableConcept {
    fn from(code: ContractSecurityControl) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContractStatus](http://hl7.org/fhir/contract-status)**. This CodeSystem contains FHIR-defined contract status types. Each definition includes usage notes explaining the precedence order in contract lifecycle - i.e., while only some stages are required, the order in which they may occur is deterministic; and a map to comparable FHIR and v.3 status codes. It follows guidance about use of status codes in FHIR in [the Status Codes Grid](sc.html).\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractStatus {
    /** **amended**

Amended. Contract is augmented with additional information to correct errors in a predecessor or to updated values in a predecessor. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: revised; replaced. */
    Amended,
    /** **appended**

Appended. Contract is augmented with additional information that was missing from a predecessor Contract. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: updated, replaced. */
    Appended,
    /** **cancelled**

Cancelled. Contract is terminated due to failure of the Grantor and/or the Grantee to fulfil one or more contract provisions. Usage: Abnormal contract termination. Precedence Order = 10. Comparable FHIR and v.3 status codes: stopped; failed; aborted. */
    Cancelled,
    /** **disputed**

Disputed. Contract is pended to rectify failure of the Grantor or the Grantee to fulfil contract provision(s). E.g., Grantee complaint about Grantor's failure to comply with contract provisions. Usage: Contract pended. Precedence Order = 7. Comparable FHIR and v.3 status codes: on hold; pended; suspended. */
    Disputed,
    /** **entered-in-error**

Entered in Error. Contract was created in error. No Precedence Order.  Status may be applied to a Contract with any status. */
    EnteredInError,
    /** **executable**

Executable. Contract execution pending; may be executed when either the Grantor or the Grantee accepts the contract provisions by signing. I.e., where either the Grantor or the Grantee has signed, but not both. E.g., when an insurance applicant signs the insurers application, which references the policy. Usage: Optional first step of contract execution activity.  May be skipped and contracting activity moves directly to executed state. Precedence Order = 3. Comparable FHIR and v.3 status codes: draft; preliminary; planned; intended; active. */
    Executable,
    /** **executed**

Executed. Contract is activated for period stipulated when both the Grantor and Grantee have signed it. Usage: Required state for normal completion of contracting activity.  Precedence Order = 6. Comparable FHIR and v.3 status codes: accepted; completed. */
    Executed,
    /** **negotiable**

Negotiable. Contract execution is suspended while either or both the Grantor and Grantee propose and consider new or revised contract provisions. I.e., where the party which has not signed proposes changes to the terms.  E .g., a life insurer declines to agree to the signed application because the life insurer has evidence that the applicant, who asserted to being younger or a non-smoker to get a lower premium rate - but offers instead to agree to a higher premium based on the applicants actual age or smoking status. Usage: Optional contract activity between executable and executed state. Precedence Order = 4. Comparable FHIR and v.3 status codes: in progress; review; held. */
    Negotiable,
    /** **offered**

Offered. Contract is a proposal by either the Grantor or the Grantee. Aka - A Contract hard copy or electronic 'template', 'form' or 'application'. E.g., health insurance application; consent directive form. Usage: Beginning of contract negotiation, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 2. Comparable FHIR and v.3 status codes: requested; new. */
    Offered,
    /** **policy**

Policy. Contract template is available as the basis for an application or offer by the Grantor or Grantee. E.g., health insurance policy; consent directive policy.  Usage: Required initial contract activity, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 1. Comparable FHIR and v.3 status codes: proposed; intended. */
    Policy,
    /** **rejected**

Rejected.  Execution of the Contract is not completed because either or both the Grantor and Grantee decline to accept some or all of the contract provisions. Usage: Optional contract activity between executable and abnormal termination. Precedence Order = 5. Comparable FHIR and v.3 status codes:  stopped; cancelled. */
    Rejected,
    /** **renewed**

Renewed. Beginning of a successor Contract at the termination of predecessor Contract lifecycle. Usage: Follows termination of a preceding Contract that has reached its expiry date. Precedence Order = 13. Comparable FHIR and v.3 status codes: superseded. */
    Renewed,
    /** **resolved**

Resolved. Contract is reactivated after being pended because of faulty execution. *E.g., competency of the signer(s), or where the policy is substantially different from and did not accompany the application/form so that the applicant could not compare them. Aka - ''reactivated''. Usage: Optional stage where a pended contract is reactivated. Precedence Order = 8. Comparable FHIR and v.3 status codes: reactivated. */
    Resolved,
    /** **revoked**

Revoked. A Contract that is rescinded.  May be required prior to replacing with an updated Contract. Comparable FHIR and v.3 status codes: nullified. */
    Revoked,
    /** **terminated**

Terminated. Contract reaches its expiry date. It might or might not be renewed or renegotiated. Usage: Normal end of contract period. Precedence Order = 12. Comparable FHIR and v.3 status codes: Obsoleted. */
    Terminated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "disputed" => Ok(Self::Disputed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "executable" => Ok(Self::Executable),
            "executed" => Ok(Self::Executed),
            "negotiable" => Ok(Self::Negotiable),
            "offered" => Ok(Self::Offered),
            "policy" => Ok(Self::Policy),
            "rejected" => Ok(Self::Rejected),
            "renewed" => Ok(Self::Renewed),
            "resolved" => Ok(Self::Resolved),
            "revoked" => Ok(Self::Revoked),
            "terminated" => Ok(Self::Terminated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Disputed => "disputed",
            Self::EnteredInError => "entered-in-error",
            Self::Executable => "executable",
            Self::Executed => "executed",
            Self::Negotiable => "negotiable",
            Self::Offered => "offered",
            Self::Policy => "policy",
            Self::Rejected => "rejected",
            Self::Renewed => "renewed",
            Self::Resolved => "resolved",
            Self::Revoked => "revoked",
            Self::Terminated => "terminated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ContractStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Amended => "Amended",
            Self::Appended => "Appended",
            Self::Cancelled => "Cancelled",
            Self::Disputed => "Disputed",
            Self::EnteredInError => "Entered in Error",
            Self::Executable => "Executable",
            Self::Executed => "Executed",
            Self::Negotiable => "Negotiable",
            Self::Offered => "Offered",
            Self::Policy => "Policy",
            Self::Rejected => "Rejected",
            Self::Renewed => "Renewed",
            Self::Resolved => "Resolved",
            Self::Revoked => "Revoked",
            Self::Terminated => "Terminated",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContractStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContractStatus> for Coding {
    fn from(code: ContractStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/contract-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContractStatus> for CodeableConcept {
    fn from(code: ContractStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContributorRole](http://hl7.org/fhir/ValueSet/contributor-role)**. Used to code the format of the display string.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorRole {
    /** **author**

Author/Creator. An entity primarily responsible for making the resource, often called author or creator */
    Author,
    /** **editor**

Editor. Entity that revises or has authority to control the content */
    Editor,
    /** **endorser**

Endorser. Entity that supports, approves, or advocates for the content */
    Endorser,
    /** **funder**

Funder. Entity that supplies financial support */
    Funder,
    /** **informant**

Informant. Entity that supplies information */
    Informant,
    /** **publisher**

Publisher. Entity that makes the content available for public use */
    Publisher,
    /** **reviewer**

Reviewer. Entity that examines the content, formally or informally, and suggests revisions or comments */
    Reviewer,
}
impl ::core::str::FromStr for ContributorRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "author" => Ok(Self::Author),
            "editor" => Ok(Self::Editor),
            "endorser" => Ok(Self::Endorser),
            "funder" => Ok(Self::Funder),
            "informant" => Ok(Self::Informant),
            "publisher" => Ok(Self::Publisher),
            "reviewer" => Ok(Self::Reviewer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Author => "author",
            Self::Editor => "editor",
            Self::Endorser => "endorser",
            Self::Funder => "funder",
            Self::Informant => "informant",
            Self::Publisher => "publisher",
            Self::Reviewer => "reviewer",
        }
    }
}
impl ::std::fmt::Display for ContributorRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Author => "Author/Creator",
            Self::Editor => "Editor",
            Self::Endorser => "Endorser",
            Self::Funder => "Funder",
            Self::Informant => "Informant",
            Self::Publisher => "Publisher",
            Self::Reviewer => "Reviewer",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContributorRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorRole> for Coding {
    fn from(code: ContributorRole) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/contributor-role".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContributorRole> for CodeableConcept {
    fn from(code: ContributorRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContributorSummarySource](http://hl7.org/fhir/ValueSet/contributor-summary-source)**. Used to code the producer or rule for creating the display string.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorSummarySource {
    /** **article-copy**

Copied from article. Data copied by human from article text. */
    ArticleCopy,
    /** **citation-manager**

Reported by citation manager. Data copied by machine from citation manager data. */
    CitationManager,
    /** **custom**

custom format. Custom format (may be described in text note). */
    Custom,
    /** **publisher-data**

Publisher provided. Data copied by machine from publisher data. */
    PublisherData,
}
impl ::core::str::FromStr for ContributorSummarySource {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "article-copy" => Ok(Self::ArticleCopy),
            "citation-manager" => Ok(Self::CitationManager),
            "custom" => Ok(Self::Custom),
            "publisher-data" => Ok(Self::PublisherData),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorSummarySource {
    fn as_ref(&self) -> &str {
        match self {
            Self::ArticleCopy => "article-copy",
            Self::CitationManager => "citation-manager",
            Self::Custom => "custom",
            Self::PublisherData => "publisher-data",
        }
    }
}
impl ::std::fmt::Display for ContributorSummarySource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ArticleCopy => "Copied from article",
            Self::CitationManager => "Reported by citation manager",
            Self::Custom => "custom format",
            Self::PublisherData => "Publisher provided",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContributorSummarySource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorSummarySource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorSummarySource> for Coding {
    fn from(code: ContributorSummarySource) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/contributor-summary-source".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContributorSummarySource> for CodeableConcept {
    fn from(code: ContributorSummarySource) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContributorSummaryStyle](http://hl7.org/fhir/ValueSet/contributor-summary-style)**. Used to code the format of the display string.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorSummaryStyle {
    /** **a1full**

First author (full name) et al. Example: Jennifer Laskowski et al. */
    A1Full,
    /** **a1init**

First author (last name first initials) et al. Example: Laskowski J et al. */
    A1Init,
    /** **a3full**

First 3 authors (full name) et al. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, et al. */
    A3Full,
    /** **a3init**

First 3 authors (last name first initials) et al. Example:  Laskowski J, Renner B, Pickering MC, et al. */
    A3Init,
    /** **a6full**

First 6 authors (full name) et al. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, et al. */
    A6Full,
    /** **a6init**

First 6 authors (last name first initials) et al. Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, et al. */
    A6Init,
    /** **aallfull**

All authors (full name). Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, Joshua M. Thurman. */
    Aallfull,
    /** **aallfullwithampersand**

All authors (full name) with an ampersand before last author. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, & Joshua M. Thurman. */
    Aallfullwithampersand,
    /** **aallfullwithand**

All authors (full name) with and before last author. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, and Joshua M. Thurman. */
    Aallfullwithand,
    /** **aallinit**

All authors (last name first initials). Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, Thurman JM. */
    Aallinit,
    /** **aallinitwithampersand**

All authors (last name first initials) with an ampersand before last author. Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, & Thurman JM. */
    Aallinitwithampersand,
    /** **aallinitwithand**

All authors (last name first initials) with and before last author. Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, and Thurman JM. */
    Aallinitwithand,
    /** **contr-full-by-contr**

Contributorship statement listed by contribution with full names. Project design by Jennnifer Laskowski (JL), Experiment design by JL and Joshua M. Thurman (JMT), technical advice and study design contribution by Matthew C. Pickering, experiments performed by JL, data collection and analysis by JL, PET imaging and associated analyses by Natalie J. Serkova and Peter M. Smith-Jones, conceptual and technical guidance by Eric T. Clambey (etc.) and Raphael A. Nemenoff (RAN), manuscript writing by JL and JMT, manuscript revised critically by JL, Brandon Renner, etc., and RAN. */
    ContrFullByContr,
    /** **contr-full-by-person**

Contributorship statement listed by person with full names. Jennnifer Laskowski designed project; developed and performed experiments; collected and analyzed data; wrote and revised manuscript. Brandon Renner performed critical review of manuscript. Matthew C. Pickering provided technical advice and contributed to study design. Natalie J. Serkova and Peter M. Smith-Jones performed PET imaging and associated analyses. Eric T. Clambey and Raphael A. Nemenoff provided conceptual and technical guidance and critical review of manuscript. Joshua M. Thurman contributed to experimental design and wrote manuscript. */
    ContrFullByPerson,
    /** **contr-init-by-contr**

Contributorship statement listed by contribution with initials. Project design by JL, Experiment design by JL and JMT, technical advice and study design contribution by MCP, experiments performed by JL, data collection and analysis by JL, PET imaging and associated analyses by NJS and PMS-J, conceptual and technical guidance by etc. and RAN, manuscript writing by JL and JMT, manuscript revised critically by JL, BR, etc., and RAN. */
    ContrInitByContr,
    /** **contr-init-by-person**

Contributorship statement listed by person with initials. J.L. designed project; developed and performed experiments; collected and analyzed data; wrote and revised manuscript. B.R. performed critical review of manuscript. M.C.P. provided technical advice and contributed to study design. N.J.S and P.M.S.-J. performed PET imaging and associated analyses. E.T.C. and R.A.N provided conceptual and technical guidance and critical review of manuscript. J.M.T contributed to experimental design and wrote manuscript. */
    ContrInitByPerson,
}
impl ::core::str::FromStr for ContributorSummaryStyle {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a1full" => Ok(Self::A1Full),
            "a1init" => Ok(Self::A1Init),
            "a3full" => Ok(Self::A3Full),
            "a3init" => Ok(Self::A3Init),
            "a6full" => Ok(Self::A6Full),
            "a6init" => Ok(Self::A6Init),
            "aallfull" => Ok(Self::Aallfull),
            "aallfullwithampersand" => Ok(Self::Aallfullwithampersand),
            "aallfullwithand" => Ok(Self::Aallfullwithand),
            "aallinit" => Ok(Self::Aallinit),
            "aallinitwithampersand" => Ok(Self::Aallinitwithampersand),
            "aallinitwithand" => Ok(Self::Aallinitwithand),
            "contr-full-by-contr" => Ok(Self::ContrFullByContr),
            "contr-full-by-person" => Ok(Self::ContrFullByPerson),
            "contr-init-by-contr" => Ok(Self::ContrInitByContr),
            "contr-init-by-person" => Ok(Self::ContrInitByPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorSummaryStyle {
    fn as_ref(&self) -> &str {
        match self {
            Self::A1Full => "a1full",
            Self::A1Init => "a1init",
            Self::A3Full => "a3full",
            Self::A3Init => "a3init",
            Self::A6Full => "a6full",
            Self::A6Init => "a6init",
            Self::Aallfull => "aallfull",
            Self::Aallfullwithampersand => "aallfullwithampersand",
            Self::Aallfullwithand => "aallfullwithand",
            Self::Aallinit => "aallinit",
            Self::Aallinitwithampersand => "aallinitwithampersand",
            Self::Aallinitwithand => "aallinitwithand",
            Self::ContrFullByContr => "contr-full-by-contr",
            Self::ContrFullByPerson => "contr-full-by-person",
            Self::ContrInitByContr => "contr-init-by-contr",
            Self::ContrInitByPerson => "contr-init-by-person",
        }
    }
}
impl ::std::fmt::Display for ContributorSummaryStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::A1Full => "First author (full name) et al",
            Self::A1Init => "First author (last name first initials) et al",
            Self::A3Full => "First 3 authors (full name) et al",
            Self::A3Init => "First 3 authors (last name first initials) et al",
            Self::A6Full => "First 6 authors (full name) et al",
            Self::A6Init => "First 6 authors (last name first initials) et al",
            Self::Aallfull => "All authors (full name)",
            Self::Aallfullwithampersand => {
                "All authors (full name) with an ampersand before last author"
            }
            Self::Aallfullwithand => {
                "All authors (full name) with and before last author"
            }
            Self::Aallinit => "All authors (last name first initials)",
            Self::Aallinitwithampersand => {
                "All authors (last name first initials) with an ampersand before last author"
            }
            Self::Aallinitwithand => {
                "All authors (last name first initials) with and before last author"
            }
            Self::ContrFullByContr => {
                "Contributorship statement listed by contribution with full names"
            }
            Self::ContrFullByPerson => {
                "Contributorship statement listed by person with full names"
            }
            Self::ContrInitByContr => {
                "Contributorship statement listed by contribution with initials"
            }
            Self::ContrInitByPerson => {
                "Contributorship statement listed by person with initials"
            }
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContributorSummaryStyle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorSummaryStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorSummaryStyle> for Coding {
    fn from(code: ContributorSummaryStyle) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/contributor-summary-style".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContributorSummaryStyle> for CodeableConcept {
    fn from(code: ContributorSummaryStyle) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContributorSummaryType](http://hl7.org/fhir/ValueSet/contributor-summary-type)**. Used to code author list statement, contributorship statement, and such.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorSummaryType {
    /** **acknowledgement-list**

Acknowledgment list. Display of the list of acknowledged parties as a complete string. */
    AcknowledgementList,
    /** **acknowledgment-statement**

Acknowledgment statement. Statement of acknowledgment of contributions beyond those compiled for formal contributorship statements. */
    AcknowledgmentStatement,
    /** **author-string**

Author string. Display of the author list as a complete string. */
    AuthorString,
    /** **competing-interests-statement**

Competing interests statement. Statement of completing interests related to the creation of the cited artifact. Also called conflicts of interest or declaration of interests. */
    CompetingInterestsStatement,
    /** **contributorship-list**

Contributorship list. Display of the list of contributors as a complete string. */
    ContributorshipList,
    /** **contributorship-statement**

Contributorship statement. Compiled summary of contributions. */
    ContributorshipStatement,
    /** **funding-statement**

Funding statement. Statement of financial support for the creation of the cited artifact. */
    FundingStatement,
}
impl ::core::str::FromStr for ContributorSummaryType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acknowledgement-list" => Ok(Self::AcknowledgementList),
            "acknowledgment-statement" => Ok(Self::AcknowledgmentStatement),
            "author-string" => Ok(Self::AuthorString),
            "competing-interests-statement" => Ok(Self::CompetingInterestsStatement),
            "contributorship-list" => Ok(Self::ContributorshipList),
            "contributorship-statement" => Ok(Self::ContributorshipStatement),
            "funding-statement" => Ok(Self::FundingStatement),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorSummaryType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AcknowledgementList => "acknowledgement-list",
            Self::AcknowledgmentStatement => "acknowledgment-statement",
            Self::AuthorString => "author-string",
            Self::CompetingInterestsStatement => "competing-interests-statement",
            Self::ContributorshipList => "contributorship-list",
            Self::ContributorshipStatement => "contributorship-statement",
            Self::FundingStatement => "funding-statement",
        }
    }
}
impl ::std::fmt::Display for ContributorSummaryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AcknowledgementList => "Acknowledgment list",
            Self::AcknowledgmentStatement => "Acknowledgment statement",
            Self::AuthorString => "Author string",
            Self::CompetingInterestsStatement => "Competing interests statement",
            Self::ContributorshipList => "Contributorship list",
            Self::ContributorshipStatement => "Contributorship statement",
            Self::FundingStatement => "Funding statement",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContributorSummaryType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorSummaryType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorSummaryType> for Coding {
    fn from(code: ContributorSummaryType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/contributor-summary-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContributorSummaryType> for CodeableConcept {
    fn from(code: ContributorSummaryType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ContributorType](http://hl7.org/fhir/ValueSet/contributor-type)**. The type of contributor.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorType {
    /** **author**

Author. An author of the content of the module. */
    Author,
    /** **editor**

Editor. An editor of the content of the module. */
    Editor,
    /** **endorser**

Endorser. An endorser of the content of the module. */
    Endorser,
    /** **reviewer**

Reviewer. A reviewer of the content of the module. */
    Reviewer,
}
impl ::core::str::FromStr for ContributorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "author" => Ok(Self::Author),
            "editor" => Ok(Self::Editor),
            "endorser" => Ok(Self::Endorser),
            "reviewer" => Ok(Self::Reviewer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Author => "author",
            Self::Editor => "editor",
            Self::Endorser => "endorser",
            Self::Reviewer => "reviewer",
        }
    }
}
impl ::std::fmt::Display for ContributorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Author => "Author",
            Self::Editor => "Editor",
            Self::Endorser => "Endorser",
            Self::Reviewer => "Reviewer",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ContributorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ContributorType> for Coding {
    fn from(code: ContributorType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/contributor-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ContributorType> for CodeableConcept {
    fn from(code: ContributorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[CriteriaNotExistsBehavior](http://hl7.org/fhir/ValueSet/subscriptiontopic-cr-behavior)**. Behavior a server can exhibit when a criteria state does not exist (e.g., state prior to a create or after a delete).\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CriteriaNotExistsBehavior {
    /** **test-fails**

Test fails. The requested conditional statement will fail if a matching state does not exist (e.g., previous state during create). */
    TestFails,
    /** **test-passes**

Test passes. The requested conditional statement will pass if a matching state does not exist (e.g., previous state during create). */
    TestPasses,
}
impl ::core::str::FromStr for CriteriaNotExistsBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "test-fails" => Ok(Self::TestFails),
            "test-passes" => Ok(Self::TestPasses),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CriteriaNotExistsBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::TestFails => "test-fails",
            Self::TestPasses => "test-passes",
        }
    }
}
impl ::std::fmt::Display for CriteriaNotExistsBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::TestFails => "Test fails",
            Self::TestPasses => "Test passes",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for CriteriaNotExistsBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CriteriaNotExistsBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<CriteriaNotExistsBehavior> for Coding {
    fn from(code: CriteriaNotExistsBehavior) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/subscriptiontopic-cr-behavior".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<CriteriaNotExistsBehavior> for CodeableConcept {
    fn from(code: CriteriaNotExistsBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DatesEventTypeCodes](http://hl7.org/fhir/datestype)**. This value set includes sample Dates Event Type codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DatesEventTypeCodes {
    /** **card-issued**

Card Issued. The date when an insurance card was issued. */
    CardIssued,
    /** **claim-received**

Claim Received. The date when an insurer nreceived a claim, pre-authorization or predetermination. */
    ClaimReceived,
    /** **service-expected**

Service Expected. The date or period on or during which the services are expected to be performed. */
    ServiceExpected,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for DatesEventTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "card-issued" => Ok(Self::CardIssued),
            "claim-received" => Ok(Self::ClaimReceived),
            "service-expected" => Ok(Self::ServiceExpected),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for DatesEventTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::CardIssued => "card-issued",
            Self::ClaimReceived => "claim-received",
            Self::ServiceExpected => "service-expected",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for DatesEventTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::CardIssued => "Card Issued",
            Self::ClaimReceived => "Claim Received",
            Self::ServiceExpected => "Service Expected",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DatesEventTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DatesEventTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DatesEventTypeCodes> for Coding {
    fn from(code: DatesEventTypeCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/datestype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DatesEventTypeCodes> for CodeableConcept {
    fn from(code: DatesEventTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DaysOfWeek](http://hl7.org/fhir/ValueSet/days-of-week)**. The days of the week.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DaysOfWeek {
    /** **fri**

Friday. Friday. */
    Fri,
    /** **mon**

Monday. Monday. */
    Mon,
    /** **sat**

Saturday. Saturday. */
    Sat,
    /** **sun**

Sunday. Sunday. */
    Sun,
    /** **thu**

Thursday. Thursday. */
    Thu,
    /** **tue**

Tuesday. Tuesday. */
    Tue,
    /** **wed**

Wednesday. Wednesday. */
    Wed,
}
impl ::core::str::FromStr for DaysOfWeek {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fri" => Ok(Self::Fri),
            "mon" => Ok(Self::Mon),
            "sat" => Ok(Self::Sat),
            "sun" => Ok(Self::Sun),
            "thu" => Ok(Self::Thu),
            "tue" => Ok(Self::Tue),
            "wed" => Ok(Self::Wed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DaysOfWeek {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fri => "fri",
            Self::Mon => "mon",
            Self::Sat => "sat",
            Self::Sun => "sun",
            Self::Thu => "thu",
            Self::Tue => "tue",
            Self::Wed => "wed",
        }
    }
}
impl ::std::fmt::Display for DaysOfWeek {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Fri => "Friday",
            Self::Mon => "Monday",
            Self::Sat => "Saturday",
            Self::Sun => "Sunday",
            Self::Thu => "Thursday",
            Self::Tue => "Tuesday",
            Self::Wed => "Wednesday",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DaysOfWeek {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DaysOfWeek {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DaysOfWeek> for Coding {
    fn from(code: DaysOfWeek) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/days-of-week".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DaysOfWeek> for CodeableConcept {
    fn from(code: DaysOfWeek) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DefinitionMethod](http://hl7.org/fhir/ValueSet/definition-method)**. The method used to define, describe, or determine a characteristic value.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DefinitionMethod {
    /** **mean**

Mean. Aggregated using mean of observed values. */
    Mean,
    /** **mean-of-mean**

Mean of Means. Aggregated using mean of means (e.g. study mean values). */
    MeanOfMean,
    /** **mean-of-median**

Mean of Medians. Aggregated using mean of medians (e.g. study median values). */
    MeanOfMedian,
    /** **median**

Median. Aggregated using median of observed values. */
    Median,
    /** **median-of-mean**

Median of Means. Aggregated using median of means (e.g. study mean values). */
    MedianOfMean,
    /** **median-of-median**

Median of Medians. Aggregated using median of medians (e.g. study median values). */
    MedianOfMedian,
    /** **non-systematic-assessment**

Non-Systematic Assessment. Any non-systematic method for determining whether or not adverse events have occurred, such as self-reporting by participants or occasional assessment/testing */
    NonSystematicAssessment,
    /** **systematic-assessment**

Systematic Assessment. Any method of routinely determining whether or not specific outcomes (e.g. adverse events) have occurred, for example through a standard questionnaire, regular investigator assessment, regular laboratory testing, or other method */
    SystematicAssessment,
}
impl ::core::str::FromStr for DefinitionMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mean" => Ok(Self::Mean),
            "mean-of-mean" => Ok(Self::MeanOfMean),
            "mean-of-median" => Ok(Self::MeanOfMedian),
            "median" => Ok(Self::Median),
            "median-of-mean" => Ok(Self::MedianOfMean),
            "median-of-median" => Ok(Self::MedianOfMedian),
            "non-systematic-assessment" => Ok(Self::NonSystematicAssessment),
            "systematic-assessment" => Ok(Self::SystematicAssessment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mean => "mean",
            Self::MeanOfMean => "mean-of-mean",
            Self::MeanOfMedian => "mean-of-median",
            Self::Median => "median",
            Self::MedianOfMean => "median-of-mean",
            Self::MedianOfMedian => "median-of-median",
            Self::NonSystematicAssessment => "non-systematic-assessment",
            Self::SystematicAssessment => "systematic-assessment",
        }
    }
}
impl ::std::fmt::Display for DefinitionMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Mean => "Mean",
            Self::MeanOfMean => "Mean of Means",
            Self::MeanOfMedian => "Mean of Medians",
            Self::Median => "Median",
            Self::MedianOfMean => "Median of Means",
            Self::MedianOfMedian => "Median of Medians",
            Self::NonSystematicAssessment => "Non-Systematic Assessment",
            Self::SystematicAssessment => "Systematic Assessment",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DefinitionMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DefinitionMethod> for Coding {
    fn from(code: DefinitionMethod) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/definition-method".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DefinitionMethod> for CodeableConcept {
    fn from(code: DefinitionMethod) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DetectedIssueSeverity](http://hl7.org/fhir/ValueSet/detectedissue-severity)**. Indicates the potential degree of impact of the identified issue on the patient.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DetectedIssueSeverity {
    /** **high**

High. Indicates the issue may be life-threatening or has the potential to cause permanent injury. */
    High,
    /** **low**

Low. Indicates the issue may result in some adverse consequences but is unlikely to substantially affect the situation of the subject. */
    Low,
    /** **moderate**

Moderate. Indicates the issue may result in noticeable adverse consequences but is unlikely to be life-threatening or cause permanent injury. */
    Moderate,
}
impl ::core::str::FromStr for DetectedIssueSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DetectedIssueSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
        }
    }
}
impl ::std::fmt::Display for DetectedIssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::High => "High",
            Self::Low => "Low",
            Self::Moderate => "Moderate",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DetectedIssueSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DetectedIssueSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DetectedIssueSeverity> for Coding {
    fn from(code: DetectedIssueSeverity) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/detectedissue-severity".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DetectedIssueSeverity> for CodeableConcept {
    fn from(code: DetectedIssueSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DetectedIssueStatus](http://hl7.org/fhir/detectedissue-status)**. Indicates the status of the detected issue. This code system contains only status codes that are not already defined and used from the ObservationStatus code system.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DetectedIssueStatus {
    /** **mitigated**

Mitigated. Indicates the detected issue has been mitigated */
    Mitigated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for DetectedIssueStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mitigated" => Ok(Self::Mitigated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for DetectedIssueStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mitigated => "mitigated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for DetectedIssueStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Mitigated => "Mitigated",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DetectedIssueStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DetectedIssueStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DetectedIssueStatus> for Coding {
    fn from(code: DetectedIssueStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/detectedissue-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DetectedIssueStatus> for CodeableConcept {
    fn from(code: DetectedIssueStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceAssociation](http://hl7.org/fhir/ValueSet/deviceassociation-status)**. DeviceAssociation Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceAssociation {
    /** **attached**

Attached. The device is attached to the patient but not implanted in the patient. */
    Attached,
    /** **entered-in-error**

Entered in Error. The association was entered in error and therefore nullified. */
    EnteredInError,
    /** **explanted**

Explanted. The device is no longer implanted in the patient. Note that this is not the value to be used for devices that have never been implanted. In those cases, no value or a specific value can be used. */
    Explanted,
    /** **implanted**

Implanted. The device is implanted in the patient. */
    Implanted,
    /** **unknown**

Unknown. The association status of the device has not been determined. */
    Unknown,
}
impl ::core::str::FromStr for DeviceAssociation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "attached" => Ok(Self::Attached),
            "entered-in-error" => Ok(Self::EnteredInError),
            "explanted" => Ok(Self::Explanted),
            "implanted" => Ok(Self::Implanted),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceAssociation {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attached => "attached",
            Self::EnteredInError => "entered-in-error",
            Self::Explanted => "explanted",
            Self::Implanted => "implanted",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for DeviceAssociation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Attached => "Attached",
            Self::EnteredInError => "Entered in Error",
            Self::Explanted => "Explanted",
            Self::Implanted => "Implanted",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceAssociation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceAssociation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceAssociation> for Coding {
    fn from(code: DeviceAssociation) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/deviceassociation-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceAssociation> for CodeableConcept {
    fn from(code: DeviceAssociation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceCorrectiveActionScope](http://hl7.org/fhir/ValueSet/device-correctiveactionscope)**. The type of relation between devices.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceCorrectiveActionScope {
    /** **lot-numbers**

Lot Numbers. The corrective action was intended for a specific batch of units identified by a lot number. */
    LotNumbers,
    /** **model**

Model. The corrective action was intended for all units of the same model. */
    Model,
    /** **serial-numbers**

Serial Numbers. The corrective action was intended for an individual unit (or a set of units) individually identified by serial number. */
    SerialNumbers,
}
impl ::core::str::FromStr for DeviceCorrectiveActionScope {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "lot-numbers" => Ok(Self::LotNumbers),
            "model" => Ok(Self::Model),
            "serial-numbers" => Ok(Self::SerialNumbers),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceCorrectiveActionScope {
    fn as_ref(&self) -> &str {
        match self {
            Self::LotNumbers => "lot-numbers",
            Self::Model => "model",
            Self::SerialNumbers => "serial-numbers",
        }
    }
}
impl ::std::fmt::Display for DeviceCorrectiveActionScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::LotNumbers => "Lot Numbers",
            Self::Model => "Model",
            Self::SerialNumbers => "Serial Numbers",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceCorrectiveActionScope {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceCorrectiveActionScope {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceCorrectiveActionScope> for Coding {
    fn from(code: DeviceCorrectiveActionScope) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/device-correctiveactionscope".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceCorrectiveActionScope> for CodeableConcept {
    fn from(code: DeviceCorrectiveActionScope) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceDefinitionRelationType](http://hl7.org/fhir/ValueSet/device-relationtype)**. The type of relation between devices.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceDefinitionRelationType {
    /** **gateway**

Gateway. Gateway. */
    Gateway,
    /** **previous**

Previous. The current device is a previous device and has been replaced by the linked device. */
    Previous,
    /** **replaces**

Replaces. The current device replaces the linked device. */
    Replaces,
}
impl ::core::str::FromStr for DeviceDefinitionRelationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "gateway" => Ok(Self::Gateway),
            "previous" => Ok(Self::Previous),
            "replaces" => Ok(Self::Replaces),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceDefinitionRelationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Gateway => "gateway",
            Self::Previous => "previous",
            Self::Replaces => "replaces",
        }
    }
}
impl ::std::fmt::Display for DeviceDefinitionRelationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Gateway => "Gateway",
            Self::Previous => "Previous",
            Self::Replaces => "Replaces",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceDefinitionRelationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceDefinitionRelationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceDefinitionRelationType> for Coding {
    fn from(code: DeviceDefinitionRelationType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/device-relationtype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceDefinitionRelationType> for CodeableConcept {
    fn from(code: DeviceDefinitionRelationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceDispenseStatusCodes](http://hl7.org/fhir/ValueSet/devicedispense-status)**. DeviceDispense Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceDispenseStatusCodes {
    /** **cancelled**

Cancelled. The dispensed product was not and will never be picked up by the patient. */
    Cancelled,
    /** **completed**

Completed. The dispensed product has been picked up. */
    Completed,
    /** **declined**

Declined. The dispense was declined and not performed. */
    Declined,
    /** **entered-in-error**

Entered in Error. The dispense was entered in error and therefore nullified. */
    EnteredInError,
    /** **in-progress**

In Progress. The dispensed product is ready for pickup. */
    InProgress,
    /** **on-hold**

On Hold. The dispense process is paused while waiting for an external event to reactivate the dispense.  For example, new stock has arrived or the prescriber has called. */
    OnHold,
    /** **preparation**

Preparation. The core event has not started yet, but some staging activities have begun (e.g. initial preparing of the device. Preparation stages may be tracked e.g. for planning, supply or billing purposes. */
    Preparation,
    /** **stopped**

Stopped. Actions implied by the dispense have been permanently halted, before all of them occurred. */
    Stopped,
    /** **unknown**

Unknown. The authoring system does not know which of the status values applies for this dispense.  Note: this concept is not to be used for other - one of the listed statuses is presumed to apply, it's just now known which one. */
    Unknown,
}
impl ::core::str::FromStr for DeviceDispenseStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "declined" => Ok(Self::Declined),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "preparation" => Ok(Self::Preparation),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceDispenseStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Declined => "declined",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::Preparation => "preparation",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for DeviceDispenseStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Cancelled => "Cancelled",
            Self::Completed => "Completed",
            Self::Declined => "Declined",
            Self::EnteredInError => "Entered in Error",
            Self::InProgress => "In Progress",
            Self::OnHold => "On Hold",
            Self::Preparation => "Preparation",
            Self::Stopped => "Stopped",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceDispenseStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceDispenseStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceDispenseStatusCodes> for Coding {
    fn from(code: DeviceDispenseStatusCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/devicedispense-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceDispenseStatusCodes> for CodeableConcept {
    fn from(code: DeviceDispenseStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceDispenseStatusReasonCodes](http://hl7.org/fhir/CodeSystem/devicedispense-status-reason)**. DeviceDispense Status Reason Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DeviceDispenseStatusReasonCodes {
    /** **contraindication**

Contraindication. The device was not dispensed because a contraindication was found - for example pregnancy, allergy to a device component... */
    Contraindication,
    /** **incompatible-device**

Incompatible device. The device was not dispensed because an incompatibility has been found with the device or between the device and other devices being used in the same context. */
    IncompatibleDevice,
    /** **off-market**

Off market. The device was not dispensed because it is of-market - for example not authorized, withdrawn or recalled. */
    OffMarket,
    /** **order-expired**

Order expired. The device was not dispensed because the order has expired or been invalidated. */
    OrderExpired,
    /** **out-of-stock**

Out of Stock. The device was not dispensed because it was not available. */
    OutOfStock,
    /** **verbal-order**

Verbal order. The device not dispensed because there was a verbal order. */
    VerbalOrder,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for DeviceDispenseStatusReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contraindication" => Ok(Self::Contraindication),
            "incompatible-device" => Ok(Self::IncompatibleDevice),
            "off-market" => Ok(Self::OffMarket),
            "order-expired" => Ok(Self::OrderExpired),
            "out-of-stock" => Ok(Self::OutOfStock),
            "verbal-order" => Ok(Self::VerbalOrder),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for DeviceDispenseStatusReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contraindication => "contraindication",
            Self::IncompatibleDevice => "incompatible-device",
            Self::OffMarket => "off-market",
            Self::OrderExpired => "order-expired",
            Self::OutOfStock => "out-of-stock",
            Self::VerbalOrder => "verbal-order",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for DeviceDispenseStatusReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Contraindication => "Contraindication",
            Self::IncompatibleDevice => "Incompatible device",
            Self::OffMarket => "Off market",
            Self::OrderExpired => "Order expired",
            Self::OutOfStock => "Out of Stock",
            Self::VerbalOrder => "Verbal order",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceDispenseStatusReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceDispenseStatusReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceDispenseStatusReasonCodes> for Coding {
    fn from(code: DeviceDispenseStatusReasonCodes) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/CodeSystem/devicedispense-status-reason".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceDispenseStatusReasonCodes> for CodeableConcept {
    fn from(code: DeviceDispenseStatusReasonCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceMetricCalibrationState](http://hl7.org/fhir/ValueSet/metric-calibration-state)**. Describes the state of a metric calibration.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceMetricCalibrationState {
    /** **calibrated**

Calibrated. The metric has been calibrated. */
    Calibrated,
    /** **calibration-required**

Calibration Required. The metric needs to be calibrated. */
    CalibrationRequired,
    /** **not-calibrated**

Not Calibrated. The metric has not been calibrated. */
    NotCalibrated,
    /** **unspecified**

Unspecified. The state of calibration of this metric is unspecified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCalibrationState {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calibrated" => Ok(Self::Calibrated),
            "calibration-required" => Ok(Self::CalibrationRequired),
            "not-calibrated" => Ok(Self::NotCalibrated),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCalibrationState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calibrated => "calibrated",
            Self::CalibrationRequired => "calibration-required",
            Self::NotCalibrated => "not-calibrated",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Display for DeviceMetricCalibrationState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Calibrated => "Calibrated",
            Self::CalibrationRequired => "Calibration Required",
            Self::NotCalibrated => "Not Calibrated",
            Self::Unspecified => "Unspecified",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCalibrationState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCalibrationState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricCalibrationState> for Coding {
    fn from(code: DeviceMetricCalibrationState) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/metric-calibration-state".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceMetricCalibrationState> for CodeableConcept {
    fn from(code: DeviceMetricCalibrationState) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceMetricCalibrationType](http://hl7.org/fhir/ValueSet/metric-calibration-type)**. Describes the type of a metric calibration.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceMetricCalibrationType {
    /** **gain**

Gain. Gain metric calibration method. */
    Gain,
    /** **offset**

Offset. Offset metric calibration method. */
    Offset,
    /** **two-point**

Two Point. Two-point metric calibration method. */
    TwoPoint,
    /** **unspecified**

Unspecified. Metric calibration method has not been identified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCalibrationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "gain" => Ok(Self::Gain),
            "offset" => Ok(Self::Offset),
            "two-point" => Ok(Self::TwoPoint),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCalibrationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Gain => "gain",
            Self::Offset => "offset",
            Self::TwoPoint => "two-point",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Display for DeviceMetricCalibrationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Gain => "Gain",
            Self::Offset => "Offset",
            Self::TwoPoint => "Two Point",
            Self::Unspecified => "Unspecified",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCalibrationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCalibrationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricCalibrationType> for Coding {
    fn from(code: DeviceMetricCalibrationType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/metric-calibration-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceMetricCalibrationType> for CodeableConcept {
    fn from(code: DeviceMetricCalibrationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceMetricCategory](http://hl7.org/fhir/ValueSet/metric-category)**. Describes the category of the metric.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceMetricCategory {
    /** **calculation**

Calculation. Observations generated for this DeviceMetric are calculated. */
    Calculation,
    /** **measurement**

Measurement. Observations generated for this DeviceMetric are measured. */
    Measurement,
    /** **setting**

Setting. Observations generated for this DeviceMetric is a setting that will influence the behavior of the Device. */
    Setting,
    /** **unspecified**

Unspecified. The category of this DeviceMetric is unspecified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calculation" => Ok(Self::Calculation),
            "measurement" => Ok(Self::Measurement),
            "setting" => Ok(Self::Setting),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calculation => "calculation",
            Self::Measurement => "measurement",
            Self::Setting => "setting",
            Self::Unspecified => "unspecified",
        }
    }
}
impl ::std::fmt::Display for DeviceMetricCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Calculation => "Calculation",
            Self::Measurement => "Measurement",
            Self::Setting => "Setting",
            Self::Unspecified => "Unspecified",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricCategory> for Coding {
    fn from(code: DeviceMetricCategory) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/metric-category".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceMetricCategory> for CodeableConcept {
    fn from(code: DeviceMetricCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceMetricOperationalStatus](http://hl7.org/fhir/ValueSet/metric-operational-status)**. Describes the operational status of the DeviceMetric.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceMetricOperationalStatus {
    /** **entered-in-error**

Entered In Error. The DeviceMetric was entered in error. */
    EnteredInError,
    /** **off**

Off. The DeviceMetric is not operating. */
    Off,
    /** **on**

On. The DeviceMetric is operating and will generate Observations. */
    On,
    /** **standby**

Standby. The DeviceMetric is operating, but will not generate any Observations. */
    Standby,
}
impl ::core::str::FromStr for DeviceMetricOperationalStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "entered-in-error" => Ok(Self::EnteredInError),
            "off" => Ok(Self::Off),
            "on" => Ok(Self::On),
            "standby" => Ok(Self::Standby),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricOperationalStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::EnteredInError => "entered-in-error",
            Self::Off => "off",
            Self::On => "on",
            Self::Standby => "standby",
        }
    }
}
impl ::std::fmt::Display for DeviceMetricOperationalStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::EnteredInError => "Entered In Error",
            Self::Off => "Off",
            Self::On => "On",
            Self::Standby => "Standby",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceMetricOperationalStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricOperationalStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceMetricOperationalStatus> for Coding {
    fn from(code: DeviceMetricOperationalStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/metric-operational-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceMetricOperationalStatus> for CodeableConcept {
    fn from(code: DeviceMetricOperationalStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceNameType](http://hl7.org/fhir/ValueSet/device-nametype)**. The type of name the device is referred by.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceNameType {
    /** **patient-reported-name**

Patient Reported name. the term used by the patient associated with the device when describing the device, for example 'knee implant', when documented as a self-reported device. */
    PatientReportedName,
    /** **registered-name**

Registered name. The term assigned to a medical device by the entity who registers or submits information about it to a jurisdiction or its databases. This may be considered the manufacturer assigned name (e.g., brand name assigned by the labeler or manufacturer in US, or device name assigned by the manufacturer in EU) and may also be synonymous with proprietary name or trade name of the device. */
    RegisteredName,
    /** **user-friendly-name**

User Friendly name. The term that generically describes the device by a name as assigned by the manufacturer that is recognized by lay person.  This common or generic name may be printed on the package it came in or some combination of that name with the model number, serial number, or other attribute that makes the name easy to understand for the user of that device. It is often exposed in communicating devices transport protocols. It is provided to help users identify the device when reported in discovery operations. */
    UserFriendlyName,
}
impl ::core::str::FromStr for DeviceNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "patient-reported-name" => Ok(Self::PatientReportedName),
            "registered-name" => Ok(Self::RegisteredName),
            "user-friendly-name" => Ok(Self::UserFriendlyName),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::PatientReportedName => "patient-reported-name",
            Self::RegisteredName => "registered-name",
            Self::UserFriendlyName => "user-friendly-name",
        }
    }
}
impl ::std::fmt::Display for DeviceNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::PatientReportedName => "Patient Reported name",
            Self::RegisteredName => "Registered name",
            Self::UserFriendlyName => "User Friendly name",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceNameType> for Coding {
    fn from(code: DeviceNameType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/device-nametype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceNameType> for CodeableConcept {
    fn from(code: DeviceNameType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceProductionIdentifierInUDI](http://hl7.org/fhir/device-productidentifierinudi)**. The production identifier(s) that are expected to appear in the UDI carrier.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DeviceProductionIdentifierInUDI {
    /** **biological-source**

Biological source. The label includes the biological source identifier. */
    BiologicalSource,
    /** **expiration-date**

Expiration date. The label includes the expiration date. */
    ExpirationDate,
    /** **lot-number**

Lot Number. The label includes the lot number. */
    LotNumber,
    /** **manufactured-date**

Manufactured date. The label includes the manufacture date. */
    ManufacturedDate,
    /** **serial-number**

Serial Number. The label includes the serial number. */
    SerialNumber,
    /** **software-version**

Software Version. The label includes the software version. */
    SoftwareVersion,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for DeviceProductionIdentifierInUDI {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "biological-source" => Ok(Self::BiologicalSource),
            "expiration-date" => Ok(Self::ExpirationDate),
            "lot-number" => Ok(Self::LotNumber),
            "manufactured-date" => Ok(Self::ManufacturedDate),
            "serial-number" => Ok(Self::SerialNumber),
            "software-version" => Ok(Self::SoftwareVersion),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for DeviceProductionIdentifierInUDI {
    fn as_ref(&self) -> &str {
        match self {
            Self::BiologicalSource => "biological-source",
            Self::ExpirationDate => "expiration-date",
            Self::LotNumber => "lot-number",
            Self::ManufacturedDate => "manufactured-date",
            Self::SerialNumber => "serial-number",
            Self::SoftwareVersion => "software-version",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for DeviceProductionIdentifierInUDI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::BiologicalSource => "Biological source",
            Self::ExpirationDate => "Expiration date",
            Self::LotNumber => "Lot Number",
            Self::ManufacturedDate => "Manufactured date",
            Self::SerialNumber => "Serial Number",
            Self::SoftwareVersion => "Software Version",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceProductionIdentifierInUDI {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceProductionIdentifierInUDI {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceProductionIdentifierInUDI> for Coding {
    fn from(code: DeviceProductionIdentifierInUDI) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/device-productidentifierinudi".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceProductionIdentifierInUDI> for CodeableConcept {
    fn from(code: DeviceProductionIdentifierInUDI) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceRegulatoryIdentifierType](http://hl7.org/fhir/devicedefinition-regulatory-identifier-type)**. The type of regulatory identifier.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DeviceRegulatoryIdentifierType {
    /** **basic**

Basic. EUDAMED's basic UDI-DI identifier. */
    Basic,
    /** **license**

License. The identifier is a license number. */
    License,
    /** **master**

Master. EUDAMED's master UDI-DI identifier. */
    Master,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for DeviceRegulatoryIdentifierType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "basic" => Ok(Self::Basic),
            "license" => Ok(Self::License),
            "master" => Ok(Self::Master),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for DeviceRegulatoryIdentifierType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Basic => "basic",
            Self::License => "license",
            Self::Master => "master",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for DeviceRegulatoryIdentifierType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Basic => "Basic",
            Self::License => "License",
            Self::Master => "Master",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceRegulatoryIdentifierType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceRegulatoryIdentifierType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceRegulatoryIdentifierType> for Coding {
    fn from(code: DeviceRegulatoryIdentifierType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/devicedefinition-regulatory-identifier-type"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceRegulatoryIdentifierType> for CodeableConcept {
    fn from(code: DeviceRegulatoryIdentifierType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceUsageAdherenceCode](http://hl7.org/fhir/ValueSet/deviceusage-adherence-code)**. A coded concept indicating the usage of the device.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceUsageAdherenceCode {
    /** **always**

Always. The device is always used. */
    Always,
    /** **never**

Never. The device is never used. */
    Never,
    /** **sometimes**

Sometimes. The device is sometimes used. */
    Sometimes,
}
impl ::core::str::FromStr for DeviceUsageAdherenceCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "always" => Ok(Self::Always),
            "never" => Ok(Self::Never),
            "sometimes" => Ok(Self::Sometimes),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceUsageAdherenceCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Always => "always",
            Self::Never => "never",
            Self::Sometimes => "sometimes",
        }
    }
}
impl ::std::fmt::Display for DeviceUsageAdherenceCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Always => "Always",
            Self::Never => "Never",
            Self::Sometimes => "Sometimes",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceUsageAdherenceCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceUsageAdherenceCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceUsageAdherenceCode> for Coding {
    fn from(code: DeviceUsageAdherenceCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/deviceusage-adherence-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceUsageAdherenceCode> for CodeableConcept {
    fn from(code: DeviceUsageAdherenceCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceUsageAdherenceReason](http://hl7.org/fhir/ValueSet/deviceusage-adherence-reason)**. A coded concept indicating the reason for the usage of the device.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceUsageAdherenceReason {
    /** **broken**

Broken. The device is broken. */
    Broken,
    /** **burned**

Burned. The device is burned. */
    Burned,
    /** **forgot**

Forgot. The device is forgotten. */
    Forgot,
    /** **lost**

Lost. The device is lost. */
    Lost,
    /** **prescribed**

Prescribed. The device is prescribed. */
    Prescribed,
    /** **stolen**

Stolen. The device is stolen. */
    Stolen,
}
impl ::core::str::FromStr for DeviceUsageAdherenceReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "broken" => Ok(Self::Broken),
            "burned" => Ok(Self::Burned),
            "forgot" => Ok(Self::Forgot),
            "lost" => Ok(Self::Lost),
            "prescribed" => Ok(Self::Prescribed),
            "stolen" => Ok(Self::Stolen),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceUsageAdherenceReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::Broken => "broken",
            Self::Burned => "burned",
            Self::Forgot => "forgot",
            Self::Lost => "lost",
            Self::Prescribed => "prescribed",
            Self::Stolen => "stolen",
        }
    }
}
impl ::std::fmt::Display for DeviceUsageAdherenceReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Broken => "Broken",
            Self::Burned => "Burned",
            Self::Forgot => "Forgot",
            Self::Lost => "Lost",
            Self::Prescribed => "Prescribed",
            Self::Stolen => "Stolen",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceUsageAdherenceReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceUsageAdherenceReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceUsageAdherenceReason> for Coding {
    fn from(code: DeviceUsageAdherenceReason) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/deviceusage-adherence-reason".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceUsageAdherenceReason> for CodeableConcept {
    fn from(code: DeviceUsageAdherenceReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DeviceUsageStatus](http://hl7.org/fhir/ValueSet/deviceusage-status)**. A coded concept indicating the current status of the Device Usage.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceUsageStatus {
    /** **active**

Active. The device is still being used. */
    Active,
    /** **completed**

Completed. The device is no longer being used. */
    Completed,
    /** **entered-in-error**

Entered in Error. The statement was recorded incorrectly. */
    EnteredInError,
    /** **intended**

Intended. The device may be used at some time in the future. */
    Intended,
    /** **not-done**

Not done. The device was not used. */
    NotDone,
    /** **on-hold**

On Hold. Actions implied by the statement have been temporarily halted, but are expected to continue later. May also be called "suspended". */
    OnHold,
    /** **stopped**

Stopped. Actions implied by the statement have been permanently halted, before all of them occurred. */
    Stopped,
}
impl ::core::str::FromStr for DeviceUsageStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "intended" => Ok(Self::Intended),
            "not-done" => Ok(Self::NotDone),
            "on-hold" => Ok(Self::OnHold),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceUsageStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::Intended => "intended",
            Self::NotDone => "not-done",
            Self::OnHold => "on-hold",
            Self::Stopped => "stopped",
        }
    }
}
impl ::std::fmt::Display for DeviceUsageStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Completed => "Completed",
            Self::EnteredInError => "Entered in Error",
            Self::Intended => "Intended",
            Self::NotDone => "Not done",
            Self::OnHold => "On Hold",
            Self::Stopped => "Stopped",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DeviceUsageStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceUsageStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DeviceUsageStatus> for Coding {
    fn from(code: DeviceUsageStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/deviceusage-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DeviceUsageStatus> for CodeableConcept {
    fn from(code: DeviceUsageStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DiagnosticReportStatus](http://hl7.org/fhir/ValueSet/diagnostic-report-status)**. The status of the diagnostic report.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DiagnosticReportStatus {
    /** **amended**

Amended. Subsequent to being final, the report has been modified.  This includes any change in the results, diagnosis, narrative text, or other content of a report that has been issued. */
    Amended,
    /** **appended**

Appended. Subsequent to being final, the report has been modified by adding new content. The existing content is unchanged. */
    Appended,
    /** **cancelled**

Cancelled. The report is unavailable because the measurement was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **corrected**

Corrected. Subsequent to being final, the report has been modified to correct an error in the report or referenced results. */
    Corrected,
    /** **entered-in-error**

Entered in Error. The report has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **final**

Final. The report is complete and verified by an authorized person. */
    Final,
    /** **modified**

Modified. Prior to being final, the report has been modified.  This includes any change in the results, diagnosis, narrative text, or other content of a non-finalized (e.g., preliminary) report that has been issued. */
    Modified,
    /** **partial**

Partial. This is a partial (e.g. initial, interim or preliminary) report: data in the report may be incomplete or unverified. */
    Partial,
    /** **preliminary**

Preliminary. Verified early results are available, but not all results are final. */
    Preliminary,
    /** **registered**

Registered. The existence of the report is registered, but there is nothing yet available. */
    Registered,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for DiagnosticReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "corrected" => Ok(Self::Corrected),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "modified" => Ok(Self::Modified),
            "partial" => Ok(Self::Partial),
            "preliminary" => Ok(Self::Preliminary),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiagnosticReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Corrected => "corrected",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Modified => "modified",
            Self::Partial => "partial",
            Self::Preliminary => "preliminary",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for DiagnosticReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Amended => "Amended",
            Self::Appended => "Appended",
            Self::Cancelled => "Cancelled",
            Self::Corrected => "Corrected",
            Self::EnteredInError => "Entered in Error",
            Self::Final => "Final",
            Self::Modified => "Modified",
            Self::Partial => "Partial",
            Self::Preliminary => "Preliminary",
            Self::Registered => "Registered",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DiagnosticReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiagnosticReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DiagnosticReportStatus> for Coding {
    fn from(code: DiagnosticReportStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/diagnostic-report-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DiagnosticReportStatus> for CodeableConcept {
    fn from(code: DiagnosticReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DiscriminatorType](http://hl7.org/fhir/ValueSet/discriminator-type)**. How an element value is interpreted when discrimination is evaluated.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DiscriminatorType {
    /** **exists**

Exists. The slices are differentiated by the presence or absence of the nominated element. There SHALL be no more than two slices. The slices are differentiated by the fact that one must have a max of 0 and the other must have a min of 1 (or more).  The order in which the slices are declared doesn't matter. */
    Exists,
    /** **pattern**

Pattern. The slices have different values in the nominated element, as determined by the applicable fixed value, pattern, or required ValueSet binding. This has the same meaning as 'value' and is deprecated. */
    Pattern,
    /** **position**

Position. The slices are differentiated by their index. This is only possible if all but the last slice have min=max cardinality, and the (optional) last slice contains other undifferentiated elements. */
    Position,
    /** **profile**

Profile. The slices are differentiated by conformance of the nominated element to a specified profile. Note that if the path specifies .resolve() then the profile is the target profile on the reference. In this case, validation by the possible profiles is required to differentiate the slices. */
    Profile,
    /** **type**

Type. The slices are differentiated by type of the nominated element. */
    Type,
    /** **value**

Value. The slices have different values in the nominated element, as determined by the applicable fixed value, pattern, or required ValueSet binding. */
    Value,
}
impl ::core::str::FromStr for DiscriminatorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exists" => Ok(Self::Exists),
            "pattern" => Ok(Self::Pattern),
            "position" => Ok(Self::Position),
            "profile" => Ok(Self::Profile),
            "type" => Ok(Self::Type),
            "value" => Ok(Self::Value),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiscriminatorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exists => "exists",
            Self::Pattern => "pattern",
            Self::Position => "position",
            Self::Profile => "profile",
            Self::Type => "type",
            Self::Value => "value",
        }
    }
}
impl ::std::fmt::Display for DiscriminatorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Exists => "Exists",
            Self::Pattern => "Pattern",
            Self::Position => "Position",
            Self::Profile => "Profile",
            Self::Type => "Type",
            Self::Value => "Value",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DiscriminatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiscriminatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DiscriminatorType> for Coding {
    fn from(code: DiscriminatorType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/discriminator-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DiscriminatorType> for CodeableConcept {
    fn from(code: DiscriminatorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DocumentMode](http://hl7.org/fhir/ValueSet/document-mode)**. Whether the application produces or consumes documents.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DocumentMode {
    /** **consumer**

Consumer. The application consumes documents of the specified type. */
    Consumer,
    /** **producer**

Producer. The application produces documents of the specified type. */
    Producer,
}
impl ::core::str::FromStr for DocumentMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "consumer" => Ok(Self::Consumer),
            "producer" => Ok(Self::Producer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consumer => "consumer",
            Self::Producer => "producer",
        }
    }
}
impl ::std::fmt::Display for DocumentMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Consumer => "Consumer",
            Self::Producer => "Producer",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DocumentMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DocumentMode> for Coding {
    fn from(code: DocumentMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/document-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DocumentMode> for CodeableConcept {
    fn from(code: DocumentMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DocumentReferenceStatus](http://hl7.org/fhir/ValueSet/document-reference-status)**. The status of the document reference.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DocumentReferenceStatus {
    /** **current**

Current. This is the current reference for this document. */
    Current,
    /** **entered-in-error**

Entered in Error. This reference was created in error. */
    EnteredInError,
    /** **superseded**

Superseded. This reference has been superseded by another reference. */
    Superseded,
}
impl ::core::str::FromStr for DocumentReferenceStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "current" => Ok(Self::Current),
            "entered-in-error" => Ok(Self::EnteredInError),
            "superseded" => Ok(Self::Superseded),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentReferenceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Current => "current",
            Self::EnteredInError => "entered-in-error",
            Self::Superseded => "superseded",
        }
    }
}
impl ::std::fmt::Display for DocumentReferenceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Current => "Current",
            Self::EnteredInError => "Entered in Error",
            Self::Superseded => "Superseded",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DocumentReferenceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentReferenceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DocumentReferenceStatus> for Coding {
    fn from(code: DocumentReferenceStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/document-reference-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DocumentReferenceStatus> for CodeableConcept {
    fn from(code: DocumentReferenceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[DocumentRelationshipType](http://hl7.org/fhir/ValueSet/document-relationship-type)**. The type of relationship between documents.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DocumentRelationshipType {
    /** **appends**

Appends. This document adds additional information to the target document. */
    Appends,
    /** **incorporates**

Incorporates. This document embeds the content from the (source) target document. */
    Incorporates,
    /** **replaces**

Replaces. This document logically replaces or supersedes the target document. */
    Replaces,
    /** **signs**

Signs. This document is a signature of the target document. */
    Signs,
    /** **summarizes**

Summarizes. This document summarizes the content from the (source) target document. */
    Summarizes,
    /** **transforms**

Transforms. This document was generated by transforming the target document (e.g. format or language conversion). */
    Transforms,
}
impl ::core::str::FromStr for DocumentRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "appends" => Ok(Self::Appends),
            "incorporates" => Ok(Self::Incorporates),
            "replaces" => Ok(Self::Replaces),
            "signs" => Ok(Self::Signs),
            "summarizes" => Ok(Self::Summarizes),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Appends => "appends",
            Self::Incorporates => "incorporates",
            Self::Replaces => "replaces",
            Self::Signs => "signs",
            Self::Summarizes => "summarizes",
            Self::Transforms => "transforms",
        }
    }
}
impl ::std::fmt::Display for DocumentRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Appends => "Appends",
            Self::Incorporates => "Incorporates",
            Self::Replaces => "Replaces",
            Self::Signs => "Signs",
            Self::Summarizes => "Summarizes",
            Self::Transforms => "Transforms",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for DocumentRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<DocumentRelationshipType> for Coding {
    fn from(code: DocumentRelationshipType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/document-relationship-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<DocumentRelationshipType> for CodeableConcept {
    fn from(code: DocumentRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EligibilityRequestPurpose](http://hl7.org/fhir/ValueSet/eligibilityrequest-purpose)**. A code specifying the types of information being requested.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EligibilityRequestPurpose {
    /** **auth-requirements**

Coverage auth-requirements. The prior authorization requirements for the listed, or discovered if specified, converages for the categories of service and/or specifed biling codes are requested. */
    AuthRequirements,
    /** **benefits**

Coverage benefits. The plan benefits and optionally benefits consumed  for the listed, or discovered if specified, converages are requested. */
    Benefits,
    /** **discovery**

Coverage Discovery. The insurer is requested to report on any coverages which they are aware of in addition to any specifed. */
    Discovery,
    /** **validation**

Coverage Validation. A check that the specified coverages are in-force is requested. */
    Validation,
}
impl ::core::str::FromStr for EligibilityRequestPurpose {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "auth-requirements" => Ok(Self::AuthRequirements),
            "benefits" => Ok(Self::Benefits),
            "discovery" => Ok(Self::Discovery),
            "validation" => Ok(Self::Validation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EligibilityRequestPurpose {
    fn as_ref(&self) -> &str {
        match self {
            Self::AuthRequirements => "auth-requirements",
            Self::Benefits => "benefits",
            Self::Discovery => "discovery",
            Self::Validation => "validation",
        }
    }
}
impl ::std::fmt::Display for EligibilityRequestPurpose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AuthRequirements => "Coverage auth-requirements",
            Self::Benefits => "Coverage benefits",
            Self::Discovery => "Coverage Discovery",
            Self::Validation => "Coverage Validation",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EligibilityRequestPurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EligibilityRequestPurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EligibilityRequestPurpose> for Coding {
    fn from(code: EligibilityRequestPurpose) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/eligibilityrequest-purpose".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EligibilityRequestPurpose> for CodeableConcept {
    fn from(code: EligibilityRequestPurpose) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EligibilityResponsePurpose](http://hl7.org/fhir/ValueSet/eligibilityresponse-purpose)**. A code specifying the types of information being requested.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EligibilityResponsePurpose {
    /** **auth-requirements**

Coverage auth-requirements. The prior authorization requirements for the listed, or discovered if specified, converages for the categories of service and/or specifed biling codes are requested. */
    AuthRequirements,
    /** **benefits**

Coverage benefits. The plan benefits and optionally benefits consumed  for the listed, or discovered if specified, converages are requested. */
    Benefits,
    /** **discovery**

Coverage Discovery. The insurer is requested to report on any coverages which they are aware of in addition to any specifed. */
    Discovery,
    /** **validation**

Coverage Validation. A check that the specified coverages are in-force is requested. */
    Validation,
}
impl ::core::str::FromStr for EligibilityResponsePurpose {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "auth-requirements" => Ok(Self::AuthRequirements),
            "benefits" => Ok(Self::Benefits),
            "discovery" => Ok(Self::Discovery),
            "validation" => Ok(Self::Validation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EligibilityResponsePurpose {
    fn as_ref(&self) -> &str {
        match self {
            Self::AuthRequirements => "auth-requirements",
            Self::Benefits => "benefits",
            Self::Discovery => "discovery",
            Self::Validation => "validation",
        }
    }
}
impl ::std::fmt::Display for EligibilityResponsePurpose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AuthRequirements => "Coverage auth-requirements",
            Self::Benefits => "Coverage benefits",
            Self::Discovery => "Coverage Discovery",
            Self::Validation => "Coverage Validation",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EligibilityResponsePurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EligibilityResponsePurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EligibilityResponsePurpose> for Coding {
    fn from(code: EligibilityResponsePurpose) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/eligibilityresponse-purpose".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EligibilityResponsePurpose> for CodeableConcept {
    fn from(code: EligibilityResponsePurpose) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EnableWhenBehavior](http://hl7.org/fhir/ValueSet/questionnaire-enable-behavior)**. Controls how multiple enableWhen values are interpreted -  whether all or any must be true.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EnableWhenBehavior {
    /** **all**

All. Enable the question when all the enableWhen criteria are satisfied. */
    All,
    /** **any**

Any. Enable the question when any of the enableWhen criteria are satisfied. */
    Any,
}
impl ::core::str::FromStr for EnableWhenBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "any" => Ok(Self::Any),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EnableWhenBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::All => "all",
            Self::Any => "any",
        }
    }
}
impl ::std::fmt::Display for EnableWhenBehavior {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::All => "All",
            Self::Any => "Any",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EnableWhenBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EnableWhenBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EnableWhenBehavior> for Coding {
    fn from(code: EnableWhenBehavior) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/questionnaire-enable-behavior".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EnableWhenBehavior> for CodeableConcept {
    fn from(code: EnableWhenBehavior) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EncounterDiagnosisUse](http://hl7.org/fhir/encounter-diagnosis-use)**. Encounter Condition Use\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum EncounterDiagnosisUse {
    /** **final**

Final. */
    Final,
    /** **working**

Working. */
    Working,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EncounterDiagnosisUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "final" => Ok(Self::Final),
            "working" => Ok(Self::Working),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EncounterDiagnosisUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Final => "final",
            Self::Working => "working",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for EncounterDiagnosisUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Final => "Final",
            Self::Working => "Working",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EncounterDiagnosisUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterDiagnosisUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterDiagnosisUse> for Coding {
    fn from(code: EncounterDiagnosisUse) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/encounter-diagnosis-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EncounterDiagnosisUse> for CodeableConcept {
    fn from(code: EncounterDiagnosisUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EncounterLocationStatus](http://hl7.org/fhir/ValueSet/encounter-location-status)**. The status of the location.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EncounterLocationStatus {
    /** **active**

Active. The patient is currently at this location, or was between the period specified.

A system may update these records when the patient leaves the location to either reserved, or completed. */
    Active,
    /** **completed**

Completed. The patient was at this location during the period specified.

Not to be used when the patient is currently at the location. */
    Completed,
    /** **planned**

Planned. The patient is planned to be moved to this location at some point in the future. */
    Planned,
    /** **reserved**

Reserved. This location is held empty for this patient. */
    Reserved,
}
impl ::core::str::FromStr for EncounterLocationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "planned" => Ok(Self::Planned),
            "reserved" => Ok(Self::Reserved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterLocationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::Planned => "planned",
            Self::Reserved => "reserved",
        }
    }
}
impl ::std::fmt::Display for EncounterLocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Completed => "Completed",
            Self::Planned => "Planned",
            Self::Reserved => "Reserved",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EncounterLocationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterLocationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterLocationStatus> for Coding {
    fn from(code: EncounterLocationStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/encounter-location-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EncounterLocationStatus> for CodeableConcept {
    fn from(code: EncounterLocationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EncounterReasonUse](http://hl7.org/fhir/ValueSet/encounter-reason-use)**. Encounter Reason Use\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EncounterReasonUse {
    /** **AD**

Admitting Diagnosis. */
    Ad,
    /** **CC**

Chief Complaint. */
    Cc,
    /** **HC**

Health Concern. */
    Hc,
    /** **HM**

Health Maintenance (including screening). */
    Hm,
    /** **RV**

Reason for Visit. */
    Rv,
}
impl ::core::str::FromStr for EncounterReasonUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AD" => Ok(Self::Ad),
            "CC" => Ok(Self::Cc),
            "HC" => Ok(Self::Hc),
            "HM" => Ok(Self::Hm),
            "RV" => Ok(Self::Rv),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterReasonUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ad => "AD",
            Self::Cc => "CC",
            Self::Hc => "HC",
            Self::Hm => "HM",
            Self::Rv => "RV",
        }
    }
}
impl ::std::fmt::Display for EncounterReasonUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Ad => "Admitting Diagnosis",
            Self::Cc => "Chief Complaint",
            Self::Hc => "Health Concern",
            Self::Hm => "Health Maintenance (including screening)",
            Self::Rv => "Reason for Visit",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EncounterReasonUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterReasonUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterReasonUse> for Coding {
    fn from(code: EncounterReasonUse) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/encounter-reason-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EncounterReasonUse> for CodeableConcept {
    fn from(code: EncounterReasonUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EncounterStatus](http://hl7.org/fhir/ValueSet/encounter-status)**. Current state of the encounter.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EncounterStatus {
    /** **cancelled**

Cancelled. The Encounter has ended before it has begun. */
    Cancelled,
    /** **completed**

Completed. The Encounter has ended. */
    Completed,
    /** **discharged**

Discharged. The Encounter has been clinically completed, the patient has been discharged from the facility or the visit has ended, and the patient may have departed (refer to subjectStatus). While the encounter is in this status, administrative activities are usually performed, collating all required documentation and charge information before being released for billing, at which point the status will move to completed. */
    Discharged,
    /** **discontinued**

Discontinued. The Encounter has started, but was not able to be completed. Further action may need to be performed, such as rescheduling appointments related to this encounter. */
    Discontinued,
    /** **entered-in-error**

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **in-progress**

In Progress. The Encounter has begun and the patient is present / the practitioner and the patient are meeting. */
    InProgress,
    /** **on-hold**

On Hold. The Encounter has begun, but is currently on hold, e.g. because the patient is temporarily on leave. */
    OnHold,
    /** **planned**

Planned. The Encounter has not yet started. */
    Planned,
    /** **unknown**

Unknown. The encounter status is unknown. Note that "unknown" is a value of last resort and every attempt should be made to provide a meaningful value other than "unknown". */
    Unknown,
}
impl ::core::str::FromStr for EncounterStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "discharged" => Ok(Self::Discharged),
            "discontinued" => Ok(Self::Discontinued),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "planned" => Ok(Self::Planned),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Discharged => "discharged",
            Self::Discontinued => "discontinued",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::Planned => "planned",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for EncounterStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Cancelled => "Cancelled",
            Self::Completed => "Completed",
            Self::Discharged => "Discharged",
            Self::Discontinued => "Discontinued",
            Self::EnteredInError => "Entered in Error",
            Self::InProgress => "In Progress",
            Self::OnHold => "On Hold",
            Self::Planned => "Planned",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EncounterStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EncounterStatus> for Coding {
    fn from(code: EncounterStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/encounter-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EncounterStatus> for CodeableConcept {
    fn from(code: EncounterStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EndpointEnvironment](http://hl7.org/fhir/ValueSet/endpoint-environment)**. The environment type of the endpoint.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EndpointEnvironment {
    /** **dev**

Development. Development environment used while building systems */
    Dev,
    /** **prod**

Production. Production environment and is expected to contain real data and should be protected appropriately */
    Prod,
    /** **staging**

Staging. Staging environment typically used while preparing for a release to production */
    Staging,
    /** **test**

Test. Test environment, it is not intended for production usage. */
    Test,
    /** **train**

Training. Training environment, it is not intended for production usage and typically contains data specifically prepared for training usage. */
    Train,
}
impl ::core::str::FromStr for EndpointEnvironment {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "dev" => Ok(Self::Dev),
            "prod" => Ok(Self::Prod),
            "staging" => Ok(Self::Staging),
            "test" => Ok(Self::Test),
            "train" => Ok(Self::Train),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EndpointEnvironment {
    fn as_ref(&self) -> &str {
        match self {
            Self::Dev => "dev",
            Self::Prod => "prod",
            Self::Staging => "staging",
            Self::Test => "test",
            Self::Train => "train",
        }
    }
}
impl ::std::fmt::Display for EndpointEnvironment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Dev => "Development",
            Self::Prod => "Production",
            Self::Staging => "Staging",
            Self::Test => "Test",
            Self::Train => "Training",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EndpointEnvironment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EndpointEnvironment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EndpointEnvironment> for Coding {
    fn from(code: EndpointEnvironment) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/endpoint-environment".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EndpointEnvironment> for CodeableConcept {
    fn from(code: EndpointEnvironment) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EndpointStatus](http://hl7.org/fhir/ValueSet/endpoint-status)**. The status of the endpoint.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EndpointStatus {
    /** **active**

Active. This endpoint is expected to be active and can be used. */
    Active,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **error**

Error. This endpoint has exceeded connectivity thresholds and is considered in an error state and should no longer be attempted to connect to until corrective action is taken. */
    Error,
    /** **off**

Off. This endpoint is no longer to be used. */
    Off,
    /** **suspended**

Suspended. This endpoint is temporarily unavailable. */
    Suspended,
}
impl ::core::str::FromStr for EndpointStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "error" => Ok(Self::Error),
            "off" => Ok(Self::Off),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EndpointStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Error => "error",
            Self::Off => "off",
            Self::Suspended => "suspended",
        }
    }
}
impl ::std::fmt::Display for EndpointStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in error",
            Self::Error => "Error",
            Self::Off => "Off",
            Self::Suspended => "Suspended",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EndpointStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EndpointStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EndpointStatus> for Coding {
    fn from(code: EndpointStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/endpoint-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EndpointStatus> for CodeableConcept {
    fn from(code: EndpointStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EpisodeOfCareStatus](http://hl7.org/fhir/ValueSet/episode-of-care-status)**. The status of the episode of care.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EpisodeOfCareStatus {
    /** **active**

Active. This episode of care is current. */
    Active,
    /** **cancelled**

Cancelled. The episode of care was cancelled, or withdrawn from service, often selected during the planned stage as the patient may have gone elsewhere, or the circumstances have changed and the organization is unable to provide the care. It indicates that services terminated outside the planned/expected workflow. */
    Cancelled,
    /** **entered-in-error**

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **finished**

Finished. This episode of care is finished and the organization is not expecting to be providing further care to the patient. Can also be known as "closed", "completed" or other similar terms. */
    Finished,
    /** **onhold**

On Hold. This episode of care is on hold; the organization has limited responsibility for the patient (such as while on respite). */
    Onhold,
    /** **planned**

Planned. This episode of care is planned to start at the date specified in the period.start. During this status, an organization may perform assessments to determine if the patient is eligible to receive services, or be organizing to make resources available to provide care services. */
    Planned,
    /** **waitlist**

Waitlist. This episode has been placed on a waitlist, pending the episode being made active (or cancelled). */
    Waitlist,
}
impl ::core::str::FromStr for EpisodeOfCareStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "finished" => Ok(Self::Finished),
            "onhold" => Ok(Self::Onhold),
            "planned" => Ok(Self::Planned),
            "waitlist" => Ok(Self::Waitlist),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EpisodeOfCareStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Finished => "finished",
            Self::Onhold => "onhold",
            Self::Planned => "planned",
            Self::Waitlist => "waitlist",
        }
    }
}
impl ::std::fmt::Display for EpisodeOfCareStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Cancelled => "Cancelled",
            Self::EnteredInError => "Entered in Error",
            Self::Finished => "Finished",
            Self::Onhold => "On Hold",
            Self::Planned => "Planned",
            Self::Waitlist => "Waitlist",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EpisodeOfCareStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EpisodeOfCareStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EpisodeOfCareStatus> for Coding {
    fn from(code: EpisodeOfCareStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/episode-of-care-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EpisodeOfCareStatus> for CodeableConcept {
    fn from(code: EpisodeOfCareStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EventCapabilityMode](http://hl7.org/fhir/ValueSet/event-capability-mode)**. The mode of a message capability statement.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EventCapabilityMode {
    /** **receiver**

Receiver. The application receives requests and sends responses. */
    Receiver,
    /** **sender**

Sender. The application sends requests and receives responses. */
    Sender,
}
impl ::core::str::FromStr for EventCapabilityMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "receiver" => Ok(Self::Receiver),
            "sender" => Ok(Self::Sender),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventCapabilityMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Receiver => "receiver",
            Self::Sender => "sender",
        }
    }
}
impl ::std::fmt::Display for EventCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Receiver => "Receiver",
            Self::Sender => "Sender",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EventCapabilityMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventCapabilityMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventCapabilityMode> for Coding {
    fn from(code: EventCapabilityMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/event-capability-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EventCapabilityMode> for CodeableConcept {
    fn from(code: EventCapabilityMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EventStatus](http://hl7.org/fhir/ValueSet/event-status)**. Codes identifying the lifecycle stage of an event.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EventStatus {
    /** **completed**

Completed. The event has now concluded. */
    Completed,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "stopped" rather than "entered-in-error".). */
    EnteredInError,
    /** **in-progress**

In Progress. The event is currently occurring. */
    InProgress,
    /** **not-done**

Not Done. The event was terminated prior to any activity beyond preparation.  I.e. The 'main' activity has not yet begun.  The boundary between preparatory and the 'main' activity is context-specific. */
    NotDone,
    /** **on-hold**

On Hold. The event has been temporarily stopped but is expected to resume in the future. */
    OnHold,
    /** **preparation**

Preparation. The core event has not started yet, but some staging activities have begun (e.g. surgical suite preparation).  Preparation stages may be tracked for billing purposes. */
    Preparation,
    /** **stopped**

Stopped. The event was terminated prior to the full completion of the intended activity but after at least some of the 'main' activity (beyond preparation) has occurred. */
    Stopped,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this event.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply,  but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for EventStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "not-done" => Ok(Self::NotDone),
            "on-hold" => Ok(Self::OnHold),
            "preparation" => Ok(Self::Preparation),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::NotDone => "not-done",
            Self::OnHold => "on-hold",
            Self::Preparation => "preparation",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for EventStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Completed => "Completed",
            Self::EnteredInError => "Entered in Error",
            Self::InProgress => "In Progress",
            Self::NotDone => "Not Done",
            Self::OnHold => "On Hold",
            Self::Preparation => "Preparation",
            Self::Stopped => "Stopped",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EventStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventStatus> for Coding {
    fn from(code: EventStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/event-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EventStatus> for CodeableConcept {
    fn from(code: EventStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EventTiming](http://hl7.org/fhir/event-timing)**. Real-world event relating to the schedule.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum EventTiming {
    /** **AFT**

Afternoon. Event occurs during the afternoon. The exact time is unspecified and established by institution convention or patient interpretation. */
    Aft,
    /** **AFT.early**

Early Afternoon. Event occurs during the early afternoon. The exact time is unspecified and established by institution convention or patient interpretation. */
    AftEarly,
    /** **AFT.late**

Late Afternoon. Event occurs during the late afternoon. The exact time is unspecified and established by institution convention or patient interpretation. */
    AftLate,
    /** **EVE**

Evening. Event occurs during the evening. The exact time is unspecified and established by institution convention or patient interpretation. */
    Eve,
    /** **EVE.early**

Early Evening. Event occurs during the early evening. The exact time is unspecified and established by institution convention or patient interpretation. */
    EveEarly,
    /** **EVE.late**

Late Evening. Event occurs during the late evening. The exact time is unspecified and established by institution convention or patient interpretation. */
    EveLate,
    /** **IMD**

Immediate. Event occurs a single time (with no repetitions) as soon as possible after the scheduled or actual start of the overall event. */
    Imd,
    /** **MORN**

Morning. Event occurs during the morning. The exact time is unspecified and established by institution convention or patient interpretation. */
    Morn,
    /** **MORN.early**

Early Morning. Event occurs during the early morning. The exact time is unspecified and established by institution convention or patient interpretation. */
    MornEarly,
    /** **MORN.late**

Late Morning. Event occurs during the late morning. The exact time is unspecified and established by institution convention or patient interpretation. */
    MornLate,
    /** **NIGHT**

Night. Event occurs during the night. The exact time is unspecified and established by institution convention or patient interpretation. */
    Night,
    /** **NOON**

Noon. Event occurs around 12:00pm. The exact time is unspecified and established by institution convention or patient interpretation. */
    Noon,
    /** **PHS**

After Sleep. Event occurs [offset] after subject goes to sleep. The exact time is unspecified and established by institution convention or patient interpretation. */
    Phs,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EventTiming {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AFT" => Ok(Self::Aft),
            "AFT.early" => Ok(Self::AftEarly),
            "AFT.late" => Ok(Self::AftLate),
            "EVE" => Ok(Self::Eve),
            "EVE.early" => Ok(Self::EveEarly),
            "EVE.late" => Ok(Self::EveLate),
            "IMD" => Ok(Self::Imd),
            "MORN" => Ok(Self::Morn),
            "MORN.early" => Ok(Self::MornEarly),
            "MORN.late" => Ok(Self::MornLate),
            "NIGHT" => Ok(Self::Night),
            "NOON" => Ok(Self::Noon),
            "PHS" => Ok(Self::Phs),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EventTiming {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aft => "AFT",
            Self::AftEarly => "AFT.early",
            Self::AftLate => "AFT.late",
            Self::Eve => "EVE",
            Self::EveEarly => "EVE.early",
            Self::EveLate => "EVE.late",
            Self::Imd => "IMD",
            Self::Morn => "MORN",
            Self::MornEarly => "MORN.early",
            Self::MornLate => "MORN.late",
            Self::Night => "NIGHT",
            Self::Noon => "NOON",
            Self::Phs => "PHS",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for EventTiming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Aft => "Afternoon",
            Self::AftEarly => "Early Afternoon",
            Self::AftLate => "Late Afternoon",
            Self::Eve => "Evening",
            Self::EveEarly => "Early Evening",
            Self::EveLate => "Late Evening",
            Self::Imd => "Immediate",
            Self::Morn => "Morning",
            Self::MornEarly => "Early Morning",
            Self::MornLate => "Late Morning",
            Self::Night => "Night",
            Self::Noon => "Noon",
            Self::Phs => "After Sleep",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EventTiming {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventTiming {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EventTiming> for Coding {
    fn from(code: EventTiming) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/event-timing".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EventTiming> for CodeableConcept {
    fn from(code: EventTiming) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EvidenceCertaintyRating](http://hl7.org/fhir/ValueSet/certainty-rating)**. The assessment of quality, confidence, or certainty.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceCertaintyRating {
    /** **absent**

absent. possible reason for increasing quality rating was checked and found to be absent. */
    Absent,
    /** **downcode1**

reduce rating: -1. reduce quality rating by 1. */
    Downcode1,
    /** **downcode2**

reduce rating: -2. reduce quality rating by 2. */
    Downcode2,
    /** **downcode3**

reduce rating: -3. reduce quality rating by 3. */
    Downcode3,
    /** **extremely-serious-concern**

extremely serious concern. extremely serious concern. */
    ExtremelySeriousConcern,
    /** **high**

High quality. High quality evidence. */
    High,
    /** **low**

Low quality. Low quality evidence. */
    Low,
    /** **moderate**

Moderate quality. Moderate quality evidence. */
    Moderate,
    /** **no-change**

no change to rating. no change to quality rating. */
    NoChange,
    /** **no-concern**

no serious concern. no serious concern. */
    NoConcern,
    /** **present**

present. possible reason for increasing quality rating was checked and found to be present. */
    Present,
    /** **serious-concern**

serious concern. serious concern. */
    SeriousConcern,
    /** **upcode1**

increase rating: +1. increase quality rating by 1. */
    Upcode1,
    /** **upcode2**

increase rating: +2. increase quality rating by 2. */
    Upcode2,
    /** **very-low**

Very low quality. Very low quality evidence. */
    VeryLow,
    /** **very-serious-concern**

very serious concern. very serious concern. */
    VerySeriousConcern,
}
impl ::core::str::FromStr for EvidenceCertaintyRating {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "absent" => Ok(Self::Absent),
            "downcode1" => Ok(Self::Downcode1),
            "downcode2" => Ok(Self::Downcode2),
            "downcode3" => Ok(Self::Downcode3),
            "extremely-serious-concern" => Ok(Self::ExtremelySeriousConcern),
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            "no-change" => Ok(Self::NoChange),
            "no-concern" => Ok(Self::NoConcern),
            "present" => Ok(Self::Present),
            "serious-concern" => Ok(Self::SeriousConcern),
            "upcode1" => Ok(Self::Upcode1),
            "upcode2" => Ok(Self::Upcode2),
            "very-low" => Ok(Self::VeryLow),
            "very-serious-concern" => Ok(Self::VerySeriousConcern),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceCertaintyRating {
    fn as_ref(&self) -> &str {
        match self {
            Self::Absent => "absent",
            Self::Downcode1 => "downcode1",
            Self::Downcode2 => "downcode2",
            Self::Downcode3 => "downcode3",
            Self::ExtremelySeriousConcern => "extremely-serious-concern",
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
            Self::NoChange => "no-change",
            Self::NoConcern => "no-concern",
            Self::Present => "present",
            Self::SeriousConcern => "serious-concern",
            Self::Upcode1 => "upcode1",
            Self::Upcode2 => "upcode2",
            Self::VeryLow => "very-low",
            Self::VerySeriousConcern => "very-serious-concern",
        }
    }
}
impl ::std::fmt::Display for EvidenceCertaintyRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Absent => "absent",
            Self::Downcode1 => "reduce rating: -1",
            Self::Downcode2 => "reduce rating: -2",
            Self::Downcode3 => "reduce rating: -3",
            Self::ExtremelySeriousConcern => "extremely serious concern",
            Self::High => "High quality",
            Self::Low => "Low quality",
            Self::Moderate => "Moderate quality",
            Self::NoChange => "no change to rating",
            Self::NoConcern => "no serious concern",
            Self::Present => "present",
            Self::SeriousConcern => "serious concern",
            Self::Upcode1 => "increase rating: +1",
            Self::Upcode2 => "increase rating: +2",
            Self::VeryLow => "Very low quality",
            Self::VerySeriousConcern => "very serious concern",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EvidenceCertaintyRating {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceCertaintyRating {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceCertaintyRating> for Coding {
    fn from(code: EvidenceCertaintyRating) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/certainty-rating".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EvidenceCertaintyRating> for CodeableConcept {
    fn from(code: EvidenceCertaintyRating) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EvidenceCertaintyType](http://hl7.org/fhir/ValueSet/certainty-type)**. The aspect of quality, confidence, or certainty.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceCertaintyType {
    /** **DoseResponseGradient**

Dose response gradient. higher certainty due to dose response relationship. */
    DoseResponseGradient,
    /** **Imprecision**

Imprecision. fuzzy or wide variability. */
    Imprecision,
    /** **Inconsistency**

Inconsistency. concerns that findings are not similar enough to support certainty. */
    Inconsistency,
    /** **Indirectness**

Indirectness. concerns reducing external validity. */
    Indirectness,
    /** **LargeEffect**

Large effect. higher certainty due to large effect size. */
    LargeEffect,
    /** **Overall**

Overall certainty. Overall certainty of evidence (quality of evidence). */
    Overall,
    /** **PlausibleConfounding**

Plausible confounding. higher certainty due to risk of bias in opposite direction. */
    PlausibleConfounding,
    /** **PublicationBias**

Publication bias. likelihood that what is published misrepresents what is available to publish. */
    PublicationBias,
    /** **RiskOfBias**

Risk of bias. methodologic concerns reducing internal validity. */
    RiskOfBias,
}
impl ::core::str::FromStr for EvidenceCertaintyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "DoseResponseGradient" => Ok(Self::DoseResponseGradient),
            "Imprecision" => Ok(Self::Imprecision),
            "Inconsistency" => Ok(Self::Inconsistency),
            "Indirectness" => Ok(Self::Indirectness),
            "LargeEffect" => Ok(Self::LargeEffect),
            "Overall" => Ok(Self::Overall),
            "PlausibleConfounding" => Ok(Self::PlausibleConfounding),
            "PublicationBias" => Ok(Self::PublicationBias),
            "RiskOfBias" => Ok(Self::RiskOfBias),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceCertaintyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DoseResponseGradient => "DoseResponseGradient",
            Self::Imprecision => "Imprecision",
            Self::Inconsistency => "Inconsistency",
            Self::Indirectness => "Indirectness",
            Self::LargeEffect => "LargeEffect",
            Self::Overall => "Overall",
            Self::PlausibleConfounding => "PlausibleConfounding",
            Self::PublicationBias => "PublicationBias",
            Self::RiskOfBias => "RiskOfBias",
        }
    }
}
impl ::std::fmt::Display for EvidenceCertaintyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::DoseResponseGradient => "Dose response gradient",
            Self::Imprecision => "Imprecision",
            Self::Inconsistency => "Inconsistency",
            Self::Indirectness => "Indirectness",
            Self::LargeEffect => "Large effect",
            Self::Overall => "Overall certainty",
            Self::PlausibleConfounding => "Plausible confounding",
            Self::PublicationBias => "Publication bias",
            Self::RiskOfBias => "Risk of bias",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EvidenceCertaintyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceCertaintyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceCertaintyType> for Coding {
    fn from(code: EvidenceCertaintyType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/certainty-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EvidenceCertaintyType> for CodeableConcept {
    fn from(code: EvidenceCertaintyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EvidenceClassifier](http://hl7.org/fhir/ValueSet/evidence-classifier-code)**. Commonly used classifiers for evidence sets.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceClassifier {
    /** **AllocConcealNotStated**

Allocation concealment not stated. Allocation concealment not stated. */
    AllocConcealNotStated,
    /** **BaselineImbalance**

Baseline imbalances. Differences between groups at start of trial may confound or bias the findings. */
    BaselineImbalance,
    /** **COVID19HumanResearch**

COVID-19 human data in population, exposure, or outcome. contains human COVID-19 disease in the research data as any variable (population, exposure or outcome). */
    Covid19HumanResearch,
    /** **COVID19Relevant**

COVID-19 relevant (but not specific) article. Not about COVID-19 but relevant to COVID-19 management or understanding. */
    Covid19Relevant,
    /** **COVID19Specific**

COVID-19 specific article. About COVID-19. */
    Covid19Specific,
    /** **Diagnosis**

Article about diagnosis. about methods to distinguish having or not having a condition. */
    Diagnosis,
    /** **EarlyTrialTermination**

Early trial termination. Early trial termination. */
    EarlyTrialTermination,
    /** **Guideline**

Article includes guideline. for clinical practice guidelines. */
    Guideline,
    /** **NoBlinding**

No blinding. No blinding. */
    NoBlinding,
    /** **NoITT**

No intention-to-treat analysis. No intention-to-treat analysis. */
    NoITT,
    /** **NotAssessed**

Not rated, not assessed. Neither rated as yes nor rated as no. */
    NotAssessed,
    /** **NotResearchNotGuideline**

Article is neither research nor guideline. for things that are not research reports, research protocols or guidelines. */
    NotResearchNotGuideline,
    /** **OriginalResearch**

Article includes original research. such as randomized trial, observational study. */
    OriginalResearch,
    /** **PreliminaryAnalysis**

Preliminary analysis. Preliminary analysis. */
    PreliminaryAnalysis,
    /** **Preprint**

Preprint (not final publication). Results presented in preprint (pre-final publication) form. */
    Preprint,
    /** **PreventionAndControl**

Article about prevention and control. about preventive care and interventions. */
    PreventionAndControl,
    /** **PrognosisPrediction**

Article about prognosis or prediction. about predicting risk for something or risk factors for it. */
    PrognosisPrediction,
    /** **RatedAsCaseControl**

classified as case-control study. classified as case-control study. */
    RatedAsCaseControl,
    /** **RatedAsComparativeCohort**

classified as comparative cohort study (observational). classified as comparative cohort study (observational). */
    RatedAsComparativeCohort,
    /** **RatedAsControlledTrial**

classified as nonrandomized controlled trial (experimental). classified as nonrandomized controlled trial (experimental). */
    RatedAsControlledTrial,
    /** **RatedAsMixedMethods**

classified as mixed-methods study. classified as mixed-methods study. */
    RatedAsMixedMethods,
    /** **RatedAsNo**

Rated as no, negative, absent, or exclude. Rated as no, negative, absent, or exclude. */
    RatedAsNo,
    /** **RatedAsOther**

classified as other concept (not elsewhere classified). classified as other concept (not elsewhere classified). */
    RatedAsOther,
    /** **RatedAsRCT**

classified as randomized controlled trial. classified as randomized controlled trial. */
    RatedAsRCT,
    /** **RatedAsUncontrolledSeries**

classified as uncontrolled cohort (case series). classified as uncontrolled cohort (case series). */
    RatedAsUncontrolledSeries,
    /** **RatedAsYes**

Rated as yes, affirmative, positive, present, or include. */
    RatedAsYes,
    /** **ResearchProtocol**

Article provides protocol without results. for research protocols. */
    ResearchProtocol,
    /** **ResearchSynthesis**

Article includes synthesis of research. such as systematic review, meta-analysis, rapid review. */
    ResearchSynthesis,
    /** **RiskOfBias**

Risk of bias assessment. Risk of bias assessment. */
    RiskOfBias,
    /** **SubgroupAnalysis**

Subgroup analysis. Subgroup analysis. */
    SubgroupAnalysis,
    /** **Treatment**

Article about treatment. about therapeutic interventions. */
    Treatment,
}
impl ::core::str::FromStr for EvidenceClassifier {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AllocConcealNotStated" => Ok(Self::AllocConcealNotStated),
            "BaselineImbalance" => Ok(Self::BaselineImbalance),
            "COVID19HumanResearch" => Ok(Self::Covid19HumanResearch),
            "COVID19Relevant" => Ok(Self::Covid19Relevant),
            "COVID19Specific" => Ok(Self::Covid19Specific),
            "Diagnosis" => Ok(Self::Diagnosis),
            "EarlyTrialTermination" => Ok(Self::EarlyTrialTermination),
            "Guideline" => Ok(Self::Guideline),
            "NoBlinding" => Ok(Self::NoBlinding),
            "NoITT" => Ok(Self::NoITT),
            "NotAssessed" => Ok(Self::NotAssessed),
            "NotResearchNotGuideline" => Ok(Self::NotResearchNotGuideline),
            "OriginalResearch" => Ok(Self::OriginalResearch),
            "PreliminaryAnalysis" => Ok(Self::PreliminaryAnalysis),
            "Preprint" => Ok(Self::Preprint),
            "PreventionAndControl" => Ok(Self::PreventionAndControl),
            "PrognosisPrediction" => Ok(Self::PrognosisPrediction),
            "RatedAsCaseControl" => Ok(Self::RatedAsCaseControl),
            "RatedAsComparativeCohort" => Ok(Self::RatedAsComparativeCohort),
            "RatedAsControlledTrial" => Ok(Self::RatedAsControlledTrial),
            "RatedAsMixedMethods" => Ok(Self::RatedAsMixedMethods),
            "RatedAsNo" => Ok(Self::RatedAsNo),
            "RatedAsOther" => Ok(Self::RatedAsOther),
            "RatedAsRCT" => Ok(Self::RatedAsRCT),
            "RatedAsUncontrolledSeries" => Ok(Self::RatedAsUncontrolledSeries),
            "RatedAsYes" => Ok(Self::RatedAsYes),
            "ResearchProtocol" => Ok(Self::ResearchProtocol),
            "ResearchSynthesis" => Ok(Self::ResearchSynthesis),
            "RiskOfBias" => Ok(Self::RiskOfBias),
            "SubgroupAnalysis" => Ok(Self::SubgroupAnalysis),
            "Treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceClassifier {
    fn as_ref(&self) -> &str {
        match self {
            Self::AllocConcealNotStated => "AllocConcealNotStated",
            Self::BaselineImbalance => "BaselineImbalance",
            Self::Covid19HumanResearch => "COVID19HumanResearch",
            Self::Covid19Relevant => "COVID19Relevant",
            Self::Covid19Specific => "COVID19Specific",
            Self::Diagnosis => "Diagnosis",
            Self::EarlyTrialTermination => "EarlyTrialTermination",
            Self::Guideline => "Guideline",
            Self::NoBlinding => "NoBlinding",
            Self::NoITT => "NoITT",
            Self::NotAssessed => "NotAssessed",
            Self::NotResearchNotGuideline => "NotResearchNotGuideline",
            Self::OriginalResearch => "OriginalResearch",
            Self::PreliminaryAnalysis => "PreliminaryAnalysis",
            Self::Preprint => "Preprint",
            Self::PreventionAndControl => "PreventionAndControl",
            Self::PrognosisPrediction => "PrognosisPrediction",
            Self::RatedAsCaseControl => "RatedAsCaseControl",
            Self::RatedAsComparativeCohort => "RatedAsComparativeCohort",
            Self::RatedAsControlledTrial => "RatedAsControlledTrial",
            Self::RatedAsMixedMethods => "RatedAsMixedMethods",
            Self::RatedAsNo => "RatedAsNo",
            Self::RatedAsOther => "RatedAsOther",
            Self::RatedAsRCT => "RatedAsRCT",
            Self::RatedAsUncontrolledSeries => "RatedAsUncontrolledSeries",
            Self::RatedAsYes => "RatedAsYes",
            Self::ResearchProtocol => "ResearchProtocol",
            Self::ResearchSynthesis => "ResearchSynthesis",
            Self::RiskOfBias => "RiskOfBias",
            Self::SubgroupAnalysis => "SubgroupAnalysis",
            Self::Treatment => "Treatment",
        }
    }
}
impl ::std::fmt::Display for EvidenceClassifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AllocConcealNotStated => "Allocation concealment not stated",
            Self::BaselineImbalance => "Baseline imbalances",
            Self::Covid19HumanResearch => {
                "COVID-19 human data in population, exposure, or outcome"
            }
            Self::Covid19Relevant => "COVID-19 relevant (but not specific) article",
            Self::Covid19Specific => "COVID-19 specific article",
            Self::Diagnosis => "Article about diagnosis",
            Self::EarlyTrialTermination => "Early trial termination",
            Self::Guideline => "Article includes guideline",
            Self::NoBlinding => "No blinding",
            Self::NoITT => "No intention-to-treat analysis",
            Self::NotAssessed => "Not rated, not assessed",
            Self::NotResearchNotGuideline => "Article is neither research nor guideline",
            Self::OriginalResearch => "Article includes original research",
            Self::PreliminaryAnalysis => "Preliminary analysis",
            Self::Preprint => "Preprint (not final publication)",
            Self::PreventionAndControl => "Article about prevention and control",
            Self::PrognosisPrediction => "Article about prognosis or prediction",
            Self::RatedAsCaseControl => "classified as case-control study",
            Self::RatedAsComparativeCohort => {
                "classified as comparative cohort study (observational)"
            }
            Self::RatedAsControlledTrial => {
                "classified as nonrandomized controlled trial (experimental)"
            }
            Self::RatedAsMixedMethods => "classified as mixed-methods study",
            Self::RatedAsNo => "Rated as no, negative, absent, or exclude",
            Self::RatedAsOther => {
                "classified as other concept (not elsewhere classified)"
            }
            Self::RatedAsRCT => "classified as randomized controlled trial",
            Self::RatedAsUncontrolledSeries => {
                "classified as uncontrolled cohort (case series)"
            }
            Self::RatedAsYes => {
                "Rated as yes, affirmative, positive, present, or include"
            }
            Self::ResearchProtocol => "Article provides protocol without results",
            Self::ResearchSynthesis => "Article includes synthesis of research",
            Self::RiskOfBias => "Risk of bias assessment",
            Self::SubgroupAnalysis => "Subgroup analysis",
            Self::Treatment => "Article about treatment",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EvidenceClassifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceClassifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceClassifier> for Coding {
    fn from(code: EvidenceClassifier) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/evidence-classifier-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EvidenceClassifier> for CodeableConcept {
    fn from(code: EvidenceClassifier) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EvidenceReportType](http://hl7.org/fhir/ValueSet/evidence-report-type)**. The kind of report, such as grouping of classifiers, search results, or human-compiled expression.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceReportType {
    /** **classification**

Classification. The report is primarily a listing of classifiers about the report subject. */
    Classification,
    /** **resources-compiled**

Resource Compilation. The report is a composition containing one or more FHIR resources in the content. */
    ResourcesCompiled,
    /** **search-results**

Search Results. The report is a composition of results generated in response to a search query. */
    SearchResults,
    /** **text-structured**

Structured Text. The report is a structured representation of text. */
    TextStructured,
}
impl ::core::str::FromStr for EvidenceReportType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "classification" => Ok(Self::Classification),
            "resources-compiled" => Ok(Self::ResourcesCompiled),
            "search-results" => Ok(Self::SearchResults),
            "text-structured" => Ok(Self::TextStructured),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceReportType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Classification => "classification",
            Self::ResourcesCompiled => "resources-compiled",
            Self::SearchResults => "search-results",
            Self::TextStructured => "text-structured",
        }
    }
}
impl ::std::fmt::Display for EvidenceReportType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Classification => "Classification",
            Self::ResourcesCompiled => "Resource Compilation",
            Self::SearchResults => "Search Results",
            Self::TextStructured => "Structured Text",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EvidenceReportType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceReportType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceReportType> for Coding {
    fn from(code: EvidenceReportType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/evidence-report-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EvidenceReportType> for CodeableConcept {
    fn from(code: EvidenceReportType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EvidenceVariableEvent](http://hl7.org/fhir/ValueSet/evidence-variable-event)**. The event used as a base point (reference point) in time.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceVariableEvent {
    /** **condition-detection**

Detection of Condition. The time of first detection of the condition */
    ConditionDetection,
    /** **condition-treatment**

Treatment of Condition. The time of first treatment of the condition */
    ConditionTreatment,
    /** **hospital-admission**

Hospital Admission. The time of admission to the hospital */
    HospitalAdmission,
    /** **hospital-discharge**

Hospital Discharge. The time of discharge from the hospital */
    HospitalDischarge,
    /** **operative-procedure**

Operative Procedure. The time of surgery */
    OperativeProcedure,
    /** **study-start**

Study Start. The time of enrollment for the study participant */
    StudyStart,
    /** **treatment-start**

Start of Treatment. The time of initiation of the treatment */
    TreatmentStart,
}
impl ::core::str::FromStr for EvidenceVariableEvent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "condition-detection" => Ok(Self::ConditionDetection),
            "condition-treatment" => Ok(Self::ConditionTreatment),
            "hospital-admission" => Ok(Self::HospitalAdmission),
            "hospital-discharge" => Ok(Self::HospitalDischarge),
            "operative-procedure" => Ok(Self::OperativeProcedure),
            "study-start" => Ok(Self::StudyStart),
            "treatment-start" => Ok(Self::TreatmentStart),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceVariableEvent {
    fn as_ref(&self) -> &str {
        match self {
            Self::ConditionDetection => "condition-detection",
            Self::ConditionTreatment => "condition-treatment",
            Self::HospitalAdmission => "hospital-admission",
            Self::HospitalDischarge => "hospital-discharge",
            Self::OperativeProcedure => "operative-procedure",
            Self::StudyStart => "study-start",
            Self::TreatmentStart => "treatment-start",
        }
    }
}
impl ::std::fmt::Display for EvidenceVariableEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ConditionDetection => "Detection of Condition",
            Self::ConditionTreatment => "Treatment of Condition",
            Self::HospitalAdmission => "Hospital Admission",
            Self::HospitalDischarge => "Hospital Discharge",
            Self::OperativeProcedure => "Operative Procedure",
            Self::StudyStart => "Study Start",
            Self::TreatmentStart => "Start of Treatment",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EvidenceVariableEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceVariableEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceVariableEvent> for Coding {
    fn from(code: EvidenceVariableEvent) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/evidence-variable-event".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EvidenceVariableEvent> for CodeableConcept {
    fn from(code: EvidenceVariableEvent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[EvidenceVariableHandling](http://hl7.org/fhir/ValueSet/variable-handling)**. The handling of the variable in statistical analysis for exposures or outcomes (E.g. Dichotomous, Continuous, Descriptive).\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceVariableHandling {
    /** **continuous**

continuous variable. A continuous variable is one for which, within the limits the variable ranges, any value is possible (from STATO http://purl.obolibrary.org/obo/STATO_0000251). */
    Continuous,
    /** **dichotomous**

dichotomous variable. A dichotomous variable is a categorical variable which is defined to have only 2 categories or possible values (from STATO http://purl.obolibrary.org/obo/STATO_0000090). */
    Dichotomous,
    /** **ordinal**

ordinal variable. An ordinal variable is a categorical variable where the discrete possible values are ordered or correspond to an implicit ranking (from STATO http://purl.obolibrary.org/obo/STATO_0000228). */
    Ordinal,
    /** **polychotomous**

polychotomous variable. A polychotomous variable is a categorical variable which is defined to have minimally 2 categories or possible values. (from STATO  http://purl.obolibrary.org/obo/STATO_0000087).  Suggestion to limit code use to situations when neither dichotomous nor ordinal variables apply. */
    Polychotomous,
}
impl ::core::str::FromStr for EvidenceVariableHandling {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "continuous" => Ok(Self::Continuous),
            "dichotomous" => Ok(Self::Dichotomous),
            "ordinal" => Ok(Self::Ordinal),
            "polychotomous" => Ok(Self::Polychotomous),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceVariableHandling {
    fn as_ref(&self) -> &str {
        match self {
            Self::Continuous => "continuous",
            Self::Dichotomous => "dichotomous",
            Self::Ordinal => "ordinal",
            Self::Polychotomous => "polychotomous",
        }
    }
}
impl ::std::fmt::Display for EvidenceVariableHandling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Continuous => "continuous variable",
            Self::Dichotomous => "dichotomous variable",
            Self::Ordinal => "ordinal variable",
            Self::Polychotomous => "polychotomous variable",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for EvidenceVariableHandling {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceVariableHandling {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<EvidenceVariableHandling> for Coding {
    fn from(code: EvidenceVariableHandling) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/variable-handling".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<EvidenceVariableHandling> for CodeableConcept {
    fn from(code: EvidenceVariableHandling) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ExampleMetadata](http://hl7.org/fhir/CodeSystem/example-metadata)**. This is an example code system that illustrates usage of the metadata resource elements introduced in R5\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleMetadata {
    /** **A**

A. A */
    A,
    /** **B**

B. B */
    B,
    /** **C**

C. C */
    C,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleMetadata {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "A" => Ok(Self::A),
            "B" => Ok(Self::B),
            "C" => Ok(Self::C),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleMetadata {
    fn as_ref(&self) -> &str {
        match self {
            Self::A => "A",
            Self::B => "B",
            Self::C => "C",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ExampleMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::A => "A",
            Self::B => "B",
            Self::C => "C",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ExampleMetadata {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleMetadata {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleMetadata> for Coding {
    fn from(code: ExampleMetadata) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/CodeSystem/example-metadata".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ExampleMetadata> for CodeableConcept {
    fn from(code: ExampleMetadata) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ExampleScenarioActorType](http://hl7.org/fhir/ValueSet/examplescenario-actor-type)**. The type of actor - system or human.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ExampleScenarioActorType {
    /** **person**

Person. A human actor */
    Person,
    /** **system**

System. A software application or other system */
    System,
}
impl ::core::str::FromStr for ExampleScenarioActorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "person" => Ok(Self::Person),
            "system" => Ok(Self::System),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExampleScenarioActorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Person => "person",
            Self::System => "system",
        }
    }
}
impl ::std::fmt::Display for ExampleScenarioActorType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Person => "Person",
            Self::System => "System",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ExampleScenarioActorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleScenarioActorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExampleScenarioActorType> for Coding {
    fn from(code: ExampleScenarioActorType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/examplescenario-actor-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ExampleScenarioActorType> for CodeableConcept {
    fn from(code: ExampleScenarioActorType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ExplanationOfBenefitStatus](http://hl7.org/fhir/ValueSet/explanationofbenefit-status)**. A code specifying the state of the resource instance.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ExplanationOfBenefitStatus {
    /** **active**

Active. The resource instance is currently in-force. */
    Active,
    /** **cancelled**

Cancelled. The resource instance is withdrawn, rescinded or reversed. */
    Cancelled,
    /** **draft**

Draft. A new resource instance the contents of which is not complete. */
    Draft,
    /** **entered-in-error**

Entered In Error. The resource instance was entered in error. */
    EnteredInError,
}
impl ::core::str::FromStr for ExplanationOfBenefitStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExplanationOfBenefitStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
        }
    }
}
impl ::std::fmt::Display for ExplanationOfBenefitStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Cancelled => "Cancelled",
            Self::Draft => "Draft",
            Self::EnteredInError => "Entered In Error",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ExplanationOfBenefitStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExplanationOfBenefitStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExplanationOfBenefitStatus> for Coding {
    fn from(code: ExplanationOfBenefitStatus) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/explanationofbenefit-status".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ExplanationOfBenefitStatus> for CodeableConcept {
    fn from(code: ExplanationOfBenefitStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ExtensionContextType](http://hl7.org/fhir/ValueSet/extension-context-type)**. How an extension context is interpreted.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ExtensionContextType {
    /** **element**

Element ID. The context is any element that has an ElementDefinition.id that matches that found in the expression. This includes ElementDefinition Ids that have slicing identifiers. The full path for the element is [url]#[elementid]. If there is no #, the Element id is one defined in the base specification. */
    Element,
    /** **extension**

Extension URL. The context is a particular extension from a particular StructureDefinition, and the expression is just a uri that identifies the extension. */
    Extension,
    /** **fhirpath**

FHIRPath. The context is all elements that match the FHIRPath query found in the expression. */
    Fhirpath,
}
impl ::core::str::FromStr for ExtensionContextType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "element" => Ok(Self::Element),
            "extension" => Ok(Self::Extension),
            "fhirpath" => Ok(Self::Fhirpath),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExtensionContextType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Element => "element",
            Self::Extension => "extension",
            Self::Fhirpath => "fhirpath",
        }
    }
}
impl ::std::fmt::Display for ExtensionContextType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Element => "Element ID",
            Self::Extension => "Extension URL",
            Self::Fhirpath => "FHIRPath",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ExtensionContextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExtensionContextType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExtensionContextType> for Coding {
    fn from(code: ExtensionContextType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/extension-context-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ExtensionContextType> for CodeableConcept {
    fn from(code: ExtensionContextType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ExtraActivityType](http://hl7.org/fhir/extra-activity-type)**. This value set includes coded concepts not well covered in any of the included valuesets.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExtraActivityType {
    /** **aggregate**

aggregate. Activity resulting in a structured collection of preexisting content that does not necessarily result in an integral object with semantic context making it more than the sum of component parts, from which components could be disaggregated without loss of semantic context, e.g., the assembly of multiple stand-alone documents. */
    Aggregate,
    /** **compose**

compose. Activity resulting in the structured compilation of new and preexisting content for the purposes of forming an integral object with  semantic context making it more than the sum of component parts, which would be lost if decomposed. For example, the composition of a document that includes in whole or part other documents along with new content that result in a new document that has unique semantic meaning. */
    Compose,
    /** **label**

label. The means used to associate a set of security attributes with a specific information object as part of the data structure for that object. [ISO-10181-3 Access Control] */
    Label,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExtraActivityType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aggregate" => Ok(Self::Aggregate),
            "compose" => Ok(Self::Compose),
            "label" => Ok(Self::Label),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExtraActivityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aggregate => "aggregate",
            Self::Compose => "compose",
            Self::Label => "label",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ExtraActivityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Aggregate => "aggregate",
            Self::Compose => "compose",
            Self::Label => "label",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ExtraActivityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExtraActivityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ExtraActivityType> for Coding {
    fn from(code: ExtraActivityType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/extra-activity-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ExtraActivityType> for CodeableConcept {
    fn from(code: ExtraActivityType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[FamilyHistoryStatus](http://hl7.org/fhir/ValueSet/history-status)**. A code that identifies the status of the family history record.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FamilyHistoryStatus {
    /** **completed**

Completed. All available related health information is captured as of the date (and possibly time) when the family member history was taken. */
    Completed,
    /** **entered-in-error**

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **health-unknown**

Health Unknown. Health information for this family member is unavailable/unknown. */
    HealthUnknown,
    /** **partial**

Partial. Some health information is known and captured, but not complete - see notes for details. */
    Partial,
}
impl ::core::str::FromStr for FamilyHistoryStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "health-unknown" => Ok(Self::HealthUnknown),
            "partial" => Ok(Self::Partial),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FamilyHistoryStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::HealthUnknown => "health-unknown",
            Self::Partial => "partial",
        }
    }
}
impl ::std::fmt::Display for FamilyHistoryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Completed => "Completed",
            Self::EnteredInError => "Entered in Error",
            Self::HealthUnknown => "Health Unknown",
            Self::Partial => "Partial",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for FamilyHistoryStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FamilyHistoryStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FamilyHistoryStatus> for Coding {
    fn from(code: FamilyHistoryStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/history-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<FamilyHistoryStatus> for CodeableConcept {
    fn from(code: FamilyHistoryStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[FilterOperator](http://hl7.org/fhir/ValueSet/filter-operator)**. The kind of operation to perform as a part of a property based filter.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FilterOperator {
    /** **=**

Equals. The specified property of the code equals the provided value. */
    Equal,
    /** **child-of**

Child Of. Only concepts with a direct hierarchical relationship to the index code and no other concepts. This does not include the index code in the output. */
    ChildOf,
    /** **descendent-leaf**

Descendent Leaf. Includes concept ids that have a transitive is-a relationship with the concept Id provided as the value, but which do not have any concept ids with transitive is-a relationships with themselves. */
    DescendentLeaf,
    /** **descendent-of**

Descendent Of (by subsumption). Includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, excluding the provided concept itself (i.e. include descendant codes only). */
    DescendentOf,
    /** **exists**

Exists. The specified property of the code has at least one value (if the specified value is true; if the specified value is false, then matches when the specified property of the code has no values). */
    Exists,
    /** **generalizes**

Generalizes (by Subsumption). Includes all concept ids that have a transitive is-a relationship from the concept Id provided as the value, including the provided concept itself (i.e. include ancestor codes and self). */
    Generalizes,
    /** **in**

In Set. The specified property of the code is in the set of codes or concepts specified in the provided value (comma-separated list). */
    In,
    /** **is-a**

Is A (by subsumption). Includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, including the provided concept itself (include descendant codes and self). */
    IsA,
    /** **is-not-a**

Not (Is A) (by subsumption). The specified property of the code does not have an is-a relationship with the provided value. */
    IsNotA,
    /** **not-in**

Not in Set. The specified property of the code is not in the set of codes or concepts specified in the provided value (comma-separated list). */
    NotIn,
    /** **regex**

Regular Expression. The specified property of the code  matches the regex specified in the provided value. */
    Regex,
}
impl ::core::str::FromStr for FilterOperator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "=" => Ok(Self::Equal),
            "child-of" => Ok(Self::ChildOf),
            "descendent-leaf" => Ok(Self::DescendentLeaf),
            "descendent-of" => Ok(Self::DescendentOf),
            "exists" => Ok(Self::Exists),
            "generalizes" => Ok(Self::Generalizes),
            "in" => Ok(Self::In),
            "is-a" => Ok(Self::IsA),
            "is-not-a" => Ok(Self::IsNotA),
            "not-in" => Ok(Self::NotIn),
            "regex" => Ok(Self::Regex),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FilterOperator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equal => "=",
            Self::ChildOf => "child-of",
            Self::DescendentLeaf => "descendent-leaf",
            Self::DescendentOf => "descendent-of",
            Self::Exists => "exists",
            Self::Generalizes => "generalizes",
            Self::In => "in",
            Self::IsA => "is-a",
            Self::IsNotA => "is-not-a",
            Self::NotIn => "not-in",
            Self::Regex => "regex",
        }
    }
}
impl ::std::fmt::Display for FilterOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Equal => "Equals",
            Self::ChildOf => "Child Of",
            Self::DescendentLeaf => "Descendent Leaf",
            Self::DescendentOf => "Descendent Of (by subsumption)",
            Self::Exists => "Exists",
            Self::Generalizes => "Generalizes (by Subsumption)",
            Self::In => "In Set",
            Self::IsA => "Is A (by subsumption)",
            Self::IsNotA => "Not (Is A) (by subsumption)",
            Self::NotIn => "Not in Set",
            Self::Regex => "Regular Expression",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for FilterOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FilterOperator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FilterOperator> for Coding {
    fn from(code: FilterOperator) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/filter-operator".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<FilterOperator> for CodeableConcept {
    fn from(code: FilterOperator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[FinancialResourceStatusCodes](http://hl7.org/fhir/fm-status)**. This value set includes Status codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum FinancialResourceStatusCodes {
    /** **active**

Active. The instance is currently in-force. */
    Active,
    /** **cancelled**

Cancelled. The instance is withdrawn, rescinded or reversed. */
    Cancelled,
    /** **draft**

Draft. A new instance the contents of which is not complete. */
    Draft,
    /** **entered-in-error**

Entered in Error. The instance was entered in error. */
    EnteredInError,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for FinancialResourceStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for FinancialResourceStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for FinancialResourceStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Cancelled => "Cancelled",
            Self::Draft => "Draft",
            Self::EnteredInError => "Entered in Error",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for FinancialResourceStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FinancialResourceStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FinancialResourceStatusCodes> for Coding {
    fn from(code: FinancialResourceStatusCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/fm-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<FinancialResourceStatusCodes> for CodeableConcept {
    fn from(code: FinancialResourceStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[FlagStatus](http://hl7.org/fhir/ValueSet/flag-status)**. Indicates whether this flag is active and needs to be displayed to a user, or whether it is no longer needed or was entered in error.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FlagStatus {
    /** **active**

Active. A current flag that should be displayed to a user. A system may use the category to determine which user roles should view the flag. */
    Active,
    /** **entered-in-error**

Entered in Error. The flag was added in error and should no longer be displayed. */
    EnteredInError,
    /** **inactive**

Inactive. The flag no longer needs to be displayed. */
    Inactive,
}
impl ::core::str::FromStr for FlagStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FlagStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Display for FlagStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in Error",
            Self::Inactive => "Inactive",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for FlagStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FlagStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FlagStatus> for Coding {
    fn from(code: FlagStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/flag-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<FlagStatus> for CodeableConcept {
    fn from(code: FlagStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[FocusCharacteristicCode](http://hl7.org/fhir/ValueSet/focus-characteristic-code)**. Evidence focus characteristic code.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FocusCharacteristicCode {
    /** **citation**

Citation. Used to reference a specific article. */
    Citation,
    /** **clinical-outcomes-observed**

Observed outcomes are clinical outcomes. Used to denote a focus on clinical outcomes, ie evidence variable in role of outcome (measured variable) as observed is considered a "clinical outcome" (patient-important outcome such as mortality, symptoms, function or quality of life). */
    ClinicalOutcomesObserved,
    /** **comparator**

Comparator. The comparator (intervention or control state) of interest. */
    Comparator,
    /** **exposure**

Exposure. The exposure of interest, such as an intervention. */
    Exposure,
    /** **medication-exposures**

Medication exposures. Any medication exposures. A subset of exposures or interventions that are medications. */
    MedicationExposures,
    /** **outcome**

Outcome. the outcome of interest. */
    Outcome,
    /** **population**

Population. The population of interest. */
    Population,
    /** **study-type**

Study type. Type of research study, such as randomized trial or case-control study. */
    StudyType,
}
impl ::core::str::FromStr for FocusCharacteristicCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "citation" => Ok(Self::Citation),
            "clinical-outcomes-observed" => Ok(Self::ClinicalOutcomesObserved),
            "comparator" => Ok(Self::Comparator),
            "exposure" => Ok(Self::Exposure),
            "medication-exposures" => Ok(Self::MedicationExposures),
            "outcome" => Ok(Self::Outcome),
            "population" => Ok(Self::Population),
            "study-type" => Ok(Self::StudyType),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FocusCharacteristicCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Citation => "citation",
            Self::ClinicalOutcomesObserved => "clinical-outcomes-observed",
            Self::Comparator => "comparator",
            Self::Exposure => "exposure",
            Self::MedicationExposures => "medication-exposures",
            Self::Outcome => "outcome",
            Self::Population => "population",
            Self::StudyType => "study-type",
        }
    }
}
impl ::std::fmt::Display for FocusCharacteristicCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Citation => "Citation",
            Self::ClinicalOutcomesObserved => "Observed outcomes are clinical outcomes",
            Self::Comparator => "Comparator",
            Self::Exposure => "Exposure",
            Self::MedicationExposures => "Medication exposures",
            Self::Outcome => "Outcome",
            Self::Population => "Population",
            Self::StudyType => "Study type",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for FocusCharacteristicCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FocusCharacteristicCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FocusCharacteristicCode> for Coding {
    fn from(code: FocusCharacteristicCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/focus-characteristic-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<FocusCharacteristicCode> for CodeableConcept {
    fn from(code: FocusCharacteristicCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[FormularyItemStatusCodes](http://hl7.org/fhir/ValueSet/formularyitem-status)**. FormularyItem Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FormularyItemStatusCodes {
    /** **active**

Active. The service or product referred to by this FormularyItem is in active use within the drug database or inventory system. */
    Active,
    /** **entered-in-error**

Entered in Error. The service or product referred to by this FormularyItem was entered in error within the drug database or inventory system. */
    EnteredInError,
    /** **inactive**

Inactive. The service or product referred to by this FormularyItem is not in active use within the drug database or inventory system. */
    Inactive,
}
impl ::core::str::FromStr for FormularyItemStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FormularyItemStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Display for FormularyItemStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in Error",
            Self::Inactive => "Inactive",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for FormularyItemStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FormularyItemStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<FormularyItemStatusCodes> for Coding {
    fn from(code: FormularyItemStatusCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/formularyitem-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<FormularyItemStatusCodes> for CodeableConcept {
    fn from(code: FormularyItemStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GenomicStudyChangeType](http://hl7.org/fhir/ValueSet/genomicstudy-changetype)**. The change type relevant to GenomicStudy analysis.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GenomicStudyChangeType {
    /** **AA**

Protein/amino Acids change . Change that involves Amino Acid (AA) or protein sequences. */
    Aa,
    /** **CHR**

Chromosomal changes. Change that involves number or strcture of chromosomes. */
    Chr,
    /** **CNV**

Copy number variations. Change that involves copy number variations among various genomes. */
    Cnv,
    /** **DNA**

DNA change. Change that involves Deoxyribonucleic acid (DNA) sequences. */
    Dna,
    /** **RNA**

RNA change. Change that involves Ribonucleic Acid (RNA) sequences. */
    Rna,
}
impl ::core::str::FromStr for GenomicStudyChangeType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AA" => Ok(Self::Aa),
            "CHR" => Ok(Self::Chr),
            "CNV" => Ok(Self::Cnv),
            "DNA" => Ok(Self::Dna),
            "RNA" => Ok(Self::Rna),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GenomicStudyChangeType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aa => "AA",
            Self::Chr => "CHR",
            Self::Cnv => "CNV",
            Self::Dna => "DNA",
            Self::Rna => "RNA",
        }
    }
}
impl ::std::fmt::Display for GenomicStudyChangeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Aa => "Protein/amino Acids change ",
            Self::Chr => "Chromosomal changes",
            Self::Cnv => "Copy number variations",
            Self::Dna => "DNA change",
            Self::Rna => "RNA change",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GenomicStudyChangeType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenomicStudyChangeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GenomicStudyChangeType> for Coding {
    fn from(code: GenomicStudyChangeType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/genomicstudy-changetype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GenomicStudyChangeType> for CodeableConcept {
    fn from(code: GenomicStudyChangeType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GenomicStudyDataFormat](http://hl7.org/fhir/ValueSet/genomicstudy-dataformat)**. The data format relevant to genomics. These formats and relevant codes were pulled from [Integrative Genomics Viewer Documentation](https://software.broadinstitute.org/software/igv/FileFormats) by Broad Institute.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GenomicStudyDataFormat {
    /** **bam**

BAM. */
    Bam,
    /** **bed**

BED. */
    Bed,
    /** **bedgraph**

BedGraph. */
    Bedgraph,
    /** **bedpe**

BEDPE. */
    Bedpe,
    /** **bigWig**

bigWig. */
    BigWig,
    /** **bigbed**

bigBed. */
    Bigbed,
    /** **birdsuite-files**

Birdsuite-Files. */
    BirdsuiteFiles,
    /** **broadpeak**

broadPeak. */
    Broadpeak,
    /** **cbs**

CBS. */
    Cbs,
    /** **chemical-reactivity-probing-profiles**

Chemical-Reactivity-Probing-Profiles. */
    ChemicalReactivityProbingProfiles,
    /** **chrom-sizes**

chrom-sizes. */
    ChromSizes,
    /** **cn**

CN. */
    Cn,
    /** **cram**

CRAM. */
    Cram,
    /** **custom-file-formats**

Custom-File-Formats. */
    CustomFileFormats,
    /** **cytoband**

Cytoband. */
    Cytoband,
    /** **fasta**

FASTA. */
    Fasta,
    /** **gct**

GCT. */
    Gct,
    /** **genepred**

genePred. */
    Genepred,
    /** **gff-gtf**

GFF/GTF. */
    GffGtf,
    /** **gistic**

GISTIC. */
    Gistic,
    /** **goby**

Goby. */
    Goby,
    /** **gwas**

GWAS. */
    Gwas,
    /** **igv**

IGV. */
    Igv,
    /** **loh**

LOH. */
    Loh,
    /** **maf-multiple-alignment-format**

MAF-Multiple Alignment Format. */
    MafMultipleAlignmentFormat,
    /** **maf-mutation-annotation-format**

MAF-Mutation-Annotation-Format. */
    MafMutationAnnotationFormat,
    /** **merged-bam-file**

Merged BAM File. */
    MergedBamFile,
    /** **mut**

MUT. */
    Mut,
    /** **narrowpeak**

narrowPeak. */
    Narrowpeak,
    /** **psl**

PSL. */
    Psl,
    /** **res**

RES. */
    Res,
    /** **rna-secondary-structure-formats**

RNA-Secondary-Structure-Formats. */
    RnaSecondaryStructureFormats,
    /** **sam**

SAM. */
    Sam,
    /** **sample-info-attributes-file**

Sample-Info-Attributes-file. */
    SampleInfoAttributesFile,
    /** **seg**

SEG. */
    Seg,
    /** **tdf**

TDF. */
    Tdf,
    /** **track-line**

Track Line. */
    TrackLine,
    /** **type-line**

Type Line. */
    TypeLine,
    /** **vcf**

VCF. */
    Vcf,
    /** **wig**

WIG. */
    Wig,
}
impl ::core::str::FromStr for GenomicStudyDataFormat {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bam" => Ok(Self::Bam),
            "bed" => Ok(Self::Bed),
            "bedgraph" => Ok(Self::Bedgraph),
            "bedpe" => Ok(Self::Bedpe),
            "bigWig" => Ok(Self::BigWig),
            "bigbed" => Ok(Self::Bigbed),
            "birdsuite-files" => Ok(Self::BirdsuiteFiles),
            "broadpeak" => Ok(Self::Broadpeak),
            "cbs" => Ok(Self::Cbs),
            "chemical-reactivity-probing-profiles" => {
                Ok(Self::ChemicalReactivityProbingProfiles)
            }
            "chrom-sizes" => Ok(Self::ChromSizes),
            "cn" => Ok(Self::Cn),
            "cram" => Ok(Self::Cram),
            "custom-file-formats" => Ok(Self::CustomFileFormats),
            "cytoband" => Ok(Self::Cytoband),
            "fasta" => Ok(Self::Fasta),
            "gct" => Ok(Self::Gct),
            "genepred" => Ok(Self::Genepred),
            "gff-gtf" => Ok(Self::GffGtf),
            "gistic" => Ok(Self::Gistic),
            "goby" => Ok(Self::Goby),
            "gwas" => Ok(Self::Gwas),
            "igv" => Ok(Self::Igv),
            "loh" => Ok(Self::Loh),
            "maf-multiple-alignment-format" => Ok(Self::MafMultipleAlignmentFormat),
            "maf-mutation-annotation-format" => Ok(Self::MafMutationAnnotationFormat),
            "merged-bam-file" => Ok(Self::MergedBamFile),
            "mut" => Ok(Self::Mut),
            "narrowpeak" => Ok(Self::Narrowpeak),
            "psl" => Ok(Self::Psl),
            "res" => Ok(Self::Res),
            "rna-secondary-structure-formats" => Ok(Self::RnaSecondaryStructureFormats),
            "sam" => Ok(Self::Sam),
            "sample-info-attributes-file" => Ok(Self::SampleInfoAttributesFile),
            "seg" => Ok(Self::Seg),
            "tdf" => Ok(Self::Tdf),
            "track-line" => Ok(Self::TrackLine),
            "type-line" => Ok(Self::TypeLine),
            "vcf" => Ok(Self::Vcf),
            "wig" => Ok(Self::Wig),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GenomicStudyDataFormat {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bam => "bam",
            Self::Bed => "bed",
            Self::Bedgraph => "bedgraph",
            Self::Bedpe => "bedpe",
            Self::BigWig => "bigWig",
            Self::Bigbed => "bigbed",
            Self::BirdsuiteFiles => "birdsuite-files",
            Self::Broadpeak => "broadpeak",
            Self::Cbs => "cbs",
            Self::ChemicalReactivityProbingProfiles => {
                "chemical-reactivity-probing-profiles"
            }
            Self::ChromSizes => "chrom-sizes",
            Self::Cn => "cn",
            Self::Cram => "cram",
            Self::CustomFileFormats => "custom-file-formats",
            Self::Cytoband => "cytoband",
            Self::Fasta => "fasta",
            Self::Gct => "gct",
            Self::Genepred => "genepred",
            Self::GffGtf => "gff-gtf",
            Self::Gistic => "gistic",
            Self::Goby => "goby",
            Self::Gwas => "gwas",
            Self::Igv => "igv",
            Self::Loh => "loh",
            Self::MafMultipleAlignmentFormat => "maf-multiple-alignment-format",
            Self::MafMutationAnnotationFormat => "maf-mutation-annotation-format",
            Self::MergedBamFile => "merged-bam-file",
            Self::Mut => "mut",
            Self::Narrowpeak => "narrowpeak",
            Self::Psl => "psl",
            Self::Res => "res",
            Self::RnaSecondaryStructureFormats => "rna-secondary-structure-formats",
            Self::Sam => "sam",
            Self::SampleInfoAttributesFile => "sample-info-attributes-file",
            Self::Seg => "seg",
            Self::Tdf => "tdf",
            Self::TrackLine => "track-line",
            Self::TypeLine => "type-line",
            Self::Vcf => "vcf",
            Self::Wig => "wig",
        }
    }
}
impl ::std::fmt::Display for GenomicStudyDataFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Bam => "BAM",
            Self::Bed => "BED",
            Self::Bedgraph => "BedGraph",
            Self::Bedpe => "BEDPE",
            Self::BigWig => "bigWig",
            Self::Bigbed => "bigBed",
            Self::BirdsuiteFiles => "Birdsuite-Files",
            Self::Broadpeak => "broadPeak",
            Self::Cbs => "CBS",
            Self::ChemicalReactivityProbingProfiles => {
                "Chemical-Reactivity-Probing-Profiles"
            }
            Self::ChromSizes => "chrom-sizes",
            Self::Cn => "CN",
            Self::Cram => "CRAM",
            Self::CustomFileFormats => "Custom-File-Formats",
            Self::Cytoband => "Cytoband",
            Self::Fasta => "FASTA",
            Self::Gct => "GCT",
            Self::Genepred => "genePred",
            Self::GffGtf => "GFF/GTF",
            Self::Gistic => "GISTIC",
            Self::Goby => "Goby",
            Self::Gwas => "GWAS",
            Self::Igv => "IGV",
            Self::Loh => "LOH",
            Self::MafMultipleAlignmentFormat => "MAF-Multiple Alignment Format",
            Self::MafMutationAnnotationFormat => "MAF-Mutation-Annotation-Format",
            Self::MergedBamFile => "Merged BAM File",
            Self::Mut => "MUT",
            Self::Narrowpeak => "narrowPeak",
            Self::Psl => "PSL",
            Self::Res => "RES",
            Self::RnaSecondaryStructureFormats => "RNA-Secondary-Structure-Formats",
            Self::Sam => "SAM",
            Self::SampleInfoAttributesFile => "Sample-Info-Attributes-file",
            Self::Seg => "SEG",
            Self::Tdf => "TDF",
            Self::TrackLine => "Track Line",
            Self::TypeLine => "Type Line",
            Self::Vcf => "VCF",
            Self::Wig => "WIG",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GenomicStudyDataFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenomicStudyDataFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GenomicStudyDataFormat> for Coding {
    fn from(code: GenomicStudyDataFormat) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/genomicstudy-dataformat".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GenomicStudyDataFormat> for CodeableConcept {
    fn from(code: GenomicStudyDataFormat) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GenomicStudyMethodType](http://hl7.org/fhir/ValueSet/genomicstudy-methodtype)**. The method type of the GenomicStudy analysis. These method types and relevant codes were pulled from [National Library of Medicine-Genetic Testing Registry](https://www.ncbi.nlm.nih.gov/gtr/) (NCBI-GTR) values of describing different testing methods on various levels: [major method category](https://ftp.ncbi.nlm.nih.gov/pub/GTR/standard_terms/Major_method_category.txt), [method category](https://ftp.ncbi.nlm.nih.gov/pub/GTR/standard_terms/Method_category.txt), and [primary methodology](https://ftp.ncbi.nlm.nih.gov/pub/GTR/standard_terms/Primary_test_methodology.txt)\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GenomicStudyMethodType {
    /** **alternative-splicing-detection**

Alternative splicing detection. */
    AlternativeSplicingDetection,
    /** **analyte**

Analyte. */
    Analyte,
    /** **aspe**

Allele-specific primer extension (ASPE). */
    Aspe,
    /** **bi-directional-sanger-sequence-analysis**

Bi-directional Sanger Sequence Analysis. */
    BiDirectionalSangerSequenceAnalysis,
    /** **biochemical-genetics**

Biochemical Genetics. */
    BiochemicalGenetics,
    /** **c-banding**

C-banding. */
    CBanding,
    /** **chromatin-immunoprecipitation-on-chip**

Chromatin Immunoprecipitation on ChIP. */
    ChromatinImmunoprecipitationOnChip,
    /** **chromosome-breakage-studies**

Chromosome breakage studies. */
    ChromosomeBreakageStudies,
    /** **cia**

Chemiluminescent Immunoassay (CIA). */
    Cia,
    /** **comparative-genomic-hybridization**

Comparative Genomic Hybridization. */
    ComparativeGenomicHybridization,
    /** **cytogenetics**

Cytogenetics. */
    Cytogenetics,
    /** **damid**

DamID. */
    Damid,
    /** **deletion-duplication-analysis**

Deletion/duplication analysis. */
    DeletionDuplicationAnalysis,
    /** **detection-of-homozygosity**

Detection of homozygosity. */
    DetectionOfHomozygosity,
    /** **digital-microfluidic-microspheres**

Digital microfluidic microspheres. */
    DigitalMicrofluidicMicrospheres,
    /** **digital-virtual-karyotyping**

Digital / Virtual karyotyping. */
    DigitalVirtualKaryotyping,
    /** **elisa**

Enzyme-Linked Immunosorbent Assays (ELISA). */
    Elisa,
    /** **enzymatic-levels**

Enzymatic levels. */
    EnzymaticLevels,
    /** **enzyme-activity**

Enzyme activity. */
    EnzymeActivity,
    /** **enzyme-assay**

Enzyme assay. */
    EnzymeAssay,
    /** **fish**

Fluorescence in situ hybridization (FISH). */
    Fish,
    /** **fish-interphase**

FISH-interphase. */
    FishInterphase,
    /** **fish-metaphase**

FISH-metaphase. */
    FishMetaphase,
    /** **flow-cytometry**

Flow cytometry. */
    FlowCytometry,
    /** **fluorometry**

Fluorometry. */
    Fluorometry,
    /** **fusion-genes-microarrays**

Fusion genes microarrays. */
    FusionGenesMicroarrays,
    /** **g-banding**

G-banding. */
    GBanding,
    /** **gc-ms**

Gas chromatographyâ€“mass spectrometry (GC-MS). */
    GcMs,
    /** **gene-expression-profiling**

Gene expression profiling. */
    GeneExpressionProfiling,
    /** **gene-id**

GeneID. */
    GeneId,
    /** **gold-nanoparticle-probe-technology**

Gold nanoparticle probe technology. */
    GoldNanoparticleProbeTechnology,
    /** **hplc**

High-performance liquid chromatography (HPLC). */
    Hplc,
    /** **immunohistochemistry**

Immunohistochemistry. */
    Immunohistochemistry,
    /** **karyotyping**

Karyotyping. */
    Karyotyping,
    /** **lc-ms**

Liquid chromatography mass spectrometry (LC-MS). */
    LcMs,
    /** **lc-ms-ms**

Liquid chromatography-tandem mass spectrometry (LC-MS/MS). */
    LcMsMs,
    /** **linkage-analysis**

Linkage analysis. */
    LinkageAnalysis,
    /** **m-fish**

Multicolor FISH (M-FISH). */
    MFish,
    /** **metabolite-levels**

Metabolite levels. */
    MetaboliteLevels,
    /** **methylation-analysis**

Methylation analysis. */
    MethylationAnalysis,
    /** **methylation-specific-pcr**

Methylation-specific PCR. */
    MethylationSpecificPcr,
    /** **microarray**

Microarray. */
    Microarray,
    /** **mlpa**

Multiplex Ligation-dependent Probe Amplification (MLPA). */
    Mlpa,
    /** **molecular-genetics**

Molecular Genetics. */
    MolecularGenetics,
    /** **ms-ms**

Tandem mass spectrometry (MS/MS). */
    MsMs,
    /** **msi**

Microsatellite instability testing (MSI). */
    Msi,
    /** **mutation-scanning-of-select-exons**

Mutation scanning of select exons. */
    MutationScanningOfSelectExons,
    /** **mutation-scanning-of-the-entire-coding-region**

Mutation scanning of the entire coding region. */
    MutationScanningOfTheEntireCodingRegion,
    /** **ngs-mps**

Next-Generation (NGS)/Massively parallel sequencing (MPS). */
    NgsMps,
    /** **ola**

Oligonucleotide Ligation Assay (OLA). */
    Ola,
    /** **oligonucleotide-hybridization-based-dna-sequencing**

Oligonucleotide hybridization-based DNA sequencing. */
    OligonucleotideHybridizationBasedDnaSequencing,
    /** **other**

Other. */
    Other,
    /** **pcr**

PCR. */
    Pcr,
    /** **pcr-rflp-with-southern-hybridization**

PCR-RFLP with Southern hybridization. */
    PcrRflpWithSouthernHybridization,
    /** **pcr-with-allele-specific-hybridization**

PCR with allele specific hybridization. */
    PcrWithAlleleSpecificHybridization,
    /** **protein-analysis**

Protein analysis. */
    ProteinAnalysis,
    /** **protein-expression**

Protein expression. */
    ProteinExpression,
    /** **protein-truncation-test**

Protein truncation test. */
    ProteinTruncationTest,
    /** **pyrosequencing**

Pyrosequencing. */
    Pyrosequencing,
    /** **q-banding**

Q-banding. */
    QBanding,
    /** **qpcr**

Quantitative PCR (qPCR). */
    Qpcr,
    /** **r-banding**

R-banding. */
    RBanding,
    /** **rflp**

RFLP. */
    Rflp,
    /** **rna-analysis**

RNA analysis. */
    RnaAnalysis,
    /** **rt-lamp**

RT-LAMP. */
    RtLamp,
    /** **rt-pcr**

RT-PCR. */
    RtPcr,
    /** **rt-pcr-with-gel-analysis**

RT-PCR with gel analysis. */
    RtPcrWithGelAnalysis,
    /** **rt-qpcr**

RT-qPCR. */
    RtQpcr,
    /** **sequence-analysis-of-select-exons**

Sequence analysis of select exons. */
    SequenceAnalysisOfSelectExons,
    /** **sequence-analysis-of-the-entire-coding-region**

Sequence analysis of the entire coding region. */
    SequenceAnalysisOfTheEntireCodingRegion,
    /** **silver-staining**

Silver staining. */
    SilverStaining,
    /** **sister-chromatid-exchange**

Sister chromatid exchange. */
    SisterChromatidExchange,
    /** **sky**

Spectral karyotyping (SKY). */
    Sky,
    /** **snp-detection**

SNP Detection. */
    SnpDetection,
    /** **t-banding**

T-banding. */
    TBanding,
    /** **targeted-variant-analysis**

Targeted variant analysis. */
    TargetedVariantAnalysis,
    /** **tetra-nucleotide-repeat-by-pcr-or-southern-blot**

Tetra-nucleotide repeat by PCR or Southern Blot. */
    TetraNucleotideRepeatByPcrOrSouthernBlot,
    /** **tiling-arrays**

Tiling Arrays. */
    TilingArrays,
    /** **trinucleotide-repeat-by-pcr-or-southern-blot**

Trinucleotide repeat by PCR or Southern Blot. */
    TrinucleotideRepeatByPcrOrSouthernBlot,
    /** **udp**

Uniparental disomy study (UPD). */
    Udp,
    /** **uni-directional-sanger-sequencing**

Uni-directional Sanger sequencing. */
    UniDirectionalSangerSequencing,
}
impl ::core::str::FromStr for GenomicStudyMethodType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alternative-splicing-detection" => Ok(Self::AlternativeSplicingDetection),
            "analyte" => Ok(Self::Analyte),
            "aspe" => Ok(Self::Aspe),
            "bi-directional-sanger-sequence-analysis" => {
                Ok(Self::BiDirectionalSangerSequenceAnalysis)
            }
            "biochemical-genetics" => Ok(Self::BiochemicalGenetics),
            "c-banding" => Ok(Self::CBanding),
            "chromatin-immunoprecipitation-on-chip" => {
                Ok(Self::ChromatinImmunoprecipitationOnChip)
            }
            "chromosome-breakage-studies" => Ok(Self::ChromosomeBreakageStudies),
            "cia" => Ok(Self::Cia),
            "comparative-genomic-hybridization" => {
                Ok(Self::ComparativeGenomicHybridization)
            }
            "cytogenetics" => Ok(Self::Cytogenetics),
            "damid" => Ok(Self::Damid),
            "deletion-duplication-analysis" => Ok(Self::DeletionDuplicationAnalysis),
            "detection-of-homozygosity" => Ok(Self::DetectionOfHomozygosity),
            "digital-microfluidic-microspheres" => {
                Ok(Self::DigitalMicrofluidicMicrospheres)
            }
            "digital-virtual-karyotyping" => Ok(Self::DigitalVirtualKaryotyping),
            "elisa" => Ok(Self::Elisa),
            "enzymatic-levels" => Ok(Self::EnzymaticLevels),
            "enzyme-activity" => Ok(Self::EnzymeActivity),
            "enzyme-assay" => Ok(Self::EnzymeAssay),
            "fish" => Ok(Self::Fish),
            "fish-interphase" => Ok(Self::FishInterphase),
            "fish-metaphase" => Ok(Self::FishMetaphase),
            "flow-cytometry" => Ok(Self::FlowCytometry),
            "fluorometry" => Ok(Self::Fluorometry),
            "fusion-genes-microarrays" => Ok(Self::FusionGenesMicroarrays),
            "g-banding" => Ok(Self::GBanding),
            "gc-ms" => Ok(Self::GcMs),
            "gene-expression-profiling" => Ok(Self::GeneExpressionProfiling),
            "gene-id" => Ok(Self::GeneId),
            "gold-nanoparticle-probe-technology" => {
                Ok(Self::GoldNanoparticleProbeTechnology)
            }
            "hplc" => Ok(Self::Hplc),
            "immunohistochemistry" => Ok(Self::Immunohistochemistry),
            "karyotyping" => Ok(Self::Karyotyping),
            "lc-ms" => Ok(Self::LcMs),
            "lc-ms-ms" => Ok(Self::LcMsMs),
            "linkage-analysis" => Ok(Self::LinkageAnalysis),
            "m-fish" => Ok(Self::MFish),
            "metabolite-levels" => Ok(Self::MetaboliteLevels),
            "methylation-analysis" => Ok(Self::MethylationAnalysis),
            "methylation-specific-pcr" => Ok(Self::MethylationSpecificPcr),
            "microarray" => Ok(Self::Microarray),
            "mlpa" => Ok(Self::Mlpa),
            "molecular-genetics" => Ok(Self::MolecularGenetics),
            "ms-ms" => Ok(Self::MsMs),
            "msi" => Ok(Self::Msi),
            "mutation-scanning-of-select-exons" => {
                Ok(Self::MutationScanningOfSelectExons)
            }
            "mutation-scanning-of-the-entire-coding-region" => {
                Ok(Self::MutationScanningOfTheEntireCodingRegion)
            }
            "ngs-mps" => Ok(Self::NgsMps),
            "ola" => Ok(Self::Ola),
            "oligonucleotide-hybridization-based-dna-sequencing" => {
                Ok(Self::OligonucleotideHybridizationBasedDnaSequencing)
            }
            "other" => Ok(Self::Other),
            "pcr" => Ok(Self::Pcr),
            "pcr-rflp-with-southern-hybridization" => {
                Ok(Self::PcrRflpWithSouthernHybridization)
            }
            "pcr-with-allele-specific-hybridization" => {
                Ok(Self::PcrWithAlleleSpecificHybridization)
            }
            "protein-analysis" => Ok(Self::ProteinAnalysis),
            "protein-expression" => Ok(Self::ProteinExpression),
            "protein-truncation-test" => Ok(Self::ProteinTruncationTest),
            "pyrosequencing" => Ok(Self::Pyrosequencing),
            "q-banding" => Ok(Self::QBanding),
            "qpcr" => Ok(Self::Qpcr),
            "r-banding" => Ok(Self::RBanding),
            "rflp" => Ok(Self::Rflp),
            "rna-analysis" => Ok(Self::RnaAnalysis),
            "rt-lamp" => Ok(Self::RtLamp),
            "rt-pcr" => Ok(Self::RtPcr),
            "rt-pcr-with-gel-analysis" => Ok(Self::RtPcrWithGelAnalysis),
            "rt-qpcr" => Ok(Self::RtQpcr),
            "sequence-analysis-of-select-exons" => {
                Ok(Self::SequenceAnalysisOfSelectExons)
            }
            "sequence-analysis-of-the-entire-coding-region" => {
                Ok(Self::SequenceAnalysisOfTheEntireCodingRegion)
            }
            "silver-staining" => Ok(Self::SilverStaining),
            "sister-chromatid-exchange" => Ok(Self::SisterChromatidExchange),
            "sky" => Ok(Self::Sky),
            "snp-detection" => Ok(Self::SnpDetection),
            "t-banding" => Ok(Self::TBanding),
            "targeted-variant-analysis" => Ok(Self::TargetedVariantAnalysis),
            "tetra-nucleotide-repeat-by-pcr-or-southern-blot" => {
                Ok(Self::TetraNucleotideRepeatByPcrOrSouthernBlot)
            }
            "tiling-arrays" => Ok(Self::TilingArrays),
            "trinucleotide-repeat-by-pcr-or-southern-blot" => {
                Ok(Self::TrinucleotideRepeatByPcrOrSouthernBlot)
            }
            "udp" => Ok(Self::Udp),
            "uni-directional-sanger-sequencing" => {
                Ok(Self::UniDirectionalSangerSequencing)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GenomicStudyMethodType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AlternativeSplicingDetection => "alternative-splicing-detection",
            Self::Analyte => "analyte",
            Self::Aspe => "aspe",
            Self::BiDirectionalSangerSequenceAnalysis => {
                "bi-directional-sanger-sequence-analysis"
            }
            Self::BiochemicalGenetics => "biochemical-genetics",
            Self::CBanding => "c-banding",
            Self::ChromatinImmunoprecipitationOnChip => {
                "chromatin-immunoprecipitation-on-chip"
            }
            Self::ChromosomeBreakageStudies => "chromosome-breakage-studies",
            Self::Cia => "cia",
            Self::ComparativeGenomicHybridization => "comparative-genomic-hybridization",
            Self::Cytogenetics => "cytogenetics",
            Self::Damid => "damid",
            Self::DeletionDuplicationAnalysis => "deletion-duplication-analysis",
            Self::DetectionOfHomozygosity => "detection-of-homozygosity",
            Self::DigitalMicrofluidicMicrospheres => "digital-microfluidic-microspheres",
            Self::DigitalVirtualKaryotyping => "digital-virtual-karyotyping",
            Self::Elisa => "elisa",
            Self::EnzymaticLevels => "enzymatic-levels",
            Self::EnzymeActivity => "enzyme-activity",
            Self::EnzymeAssay => "enzyme-assay",
            Self::Fish => "fish",
            Self::FishInterphase => "fish-interphase",
            Self::FishMetaphase => "fish-metaphase",
            Self::FlowCytometry => "flow-cytometry",
            Self::Fluorometry => "fluorometry",
            Self::FusionGenesMicroarrays => "fusion-genes-microarrays",
            Self::GBanding => "g-banding",
            Self::GcMs => "gc-ms",
            Self::GeneExpressionProfiling => "gene-expression-profiling",
            Self::GeneId => "gene-id",
            Self::GoldNanoparticleProbeTechnology => "gold-nanoparticle-probe-technology",
            Self::Hplc => "hplc",
            Self::Immunohistochemistry => "immunohistochemistry",
            Self::Karyotyping => "karyotyping",
            Self::LcMs => "lc-ms",
            Self::LcMsMs => "lc-ms-ms",
            Self::LinkageAnalysis => "linkage-analysis",
            Self::MFish => "m-fish",
            Self::MetaboliteLevels => "metabolite-levels",
            Self::MethylationAnalysis => "methylation-analysis",
            Self::MethylationSpecificPcr => "methylation-specific-pcr",
            Self::Microarray => "microarray",
            Self::Mlpa => "mlpa",
            Self::MolecularGenetics => "molecular-genetics",
            Self::MsMs => "ms-ms",
            Self::Msi => "msi",
            Self::MutationScanningOfSelectExons => "mutation-scanning-of-select-exons",
            Self::MutationScanningOfTheEntireCodingRegion => {
                "mutation-scanning-of-the-entire-coding-region"
            }
            Self::NgsMps => "ngs-mps",
            Self::Ola => "ola",
            Self::OligonucleotideHybridizationBasedDnaSequencing => {
                "oligonucleotide-hybridization-based-dna-sequencing"
            }
            Self::Other => "other",
            Self::Pcr => "pcr",
            Self::PcrRflpWithSouthernHybridization => {
                "pcr-rflp-with-southern-hybridization"
            }
            Self::PcrWithAlleleSpecificHybridization => {
                "pcr-with-allele-specific-hybridization"
            }
            Self::ProteinAnalysis => "protein-analysis",
            Self::ProteinExpression => "protein-expression",
            Self::ProteinTruncationTest => "protein-truncation-test",
            Self::Pyrosequencing => "pyrosequencing",
            Self::QBanding => "q-banding",
            Self::Qpcr => "qpcr",
            Self::RBanding => "r-banding",
            Self::Rflp => "rflp",
            Self::RnaAnalysis => "rna-analysis",
            Self::RtLamp => "rt-lamp",
            Self::RtPcr => "rt-pcr",
            Self::RtPcrWithGelAnalysis => "rt-pcr-with-gel-analysis",
            Self::RtQpcr => "rt-qpcr",
            Self::SequenceAnalysisOfSelectExons => "sequence-analysis-of-select-exons",
            Self::SequenceAnalysisOfTheEntireCodingRegion => {
                "sequence-analysis-of-the-entire-coding-region"
            }
            Self::SilverStaining => "silver-staining",
            Self::SisterChromatidExchange => "sister-chromatid-exchange",
            Self::Sky => "sky",
            Self::SnpDetection => "snp-detection",
            Self::TBanding => "t-banding",
            Self::TargetedVariantAnalysis => "targeted-variant-analysis",
            Self::TetraNucleotideRepeatByPcrOrSouthernBlot => {
                "tetra-nucleotide-repeat-by-pcr-or-southern-blot"
            }
            Self::TilingArrays => "tiling-arrays",
            Self::TrinucleotideRepeatByPcrOrSouthernBlot => {
                "trinucleotide-repeat-by-pcr-or-southern-blot"
            }
            Self::Udp => "udp",
            Self::UniDirectionalSangerSequencing => "uni-directional-sanger-sequencing",
        }
    }
}
impl ::std::fmt::Display for GenomicStudyMethodType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AlternativeSplicingDetection => "Alternative splicing detection",
            Self::Analyte => "Analyte",
            Self::Aspe => "Allele-specific primer extension (ASPE)",
            Self::BiDirectionalSangerSequenceAnalysis => {
                "Bi-directional Sanger Sequence Analysis"
            }
            Self::BiochemicalGenetics => "Biochemical Genetics",
            Self::CBanding => "C-banding",
            Self::ChromatinImmunoprecipitationOnChip => {
                "Chromatin Immunoprecipitation on ChIP"
            }
            Self::ChromosomeBreakageStudies => "Chromosome breakage studies",
            Self::Cia => "Chemiluminescent Immunoassay (CIA)",
            Self::ComparativeGenomicHybridization => "Comparative Genomic Hybridization",
            Self::Cytogenetics => "Cytogenetics",
            Self::Damid => "DamID",
            Self::DeletionDuplicationAnalysis => "Deletion/duplication analysis",
            Self::DetectionOfHomozygosity => "Detection of homozygosity",
            Self::DigitalMicrofluidicMicrospheres => "Digital microfluidic microspheres",
            Self::DigitalVirtualKaryotyping => "Digital / Virtual karyotyping",
            Self::Elisa => "Enzyme-Linked Immunosorbent Assays (ELISA)",
            Self::EnzymaticLevels => "Enzymatic levels",
            Self::EnzymeActivity => "Enzyme activity",
            Self::EnzymeAssay => "Enzyme assay",
            Self::Fish => "Fluorescence in situ hybridization (FISH)",
            Self::FishInterphase => "FISH-interphase",
            Self::FishMetaphase => "FISH-metaphase",
            Self::FlowCytometry => "Flow cytometry",
            Self::Fluorometry => "Fluorometry",
            Self::FusionGenesMicroarrays => "Fusion genes microarrays",
            Self::GBanding => "G-banding",
            Self::GcMs => "Gas chromatographyâ€“mass spectrometry (GC-MS)",
            Self::GeneExpressionProfiling => "Gene expression profiling",
            Self::GeneId => "GeneID",
            Self::GoldNanoparticleProbeTechnology => "Gold nanoparticle probe technology",
            Self::Hplc => "High-performance liquid chromatography (HPLC)",
            Self::Immunohistochemistry => "Immunohistochemistry",
            Self::Karyotyping => "Karyotyping",
            Self::LcMs => "Liquid chromatography mass spectrometry (LC-MS)",
            Self::LcMsMs => "Liquid chromatography-tandem mass spectrometry (LC-MS/MS)",
            Self::LinkageAnalysis => "Linkage analysis",
            Self::MFish => "Multicolor FISH (M-FISH)",
            Self::MetaboliteLevels => "Metabolite levels",
            Self::MethylationAnalysis => "Methylation analysis",
            Self::MethylationSpecificPcr => "Methylation-specific PCR",
            Self::Microarray => "Microarray",
            Self::Mlpa => "Multiplex Ligation-dependent Probe Amplification (MLPA)",
            Self::MolecularGenetics => "Molecular Genetics",
            Self::MsMs => "Tandem mass spectrometry (MS/MS)",
            Self::Msi => "Microsatellite instability testing (MSI)",
            Self::MutationScanningOfSelectExons => "Mutation scanning of select exons",
            Self::MutationScanningOfTheEntireCodingRegion => {
                "Mutation scanning of the entire coding region"
            }
            Self::NgsMps => "Next-Generation (NGS)/Massively parallel sequencing (MPS)",
            Self::Ola => "Oligonucleotide Ligation Assay (OLA)",
            Self::OligonucleotideHybridizationBasedDnaSequencing => {
                "Oligonucleotide hybridization-based DNA sequencing"
            }
            Self::Other => "Other",
            Self::Pcr => "PCR",
            Self::PcrRflpWithSouthernHybridization => {
                "PCR-RFLP with Southern hybridization"
            }
            Self::PcrWithAlleleSpecificHybridization => {
                "PCR with allele specific hybridization"
            }
            Self::ProteinAnalysis => "Protein analysis",
            Self::ProteinExpression => "Protein expression",
            Self::ProteinTruncationTest => "Protein truncation test",
            Self::Pyrosequencing => "Pyrosequencing",
            Self::QBanding => "Q-banding",
            Self::Qpcr => "Quantitative PCR (qPCR)",
            Self::RBanding => "R-banding",
            Self::Rflp => "RFLP",
            Self::RnaAnalysis => "RNA analysis",
            Self::RtLamp => "RT-LAMP",
            Self::RtPcr => "RT-PCR",
            Self::RtPcrWithGelAnalysis => "RT-PCR with gel analysis",
            Self::RtQpcr => "RT-qPCR",
            Self::SequenceAnalysisOfSelectExons => "Sequence analysis of select exons",
            Self::SequenceAnalysisOfTheEntireCodingRegion => {
                "Sequence analysis of the entire coding region"
            }
            Self::SilverStaining => "Silver staining",
            Self::SisterChromatidExchange => "Sister chromatid exchange",
            Self::Sky => "Spectral karyotyping (SKY)",
            Self::SnpDetection => "SNP Detection",
            Self::TBanding => "T-banding",
            Self::TargetedVariantAnalysis => "Targeted variant analysis",
            Self::TetraNucleotideRepeatByPcrOrSouthernBlot => {
                "Tetra-nucleotide repeat by PCR or Southern Blot"
            }
            Self::TilingArrays => "Tiling Arrays",
            Self::TrinucleotideRepeatByPcrOrSouthernBlot => {
                "Trinucleotide repeat by PCR or Southern Blot"
            }
            Self::Udp => "Uniparental disomy study (UPD)",
            Self::UniDirectionalSangerSequencing => "Uni-directional Sanger sequencing",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GenomicStudyMethodType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenomicStudyMethodType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GenomicStudyMethodType> for Coding {
    fn from(code: GenomicStudyMethodType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/genomicstudy-methodtype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GenomicStudyMethodType> for CodeableConcept {
    fn from(code: GenomicStudyMethodType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GenomicStudyStatus](http://hl7.org/fhir/ValueSet/genomicstudy-status)**. The status of the GenomicStudy.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GenomicStudyStatus {
    /** **available**

Available. At least one instance has been associated with this genomic study. */
    Available,
    /** **cancelled**

Cancelled. The genomic study is unavailable because the genomic study was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **entered-in-error**

Entered in Error. The genomic study has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **registered**

Registered. The existence of the genomic study is registered, but there is nothing yet available. */
    Registered,
    /** **unknown**

Unknown. The system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for GenomicStudyStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GenomicStudyStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for GenomicStudyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Available => "Available",
            Self::Cancelled => "Cancelled",
            Self::EnteredInError => "Entered in Error",
            Self::Registered => "Registered",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GenomicStudyStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenomicStudyStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GenomicStudyStatus> for Coding {
    fn from(code: GenomicStudyStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/genomicstudy-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GenomicStudyStatus> for CodeableConcept {
    fn from(code: GenomicStudyStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GenomicStudyType](http://hl7.org/fhir/ValueSet/genomicstudy-type)**. The type relevant to GenomicStudy.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GenomicStudyType {
    /** **alt-splc**

Alternative splicing detection. Identification of multiple different processed mRNA transcripts from the same DNA template */
    AltSplc,
    /** **chromatin**

Chromatin conformation. Analysis of the spacial organization of chromatin within a cell */
    Chromatin,
    /** **cnv**

CNV detection. Detection of a change in the number of copies of a defined region of genomic DNA sequence resulting in structural variation when compared to the reference sequence */
    Cnv,
    /** **epi-alt-dna**

Epigenetic Alterations -DNA methylation. Detection of the presence of an additional methyl group on a DNA nucleobase, which may alter gene transcription */
    EpiAltDna,
    /** **epi-alt-hist**

Epigenetic Alterations - histone modifications. Detection of biochemical modifications covalently bound to the N-terminal tail of a histone protein. These modifications may alter chromatin compaction and gene expression */
    EpiAltHist,
    /** **fam-var-segr**

Familial variant segregation. Determining if a variant identified in an individual is present in other family members */
    FamVarSegr,
    /** **func-var**

Functional variation detection. Detection of sequence variants which may alter gene expression or gene product function when compared to the reference sequence */
    FuncVar,
    /** **gene-expression**

Gene expression profiling. Measurement and characterization of activity from all gene products */
    GeneExpression,
    /** **post-trans-mod**

Post-translational Modification Identification. Detection of biochemical modifications covalently bound to the amino acid monomers of a processed protein */
    PostTransMod,
    /** **snp**

SNP Detection. Determination of which nucleotide is base present at a known variable location of the genomic sequence */
    Snp,
    /** **str**

STR count. Quantification of the number of sequential microsatellite units in a repetitive sequence region */
    Str,
    /** **struc-var**

Structural variation detection. Detection of deletions, insertions, or rearrangements of DNA segments compared to the reference sequence */
    StrucVar,
}
impl ::core::str::FromStr for GenomicStudyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alt-splc" => Ok(Self::AltSplc),
            "chromatin" => Ok(Self::Chromatin),
            "cnv" => Ok(Self::Cnv),
            "epi-alt-dna" => Ok(Self::EpiAltDna),
            "epi-alt-hist" => Ok(Self::EpiAltHist),
            "fam-var-segr" => Ok(Self::FamVarSegr),
            "func-var" => Ok(Self::FuncVar),
            "gene-expression" => Ok(Self::GeneExpression),
            "post-trans-mod" => Ok(Self::PostTransMod),
            "snp" => Ok(Self::Snp),
            "str" => Ok(Self::Str),
            "struc-var" => Ok(Self::StrucVar),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GenomicStudyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AltSplc => "alt-splc",
            Self::Chromatin => "chromatin",
            Self::Cnv => "cnv",
            Self::EpiAltDna => "epi-alt-dna",
            Self::EpiAltHist => "epi-alt-hist",
            Self::FamVarSegr => "fam-var-segr",
            Self::FuncVar => "func-var",
            Self::GeneExpression => "gene-expression",
            Self::PostTransMod => "post-trans-mod",
            Self::Snp => "snp",
            Self::Str => "str",
            Self::StrucVar => "struc-var",
        }
    }
}
impl ::std::fmt::Display for GenomicStudyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AltSplc => "Alternative splicing detection",
            Self::Chromatin => "Chromatin conformation",
            Self::Cnv => "CNV detection",
            Self::EpiAltDna => "Epigenetic Alterations -DNA methylation",
            Self::EpiAltHist => "Epigenetic Alterations - histone modifications",
            Self::FamVarSegr => "Familial variant segregation",
            Self::FuncVar => "Functional variation detection",
            Self::GeneExpression => "Gene expression profiling",
            Self::PostTransMod => "Post-translational Modification Identification",
            Self::Snp => "SNP Detection",
            Self::Str => "STR count",
            Self::StrucVar => "Structural variation detection",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GenomicStudyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenomicStudyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GenomicStudyType> for Coding {
    fn from(code: GenomicStudyType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/genomicstudy-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GenomicStudyType> for CodeableConcept {
    fn from(code: GenomicStudyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GoalLifecycleStatus](http://hl7.org/fhir/ValueSet/goal-status)**. Codes that reflect the current state of a goal and whether the goal is still being targeted.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GoalLifecycleStatus {
    /** **accepted**

Accepted. A proposed goal was accepted or acknowledged. */
    Accepted,
    /** **active**

Active. The goal is being sought actively. */
    Active,
    /** **cancelled**

Cancelled. The goal has been abandoned. */
    Cancelled,
    /** **completed**

Completed. The goal is no longer being sought. */
    Completed,
    /** **entered-in-error**

Entered in Error. The goal was entered in error and voided. */
    EnteredInError,
    /** **on-hold**

On Hold. The goal remains a long term objective but is no longer being actively pursued for a temporary period of time. */
    OnHold,
    /** **planned**

Planned. A goal is planned for this patient. */
    Planned,
    /** **proposed**

Proposed. A goal is proposed for this patient. */
    Proposed,
    /** **rejected**

Rejected. A proposed goal was rejected. */
    Rejected,
}
impl ::core::str::FromStr for GoalLifecycleStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "on-hold" => Ok(Self::OnHold),
            "planned" => Ok(Self::Planned),
            "proposed" => Ok(Self::Proposed),
            "rejected" => Ok(Self::Rejected),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalLifecycleStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::OnHold => "on-hold",
            Self::Planned => "planned",
            Self::Proposed => "proposed",
            Self::Rejected => "rejected",
        }
    }
}
impl ::std::fmt::Display for GoalLifecycleStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Accepted => "Accepted",
            Self::Active => "Active",
            Self::Cancelled => "Cancelled",
            Self::Completed => "Completed",
            Self::EnteredInError => "Entered in Error",
            Self::OnHold => "On Hold",
            Self::Planned => "Planned",
            Self::Proposed => "Proposed",
            Self::Rejected => "Rejected",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GoalLifecycleStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalLifecycleStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GoalLifecycleStatus> for Coding {
    fn from(code: GoalLifecycleStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/goal-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GoalLifecycleStatus> for CodeableConcept {
    fn from(code: GoalLifecycleStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GraphCompartmentRule](http://hl7.org/fhir/ValueSet/graph-compartment-rule)**. How a compartment must be linked.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GraphCompartmentRule {
    /** **custom**

Custom. The compartment rule is defined in the accompanying FHIRPath expression. */
    Custom,
    /** **different**

Different. The compartment must be different. */
    Different,
    /** **identical**

Identical. The compartment must be identical (the same literal reference). */
    Identical,
    /** **matching**

Matching. The compartment must be the same - the record must be about the same patient, but the reference may be different. */
    Matching,
}
impl ::core::str::FromStr for GraphCompartmentRule {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "custom" => Ok(Self::Custom),
            "different" => Ok(Self::Different),
            "identical" => Ok(Self::Identical),
            "matching" => Ok(Self::Matching),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GraphCompartmentRule {
    fn as_ref(&self) -> &str {
        match self {
            Self::Custom => "custom",
            Self::Different => "different",
            Self::Identical => "identical",
            Self::Matching => "matching",
        }
    }
}
impl ::std::fmt::Display for GraphCompartmentRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Custom => "Custom",
            Self::Different => "Different",
            Self::Identical => "Identical",
            Self::Matching => "Matching",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GraphCompartmentRule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GraphCompartmentRule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GraphCompartmentRule> for Coding {
    fn from(code: GraphCompartmentRule) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/graph-compartment-rule".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GraphCompartmentRule> for CodeableConcept {
    fn from(code: GraphCompartmentRule) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GraphCompartmentUse](http://hl7.org/fhir/ValueSet/graph-compartment-use)**. Defines how a compartment rule is used.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GraphCompartmentUse {
    /** **requires**

requires. This compartment rule is enforced on any relationships that meet the conditions. */
    Requires,
    /** **where**

Where. This compartment rule is a condition for whether the rule applies. */
    Where,
}
impl ::core::str::FromStr for GraphCompartmentUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "requires" => Ok(Self::Requires),
            "where" => Ok(Self::Where),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GraphCompartmentUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Requires => "requires",
            Self::Where => "where",
        }
    }
}
impl ::std::fmt::Display for GraphCompartmentUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Requires => "requires",
            Self::Where => "Where",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GraphCompartmentUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GraphCompartmentUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GraphCompartmentUse> for Coding {
    fn from(code: GraphCompartmentUse) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/graph-compartment-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GraphCompartmentUse> for CodeableConcept {
    fn from(code: GraphCompartmentUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GroupMembershipBasis](http://hl7.org/fhir/ValueSet/group-membership-basis)**. Basis for membership in a group\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GroupMembershipBasis {
    /** **definitional**

Definitional. The Group.characteristics specified are both necessary and sufficient to determine membership. All entities that meet the criteria are considered to be members of the group, whether referenced by the group or not. If members are present, they are individuals that happen to be known as meeting the Group.characteristics. The list cannot be presumed to be complete. */
    Definitional,
    /** **enumerated**

Enumerated. The Group.characteristics are necessary but not sufficient to determine membership. Membership is determined by being listed as one of the Group.member. */
    Enumerated,
}
impl ::core::str::FromStr for GroupMembershipBasis {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "definitional" => Ok(Self::Definitional),
            "enumerated" => Ok(Self::Enumerated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GroupMembershipBasis {
    fn as_ref(&self) -> &str {
        match self {
            Self::Definitional => "definitional",
            Self::Enumerated => "enumerated",
        }
    }
}
impl ::std::fmt::Display for GroupMembershipBasis {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Definitional => "Definitional",
            Self::Enumerated => "Enumerated",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GroupMembershipBasis {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GroupMembershipBasis {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GroupMembershipBasis> for Coding {
    fn from(code: GroupMembershipBasis) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/group-membership-basis".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GroupMembershipBasis> for CodeableConcept {
    fn from(code: GroupMembershipBasis) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GroupType](http://hl7.org/fhir/ValueSet/group-type)**. Types of resources that are part of group.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GroupType {
    /** **animal**

Animal. Group contains "animal" Patient resources. */
    Animal,
    /** **careteam**

CareTeam. Group contains CareTeam resources. */
    Careteam,
    /** **device**

Device. Group contains Device resources. */
    Device,
    /** **healthcareservice**

HealthcareService. Group contains HealthcareService resources. */
    Healthcareservice,
    /** **location**

Location. Group contains Location resources. */
    Location,
    /** **organization**

Organization. Group contains Organization resources. */
    Organization,
    /** **person**

Person. Group contains "person" Patient resources. */
    Person,
    /** **practitioner**

Practitioner. Group contains healthcare practitioner resources (Practitioner or PractitionerRole). */
    Practitioner,
    /** **relatedperson**

RelatedPerson. Group contains RelatedPerson resources. */
    Relatedperson,
    /** **specimen**

Specimen. Group contains Specimen resources. */
    Specimen,
}
impl ::core::str::FromStr for GroupType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "animal" => Ok(Self::Animal),
            "careteam" => Ok(Self::Careteam),
            "device" => Ok(Self::Device),
            "healthcareservice" => Ok(Self::Healthcareservice),
            "location" => Ok(Self::Location),
            "organization" => Ok(Self::Organization),
            "person" => Ok(Self::Person),
            "practitioner" => Ok(Self::Practitioner),
            "relatedperson" => Ok(Self::Relatedperson),
            "specimen" => Ok(Self::Specimen),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GroupType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "animal",
            Self::Careteam => "careteam",
            Self::Device => "device",
            Self::Healthcareservice => "healthcareservice",
            Self::Location => "location",
            Self::Organization => "organization",
            Self::Person => "person",
            Self::Practitioner => "practitioner",
            Self::Relatedperson => "relatedperson",
            Self::Specimen => "specimen",
        }
    }
}
impl ::std::fmt::Display for GroupType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Animal => "Animal",
            Self::Careteam => "CareTeam",
            Self::Device => "Device",
            Self::Healthcareservice => "HealthcareService",
            Self::Location => "Location",
            Self::Organization => "Organization",
            Self::Person => "Person",
            Self::Practitioner => "Practitioner",
            Self::Relatedperson => "RelatedPerson",
            Self::Specimen => "Specimen",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GroupType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GroupType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GroupType> for Coding {
    fn from(code: GroupType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/group-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GroupType> for CodeableConcept {
    fn from(code: GroupType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GuidanceModuleCode](http://hl7.org/fhir/ValueSet/guidance-module-code)**. Example guidance module codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GuidanceModuleCode {
    /** **anc-cds**

ANC CDS. Clinical Decision Support for Antenatal Care. */
    AncCds,
    /** **bmi-calculator**

BMI Calculator. A Body Mass Index (BMI) calculator. */
    BmiCalculator,
    /** **chf-pathway**

CHF Pathway. Congestive Heart Failure Pathway */
    ChfPathway,
    /** **covid-19-severity**

COVID-19 Severity Score. A COVID-19 Severity Score Calculator. */
    Covid19Severity,
    /** **mme-calculator**

MME Calculator. A Morphine Milligram Equivalent (MME) calculator. */
    MmeCalculator,
    /** **opioid-cds**

Opioid CDS. Clinical Decision Support for Opioid Prescribing. */
    OpioidCds,
}
impl ::core::str::FromStr for GuidanceModuleCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "anc-cds" => Ok(Self::AncCds),
            "bmi-calculator" => Ok(Self::BmiCalculator),
            "chf-pathway" => Ok(Self::ChfPathway),
            "covid-19-severity" => Ok(Self::Covid19Severity),
            "mme-calculator" => Ok(Self::MmeCalculator),
            "opioid-cds" => Ok(Self::OpioidCds),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuidanceModuleCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::AncCds => "anc-cds",
            Self::BmiCalculator => "bmi-calculator",
            Self::ChfPathway => "chf-pathway",
            Self::Covid19Severity => "covid-19-severity",
            Self::MmeCalculator => "mme-calculator",
            Self::OpioidCds => "opioid-cds",
        }
    }
}
impl ::std::fmt::Display for GuidanceModuleCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AncCds => "ANC CDS",
            Self::BmiCalculator => "BMI Calculator",
            Self::ChfPathway => "CHF Pathway",
            Self::Covid19Severity => "COVID-19 Severity Score",
            Self::MmeCalculator => "MME Calculator",
            Self::OpioidCds => "Opioid CDS",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GuidanceModuleCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuidanceModuleCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuidanceModuleCode> for Coding {
    fn from(code: GuidanceModuleCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/guidance-module-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GuidanceModuleCode> for CodeableConcept {
    fn from(code: GuidanceModuleCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GuidanceResponseStatus](http://hl7.org/fhir/ValueSet/guidance-response-status)**. The status of a guidance response.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GuidanceResponseStatus {
    /** **data-requested**

Data Requested. The request was processed successfully, but more data may result in a more complete evaluation. */
    DataRequested,
    /** **data-required**

Data Required. The request was processed, but more data is required to complete the evaluation. */
    DataRequired,
    /** **entered-in-error**

Entered In Error. The response was entered in error. */
    EnteredInError,
    /** **failure**

Failure. The request was not processed successfully. */
    Failure,
    /** **in-progress**

In Progress. The request is currently being processed. */
    InProgress,
    /** **success**

Success. The request was processed successfully. */
    Success,
}
impl ::core::str::FromStr for GuidanceResponseStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-requested" => Ok(Self::DataRequested),
            "data-required" => Ok(Self::DataRequired),
            "entered-in-error" => Ok(Self::EnteredInError),
            "failure" => Ok(Self::Failure),
            "in-progress" => Ok(Self::InProgress),
            "success" => Ok(Self::Success),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuidanceResponseStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataRequested => "data-requested",
            Self::DataRequired => "data-required",
            Self::EnteredInError => "entered-in-error",
            Self::Failure => "failure",
            Self::InProgress => "in-progress",
            Self::Success => "success",
        }
    }
}
impl ::std::fmt::Display for GuidanceResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::DataRequested => "Data Requested",
            Self::DataRequired => "Data Required",
            Self::EnteredInError => "Entered In Error",
            Self::Failure => "Failure",
            Self::InProgress => "In Progress",
            Self::Success => "Success",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GuidanceResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuidanceResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuidanceResponseStatus> for Coding {
    fn from(code: GuidanceResponseStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/guidance-response-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GuidanceResponseStatus> for CodeableConcept {
    fn from(code: GuidanceResponseStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GuidePageGeneration](http://hl7.org/fhir/ValueSet/guide-page-generation)**. A code that indicates how the page is generated.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GuidePageGeneration {
    /** **generated**

Generated. Page will be generated by the publication process - no source to bring across. */
    Generated,
    /** **html**

HTML. Page is proper xhtml with no templating.  Will be brought across unchanged for standard post-processing. */
    Html,
    /** **markdown**

Markdown. Page is markdown with templating.  Will use the template to create a file that imports the markdown file prior to post-processing. */
    Markdown,
    /** **xml**

XML. Page is xml with templating.  Will use the template to create a file that imports the source file and run the nominated XSLT transform (see parameters) if present prior to post-processing. */
    Xml,
}
impl ::core::str::FromStr for GuidePageGeneration {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "generated" => Ok(Self::Generated),
            "html" => Ok(Self::Html),
            "markdown" => Ok(Self::Markdown),
            "xml" => Ok(Self::Xml),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuidePageGeneration {
    fn as_ref(&self) -> &str {
        match self {
            Self::Generated => "generated",
            Self::Html => "html",
            Self::Markdown => "markdown",
            Self::Xml => "xml",
        }
    }
}
impl ::std::fmt::Display for GuidePageGeneration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Generated => "Generated",
            Self::Html => "HTML",
            Self::Markdown => "Markdown",
            Self::Xml => "XML",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GuidePageGeneration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuidePageGeneration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuidePageGeneration> for Coding {
    fn from(code: GuidePageGeneration) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/guide-page-generation".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GuidePageGeneration> for CodeableConcept {
    fn from(code: GuidePageGeneration) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[GuideParameterCode](http://hl7.org/fhir/guide-parameter-code)**. GuideParameterCode\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum GuideParameterCode {
    /** **apply**

Apply Metadata Value. If the value of this string 0..* parameter is one of the metadata fields then all conformance resources will have any specified [Resource].[field] overwritten with the ImplementationGuide.[field], where field is one of: version, date, status, publisher, contact, copyright, experimental, jurisdiction, useContext. */
    Apply,
    /** **expansion-parameter**

Expansion Profile. The value of this string 0..* parameter is a parameter (name=value) when expanding value sets for this implementation guide. This is particularly used to specify the versions of published terminologies such as SNOMED CT. */
    ExpansionParameter,
    /** **generate-json**

Generate JSON. The value of this boolean 0..1 parameter specifies whether the IG publisher creates examples in JSON format. If not present, the Publication Tool decides whether to generate JSON. */
    GenerateJson,
    /** **generate-turtle**

Generate Turtle. The value of this boolean 0..1 parameter specifies whether the IG publisher creates examples in Turtle format. If not present, the Publication Tool decides whether to generate Turtle. */
    GenerateTurtle,
    /** **generate-xml**

Generate XML. The value of this boolean 0..1 parameter specifies whether the IG publisher creates examples in XML format. If not present, the Publication Tool decides whether to generate XML. */
    GenerateXml,
    /** **html-template**

HTML Template. The value of this string singleton parameter is the name of the file to use as the builder template for each generated page (see templating). */
    HtmlTemplate,
    /** **path-pages**

Pages Path. The value of this string 0..1 parameter is a subfolder of the build context's location that contains files that are part of the html content processed by the builder. */
    PathPages,
    /** **path-resource**

Resource Path. The value of this string 0..* parameter is a subfolder of the build context's location that is to be scanned to load resources. Scope is (if present) a particular resource type. */
    PathResource,
    /** **path-tx-cache**

Terminology Cache Path. The value of this string 0..1 parameter is a subfolder of the build context's location that is used as the terminology cache. If this is not present, the terminology cache is on the local system, not under version control. */
    PathTxCache,
    /** **rule-broken-links**

Broken Links Rule. The value of this string 0..1 parameter is either "warning" or "error" (default = "error"). If the value is "warning" then IG build tools allow the IG to be considered successfully build even when there is no internal broken links. */
    RuleBrokenLinks,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for GuideParameterCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "apply" => Ok(Self::Apply),
            "expansion-parameter" => Ok(Self::ExpansionParameter),
            "generate-json" => Ok(Self::GenerateJson),
            "generate-turtle" => Ok(Self::GenerateTurtle),
            "generate-xml" => Ok(Self::GenerateXml),
            "html-template" => Ok(Self::HtmlTemplate),
            "path-pages" => Ok(Self::PathPages),
            "path-resource" => Ok(Self::PathResource),
            "path-tx-cache" => Ok(Self::PathTxCache),
            "rule-broken-links" => Ok(Self::RuleBrokenLinks),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for GuideParameterCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Apply => "apply",
            Self::ExpansionParameter => "expansion-parameter",
            Self::GenerateJson => "generate-json",
            Self::GenerateTurtle => "generate-turtle",
            Self::GenerateXml => "generate-xml",
            Self::HtmlTemplate => "html-template",
            Self::PathPages => "path-pages",
            Self::PathResource => "path-resource",
            Self::PathTxCache => "path-tx-cache",
            Self::RuleBrokenLinks => "rule-broken-links",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for GuideParameterCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Apply => "Apply Metadata Value",
            Self::ExpansionParameter => "Expansion Profile",
            Self::GenerateJson => "Generate JSON",
            Self::GenerateTurtle => "Generate Turtle",
            Self::GenerateXml => "Generate XML",
            Self::HtmlTemplate => "HTML Template",
            Self::PathPages => "Pages Path",
            Self::PathResource => "Resource Path",
            Self::PathTxCache => "Terminology Cache Path",
            Self::RuleBrokenLinks => "Broken Links Rule",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for GuideParameterCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuideParameterCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<GuideParameterCode> for Coding {
    fn from(code: GuideParameterCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/guide-parameter-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<GuideParameterCode> for CodeableConcept {
    fn from(code: GuideParameterCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[IdentifierUse](http://hl7.org/fhir/ValueSet/identifier-use)**. Identifies the purpose for this identifier, if known .\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IdentifierUse {
    /** **official**

Official. The identifier considered to be most trusted for the identification of this item. Sometimes also known as "primary" and "main". The determination of "official" is subjective and implementation guides often provide additional guidelines for use. */
    Official,
    /** **old**

Old. The identifier id no longer considered valid, but may be relevant for search purposes.  E.g. Changes to identifier schemes, account merges, etc. */
    Old,
    /** **secondary**

Secondary. An identifier that was assigned in secondary use - it serves to identify the object in a relative context, but cannot be consistently assigned to the same object again in a different context. */
    Secondary,
    /** **temp**

Temp. A temporary identifier. */
    Temp,
    /** **usual**

Usual. The identifier recommended for display and use in real-world interactions which should be used when such identifier is different from the "official" identifier. */
    Usual,
}
impl ::core::str::FromStr for IdentifierUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "official" => Ok(Self::Official),
            "old" => Ok(Self::Old),
            "secondary" => Ok(Self::Secondary),
            "temp" => Ok(Self::Temp),
            "usual" => Ok(Self::Usual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IdentifierUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Official => "official",
            Self::Old => "old",
            Self::Secondary => "secondary",
            Self::Temp => "temp",
            Self::Usual => "usual",
        }
    }
}
impl ::std::fmt::Display for IdentifierUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Official => "Official",
            Self::Old => "Old",
            Self::Secondary => "Secondary",
            Self::Temp => "Temp",
            Self::Usual => "Usual",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for IdentifierUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IdentifierUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IdentifierUse> for Coding {
    fn from(code: IdentifierUse) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/identifier-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<IdentifierUse> for CodeableConcept {
    fn from(code: IdentifierUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[IdentityAssuranceLevel](http://hl7.org/fhir/ValueSet/identity-assuranceLevel)**. The level of confidence that this link represents the same actual person, based on NIST Authentication Levels.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IdentityAssuranceLevel {
    /** **level1**

Level 1. Little or no confidence in the asserted identity's accuracy. */
    Level1,
    /** **level2**

Level 2. Some confidence in the asserted identity's accuracy. */
    Level2,
    /** **level3**

Level 3. High confidence in the asserted identity's accuracy. */
    Level3,
    /** **level4**

Level 4. Very high confidence in the asserted identity's accuracy. */
    Level4,
}
impl ::core::str::FromStr for IdentityAssuranceLevel {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "level1" => Ok(Self::Level1),
            "level2" => Ok(Self::Level2),
            "level3" => Ok(Self::Level3),
            "level4" => Ok(Self::Level4),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IdentityAssuranceLevel {
    fn as_ref(&self) -> &str {
        match self {
            Self::Level1 => "level1",
            Self::Level2 => "level2",
            Self::Level3 => "level3",
            Self::Level4 => "level4",
        }
    }
}
impl ::std::fmt::Display for IdentityAssuranceLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Level1 => "Level 1",
            Self::Level2 => "Level 2",
            Self::Level3 => "Level 3",
            Self::Level4 => "Level 4",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for IdentityAssuranceLevel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IdentityAssuranceLevel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IdentityAssuranceLevel> for Coding {
    fn from(code: IdentityAssuranceLevel) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/identity-assuranceLevel".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<IdentityAssuranceLevel> for CodeableConcept {
    fn from(code: IdentityAssuranceLevel) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ImagingSelection2DGraphicType](http://hl7.org/fhir/ValueSet/imagingselection-2dgraphictype)**. The type of coordinates describing a 2D image region.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ImagingSelection2DGraphicType {
    /** **circle**

CIRCLE. Two points shall be present; the first point is to be interpreted as the center and the second point as a point on the circumference of a circle, some form of implementation dependent representation of which is to be drawn. */
    Circle,
    /** **ellipse**

ELLIPSE. An ellipse defined by four (x,y) pairs, the first two pairs specifying the endpoints of the major axis and the second two pairs specifying the endpoints of the minor axis. */
    Ellipse,
    /** **interpolated**

INTERPOLATED. An n-tuple list of (x,y) pair end points between which some form of implementation dependent curved lines are to be drawn. The rendered line shall pass through all the specified points. */
    Interpolated,
    /** **point**

POINT. A single location denoted by a single (x,y) pair. */
    Point,
    /** **polyline**

POLYLINE. A series of connected line segments with ordered vertices denoted by (x,y) triplets; the points need not be coplanar. */
    Polyline,
}
impl ::core::str::FromStr for ImagingSelection2DGraphicType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "circle" => Ok(Self::Circle),
            "ellipse" => Ok(Self::Ellipse),
            "interpolated" => Ok(Self::Interpolated),
            "point" => Ok(Self::Point),
            "polyline" => Ok(Self::Polyline),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ImagingSelection2DGraphicType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Circle => "circle",
            Self::Ellipse => "ellipse",
            Self::Interpolated => "interpolated",
            Self::Point => "point",
            Self::Polyline => "polyline",
        }
    }
}
impl ::std::fmt::Display for ImagingSelection2DGraphicType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Circle => "CIRCLE",
            Self::Ellipse => "ELLIPSE",
            Self::Interpolated => "INTERPOLATED",
            Self::Point => "POINT",
            Self::Polyline => "POLYLINE",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ImagingSelection2DGraphicType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImagingSelection2DGraphicType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImagingSelection2DGraphicType> for Coding {
    fn from(code: ImagingSelection2DGraphicType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/imagingselection-2dgraphictype".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ImagingSelection2DGraphicType> for CodeableConcept {
    fn from(code: ImagingSelection2DGraphicType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ImagingSelection3DGraphicType](http://hl7.org/fhir/ValueSet/imagingselection-3dgraphictype)**. The type of coordinates describing an image region.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ImagingSelection3DGraphicType {
    /** **ellipse**

ELLIPSE. an ellipse defined by four (x,y,z) triplets, the first two triplets specifying the endpoints of the major axis and the second two triplets specifying the endpoints of the minor axis. */
    Ellipse,
    /** **ellipsoid**

ELLIPSOID. a three-dimensional geometric surface whose plane sections are either ellipses or circles and contains three intersecting orthogonal axes, "a", "b", and "c"; the ellipsoid is defined by six (x,y,z) triplets, the first and second triplets specifying the endpoints of axis "a", the third and fourth triplets specifying the endpoints of axis "b", and the fifth and sixth triplets specifying the endpoints of axis "c". */
    Ellipsoid,
    /** **multipoint**

MULTIPOINT. multiple locations each denoted by an (x,y,z) triplet; the points need not be coplanar. */
    Multipoint,
    /** **point**

POINT. A single location denoted by a single (x,y,z) triplet. */
    Point,
    /** **polygon**

POLYGON. a series of connected line segments with ordered vertices denoted by (x,y,z) triplets, where the first and last vertices shall be the same forming a polygon; the points shall be coplanar. */
    Polygon,
    /** **polyline**

POLYLINE. a series of connected line segments with ordered vertices denoted by (x,y,z) triplets; the points need not be coplanar. */
    Polyline,
}
impl ::core::str::FromStr for ImagingSelection3DGraphicType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ellipse" => Ok(Self::Ellipse),
            "ellipsoid" => Ok(Self::Ellipsoid),
            "multipoint" => Ok(Self::Multipoint),
            "point" => Ok(Self::Point),
            "polygon" => Ok(Self::Polygon),
            "polyline" => Ok(Self::Polyline),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ImagingSelection3DGraphicType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ellipse => "ellipse",
            Self::Ellipsoid => "ellipsoid",
            Self::Multipoint => "multipoint",
            Self::Point => "point",
            Self::Polygon => "polygon",
            Self::Polyline => "polyline",
        }
    }
}
impl ::std::fmt::Display for ImagingSelection3DGraphicType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Ellipse => "ELLIPSE",
            Self::Ellipsoid => "ELLIPSOID",
            Self::Multipoint => "MULTIPOINT",
            Self::Point => "POINT",
            Self::Polygon => "POLYGON",
            Self::Polyline => "POLYLINE",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ImagingSelection3DGraphicType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImagingSelection3DGraphicType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImagingSelection3DGraphicType> for Coding {
    fn from(code: ImagingSelection3DGraphicType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/imagingselection-3dgraphictype".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ImagingSelection3DGraphicType> for CodeableConcept {
    fn from(code: ImagingSelection3DGraphicType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ImagingSelectionStatus](http://hl7.org/fhir/ValueSet/imagingselection-status)**. The status of the ImagingSelection.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ImagingSelectionStatus {
    /** **available**

Available. The selected resources are available.. */
    Available,
    /** **entered-in-error**

Entered in Error. The imaging selection has been withdrawn following a release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **unknown**

Unknown. The system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for ImagingSelectionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "entered-in-error" => Ok(Self::EnteredInError),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ImagingSelectionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::EnteredInError => "entered-in-error",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for ImagingSelectionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Available => "Available",
            Self::EnteredInError => "Entered in Error",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ImagingSelectionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImagingSelectionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImagingSelectionStatus> for Coding {
    fn from(code: ImagingSelectionStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/imagingselection-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ImagingSelectionStatus> for CodeableConcept {
    fn from(code: ImagingSelectionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ImagingStudyStatus](http://hl7.org/fhir/ValueSet/imagingstudy-status)**. The status of the ImagingStudy.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ImagingStudyStatus {
    /** **available**

Available. At least one instance has been associated with this imaging study. */
    Available,
    /** **cancelled**

Cancelled. The imaging study is unavailable because the imaging study was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **entered-in-error**

Entered in Error. The imaging study has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **registered**

Registered. The existence of the imaging study is registered, but there is nothing yet available. */
    Registered,
    /** **unknown**

Unknown. The system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for ImagingStudyStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ImagingStudyStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for ImagingStudyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Available => "Available",
            Self::Cancelled => "Cancelled",
            Self::EnteredInError => "Entered in Error",
            Self::Registered => "Registered",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ImagingStudyStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImagingStudyStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ImagingStudyStatus> for Coding {
    fn from(code: ImagingStudyStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/imagingstudy-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ImagingStudyStatus> for CodeableConcept {
    fn from(code: ImagingStudyStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[Indicator](http://hl7.org/fhir/ValueSet/cdshooks-indicator)**. This codesystem captures the indicator codes defined by the CDS Hooks specification. The indicator is included as an element of the cards in a CDS Hooks response and conveys the urgency and/or importance of the information in each card. See [Card Attributes](https://cds-hooks.hl7.org/1.0/#card-attributes) in the CDS Hooks specification for more information.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum Indicator {
    /** **critical**

Critical. The response is critical and indicates that it contains information or activities that have high urgency and importance that should be immediately addressed */
    Critical,
    /** **info**

Information. The response is informational and indicates that it contains additional information or relevant guidance that may be of interest */
    Info,
    /** **warning**

Warning. The response is a warning and indicates that it contains urgent or highly relevant information that should be considered */
    Warning,
}
impl ::core::str::FromStr for Indicator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "critical" => Ok(Self::Critical),
            "info" => Ok(Self::Info),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Indicator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Critical => "critical",
            Self::Info => "info",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Display for Indicator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Critical => "Critical",
            Self::Info => "Information",
            Self::Warning => "Warning",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for Indicator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Indicator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<Indicator> for Coding {
    fn from(code: Indicator) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/cdshooks-indicator".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<Indicator> for CodeableConcept {
    fn from(code: Indicator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[IngredientFunction](http://hl7.org/fhir/ValueSet/ingredient-function)**. A classification of the ingredient identifying its precise purpose(s) in the drug product (beyond e.g. active/inactive).\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IngredientFunction {
    /** **AlkalizingAgent**

Alkalizing Agent. */
    AlkalizingAgent,
    /** **Antioxidant**

Antioxidant. */
    Antioxidant,
}
impl ::core::str::FromStr for IngredientFunction {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AlkalizingAgent" => Ok(Self::AlkalizingAgent),
            "Antioxidant" => Ok(Self::Antioxidant),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IngredientFunction {
    fn as_ref(&self) -> &str {
        match self {
            Self::AlkalizingAgent => "AlkalizingAgent",
            Self::Antioxidant => "Antioxidant",
        }
    }
}
impl ::std::fmt::Display for IngredientFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AlkalizingAgent => "Alkalizing Agent",
            Self::Antioxidant => "Antioxidant",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for IngredientFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IngredientFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IngredientFunction> for Coding {
    fn from(code: IngredientFunction) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/ingredient-function".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<IngredientFunction> for CodeableConcept {
    fn from(code: IngredientFunction) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[IngredientManufacturerRole](http://hl7.org/fhir/ValueSet/ingredient-manufacturer-role)**. The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IngredientManufacturerRole {
    /** **actual**

Manufacturer actually makes this particular ingredient. */
    Actual,
    /** **allowed**

Manufacturer is specifically allowed for this ingredient. */
    Allowed,
    /** **possible**

Manufacturer is known to make this ingredient in general. */
    Possible,
}
impl ::core::str::FromStr for IngredientManufacturerRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "actual" => Ok(Self::Actual),
            "allowed" => Ok(Self::Allowed),
            "possible" => Ok(Self::Possible),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IngredientManufacturerRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Actual => "actual",
            Self::Allowed => "allowed",
            Self::Possible => "possible",
        }
    }
}
impl ::std::fmt::Display for IngredientManufacturerRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Actual => "Manufacturer actually makes this particular ingredient",
            Self::Allowed => "Manufacturer is specifically allowed for this ingredient",
            Self::Possible => "Manufacturer is known to make this ingredient in general",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for IngredientManufacturerRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IngredientManufacturerRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IngredientManufacturerRole> for Coding {
    fn from(code: IngredientManufacturerRole) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/ingredient-manufacturer-role".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<IngredientManufacturerRole> for CodeableConcept {
    fn from(code: IngredientManufacturerRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[IngredientRole](http://hl7.org/fhir/ValueSet/ingredient-role)**. A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IngredientRole {
    /** **100000072072**

Active. */
    N100000072072,
    /** **100000072073**

Adjuvant. */
    N100000072073,
    /** **100000072082**

Excipient. */
    N100000072082,
    /** **100000136065**

Starting material for excipient. */
    N100000136065,
    /** **100000136066**

Solvent / Diluent. */
    N100000136066,
    /** **100000136178**

Raw materials used in the manufacture of the product. */
    N100000136178,
    /** **100000136179**

Starting material for active substance. */
    N100000136179,
    /** **100000136561**

Overage. */
    N100000136561,
    /** **200000003427**

bioenhancer. */
    N200000003427,
}
impl ::core::str::FromStr for IngredientRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000072072" => Ok(Self::N100000072072),
            "100000072073" => Ok(Self::N100000072073),
            "100000072082" => Ok(Self::N100000072082),
            "100000136065" => Ok(Self::N100000136065),
            "100000136066" => Ok(Self::N100000136066),
            "100000136178" => Ok(Self::N100000136178),
            "100000136179" => Ok(Self::N100000136179),
            "100000136561" => Ok(Self::N100000136561),
            "200000003427" => Ok(Self::N200000003427),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IngredientRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000072072 => "100000072072",
            Self::N100000072073 => "100000072073",
            Self::N100000072082 => "100000072082",
            Self::N100000136065 => "100000136065",
            Self::N100000136066 => "100000136066",
            Self::N100000136178 => "100000136178",
            Self::N100000136179 => "100000136179",
            Self::N100000136561 => "100000136561",
            Self::N200000003427 => "200000003427",
        }
    }
}
impl ::std::fmt::Display for IngredientRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000072072 => "Active",
            Self::N100000072073 => "Adjuvant",
            Self::N100000072082 => "Excipient",
            Self::N100000136065 => "Starting material for excipient",
            Self::N100000136066 => "Solvent / Diluent",
            Self::N100000136178 => "Raw materials used in the manufacture of the product",
            Self::N100000136179 => "Starting material for active substance",
            Self::N100000136561 => "Overage",
            Self::N200000003427 => "bioenhancer",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for IngredientRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IngredientRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IngredientRole> for Coding {
    fn from(code: IngredientRole) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/ingredient-role".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<IngredientRole> for CodeableConcept {
    fn from(code: IngredientRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[InteractionIncidence](http://hl7.org/fhir/ValueSet/interaction-incidence)**. A categorisation for a frequency of occurence of an undesirable effect.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InteractionIncidence {
    /** **Observed**

Observed. */
    Observed,
    /** **Theoretical**

Theoretical. */
    Theoretical,
}
impl ::core::str::FromStr for InteractionIncidence {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Observed" => Ok(Self::Observed),
            "Theoretical" => Ok(Self::Theoretical),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InteractionIncidence {
    fn as_ref(&self) -> &str {
        match self {
            Self::Observed => "Observed",
            Self::Theoretical => "Theoretical",
        }
    }
}
impl ::std::fmt::Display for InteractionIncidence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Observed => "Observed",
            Self::Theoretical => "Theoretical",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for InteractionIncidence {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InteractionIncidence {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InteractionIncidence> for Coding {
    fn from(code: InteractionIncidence) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/interaction-incidence".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<InteractionIncidence> for CodeableConcept {
    fn from(code: InteractionIncidence) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[InteractionType](http://hl7.org/fhir/ValueSet/interaction-type)**. A categorisation for an interaction between two substances.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InteractionType {
    /** **drug-drug**

drug to drug interaction. */
    DrugDrug,
    /** **drug-food**

drug to food interaction. */
    DrugFood,
    /** **drug-test**

drug to laboratory test interaction. */
    DrugTest,
    /** **other**

other interaction. */
    Other,
}
impl ::core::str::FromStr for InteractionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "drug-drug" => Ok(Self::DrugDrug),
            "drug-food" => Ok(Self::DrugFood),
            "drug-test" => Ok(Self::DrugTest),
            "other" => Ok(Self::Other),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InteractionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DrugDrug => "drug-drug",
            Self::DrugFood => "drug-food",
            Self::DrugTest => "drug-test",
            Self::Other => "other",
        }
    }
}
impl ::std::fmt::Display for InteractionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::DrugDrug => "drug to drug interaction",
            Self::DrugFood => "drug to food interaction",
            Self::DrugTest => "drug to laboratory test interaction",
            Self::Other => "other interaction",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for InteractionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InteractionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InteractionType> for Coding {
    fn from(code: InteractionType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/interaction-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<InteractionType> for CodeableConcept {
    fn from(code: InteractionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[InventoryCountType](http://hl7.org/fhir/ValueSet/inventoryreport-counttype)**. The type of count.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InventoryCountType {
    /** **difference**

Difference. The inventory report is about the difference between a previous count and a current count, i.e. it represents the items that have been added/subtracted from inventory. */
    Difference,
    /** **snapshot**

Snapshot. The inventory report is a current absolute snapshot, i.e. it represents the quantities at hand. */
    Snapshot,
}
impl ::core::str::FromStr for InventoryCountType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "difference" => Ok(Self::Difference),
            "snapshot" => Ok(Self::Snapshot),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InventoryCountType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Difference => "difference",
            Self::Snapshot => "snapshot",
        }
    }
}
impl ::std::fmt::Display for InventoryCountType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Difference => "Difference",
            Self::Snapshot => "Snapshot",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for InventoryCountType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InventoryCountType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InventoryCountType> for Coding {
    fn from(code: InventoryCountType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/inventoryreport-counttype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<InventoryCountType> for CodeableConcept {
    fn from(code: InventoryCountType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[InventoryItemNameType](http://hl7.org/fhir/ValueSet/inventoryitem-nametype)**. InventoryItem Name Type\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InventoryItemNameType {
    /** **alias**

Alias. An alias or common name for the item. */
    Alias,
    /** **original-name**

Original Name. The original name of the item. */
    OriginalName,
    /** **preferred**

Preferred. The preferred name of the item. */
    Preferred,
    /** **trade-name**

Trade Name. The official trade name of the item. */
    TradeName,
}
impl ::core::str::FromStr for InventoryItemNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alias" => Ok(Self::Alias),
            "original-name" => Ok(Self::OriginalName),
            "preferred" => Ok(Self::Preferred),
            "trade-name" => Ok(Self::TradeName),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InventoryItemNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alias => "alias",
            Self::OriginalName => "original-name",
            Self::Preferred => "preferred",
            Self::TradeName => "trade-name",
        }
    }
}
impl ::std::fmt::Display for InventoryItemNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Alias => "Alias",
            Self::OriginalName => "Original Name",
            Self::Preferred => "Preferred",
            Self::TradeName => "Trade Name",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for InventoryItemNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InventoryItemNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InventoryItemNameType> for Coding {
    fn from(code: InventoryItemNameType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/inventoryitem-nametype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<InventoryItemNameType> for CodeableConcept {
    fn from(code: InventoryItemNameType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[InventoryItemStatus](http://hl7.org/fhir/ValueSet/inventoryitem-status)**. InventoryItem Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InventoryItemStatus {
    /** **active**

Active. The item is active and can be referenced. */
    Active,
    /** **entered-in-error**

Entered in Error. The item record was entered in error. */
    EnteredInError,
    /** **inactive**

Inactive. The item is presently inactive - there may be references to it but the item is not expected to be used. */
    Inactive,
    /** **unknown**

Unknown. The item status has not been determined. */
    Unknown,
}
impl ::core::str::FromStr for InventoryItemStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InventoryItemStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for InventoryItemStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in Error",
            Self::Inactive => "Inactive",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for InventoryItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InventoryItemStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InventoryItemStatus> for Coding {
    fn from(code: InventoryItemStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/inventoryitem-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<InventoryItemStatus> for CodeableConcept {
    fn from(code: InventoryItemStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[InventoryReportStatus](http://hl7.org/fhir/ValueSet/inventoryreport-status)**. The status of the InventoryReport.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InventoryReportStatus {
    /** **active**

Active. This report is submitted as current. */
    Active,
    /** **draft**

Draft. The existence of the report is registered, but it is still without content or only some preliminary content. */
    Draft,
    /** **entered-in-error**

Entered in Error. The report has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. */
    EnteredInError,
    /** **requested**

Requested. The inventory report has been requested but there is no data available. */
    Requested,
}
impl ::core::str::FromStr for InventoryReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "requested" => Ok(Self::Requested),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InventoryReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Requested => "requested",
        }
    }
}
impl ::std::fmt::Display for InventoryReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Draft => "Draft",
            Self::EnteredInError => "Entered in Error",
            Self::Requested => "Requested",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for InventoryReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InventoryReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InventoryReportStatus> for Coding {
    fn from(code: InventoryReportStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/inventoryreport-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<InventoryReportStatus> for CodeableConcept {
    fn from(code: InventoryReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[InvoiceStatus](http://hl7.org/fhir/ValueSet/invoice-status)**. Codes identifying the lifecycle stage of an Invoice.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InvoiceStatus {
    /** **balanced**

balanced. the invoice has been balaced / completely paid. */
    Balanced,
    /** **cancelled**

cancelled. the invoice was cancelled. */
    Cancelled,
    /** **draft**

draft. the invoice has been prepared but not yet finalized. */
    Draft,
    /** **entered-in-error**

entered in error. the invoice was determined as entered in error before it was issued. */
    EnteredInError,
    /** **issued**

issued. the invoice has been finalized and sent to the recipient. */
    Issued,
}
impl ::core::str::FromStr for InvoiceStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "balanced" => Ok(Self::Balanced),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "issued" => Ok(Self::Issued),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InvoiceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Balanced => "balanced",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Issued => "issued",
        }
    }
}
impl ::std::fmt::Display for InvoiceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Balanced => "balanced",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered in error",
            Self::Issued => "issued",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for InvoiceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InvoiceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<InvoiceStatus> for Coding {
    fn from(code: InvoiceStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/invoice-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<InvoiceStatus> for CodeableConcept {
    fn from(code: InvoiceStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[IssueSeverity](http://hl7.org/fhir/ValueSet/issue-severity)**. How the issue affects the success of the action.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IssueSeverity {
    /** **error**

Error. The issue is sufficiently important to cause the action to fail. */
    Error,
    /** **fatal**

Fatal. The issue caused the action to fail and no further checking could be performed. */
    Fatal,
    /** **information**

Information. The issue has no relation to the degree of success of the action. */
    Information,
    /** **success**

Operation Successful. The operation completed successfully. */
    Success,
    /** **warning**

Warning. The issue is not important enough to cause the action to fail but may cause it to be performed suboptimally or in a way that is not as desired. */
    Warning,
}
impl ::core::str::FromStr for IssueSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "fatal" => Ok(Self::Fatal),
            "information" => Ok(Self::Information),
            "success" => Ok(Self::Success),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IssueSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Fatal => "fatal",
            Self::Information => "information",
            Self::Success => "success",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Display for IssueSeverity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Error => "Error",
            Self::Fatal => "Fatal",
            Self::Information => "Information",
            Self::Success => "Operation Successful",
            Self::Warning => "Warning",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for IssueSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IssueSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IssueSeverity> for Coding {
    fn from(code: IssueSeverity) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/issue-severity".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<IssueSeverity> for CodeableConcept {
    fn from(code: IssueSeverity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[IssueType](http://hl7.org/fhir/ValueSet/issue-type)**. A code that describes the type of issue.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IssueType {
    /** **business-rule**

Business Rule Violation. The content/operation failed to pass some business rule and so could not proceed. */
    BusinessRule,
    /** **code-invalid**

Invalid Code. The code or system could not be understood, or it was not valid in the context of a particular ValueSet.code. */
    CodeInvalid,
    /** **conflict**

Edit Version Conflict. Content could not be accepted because of an edit conflict (i.e. version aware updates). (In a pure RESTful environment, this would be an HTTP 409 error, but this code may be used where the conflict is discovered further into the application architecture.). */
    Conflict,
    /** **deleted**

Deleted. The reference pointed to content (usually a resource) that has been deleted. */
    Deleted,
    /** **duplicate**

Duplicate. An attempt was made to create a duplicate record. */
    Duplicate,
    /** **exception**

Exception. An unexpected internal error has occurred. */
    Exception,
    /** **expired**

Session Expired. User session expired; a login may be required. */
    Expired,
    /** **extension**

Unacceptable Extension. An extension was found that was not acceptable, could not be resolved, or a modifierExtension was not recognized. */
    Extension,
    /** **forbidden**

Forbidden. The user does not have the rights to perform this action. */
    Forbidden,
    /** **incomplete**

Incomplete Results. Not all data sources typically accessed could be reached or responded in time, so the returned information might not be complete (applies to search interactions and some operations). */
    Incomplete,
    /** **informational**

Informational Note. A message unrelated to the processing success of the completed operation (examples of the latter include things like reminders of password expiry, system maintenance times, etc.). */
    Informational,
    /** **invalid**

Invalid Content. Content invalid against the specification or a profile. */
    Invalid,
    /** **invariant**

Validation rule failed. A content validation rule failed - e.g. a schematron rule. */
    Invariant,
    /** **limited-filter**

Limited Filter Application. Some search filters might not have applied on all results.  Data may have been included that does not meet all of the filters listed in the `self` `Bundle.link`. */
    LimitedFilter,
    /** **lock-error**

Lock Error. A resource/record locking failure (usually in an underlying database). */
    LockError,
    /** **login**

Login Required. The client needs to initiate an authentication process. */
    Login,
    /** **multiple-matches**

Multiple Matches. Multiple matching records were found when the operation required only one match. */
    MultipleMatches,
    /** **no-store**

No Store Available. The persistent store is unavailable; e.g. the database is down for maintenance or similar action, and the interaction or operation cannot be processed. */
    NoStore,
    /** **not-found**

Not Found. The reference provided was not found. In a pure RESTful environment, this would be an HTTP 404 error, but this code may be used where the content is not found further into the application architecture. */
    NotFound,
    /** **not-supported**

Content not supported. The interaction, operation, resource or profile is not supported. */
    NotSupported,
    /** **processing**

Processing Failure. Processing issues. These are expected to be final e.g. there is no point resubmitting the same content unchanged. */
    Processing,
    /** **required**

Required element missing. A required element is missing. */
    Required,
    /** **security**

Security Problem. An authentication/authorization/permissions issue of some kind. */
    Security,
    /** **structure**

Structural Issue. A structural issue in the content such as wrong namespace, unable to parse the content completely, invalid syntax, etc. */
    Structure,
    /** **success**

Operation Successful. The operation completed successfully. */
    Success,
    /** **suppressed**

Information  Suppressed. Some information was not or might not have been returned due to business rules, consent or privacy rules, or access permission constraints.  This information may be accessible through alternate processes. */
    Suppressed,
    /** **throttled**

Throttled. The system is not prepared to handle this request due to load management. */
    Throttled,
    /** **timeout**

Timeout. An internal timeout has occurred. */
    Timeout,
    /** **too-costly**

Operation Too Costly. The operation was stopped to protect server resources; e.g. a request for a value set expansion on all of SNOMED CT. */
    TooCostly,
    /** **too-long**

Content Too Long. Provided content is too long (typically, this is a denial of service protection type of error). */
    TooLong,
    /** **transient**

Transient Issue. Transient processing issues. The system receiving the message may be able to resubmit the same content once an underlying issue is resolved. */
    Transient,
    /** **unknown**

Unknown User. The user or system was not able to be authenticated (either there is no process, or the proferred token is unacceptable). */
    Unknown,
    /** **value**

Element value invalid. An element or header value is invalid. */
    Value,
}
impl ::core::str::FromStr for IssueType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "business-rule" => Ok(Self::BusinessRule),
            "code-invalid" => Ok(Self::CodeInvalid),
            "conflict" => Ok(Self::Conflict),
            "deleted" => Ok(Self::Deleted),
            "duplicate" => Ok(Self::Duplicate),
            "exception" => Ok(Self::Exception),
            "expired" => Ok(Self::Expired),
            "extension" => Ok(Self::Extension),
            "forbidden" => Ok(Self::Forbidden),
            "incomplete" => Ok(Self::Incomplete),
            "informational" => Ok(Self::Informational),
            "invalid" => Ok(Self::Invalid),
            "invariant" => Ok(Self::Invariant),
            "limited-filter" => Ok(Self::LimitedFilter),
            "lock-error" => Ok(Self::LockError),
            "login" => Ok(Self::Login),
            "multiple-matches" => Ok(Self::MultipleMatches),
            "no-store" => Ok(Self::NoStore),
            "not-found" => Ok(Self::NotFound),
            "not-supported" => Ok(Self::NotSupported),
            "processing" => Ok(Self::Processing),
            "required" => Ok(Self::Required),
            "security" => Ok(Self::Security),
            "structure" => Ok(Self::Structure),
            "success" => Ok(Self::Success),
            "suppressed" => Ok(Self::Suppressed),
            "throttled" => Ok(Self::Throttled),
            "timeout" => Ok(Self::Timeout),
            "too-costly" => Ok(Self::TooCostly),
            "too-long" => Ok(Self::TooLong),
            "transient" => Ok(Self::Transient),
            "unknown" => Ok(Self::Unknown),
            "value" => Ok(Self::Value),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IssueType {
    fn as_ref(&self) -> &str {
        match self {
            Self::BusinessRule => "business-rule",
            Self::CodeInvalid => "code-invalid",
            Self::Conflict => "conflict",
            Self::Deleted => "deleted",
            Self::Duplicate => "duplicate",
            Self::Exception => "exception",
            Self::Expired => "expired",
            Self::Extension => "extension",
            Self::Forbidden => "forbidden",
            Self::Incomplete => "incomplete",
            Self::Informational => "informational",
            Self::Invalid => "invalid",
            Self::Invariant => "invariant",
            Self::LimitedFilter => "limited-filter",
            Self::LockError => "lock-error",
            Self::Login => "login",
            Self::MultipleMatches => "multiple-matches",
            Self::NoStore => "no-store",
            Self::NotFound => "not-found",
            Self::NotSupported => "not-supported",
            Self::Processing => "processing",
            Self::Required => "required",
            Self::Security => "security",
            Self::Structure => "structure",
            Self::Success => "success",
            Self::Suppressed => "suppressed",
            Self::Throttled => "throttled",
            Self::Timeout => "timeout",
            Self::TooCostly => "too-costly",
            Self::TooLong => "too-long",
            Self::Transient => "transient",
            Self::Unknown => "unknown",
            Self::Value => "value",
        }
    }
}
impl ::std::fmt::Display for IssueType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::BusinessRule => "Business Rule Violation",
            Self::CodeInvalid => "Invalid Code",
            Self::Conflict => "Edit Version Conflict",
            Self::Deleted => "Deleted",
            Self::Duplicate => "Duplicate",
            Self::Exception => "Exception",
            Self::Expired => "Session Expired",
            Self::Extension => "Unacceptable Extension",
            Self::Forbidden => "Forbidden",
            Self::Incomplete => "Incomplete Results",
            Self::Informational => "Informational Note",
            Self::Invalid => "Invalid Content",
            Self::Invariant => "Validation rule failed",
            Self::LimitedFilter => "Limited Filter Application",
            Self::LockError => "Lock Error",
            Self::Login => "Login Required",
            Self::MultipleMatches => "Multiple Matches",
            Self::NoStore => "No Store Available",
            Self::NotFound => "Not Found",
            Self::NotSupported => "Content not supported",
            Self::Processing => "Processing Failure",
            Self::Required => "Required element missing",
            Self::Security => "Security Problem",
            Self::Structure => "Structural Issue",
            Self::Success => "Operation Successful",
            Self::Suppressed => "Information  Suppressed",
            Self::Throttled => "Throttled",
            Self::Timeout => "Timeout",
            Self::TooCostly => "Operation Too Costly",
            Self::TooLong => "Content Too Long",
            Self::Transient => "Transient Issue",
            Self::Unknown => "Unknown User",
            Self::Value => "Element value invalid",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for IssueType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IssueType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<IssueType> for Coding {
    fn from(code: IssueType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/issue-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<IssueType> for CodeableConcept {
    fn from(code: IssueType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[Kind](http://hl7.org/fhir/ValueSet/coverage-kind)**. The nature of the Coverage details which convey who is paying potentially for health services.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum Kind {
    /** **insurance**

Insurance. The Coverage provides the identifiers and card-level details of an insurance policy. */
    Insurance,
    /** **other**

Other. Some other organization is paying for the service. */
    Other,
    /** **self-pay**

Self-pay. One or more persons and/or organizations are paying for the services rendered. */
    SelfPay,
}
impl ::core::str::FromStr for Kind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "insurance" => Ok(Self::Insurance),
            "other" => Ok(Self::Other),
            "self-pay" => Ok(Self::SelfPay),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Kind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Insurance => "insurance",
            Self::Other => "other",
            Self::SelfPay => "self-pay",
        }
    }
}
impl ::std::fmt::Display for Kind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Insurance => "Insurance",
            Self::Other => "Other",
            Self::SelfPay => "Self-pay",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for Kind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Kind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<Kind> for Coding {
    fn from(code: Kind) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/coverage-kind".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<Kind> for CodeableConcept {
    fn from(code: Kind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[KnowledgeRepresentationLevel](http://hl7.org/fhir/uv/cpg/ValueSet/knowledge-representation-level)**. A knowledge representation level, narrative, semi-structured, structured, and executable\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum KnowledgeRepresentationLevel {
    /** **executable**

Executable. The knowledge is expressed in a way that is coded and interpretable by CDS systems using a variety of formats, affording direct executability, but potentially limited shareability. The knowledge is typically expressed focusing on a specific delivery method (modality), technology platform, and implementation environment. Knowledge at this level is typically built and developed by implementers working in specific technology platforms, for the purpose of implementation at a specific site, though affordances such as computable mappings and configuration capabilities can broaden the usability of the knowledge artifact. */
    Executable,
    /** **narrative**

Narrative. The knowledge is expressed as narrative text, affording broad shareability, but limited computability. The knowledge is typically expressed independent of delivery method (modality), technology platform, and implementation site. Knowledge at this level is typically authored by guideline developers for a broad range of purposes including communication of policy, synthesis of evidence, and dissemination of best-practices. */
    Narrative,
    /** **semi-structured**

Semi-Structured. The knowledge is expressed as organized text, often accompanied by diagrams such as flow charts and decision tables, affording broad shareability and moderate computability. The knowledge is typically expressed independent of delivery method (modality), technology platform, and implementation site. Knowledge at this level is typically authored by clinical domain experts for the purpose of communication the description of recommendations for implementation in various modalities. */
    SemiStructured,
    /** **structured**

Structured. The knowledge is expressed in a structured way that is interpretable by computer, including being coded using standard terminologies and specifications for the representation of structured content, affording broad shareability and high computability. The knowledge is typically expressed independent of delivery method (modality), technology platform, and implementation site. Knowledge at this level is typically authored by knowledge engineersto enable precise communication and validation of the recommendations. */
    Structured,
}
impl ::core::str::FromStr for KnowledgeRepresentationLevel {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "executable" => Ok(Self::Executable),
            "narrative" => Ok(Self::Narrative),
            "semi-structured" => Ok(Self::SemiStructured),
            "structured" => Ok(Self::Structured),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for KnowledgeRepresentationLevel {
    fn as_ref(&self) -> &str {
        match self {
            Self::Executable => "executable",
            Self::Narrative => "narrative",
            Self::SemiStructured => "semi-structured",
            Self::Structured => "structured",
        }
    }
}
impl ::std::fmt::Display for KnowledgeRepresentationLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Executable => "Executable",
            Self::Narrative => "Narrative",
            Self::SemiStructured => "Semi-Structured",
            Self::Structured => "Structured",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for KnowledgeRepresentationLevel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for KnowledgeRepresentationLevel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<KnowledgeRepresentationLevel> for Coding {
    fn from(code: KnowledgeRepresentationLevel) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/uv/cpg/ValueSet/knowledge-representation-level"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<KnowledgeRepresentationLevel> for CodeableConcept {
    fn from(code: KnowledgeRepresentationLevel) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[LegalStatusOfSupply](http://hl7.org/fhir/ValueSet/legal-status-of-supply)**. The prescription supply types appropriate to a medicinal product\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LegalStatusOfSupply {
    /** **100000072076**

Medicinal product not subject to medical prescription. */
    N100000072076,
    /** **100000072077**

Medicinal product on medical prescription for renewable or non-renewable delivery. */
    N100000072077,
    /** **100000072078**

Medicinal product subject to restricted medical prescription. */
    N100000072078,
    /** **100000072079**

Medicinal product on medical prescription for non-renewable delivery. */
    N100000072079,
    /** **100000072084**

Medicinal product subject to medical prescription. */
    N100000072084,
    /** **100000072085**

Medicinal product subject to special medical prescription. */
    N100000072085,
    /** **100000072086**

Medicinal product on medical prescription for renewable delivery. */
    N100000072086,
    /** **100000157313**

Medicinal product subject to special and restricted medical prescription. */
    N100000157313,
}
impl ::core::str::FromStr for LegalStatusOfSupply {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000072076" => Ok(Self::N100000072076),
            "100000072077" => Ok(Self::N100000072077),
            "100000072078" => Ok(Self::N100000072078),
            "100000072079" => Ok(Self::N100000072079),
            "100000072084" => Ok(Self::N100000072084),
            "100000072085" => Ok(Self::N100000072085),
            "100000072086" => Ok(Self::N100000072086),
            "100000157313" => Ok(Self::N100000157313),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LegalStatusOfSupply {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000072076 => "100000072076",
            Self::N100000072077 => "100000072077",
            Self::N100000072078 => "100000072078",
            Self::N100000072079 => "100000072079",
            Self::N100000072084 => "100000072084",
            Self::N100000072085 => "100000072085",
            Self::N100000072086 => "100000072086",
            Self::N100000157313 => "100000157313",
        }
    }
}
impl ::std::fmt::Display for LegalStatusOfSupply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000072076 => {
                "Medicinal product not subject to medical prescription"
            }
            Self::N100000072077 => {
                "Medicinal product on medical prescription for renewable or non-renewable delivery"
            }
            Self::N100000072078 => {
                "Medicinal product subject to restricted medical prescription"
            }
            Self::N100000072079 => {
                "Medicinal product on medical prescription for non-renewable delivery"
            }
            Self::N100000072084 => "Medicinal product subject to medical prescription",
            Self::N100000072085 => {
                "Medicinal product subject to special medical prescription"
            }
            Self::N100000072086 => {
                "Medicinal product on medical prescription for renewable delivery"
            }
            Self::N100000157313 => {
                "Medicinal product subject to special and restricted medical prescription"
            }
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for LegalStatusOfSupply {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LegalStatusOfSupply {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LegalStatusOfSupply> for Coding {
    fn from(code: LegalStatusOfSupply) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/legal-status-of-supply".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<LegalStatusOfSupply> for CodeableConcept {
    fn from(code: LegalStatusOfSupply) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[LinkRelationTypes](http://hl7.org/fhir/CodeSystem/iana-link-relations)**. Link Relation Types defined at https://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum LinkRelationTypes {
    /** **P3Pv1**

Refers to a P3P privacy policy for the context.. Refers to a P3P privacy policy for the context. */
    P3Pv1,
    /** **about**

Refers to a resource that is the subject of the link's context.. Refers to a resource that is the subject of the link's context. */
    About,
    /** **acl**

Asserts that the link target provides an access control description for the link context.. Asserts that the link target provides an access control description for the link context. */
    Acl,
    /** **alternate**

Refers to a substitute for this context. Refers to a substitute for this context */
    Alternate,
    /** **amphtml**

Used to reference alternative content that uses the AMP profile of the HTML format.. Used to reference alternative content that uses the AMP profile of the HTML format. */
    Amphtml,
    /** **appendix**

Refers to an appendix.. Refers to an appendix. */
    Appendix,
    /** **apple-touch-icon**

Refers to an icon for the context. Synonym for icon.. Refers to an icon for the context. Synonym for icon. */
    AppleTouchIcon,
    /** **apple-touch-startup-image**

Refers to a launch screen for the context.. Refers to a launch screen for the context. */
    AppleTouchStartupImage,
    /** **archives**

Refers to a collection of records, documents, or other
      materials of historical interest.. Refers to a collection of records, documents, or other
      materials of historical interest. */
    Archives,
    /** **author**

Refers to the context's author.. Refers to the context's author. */
    Author,
    /** **blocked-by**

Identifies the entity that blocks access to a resource
      following receipt of a legal demand.. Identifies the entity that blocks access to a resource
      following receipt of a legal demand. */
    BlockedBy,
    /** **bookmark**

Gives a permanent link to use for bookmarking purposes.. Gives a permanent link to use for bookmarking purposes. */
    Bookmark,
    /** **canonical**

Designates the preferred version of a resource (the IRI and its contents).. Designates the preferred version of a resource (the IRI and its contents). */
    Canonical,
    /** **chapter**

Refers to a chapter in a collection of resources.. Refers to a chapter in a collection of resources. */
    Chapter,
    /** **cite-as**

Indicates that the link target is preferred over the link context for the purpose of permanent citation.. Indicates that the link target is preferred over the link context for the purpose of permanent citation. */
    CiteAs,
    /** **collection**

The target IRI points to a resource which represents the collection resource for the context IRI.. The target IRI points to a resource which represents the collection resource for the context IRI. */
    Collection,
    /** **contents**

Refers to a table of contents.. Refers to a table of contents. */
    Contents,
    /** **convertedFrom**

The document linked to was later converted to the
      document that contains this link relation.  For example, an RFC can
      have a link to the Internet-Draft that became the RFC; in that case,
      the link relation would be "convertedFrom".. The document linked to was later converted to the
      document that contains this link relation.  For example, an RFC can
      have a link to the Internet-Draft that became the RFC; in that case,
      the link relation would be "convertedFrom". */
    ConvertedFrom,
    /** **copyright**

Refers to a copyright statement that applies to the
    link's context.. Refers to a copyright statement that applies to the
    link's context. */
    Copyright,
    /** **create-form**

The target IRI points to a resource where a submission form can be obtained.. The target IRI points to a resource where a submission form can be obtained. */
    CreateForm,
    /** **current**

Refers to a resource containing the most recent
      item(s) in a collection of resources.. Refers to a resource containing the most recent
      item(s) in a collection of resources. */
    Current,
    /** **describedby**

Refers to a resource providing information about the
      link's context.. Refers to a resource providing information about the
      link's context. */
    Describedby,
    /** **describes**

The relationship A 'describes' B asserts that
      resource A provides a description of resource B. There are no
      constraints on the format or representation of either A or B,
      neither are there any further constraints on either resource.. The relationship A 'describes' B asserts that
      resource A provides a description of resource B. There are no
      constraints on the format or representation of either A or B,
      neither are there any further constraints on either resource. */
    Describes,
    /** **disclosure**

Refers to a list of patent disclosures made with respect to
      material for which 'disclosure' relation is specified.. Refers to a list of patent disclosures made with respect to
      material for which 'disclosure' relation is specified. */
    Disclosure,
    /** **dns-prefetch**

Used to indicate an origin that will be used to fetch required
      resources for the link context, and that the user agent ought to resolve
      as early as possible.. Used to indicate an origin that will be used to fetch required
      resources for the link context, and that the user agent ought to resolve
      as early as possible. */
    DnsPrefetch,
    /** **duplicate**

Refers to a resource whose available representations
      are byte-for-byte identical with the corresponding representations of
      the context IRI.. Refers to a resource whose available representations
      are byte-for-byte identical with the corresponding representations of
      the context IRI. */
    Duplicate,
    /** **edit**

Refers to a resource that can be used to edit the
      link's context.. Refers to a resource that can be used to edit the
      link's context. */
    Edit,
    /** **edit-form**

The target IRI points to a resource where a submission form for
      editing associated resource can be obtained.. The target IRI points to a resource where a submission form for
      editing associated resource can be obtained. */
    EditForm,
    /** **edit-media**

Refers to a resource that can be used to edit media
      associated with the link's context.. Refers to a resource that can be used to edit media
      associated with the link's context. */
    EditMedia,
    /** **enclosure**

Identifies a related resource that is potentially
      large and might require special handling.. Identifies a related resource that is potentially
      large and might require special handling. */
    Enclosure,
    /** **external**

Refers to a resource that is not part of the same site as the current context.. Refers to a resource that is not part of the same site as the current context. */
    External,
    /** **first**

An IRI that refers to the furthest preceding resource
    in a series of resources.. An IRI that refers to the furthest preceding resource
    in a series of resources. */
    First,
    /** **glossary**

Refers to a glossary of terms.. Refers to a glossary of terms. */
    Glossary,
    /** **help**

Refers to context-sensitive help.. Refers to context-sensitive help. */
    Help,
    /** **hosts**

Refers to a resource hosted by the server indicated by
      the link context.. Refers to a resource hosted by the server indicated by
      the link context. */
    Hosts,
    /** **hub**

Refers to a hub that enables registration for
    notification of updates to the context.. Refers to a hub that enables registration for
    notification of updates to the context. */
    Hub,
    /** **icon**

Refers to an icon representing the link's context.. Refers to an icon representing the link's context. */
    Icon,
    /** **index**

Refers to an index.. Refers to an index. */
    Index,
    /** **intervalAfter**

refers to a resource associated with a time interval that ends before the beginning of the time interval associated with the context resource. refers to a resource associated with a time interval that ends before the beginning of the time interval associated with the context resource */
    IntervalAfter,
    /** **intervalBefore**

refers to a resource associated with a time interval that begins after the end of the time interval associated with the context resource. refers to a resource associated with a time interval that begins after the end of the time interval associated with the context resource */
    IntervalBefore,
    /** **intervalContains**

refers to a resource associated with a time interval that begins after the beginning of the time interval associated with the context resource, and ends before the end of the time interval associated with the context resource. refers to a resource associated with a time interval that begins after the beginning of the time interval associated with the context resource, and ends before the end of the time interval associated with the context resource */
    IntervalContains,
    /** **intervalDisjoint**

refers to a resource associated with a time interval that begins after the end of the time interval associated with the context resource, or ends before the beginning of the time interval associated with the context resource. refers to a resource associated with a time interval that begins after the end of the time interval associated with the context resource, or ends before the beginning of the time interval associated with the context resource */
    IntervalDisjoint,
    /** **intervalDuring**

refers to a resource associated with a time interval that begins before the beginning of the time interval associated with the context resource, and ends after the end of the time interval associated with the context resource. refers to a resource associated with a time interval that begins before the beginning of the time interval associated with the context resource, and ends after the end of the time interval associated with the context resource */
    IntervalDuring,
    /** **intervalEquals**

refers to a resource associated with a time interval whose beginning coincides with the beginning of the time interval associated with the context resource, and whose end coincides with the end of the time interval associated with the context resource. refers to a resource associated with a time interval whose beginning coincides with the beginning of the time interval associated with the context resource, and whose end coincides with the end of the time interval associated with the context resource */
    IntervalEquals,
    /** **intervalFinishedBy**

refers to a resource associated with a time interval that begins after the beginning of the time interval associated with the context resource, and whose end coincides with the end of the time interval associated with the context resource. refers to a resource associated with a time interval that begins after the beginning of the time interval associated with the context resource, and whose end coincides with the end of the time interval associated with the context resource */
    IntervalFinishedBy,
    /** **intervalFinishes**

refers to a resource associated with a time interval that begins before the beginning of the time interval associated with the context resource, and whose end coincides with the end of the time interval associated with the context resource. refers to a resource associated with a time interval that begins before the beginning of the time interval associated with the context resource, and whose end coincides with the end of the time interval associated with the context resource */
    IntervalFinishes,
    /** **intervalIn**

refers to a resource associated with a time interval that begins before or is coincident with the beginning of the time interval associated with the context resource, and ends after or is coincident with the end of the time interval associated with the context resource. refers to a resource associated with a time interval that begins before or is coincident with the beginning of the time interval associated with the context resource, and ends after or is coincident with the end of the time interval associated with the context resource */
    IntervalIn,
    /** **intervalMeets**

refers to a resource associated with a time interval whose beginning coincides with the end of the time interval associated with the context resource. refers to a resource associated with a time interval whose beginning coincides with the end of the time interval associated with the context resource */
    IntervalMeets,
    /** **intervalMetBy**

refers to a resource associated with a time interval whose end coincides with the beginning of the time interval associated with the context resource. refers to a resource associated with a time interval whose end coincides with the beginning of the time interval associated with the context resource */
    IntervalMetBy,
    /** **intervalOverlappedBy**

refers to a resource associated with a time interval that begins before the beginning of the time interval associated with the context resource, and ends after the beginning of the time interval associated with the context resource. refers to a resource associated with a time interval that begins before the beginning of the time interval associated with the context resource, and ends after the beginning of the time interval associated with the context resource */
    IntervalOverlappedBy,
    /** **intervalOverlaps**

refers to a resource associated with a time interval that begins before the end of the time interval associated with the context resource, and ends after the end of the time interval associated with the context resource. refers to a resource associated with a time interval that begins before the end of the time interval associated with the context resource, and ends after the end of the time interval associated with the context resource */
    IntervalOverlaps,
    /** **intervalStartedBy**

refers to a resource associated with a time interval whose beginning coincides with the beginning of the time interval associated with the context resource, and ends before the end of the time interval associated with the context resource. refers to a resource associated with a time interval whose beginning coincides with the beginning of the time interval associated with the context resource, and ends before the end of the time interval associated with the context resource */
    IntervalStartedBy,
    /** **intervalStarts**

refers to a resource associated with a time interval whose beginning coincides with the beginning of the time interval associated with the context resource, and ends after the end of the time interval associated with the context resource. refers to a resource associated with a time interval whose beginning coincides with the beginning of the time interval associated with the context resource, and ends after the end of the time interval associated with the context resource */
    IntervalStarts,
    /** **item**

The target IRI points to a resource that is a member of the collection represented by the context IRI.. The target IRI points to a resource that is a member of the collection represented by the context IRI. */
    Item,
    /** **last**

An IRI that refers to the furthest following resource
      in a series of resources.. An IRI that refers to the furthest following resource
      in a series of resources. */
    Last,
    /** **latest-version**

Points to a resource containing the latest (e.g.,
      current) version of the context.. Points to a resource containing the latest (e.g.,
      current) version of the context. */
    LatestVersion,
    /** **license**

Refers to a license associated with this context.. Refers to a license associated with this context. */
    License,
    /** **linkset**

The link target of a link with the "linkset" relation
      type provides a set of links, including links in which the link
      context of the link participates.
    . The link target of a link with the "linkset" relation
      type provides a set of links, including links in which the link
      context of the link participates.
     */
    Linkset,
    /** **lrdd**

Refers to further information about the link's context,
      expressed as a LRDD ("Link-based Resource Descriptor Document")
      resource.  See  for information about
      processing this relation type in host-meta documents. When used
      elsewhere, it refers to additional links and other metadata.
      Multiple instances indicate additional LRDD resources. LRDD
      resources MUST have an "application/xrd+xml" representation, and
      MAY have others.. Refers to further information about the link's context,
      expressed as a LRDD ("Link-based Resource Descriptor Document")
      resource.  See  for information about
      processing this relation type in host-meta documents. When used
      elsewhere, it refers to additional links and other metadata.
      Multiple instances indicate additional LRDD resources. LRDD
      resources MUST have an "application/xrd+xml" representation, and
      MAY have others. */
    Lrdd,
    /** **manifest**

Links to a manifest file for the context.. Links to a manifest file for the context. */
    Manifest,
    /** **mask-icon**

Refers to a mask that can be applied to the icon for the context.. Refers to a mask that can be applied to the icon for the context. */
    MaskIcon,
    /** **media-feed**

Refers to a feed of personalised media recommendations relevant to the link context.. Refers to a feed of personalised media recommendations relevant to the link context. */
    MediaFeed,
    /** **memento**

The Target IRI points to a Memento, a fixed resource that will not change state anymore.. The Target IRI points to a Memento, a fixed resource that will not change state anymore. */
    Memento,
    /** **micropub**

Links to the context's Micropub endpoint.. Links to the context's Micropub endpoint. */
    Micropub,
    /** **modulepreload**

Refers to a module that the user agent is to preemptively fetch and store for use in the current context.. Refers to a module that the user agent is to preemptively fetch and store for use in the current context. */
    Modulepreload,
    /** **monitor**

Refers to a resource that can be used to monitor changes in an HTTP resource.
    . Refers to a resource that can be used to monitor changes in an HTTP resource.
     */
    Monitor,
    /** **monitor-group**

Refers to a resource that can be used to monitor changes in a specified group of HTTP resources.
    . Refers to a resource that can be used to monitor changes in a specified group of HTTP resources.
     */
    MonitorGroup,
    /** **next**

Indicates that the link's context is a part of a series, and
      that the next in the series is the link target.
    . Indicates that the link's context is a part of a series, and
      that the next in the series is the link target.
     */
    Next,
    /** **next-archive**

Refers to the immediately following archive resource.. Refers to the immediately following archive resource. */
    NextArchive,
    /** **nofollow**

Indicates that the context’s original author or publisher does not endorse the link target.. Indicates that the context’s original author or publisher does not endorse the link target. */
    Nofollow,
    /** **noopener**

Indicates that any newly created top-level browsing context which results from following the link will not be an auxiliary browsing context.. Indicates that any newly created top-level browsing context which results from following the link will not be an auxiliary browsing context. */
    Noopener,
    /** **noreferrer**

Indicates that no referrer information is to be leaked when following the link.. Indicates that no referrer information is to be leaked when following the link. */
    Noreferrer,
    /** **opener**

Indicates that any newly created top-level browsing context which results from following the link will be an auxiliary browsing context.. Indicates that any newly created top-level browsing context which results from following the link will be an auxiliary browsing context. */
    Opener,
    /** **openid2.local_id**

Refers to an OpenID Authentication server on which the context relies for an assertion that the end user controls an Identifier.. Refers to an OpenID Authentication server on which the context relies for an assertion that the end user controls an Identifier. */
    Openid2LocalId,
    /** **openid2.provider**

Refers to a resource which accepts OpenID Authentication protocol messages for the context.. Refers to a resource which accepts OpenID Authentication protocol messages for the context. */
    Openid2Provider,
    /** **original**

The Target IRI points to an Original Resource.. The Target IRI points to an Original Resource. */
    Original,
    /** **payment**

Indicates a resource where payment is accepted.. Indicates a resource where payment is accepted. */
    Payment,
    /** **pingback**

Gives the address of the pingback resource for the link context.. Gives the address of the pingback resource for the link context. */
    Pingback,
    /** **preconnect**

Used to indicate an origin that will be used to fetch required
      resources for the link context. Initiating an early connection, which
      includes the DNS lookup, TCP handshake, and optional TLS negotiation,
      allows the user agent to mask the high latency costs of establishing a
      connection.. Used to indicate an origin that will be used to fetch required
      resources for the link context. Initiating an early connection, which
      includes the DNS lookup, TCP handshake, and optional TLS negotiation,
      allows the user agent to mask the high latency costs of establishing a
      connection. */
    Preconnect,
    /** **predecessor-version**

Points to a resource containing the predecessor
      version in the version history.
    . Points to a resource containing the predecessor
      version in the version history.
     */
    PredecessorVersion,
    /** **prefetch**

The prefetch link relation type is used to identify a resource
      that might be required by the next navigation from the link context, and
      that the user agent ought to fetch, such that the user agent can deliver a
      faster response once the resource is requested in the future.. The prefetch link relation type is used to identify a resource
      that might be required by the next navigation from the link context, and
      that the user agent ought to fetch, such that the user agent can deliver a
      faster response once the resource is requested in the future. */
    Prefetch,
    /** **preload**

Refers to a resource that should be loaded early in the
      processing of the link's context, without blocking rendering.. Refers to a resource that should be loaded early in the
      processing of the link's context, without blocking rendering. */
    Preload,
    /** **prerender**

Used to identify a resource that might be required by the next
      navigation from the link context, and that the user agent ought to fetch
      and execute, such that the user agent can deliver a faster response once
      the resource is requested in the future.. Used to identify a resource that might be required by the next
      navigation from the link context, and that the user agent ought to fetch
      and execute, such that the user agent can deliver a faster response once
      the resource is requested in the future. */
    Prerender,
    /** **prev**

Indicates that the link's context is a part of a series, and
      that the previous in the series is the link target.
    . Indicates that the link's context is a part of a series, and
      that the previous in the series is the link target.
     */
    Prev,
    /** **prev-archive**

Refers to the immediately preceding archive resource.. Refers to the immediately preceding archive resource. */
    PrevArchive,
    /** **preview**

Refers to a resource that provides a preview of the link's context.. Refers to a resource that provides a preview of the link's context. */
    Preview,
    /** **previous**

Refers to the previous resource in an ordered series
      of resources.  Synonym for "prev".. Refers to the previous resource in an ordered series
      of resources.  Synonym for "prev". */
    Previous,
    /** **privacy-policy**

Refers to a privacy policy associated with the link's context.. Refers to a privacy policy associated with the link's context. */
    PrivacyPolicy,
    /** **profile**

Identifying that a resource representation conforms
to a certain profile, without affecting the non-profile semantics
of the resource representation.. Identifying that a resource representation conforms
to a certain profile, without affecting the non-profile semantics
of the resource representation. */
    Profile,
    /** **publication**

Links to a publication manifest. A manifest represents
      structured information about a publication, such as informative metadata,
      a list of resources, and a default reading order.. Links to a publication manifest. A manifest represents
      structured information about a publication, such as informative metadata,
      a list of resources, and a default reading order. */
    Publication,
    /** **related**

Identifies a related resource.. Identifies a related resource. */
    Related,
    /** **replies**

Identifies a resource that is a reply to the context
      of the link.
    . Identifies a resource that is a reply to the context
      of the link.
     */
    Replies,
    /** **restconf**

Identifies the root of RESTCONF API as configured on this HTTP server.
      The "restconf" relation defines the root of the API defined in RFC8040.
      Subsequent revisions of RESTCONF will use alternate relation values to support
      protocol versioning.. Identifies the root of RESTCONF API as configured on this HTTP server.
      The "restconf" relation defines the root of the API defined in RFC8040.
      Subsequent revisions of RESTCONF will use alternate relation values to support
      protocol versioning. */
    Restconf,
    /** **ruleinput**

The resource identified by the link target provides an input value to an
    instance of a rule, where the resource which represents the rule instance is
    identified by the link context.
    . The resource identified by the link target provides an input value to an
    instance of a rule, where the resource which represents the rule instance is
    identified by the link context.
     */
    Ruleinput,
    /** **search**

Refers to a resource that can be used to search through
      the link's context and related resources.. Refers to a resource that can be used to search through
      the link's context and related resources. */
    Search,
    /** **section**

Refers to a section in a collection of resources.. Refers to a section in a collection of resources. */
    Section,
    /** **self**

Conveys an identifier for the link's context.
    . Conveys an identifier for the link's context.
     */
    _Self,
    /** **service**

Indicates a URI that can be used to retrieve a
      service document.. Indicates a URI that can be used to retrieve a
      service document. */
    Service,
    /** **service-desc**

Identifies service description for the context that
      is primarily intended for consumption by machines.. Identifies service description for the context that
      is primarily intended for consumption by machines. */
    ServiceDesc,
    /** **service-doc**

Identifies service documentation for the context that
      is primarily intended for human consumption.. Identifies service documentation for the context that
      is primarily intended for human consumption. */
    ServiceDoc,
    /** **service-meta**

Identifies general metadata for the context that is
      primarily intended for consumption by machines.. Identifies general metadata for the context that is
      primarily intended for consumption by machines. */
    ServiceMeta,
    /** **sponsored**

Refers to a resource that is within a context that is
		sponsored (such as advertising or another compensation agreement).. Refers to a resource that is within a context that is
		sponsored (such as advertising or another compensation agreement). */
    Sponsored,
    /** **start**

Refers to the first resource in a collection of
      resources.. Refers to the first resource in a collection of
      resources. */
    Start,
    /** **status**

Identifies a resource that represents the context's
      status.. Identifies a resource that represents the context's
      status. */
    Status,
    /** **stylesheet**

Refers to a stylesheet.. Refers to a stylesheet. */
    Stylesheet,
    /** **subsection**

Refers to a resource serving as a subsection in a
      collection of resources.. Refers to a resource serving as a subsection in a
      collection of resources. */
    Subsection,
    /** **successor-version**

Points to a resource containing the successor version
      in the version history.
    . Points to a resource containing the successor version
      in the version history.
     */
    SuccessorVersion,
    /** **sunset**

Identifies a resource that provides information about
      the context's retirement policy.
    . Identifies a resource that provides information about
      the context's retirement policy.
     */
    Sunset,
    /** **tag**

Gives a tag (identified by the given address) that applies to
      the current document.
    . Gives a tag (identified by the given address) that applies to
      the current document.
     */
    Tag,
    /** **terms-of-service**

Refers to the terms of service associated with the link's context.. Refers to the terms of service associated with the link's context. */
    TermsOfService,
    /** **timegate**

The Target IRI points to a TimeGate for an Original Resource.. The Target IRI points to a TimeGate for an Original Resource. */
    Timegate,
    /** **timemap**

The Target IRI points to a TimeMap for an Original Resource.. The Target IRI points to a TimeMap for an Original Resource. */
    Timemap,
    /** **type**

Refers to a resource identifying the abstract semantic type of which the link's context is considered to be an instance.. Refers to a resource identifying the abstract semantic type of which the link's context is considered to be an instance. */
    Type,
    /** **ugc**

Refers to a resource that is within a context that is User Generated Content.
    . Refers to a resource that is within a context that is User Generated Content.
     */
    Ugc,
    /** **up**

Refers to a parent document in a hierarchy of
      documents.
    . Refers to a parent document in a hierarchy of
      documents.
     */
    Up,
    /** **version-history**

Points to a resource containing the version history
      for the context.
    . Points to a resource containing the version history
      for the context.
     */
    VersionHistory,
    /** **via**

Identifies a resource that is the source of the
      information in the link's context.
    . Identifies a resource that is the source of the
      information in the link's context.
     */
    Via,
    /** **webmention**

Identifies a target URI that supports the Webmention protocol.
    This allows clients that mention a resource in some form of publishing process
    to contact that endpoint and inform it that this resource has been mentioned.. Identifies a target URI that supports the Webmention protocol.
    This allows clients that mention a resource in some form of publishing process
    to contact that endpoint and inform it that this resource has been mentioned. */
    Webmention,
    /** **working-copy**

Points to a working copy for this resource.. Points to a working copy for this resource. */
    WorkingCopy,
    /** **working-copy-of**

Points to the versioned resource from which this
      working copy was obtained.
    . Points to the versioned resource from which this
      working copy was obtained.
     */
    WorkingCopyOf,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for LinkRelationTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "P3Pv1" => Ok(Self::P3Pv1),
            "about" => Ok(Self::About),
            "acl" => Ok(Self::Acl),
            "alternate" => Ok(Self::Alternate),
            "amphtml" => Ok(Self::Amphtml),
            "appendix" => Ok(Self::Appendix),
            "apple-touch-icon" => Ok(Self::AppleTouchIcon),
            "apple-touch-startup-image" => Ok(Self::AppleTouchStartupImage),
            "archives" => Ok(Self::Archives),
            "author" => Ok(Self::Author),
            "blocked-by" => Ok(Self::BlockedBy),
            "bookmark" => Ok(Self::Bookmark),
            "canonical" => Ok(Self::Canonical),
            "chapter" => Ok(Self::Chapter),
            "cite-as" => Ok(Self::CiteAs),
            "collection" => Ok(Self::Collection),
            "contents" => Ok(Self::Contents),
            "convertedFrom" => Ok(Self::ConvertedFrom),
            "copyright" => Ok(Self::Copyright),
            "create-form" => Ok(Self::CreateForm),
            "current" => Ok(Self::Current),
            "describedby" => Ok(Self::Describedby),
            "describes" => Ok(Self::Describes),
            "disclosure" => Ok(Self::Disclosure),
            "dns-prefetch" => Ok(Self::DnsPrefetch),
            "duplicate" => Ok(Self::Duplicate),
            "edit" => Ok(Self::Edit),
            "edit-form" => Ok(Self::EditForm),
            "edit-media" => Ok(Self::EditMedia),
            "enclosure" => Ok(Self::Enclosure),
            "external" => Ok(Self::External),
            "first" => Ok(Self::First),
            "glossary" => Ok(Self::Glossary),
            "help" => Ok(Self::Help),
            "hosts" => Ok(Self::Hosts),
            "hub" => Ok(Self::Hub),
            "icon" => Ok(Self::Icon),
            "index" => Ok(Self::Index),
            "intervalAfter" => Ok(Self::IntervalAfter),
            "intervalBefore" => Ok(Self::IntervalBefore),
            "intervalContains" => Ok(Self::IntervalContains),
            "intervalDisjoint" => Ok(Self::IntervalDisjoint),
            "intervalDuring" => Ok(Self::IntervalDuring),
            "intervalEquals" => Ok(Self::IntervalEquals),
            "intervalFinishedBy" => Ok(Self::IntervalFinishedBy),
            "intervalFinishes" => Ok(Self::IntervalFinishes),
            "intervalIn" => Ok(Self::IntervalIn),
            "intervalMeets" => Ok(Self::IntervalMeets),
            "intervalMetBy" => Ok(Self::IntervalMetBy),
            "intervalOverlappedBy" => Ok(Self::IntervalOverlappedBy),
            "intervalOverlaps" => Ok(Self::IntervalOverlaps),
            "intervalStartedBy" => Ok(Self::IntervalStartedBy),
            "intervalStarts" => Ok(Self::IntervalStarts),
            "item" => Ok(Self::Item),
            "last" => Ok(Self::Last),
            "latest-version" => Ok(Self::LatestVersion),
            "license" => Ok(Self::License),
            "linkset" => Ok(Self::Linkset),
            "lrdd" => Ok(Self::Lrdd),
            "manifest" => Ok(Self::Manifest),
            "mask-icon" => Ok(Self::MaskIcon),
            "media-feed" => Ok(Self::MediaFeed),
            "memento" => Ok(Self::Memento),
            "micropub" => Ok(Self::Micropub),
            "modulepreload" => Ok(Self::Modulepreload),
            "monitor" => Ok(Self::Monitor),
            "monitor-group" => Ok(Self::MonitorGroup),
            "next" => Ok(Self::Next),
            "next-archive" => Ok(Self::NextArchive),
            "nofollow" => Ok(Self::Nofollow),
            "noopener" => Ok(Self::Noopener),
            "noreferrer" => Ok(Self::Noreferrer),
            "opener" => Ok(Self::Opener),
            "openid2.local_id" => Ok(Self::Openid2LocalId),
            "openid2.provider" => Ok(Self::Openid2Provider),
            "original" => Ok(Self::Original),
            "payment" => Ok(Self::Payment),
            "pingback" => Ok(Self::Pingback),
            "preconnect" => Ok(Self::Preconnect),
            "predecessor-version" => Ok(Self::PredecessorVersion),
            "prefetch" => Ok(Self::Prefetch),
            "preload" => Ok(Self::Preload),
            "prerender" => Ok(Self::Prerender),
            "prev" => Ok(Self::Prev),
            "prev-archive" => Ok(Self::PrevArchive),
            "preview" => Ok(Self::Preview),
            "previous" => Ok(Self::Previous),
            "privacy-policy" => Ok(Self::PrivacyPolicy),
            "profile" => Ok(Self::Profile),
            "publication" => Ok(Self::Publication),
            "related" => Ok(Self::Related),
            "replies" => Ok(Self::Replies),
            "restconf" => Ok(Self::Restconf),
            "ruleinput" => Ok(Self::Ruleinput),
            "search" => Ok(Self::Search),
            "section" => Ok(Self::Section),
            "self" => Ok(Self::_Self),
            "service" => Ok(Self::Service),
            "service-desc" => Ok(Self::ServiceDesc),
            "service-doc" => Ok(Self::ServiceDoc),
            "service-meta" => Ok(Self::ServiceMeta),
            "sponsored" => Ok(Self::Sponsored),
            "start" => Ok(Self::Start),
            "status" => Ok(Self::Status),
            "stylesheet" => Ok(Self::Stylesheet),
            "subsection" => Ok(Self::Subsection),
            "successor-version" => Ok(Self::SuccessorVersion),
            "sunset" => Ok(Self::Sunset),
            "tag" => Ok(Self::Tag),
            "terms-of-service" => Ok(Self::TermsOfService),
            "timegate" => Ok(Self::Timegate),
            "timemap" => Ok(Self::Timemap),
            "type" => Ok(Self::Type),
            "ugc" => Ok(Self::Ugc),
            "up" => Ok(Self::Up),
            "version-history" => Ok(Self::VersionHistory),
            "via" => Ok(Self::Via),
            "webmention" => Ok(Self::Webmention),
            "working-copy" => Ok(Self::WorkingCopy),
            "working-copy-of" => Ok(Self::WorkingCopyOf),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for LinkRelationTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::P3Pv1 => "P3Pv1",
            Self::About => "about",
            Self::Acl => "acl",
            Self::Alternate => "alternate",
            Self::Amphtml => "amphtml",
            Self::Appendix => "appendix",
            Self::AppleTouchIcon => "apple-touch-icon",
            Self::AppleTouchStartupImage => "apple-touch-startup-image",
            Self::Archives => "archives",
            Self::Author => "author",
            Self::BlockedBy => "blocked-by",
            Self::Bookmark => "bookmark",
            Self::Canonical => "canonical",
            Self::Chapter => "chapter",
            Self::CiteAs => "cite-as",
            Self::Collection => "collection",
            Self::Contents => "contents",
            Self::ConvertedFrom => "convertedFrom",
            Self::Copyright => "copyright",
            Self::CreateForm => "create-form",
            Self::Current => "current",
            Self::Describedby => "describedby",
            Self::Describes => "describes",
            Self::Disclosure => "disclosure",
            Self::DnsPrefetch => "dns-prefetch",
            Self::Duplicate => "duplicate",
            Self::Edit => "edit",
            Self::EditForm => "edit-form",
            Self::EditMedia => "edit-media",
            Self::Enclosure => "enclosure",
            Self::External => "external",
            Self::First => "first",
            Self::Glossary => "glossary",
            Self::Help => "help",
            Self::Hosts => "hosts",
            Self::Hub => "hub",
            Self::Icon => "icon",
            Self::Index => "index",
            Self::IntervalAfter => "intervalAfter",
            Self::IntervalBefore => "intervalBefore",
            Self::IntervalContains => "intervalContains",
            Self::IntervalDisjoint => "intervalDisjoint",
            Self::IntervalDuring => "intervalDuring",
            Self::IntervalEquals => "intervalEquals",
            Self::IntervalFinishedBy => "intervalFinishedBy",
            Self::IntervalFinishes => "intervalFinishes",
            Self::IntervalIn => "intervalIn",
            Self::IntervalMeets => "intervalMeets",
            Self::IntervalMetBy => "intervalMetBy",
            Self::IntervalOverlappedBy => "intervalOverlappedBy",
            Self::IntervalOverlaps => "intervalOverlaps",
            Self::IntervalStartedBy => "intervalStartedBy",
            Self::IntervalStarts => "intervalStarts",
            Self::Item => "item",
            Self::Last => "last",
            Self::LatestVersion => "latest-version",
            Self::License => "license",
            Self::Linkset => "linkset",
            Self::Lrdd => "lrdd",
            Self::Manifest => "manifest",
            Self::MaskIcon => "mask-icon",
            Self::MediaFeed => "media-feed",
            Self::Memento => "memento",
            Self::Micropub => "micropub",
            Self::Modulepreload => "modulepreload",
            Self::Monitor => "monitor",
            Self::MonitorGroup => "monitor-group",
            Self::Next => "next",
            Self::NextArchive => "next-archive",
            Self::Nofollow => "nofollow",
            Self::Noopener => "noopener",
            Self::Noreferrer => "noreferrer",
            Self::Opener => "opener",
            Self::Openid2LocalId => "openid2.local_id",
            Self::Openid2Provider => "openid2.provider",
            Self::Original => "original",
            Self::Payment => "payment",
            Self::Pingback => "pingback",
            Self::Preconnect => "preconnect",
            Self::PredecessorVersion => "predecessor-version",
            Self::Prefetch => "prefetch",
            Self::Preload => "preload",
            Self::Prerender => "prerender",
            Self::Prev => "prev",
            Self::PrevArchive => "prev-archive",
            Self::Preview => "preview",
            Self::Previous => "previous",
            Self::PrivacyPolicy => "privacy-policy",
            Self::Profile => "profile",
            Self::Publication => "publication",
            Self::Related => "related",
            Self::Replies => "replies",
            Self::Restconf => "restconf",
            Self::Ruleinput => "ruleinput",
            Self::Search => "search",
            Self::Section => "section",
            Self::_Self => "self",
            Self::Service => "service",
            Self::ServiceDesc => "service-desc",
            Self::ServiceDoc => "service-doc",
            Self::ServiceMeta => "service-meta",
            Self::Sponsored => "sponsored",
            Self::Start => "start",
            Self::Status => "status",
            Self::Stylesheet => "stylesheet",
            Self::Subsection => "subsection",
            Self::SuccessorVersion => "successor-version",
            Self::Sunset => "sunset",
            Self::Tag => "tag",
            Self::TermsOfService => "terms-of-service",
            Self::Timegate => "timegate",
            Self::Timemap => "timemap",
            Self::Type => "type",
            Self::Ugc => "ugc",
            Self::Up => "up",
            Self::VersionHistory => "version-history",
            Self::Via => "via",
            Self::Webmention => "webmention",
            Self::WorkingCopy => "working-copy",
            Self::WorkingCopyOf => "working-copy-of",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for LinkRelationTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::P3Pv1 => "Refers to a P3P privacy policy for the context.",
            Self::About => {
                "Refers to a resource that is the subject of the link's context."
            }
            Self::Acl => {
                "Asserts that the link target provides an access control description for the link context."
            }
            Self::Alternate => "Refers to a substitute for this context",
            Self::Amphtml => {
                "Used to reference alternative content that uses the AMP profile of the HTML format."
            }
            Self::Appendix => "Refers to an appendix.",
            Self::AppleTouchIcon => {
                "Refers to an icon for the context. Synonym for icon."
            }
            Self::AppleTouchStartupImage => "Refers to a launch screen for the context.",
            Self::Archives => {
                "Refers to a collection of records, documents, or other\n      materials of historical interest."
            }
            Self::Author => "Refers to the context's author.",
            Self::BlockedBy => {
                "Identifies the entity that blocks access to a resource\n      following receipt of a legal demand."
            }
            Self::Bookmark => "Gives a permanent link to use for bookmarking purposes.",
            Self::Canonical => {
                "Designates the preferred version of a resource (the IRI and its contents)."
            }
            Self::Chapter => "Refers to a chapter in a collection of resources.",
            Self::CiteAs => {
                "Indicates that the link target is preferred over the link context for the purpose of permanent citation."
            }
            Self::Collection => {
                "The target IRI points to a resource which represents the collection resource for the context IRI."
            }
            Self::Contents => "Refers to a table of contents.",
            Self::ConvertedFrom => {
                "The document linked to was later converted to the\n      document that contains this link relation.  For example, an RFC can\n      have a link to the Internet-Draft that became the RFC; in that case,\n      the link relation would be \"convertedFrom\"."
            }
            Self::Copyright => {
                "Refers to a copyright statement that applies to the\n    link's context."
            }
            Self::CreateForm => {
                "The target IRI points to a resource where a submission form can be obtained."
            }
            Self::Current => {
                "Refers to a resource containing the most recent\n      item(s) in a collection of resources."
            }
            Self::Describedby => {
                "Refers to a resource providing information about the\n      link's context."
            }
            Self::Describes => {
                "The relationship A 'describes' B asserts that\n      resource A provides a description of resource B. There are no\n      constraints on the format or representation of either A or B,\n      neither are there any further constraints on either resource."
            }
            Self::Disclosure => {
                "Refers to a list of patent disclosures made with respect to \n      material for which 'disclosure' relation is specified."
            }
            Self::DnsPrefetch => {
                "Used to indicate an origin that will be used to fetch required \n      resources for the link context, and that the user agent ought to resolve \n      as early as possible."
            }
            Self::Duplicate => {
                "Refers to a resource whose available representations\n      are byte-for-byte identical with the corresponding representations of\n      the context IRI."
            }
            Self::Edit => {
                "Refers to a resource that can be used to edit the\n      link's context."
            }
            Self::EditForm => {
                "The target IRI points to a resource where a submission form for\n      editing associated resource can be obtained."
            }
            Self::EditMedia => {
                "Refers to a resource that can be used to edit media\n      associated with the link's context."
            }
            Self::Enclosure => {
                "Identifies a related resource that is potentially\n      large and might require special handling."
            }
            Self::External => {
                "Refers to a resource that is not part of the same site as the current context."
            }
            Self::First => {
                "An IRI that refers to the furthest preceding resource\n    in a series of resources."
            }
            Self::Glossary => "Refers to a glossary of terms.",
            Self::Help => "Refers to context-sensitive help.",
            Self::Hosts => {
                "Refers to a resource hosted by the server indicated by\n      the link context."
            }
            Self::Hub => {
                "Refers to a hub that enables registration for\n    notification of updates to the context."
            }
            Self::Icon => "Refers to an icon representing the link's context.",
            Self::Index => "Refers to an index.",
            Self::IntervalAfter => {
                "refers to a resource associated with a time interval that ends before the beginning of the time interval associated with the context resource"
            }
            Self::IntervalBefore => {
                "refers to a resource associated with a time interval that begins after the end of the time interval associated with the context resource"
            }
            Self::IntervalContains => {
                "refers to a resource associated with a time interval that begins after the beginning of the time interval associated with the context resource, and ends before the end of the time interval associated with the context resource"
            }
            Self::IntervalDisjoint => {
                "refers to a resource associated with a time interval that begins after the end of the time interval associated with the context resource, or ends before the beginning of the time interval associated with the context resource"
            }
            Self::IntervalDuring => {
                "refers to a resource associated with a time interval that begins before the beginning of the time interval associated with the context resource, and ends after the end of the time interval associated with the context resource"
            }
            Self::IntervalEquals => {
                "refers to a resource associated with a time interval whose beginning coincides with the beginning of the time interval associated with the context resource, and whose end coincides with the end of the time interval associated with the context resource"
            }
            Self::IntervalFinishedBy => {
                "refers to a resource associated with a time interval that begins after the beginning of the time interval associated with the context resource, and whose end coincides with the end of the time interval associated with the context resource"
            }
            Self::IntervalFinishes => {
                "refers to a resource associated with a time interval that begins before the beginning of the time interval associated with the context resource, and whose end coincides with the end of the time interval associated with the context resource"
            }
            Self::IntervalIn => {
                "refers to a resource associated with a time interval that begins before or is coincident with the beginning of the time interval associated with the context resource, and ends after or is coincident with the end of the time interval associated with the context resource"
            }
            Self::IntervalMeets => {
                "refers to a resource associated with a time interval whose beginning coincides with the end of the time interval associated with the context resource"
            }
            Self::IntervalMetBy => {
                "refers to a resource associated with a time interval whose end coincides with the beginning of the time interval associated with the context resource"
            }
            Self::IntervalOverlappedBy => {
                "refers to a resource associated with a time interval that begins before the beginning of the time interval associated with the context resource, and ends after the beginning of the time interval associated with the context resource"
            }
            Self::IntervalOverlaps => {
                "refers to a resource associated with a time interval that begins before the end of the time interval associated with the context resource, and ends after the end of the time interval associated with the context resource"
            }
            Self::IntervalStartedBy => {
                "refers to a resource associated with a time interval whose beginning coincides with the beginning of the time interval associated with the context resource, and ends before the end of the time interval associated with the context resource"
            }
            Self::IntervalStarts => {
                "refers to a resource associated with a time interval whose beginning coincides with the beginning of the time interval associated with the context resource, and ends after the end of the time interval associated with the context resource"
            }
            Self::Item => {
                "The target IRI points to a resource that is a member of the collection represented by the context IRI."
            }
            Self::Last => {
                "An IRI that refers to the furthest following resource\n      in a series of resources."
            }
            Self::LatestVersion => {
                "Points to a resource containing the latest (e.g.,\n      current) version of the context."
            }
            Self::License => "Refers to a license associated with this context.",
            Self::Linkset => {
                "The link target of a link with the \"linkset\" relation\n      type provides a set of links, including links in which the link\n      context of the link participates.\n    "
            }
            Self::Lrdd => {
                "Refers to further information about the link's context,\n      expressed as a LRDD (\"Link-based Resource Descriptor Document\")\n      resource.  See  for information about\n      processing this relation type in host-meta documents. When used\n      elsewhere, it refers to additional links and other metadata.\n      Multiple instances indicate additional LRDD resources. LRDD\n      resources MUST have an \"application/xrd+xml\" representation, and\n      MAY have others."
            }
            Self::Manifest => "Links to a manifest file for the context.",
            Self::MaskIcon => {
                "Refers to a mask that can be applied to the icon for the context."
            }
            Self::MediaFeed => {
                "Refers to a feed of personalised media recommendations relevant to the link context."
            }
            Self::Memento => {
                "The Target IRI points to a Memento, a fixed resource that will not change state anymore."
            }
            Self::Micropub => "Links to the context's Micropub endpoint.",
            Self::Modulepreload => {
                "Refers to a module that the user agent is to preemptively fetch and store for use in the current context."
            }
            Self::Monitor => {
                "Refers to a resource that can be used to monitor changes in an HTTP resource.\n    "
            }
            Self::MonitorGroup => {
                "Refers to a resource that can be used to monitor changes in a specified group of HTTP resources.\n    "
            }
            Self::Next => {
                "Indicates that the link's context is a part of a series, and\n      that the next in the series is the link target.\n    "
            }
            Self::NextArchive => "Refers to the immediately following archive resource.",
            Self::Nofollow => {
                "Indicates that the context’s original author or publisher does not endorse the link target."
            }
            Self::Noopener => {
                "Indicates that any newly created top-level browsing context which results from following the link will not be an auxiliary browsing context."
            }
            Self::Noreferrer => {
                "Indicates that no referrer information is to be leaked when following the link."
            }
            Self::Opener => {
                "Indicates that any newly created top-level browsing context which results from following the link will be an auxiliary browsing context."
            }
            Self::Openid2LocalId => {
                "Refers to an OpenID Authentication server on which the context relies for an assertion that the end user controls an Identifier."
            }
            Self::Openid2Provider => {
                "Refers to a resource which accepts OpenID Authentication protocol messages for the context."
            }
            Self::Original => "The Target IRI points to an Original Resource.",
            Self::Payment => "Indicates a resource where payment is accepted.",
            Self::Pingback => {
                "Gives the address of the pingback resource for the link context."
            }
            Self::Preconnect => {
                "Used to indicate an origin that will be used to fetch required \n      resources for the link context. Initiating an early connection, which \n      includes the DNS lookup, TCP handshake, and optional TLS negotiation, \n      allows the user agent to mask the high latency costs of establishing a \n      connection."
            }
            Self::PredecessorVersion => {
                "Points to a resource containing the predecessor\n      version in the version history.\n    "
            }
            Self::Prefetch => {
                "The prefetch link relation type is used to identify a resource \n      that might be required by the next navigation from the link context, and \n      that the user agent ought to fetch, such that the user agent can deliver a \n      faster response once the resource is requested in the future."
            }
            Self::Preload => {
                "Refers to a resource that should be loaded early in the \n      processing of the link's context, without blocking rendering."
            }
            Self::Prerender => {
                "Used to identify a resource that might be required by the next \n      navigation from the link context, and that the user agent ought to fetch \n      and execute, such that the user agent can deliver a faster response once \n      the resource is requested in the future."
            }
            Self::Prev => {
                "Indicates that the link's context is a part of a series, and\n      that the previous in the series is the link target.\n    "
            }
            Self::PrevArchive => "Refers to the immediately preceding archive resource.",
            Self::Preview => {
                "Refers to a resource that provides a preview of the link's context."
            }
            Self::Previous => {
                "Refers to the previous resource in an ordered series\n      of resources.  Synonym for \"prev\"."
            }
            Self::PrivacyPolicy => {
                "Refers to a privacy policy associated with the link's context."
            }
            Self::Profile => {
                "Identifying that a resource representation conforms\nto a certain profile, without affecting the non-profile semantics\nof the resource representation."
            }
            Self::Publication => {
                "Links to a publication manifest. A manifest represents \n      structured information about a publication, such as informative metadata, \n      a list of resources, and a default reading order."
            }
            Self::Related => "Identifies a related resource.",
            Self::Replies => {
                "Identifies a resource that is a reply to the context\n      of the link.\n    "
            }
            Self::Restconf => {
                "Identifies the root of RESTCONF API as configured on this HTTP server.\n      The \"restconf\" relation defines the root of the API defined in RFC8040.\n      Subsequent revisions of RESTCONF will use alternate relation values to support \n      protocol versioning."
            }
            Self::Ruleinput => {
                "The resource identified by the link target provides an input value to an \n    instance of a rule, where the resource which represents the rule instance is \n    identified by the link context.\n    "
            }
            Self::Search => {
                "Refers to a resource that can be used to search through\n      the link's context and related resources."
            }
            Self::Section => "Refers to a section in a collection of resources.",
            Self::_Self => "Conveys an identifier for the link's context.\n    ",
            Self::Service => {
                "Indicates a URI that can be used to retrieve a\n      service document."
            }
            Self::ServiceDesc => {
                "Identifies service description for the context that\n      is primarily intended for consumption by machines."
            }
            Self::ServiceDoc => {
                "Identifies service documentation for the context that\n      is primarily intended for human consumption."
            }
            Self::ServiceMeta => {
                "Identifies general metadata for the context that is\n      primarily intended for consumption by machines."
            }
            Self::Sponsored => {
                "Refers to a resource that is within a context that is \n\t\tsponsored (such as advertising or another compensation agreement)."
            }
            Self::Start => {
                "Refers to the first resource in a collection of\n      resources."
            }
            Self::Status => {
                "Identifies a resource that represents the context's\n      status."
            }
            Self::Stylesheet => "Refers to a stylesheet.",
            Self::Subsection => {
                "Refers to a resource serving as a subsection in a\n      collection of resources."
            }
            Self::SuccessorVersion => {
                "Points to a resource containing the successor version\n      in the version history.\n    "
            }
            Self::Sunset => {
                "Identifies a resource that provides information about\n      the context's retirement policy.\n    "
            }
            Self::Tag => {
                "Gives a tag (identified by the given address) that applies to\n      the current document.\n    "
            }
            Self::TermsOfService => {
                "Refers to the terms of service associated with the link's context."
            }
            Self::Timegate => {
                "The Target IRI points to a TimeGate for an Original Resource."
            }
            Self::Timemap => {
                "The Target IRI points to a TimeMap for an Original Resource."
            }
            Self::Type => {
                "Refers to a resource identifying the abstract semantic type of which the link's context is considered to be an instance."
            }
            Self::Ugc => {
                "Refers to a resource that is within a context that is User Generated Content.\n    "
            }
            Self::Up => {
                "Refers to a parent document in a hierarchy of\n      documents.\n    "
            }
            Self::VersionHistory => {
                "Points to a resource containing the version history\n      for the context.\n    "
            }
            Self::Via => {
                "Identifies a resource that is the source of the\n      information in the link's context.\n    "
            }
            Self::Webmention => {
                "Identifies a target URI that supports the Webmention protocol.\n    This allows clients that mention a resource in some form of publishing process\n    to contact that endpoint and inform it that this resource has been mentioned."
            }
            Self::WorkingCopy => "Points to a working copy for this resource.",
            Self::WorkingCopyOf => {
                "Points to the versioned resource from which this\n      working copy was obtained.\n    "
            }
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for LinkRelationTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LinkRelationTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LinkRelationTypes> for Coding {
    fn from(code: LinkRelationTypes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/CodeSystem/iana-link-relations".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<LinkRelationTypes> for CodeableConcept {
    fn from(code: LinkRelationTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[LinkType](http://hl7.org/fhir/ValueSet/link-type)**. The type of link between this Patient resource and other Patient/RelatedPerson resource(s).\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LinkType {
    /** **refer**

Refer. The patient resource containing this link is in use and valid but not considered the main source of information about a patient. The link points forward to another patient resource that should be consulted to retrieve additional patient information. */
    Refer,
    /** **replaced-by**

Replaced-by. The patient resource containing this link must no longer be used. The link points forward to another patient resource that must be used in lieu of the patient resource that contains this link. */
    ReplacedBy,
    /** **replaces**

Replaces. The patient resource containing this link is the current active patient record. The link points back to an inactive patient resource that has been merged into this resource, and should be consulted to retrieve additional referenced information. */
    Replaces,
    /** **seealso**

See also. The patient resource containing this link is in use and valid, but points to another Patient or RelatedPerson resource that is known to contain data about the same person. Data in this resource might overlap or contradict information found in the other Patient/RelatedPerson resource. This link does not indicate any relative importance of the resources concerned, and both should be regarded as equally valid. */
    Seealso,
}
impl ::core::str::FromStr for LinkType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "refer" => Ok(Self::Refer),
            "replaced-by" => Ok(Self::ReplacedBy),
            "replaces" => Ok(Self::Replaces),
            "seealso" => Ok(Self::Seealso),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LinkType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Refer => "refer",
            Self::ReplacedBy => "replaced-by",
            Self::Replaces => "replaces",
            Self::Seealso => "seealso",
        }
    }
}
impl ::std::fmt::Display for LinkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Refer => "Refer",
            Self::ReplacedBy => "Replaced-by",
            Self::Replaces => "Replaces",
            Self::Seealso => "See also",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for LinkType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LinkType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LinkType> for Coding {
    fn from(code: LinkType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/link-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<LinkType> for CodeableConcept {
    fn from(code: LinkType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[LinkageType](http://hl7.org/fhir/ValueSet/linkage-type)**. Used to distinguish different roles a resource can play within a set of linked resources.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LinkageType {
    /** **alternate**

Alternate Record. The resource represents an alternative view of the underlying event/condition/etc.  The resource may still be actively maintained, even though it is not considered to be the source of truth. */
    Alternate,
    /** **historical**

Historical/Obsolete Record. The resource represents an obsolete record of the underlying event/condition/etc.  It is not expected to be actively maintained. */
    Historical,
    /** **source**

Source of Truth. The resource represents the "source of truth" (from the perspective of this Linkage resource) for the underlying event/condition/etc. */
    Source,
}
impl ::core::str::FromStr for LinkageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alternate" => Ok(Self::Alternate),
            "historical" => Ok(Self::Historical),
            "source" => Ok(Self::Source),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LinkageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alternate => "alternate",
            Self::Historical => "historical",
            Self::Source => "source",
        }
    }
}
impl ::std::fmt::Display for LinkageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Alternate => "Alternate Record",
            Self::Historical => "Historical/Obsolete Record",
            Self::Source => "Source of Truth",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for LinkageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LinkageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LinkageType> for Coding {
    fn from(code: LinkageType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/linkage-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<LinkageType> for CodeableConcept {
    fn from(code: LinkageType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ListMode](http://hl7.org/fhir/ValueSet/list-mode)**. The processing mode that applies to this list.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ListMode {
    /** **changes**

Change List. A point-in-time list that shows what changes have been made or recommended.  E.g. a discharge medication list showing what was added and removed during an encounter. */
    Changes,
    /** **snapshot**

Snapshot List. This list was prepared as a snapshot. It should not be assumed to be current. */
    Snapshot,
    /** **working**

Working List. This list is the master list, maintained in an ongoing fashion with regular updates as the real-world list it is tracking changes. */
    Working,
}
impl ::core::str::FromStr for ListMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "changes" => Ok(Self::Changes),
            "snapshot" => Ok(Self::Snapshot),
            "working" => Ok(Self::Working),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Changes => "changes",
            Self::Snapshot => "snapshot",
            Self::Working => "working",
        }
    }
}
impl ::std::fmt::Display for ListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Changes => "Change List",
            Self::Snapshot => "Snapshot List",
            Self::Working => "Working List",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ListMode> for Coding {
    fn from(code: ListMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/list-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ListMode> for CodeableConcept {
    fn from(code: ListMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ListStatus](http://hl7.org/fhir/ValueSet/list-status)**. The current state of the list.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ListStatus {
    /** **current**

Current. The list is considered to be an active part of the patient's record. */
    Current,
    /** **entered-in-error**

Entered In Error. The list was never accurate.  It is retained for medico-legal purposes only. */
    EnteredInError,
    /** **retired**

Retired. The list is "old" and should no longer be considered accurate or relevant. */
    Retired,
}
impl ::core::str::FromStr for ListStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "current" => Ok(Self::Current),
            "entered-in-error" => Ok(Self::EnteredInError),
            "retired" => Ok(Self::Retired),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ListStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Current => "current",
            Self::EnteredInError => "entered-in-error",
            Self::Retired => "retired",
        }
    }
}
impl ::std::fmt::Display for ListStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Current => "Current",
            Self::EnteredInError => "Entered In Error",
            Self::Retired => "Retired",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ListStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ListStatus> for Coding {
    fn from(code: ListStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/list-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ListStatus> for CodeableConcept {
    fn from(code: ListStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[LocationCharacteristic](http://hl7.org/fhir/ValueSet/location-characteristic)**. Example Set of Location Characteristics.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LocationCharacteristic {
    /** **has-icu**

has ICU. The location is or has an intensive care unit */
    HasIcu,
    /** **has-iso-ward**

isolation ward. The location is or has an isolation ward */
    HasIsoWard,
    /** **has-neg-press**

negative pressure rooms available. The location has negative pressure rooms available */
    HasNegPress,
    /** **has-oxy-nitro**

oxygen/nitrogen available. The location has oxygen and nitrogen services available */
    HasOxyNitro,
    /** **has-translation**

translation services available. The location has translation services available */
    HasTranslation,
    /** **wheelchair**

Wheelchair accessible. The location is accessible to thosre requiring wheelchair access */
    Wheelchair,
}
impl ::core::str::FromStr for LocationCharacteristic {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "has-icu" => Ok(Self::HasIcu),
            "has-iso-ward" => Ok(Self::HasIsoWard),
            "has-neg-press" => Ok(Self::HasNegPress),
            "has-oxy-nitro" => Ok(Self::HasOxyNitro),
            "has-translation" => Ok(Self::HasTranslation),
            "wheelchair" => Ok(Self::Wheelchair),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationCharacteristic {
    fn as_ref(&self) -> &str {
        match self {
            Self::HasIcu => "has-icu",
            Self::HasIsoWard => "has-iso-ward",
            Self::HasNegPress => "has-neg-press",
            Self::HasOxyNitro => "has-oxy-nitro",
            Self::HasTranslation => "has-translation",
            Self::Wheelchair => "wheelchair",
        }
    }
}
impl ::std::fmt::Display for LocationCharacteristic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::HasIcu => "has ICU",
            Self::HasIsoWard => "isolation ward",
            Self::HasNegPress => "negative pressure rooms available",
            Self::HasOxyNitro => "oxygen/nitrogen available",
            Self::HasTranslation => "translation services available",
            Self::Wheelchair => "Wheelchair accessible",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for LocationCharacteristic {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationCharacteristic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LocationCharacteristic> for Coding {
    fn from(code: LocationCharacteristic) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/location-characteristic".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<LocationCharacteristic> for CodeableConcept {
    fn from(code: LocationCharacteristic) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[LocationMode](http://hl7.org/fhir/ValueSet/location-mode)**. Indicates whether a resource instance represents a specific location or a class of locations.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LocationMode {
    /** **instance**

Instance. The Location resource represents a specific instance of a location (e.g. Operating Theatre 1A). */
    Instance,
    /** **kind**

Kind. The Location represents a class of locations (e.g. Any Operating Theatre) although this class of locations could be constrained within a specific boundary (such as organization, or parent location, address etc.). */
    Kind,
}
impl ::core::str::FromStr for LocationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "instance" => Ok(Self::Instance),
            "kind" => Ok(Self::Kind),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Instance => "instance",
            Self::Kind => "kind",
        }
    }
}
impl ::std::fmt::Display for LocationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Instance => "Instance",
            Self::Kind => "Kind",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for LocationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LocationMode> for Coding {
    fn from(code: LocationMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/location-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<LocationMode> for CodeableConcept {
    fn from(code: LocationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[LocationStatus](http://hl7.org/fhir/ValueSet/location-status)**. Indicates whether the location is still in use.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LocationStatus {
    /** **active**

Active. The location is operational. */
    Active,
    /** **inactive**

Inactive. The location is no longer used. */
    Inactive,
    /** **suspended**

Suspended. The location is temporarily closed. */
    Suspended,
}
impl ::core::str::FromStr for LocationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Suspended => "suspended",
        }
    }
}
impl ::std::fmt::Display for LocationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Inactive => "Inactive",
            Self::Suspended => "Suspended",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for LocationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<LocationStatus> for Coding {
    fn from(code: LocationStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/location-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<LocationStatus> for CodeableConcept {
    fn from(code: LocationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ManufacturedDoseForm](http://hl7.org/fhir/ValueSet/manufactured-dose-form)**. Dose form for a medication, as manufactured (and before any mixing etc.), not necessarily ready for administration to the patient.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ManufacturedDoseForm {
    /** **100000073362**

Oral suspension. */
    N100000073362,
    /** **100000073363**

Oral gel. */
    N100000073363,
    /** **100000073364**

Powder for oral solution. */
    N100000073364,
    /** **100000073365**

Granules for oral solution. */
    N100000073365,
    /** **100000073367**

Lyophilisate for suspension. */
    N100000073367,
    /** **100000073368**

Powder for syrup. */
    N100000073368,
    /** **100000073369**

Soluble tablet. */
    N100000073369,
    /** **100000073370**

Herbal tea. */
    N100000073370,
    /** **100000073371**

Instant herbal tea. */
    N100000073371,
    /** **100000073372**

Granules. */
    N100000073372,
    /** **100000073373**

Gastro-resistant granules. */
    N100000073373,
    /** **100000073374**

Modified-release granules. */
    N100000073374,
    /** **100000073375**

Capsule, hard. */
    N100000073375,
    /** **100000073376**

Gastro-resistant capsule, hard. */
    N100000073376,
    /** **100000073377**

Chewable capsule, soft. */
    N100000073377,
    /** **100000073378**

Prolonged-release capsule, soft. */
    N100000073378,
    /** **100000073379**

Modified-release capsule, soft. */
    N100000073379,
    /** **100000073380**

Coated tablet. */
    N100000073380,
    /** **100000073642**

Oral drops, solution. */
    N100000073642,
    /** **100000073643**

Oral drops, suspension. */
    N100000073643,
    /** **100000073644**

Oral drops, emulsion. */
    N100000073644,
    /** **100000073645**

Oral liquid. */
    N100000073645,
    /** **100000073646**

Oral solution. */
    N100000073646,
    /** **100000073647**

Oral emulsion. */
    N100000073647,
    /** **100000073648**

Oral paste. */
    N100000073648,
    /** **100000073649**

Powder for oral suspension. */
    N100000073649,
    /** **100000073650**

Granules for oral suspension. */
    N100000073650,
    /** **100000073652**

Syrup. */
    N100000073652,
    /** **100000073653**

Granules for syrup. */
    N100000073653,
    /** **100000073654**

Dispersible tablet. */
    N100000073654,
    /** **100000073655**

Oral powder. */
    N100000073655,
    /** **100000073656**

Effervescent powder. */
    N100000073656,
    /** **100000073657**

Effervescent granules. */
    N100000073657,
    /** **100000073658**

Prolonged-release granules. */
    N100000073658,
    /** **100000073659**

Cachet. */
    N100000073659,
    /** **100000073660**

Capsule, soft. */
    N100000073660,
    /** **100000073661**

Gastro-resistant capsule, soft. */
    N100000073661,
    /** **100000073662**

Prolonged-release capsule, hard. */
    N100000073662,
    /** **100000073663**

Modified-release capsule, hard. */
    N100000073663,
    /** **100000073664**

Tablet. */
    N100000073664,
    /** **100000073665**

Film-coated tablet. */
    N100000073665,
    /** **100000073666**

Orodispersible tablet. */
    N100000073666,
    /** **100000073667**

Gastro-resistant tablet. */
    N100000073667,
    /** **100000073668**

Modified-release tablet. */
    N100000073668,
    /** **100000073669**

Medicated chewing-gum. */
    N100000073669,
    /** **100000073670**

Pillules. */
    N100000073670,
    /** **100000073671**

Pulsatile-release intraruminal device. */
    N100000073671,
    /** **100000073672**

Premix for medicated feeding stuff. */
    N100000073672,
    /** **100000073673**

Gargle. */
    N100000073673,
    /** **100000073674**

Gargle, powder for solution. */
    N100000073674,
    /** **100000073675**

Oromucosal suspension. */
    N100000073675,
    /** **100000073676**

Oromucosal spray. */
    N100000073676,
    /** **100000073677**

Mouthwash. */
    N100000073677,
    /** **100000073678**

Gingival solution. */
    N100000073678,
    /** **100000073679**

Oromucosal paste. */
    N100000073679,
    /** **100000073680**

Gingival gel. */
    N100000073680,
    /** **100000073681**

Effervescent tablet. */
    N100000073681,
    /** **100000073682**

Oral lyophilisate. */
    N100000073682,
    /** **100000073683**

Prolonged-release tablet. */
    N100000073683,
    /** **100000073684**

Chewable tablet. */
    N100000073684,
    /** **100000073685**

Oral gum. */
    N100000073685,
    /** **100000073686**

Continuous-release intraruminal device. */
    N100000073686,
    /** **100000073687**

Lick block. */
    N100000073687,
    /** **100000073688**

Medicated pellets. */
    N100000073688,
    /** **100000073689**

Concentrate for gargle. */
    N100000073689,
    /** **100000073690**

Gargle, tablet for solution. */
    N100000073690,
    /** **100000073691**

Oromucosal solution. */
    N100000073691,
    /** **100000073692**

Oromucosal drops. */
    N100000073692,
    /** **100000073693**

Sublingual spray. */
    N100000073693,
    /** **100000073694**

Mouthwash, tablet for solution. */
    N100000073694,
    /** **100000073695**

Oromucosal gel. */
    N100000073695,
    /** **100000073696**

Oromucosal cream. */
    N100000073696,
    /** **100000073697**

Gingival paste. */
    N100000073697,
    /** **100000073698**

Sublingual tablet. */
    N100000073698,
    /** **100000073699**

Buccal tablet. */
    N100000073699,
    /** **100000073700**

Compressed lozenge. */
    N100000073700,
    /** **100000073701**

Oromucosal capsule. */
    N100000073701,
    /** **100000073702**

Muco-adhesive buccal tablet. */
    N100000073702,
    /** **100000073703**

Lozenge. */
    N100000073703,
    /** **100000073704**

Pastille. */
    N100000073704,
    /** **100000073705**

Dental gel. */
    N100000073705,
    /** **100000073706**

Dental insert. */
    N100000073706,
    /** **100000073707**

Dental powder. */
    N100000073707,
    /** **100000073708**

Dental suspension. */
    N100000073708,
    /** **100000073709**

Toothpaste. */
    N100000073709,
    /** **100000073710**

Periodontal gel. */
    N100000073710,
    /** **100000073711**

Bath additive. */
    N100000073711,
    /** **100000073712**

Cream. */
    N100000073712,
    /** **100000073713**

Ointment. */
    N100000073713,
    /** **100000073714**

Medicated plaster. */
    N100000073714,
    /** **100000073715**

Shampoo. */
    N100000073715,
    /** **100000073716**

Cutaneous spray, suspension. */
    N100000073716,
    /** **100000073717**

Cutaneous liquid. */
    N100000073717,
    /** **100000073718**

Concentrate for cutaneous solution. */
    N100000073718,
    /** **100000073719**

Cutaneous emulsion. */
    N100000073719,
    /** **100000073720**

Cutaneous patch. */
    N100000073720,
    /** **100000073721**

Periodontal powder. */
    N100000073721,
    /** **100000073722**

Dental stick. */
    N100000073722,
    /** **100000073723**

Dental solution. */
    N100000073723,
    /** **100000073724**

Dental emulsion. */
    N100000073724,
    /** **100000073725**

Periodontal insert. */
    N100000073725,
    /** **100000073726**

Gel. */
    N100000073726,
    /** **100000073727**

Cutaneous paste. */
    N100000073727,
    /** **100000073728**

Cutaneous foam. */
    N100000073728,
    /** **100000073729**

Cutaneous spray, solution. */
    N100000073729,
    /** **100000073730**

Cutaneous spray, powder. */
    N100000073730,
    /** **100000073731**

Cutaneous solution. */
    N100000073731,
    /** **100000073732**

Cutaneous suspension. */
    N100000073732,
    /** **100000073733**

Cutaneous powder. */
    N100000073733,
    /** **100000073734**

Solution for iontophoresis. */
    N100000073734,
    /** **100000073735**

Collodion. */
    N100000073735,
    /** **100000073736**

Poultice. */
    N100000073736,
    /** **100000073737**

Cutaneous sponge. */
    N100000073737,
    /** **100000073738**

Collar. */
    N100000073738,
    /** **100000073739**

Ear tag. */
    N100000073739,
    /** **100000073740**

Dip suspension. */
    N100000073740,
    /** **100000073741**

Transdermal patch. */
    N100000073741,
    /** **100000073742**

Medicated nail lacquer. */
    N100000073742,
    /** **100000073743**

Cutaneous stick. */
    N100000073743,
    /** **100000073744**

Impregnated dressing. */
    N100000073744,
    /** **100000073745**

Medicated pendant. */
    N100000073745,
    /** **100000073746**

Dip solution. */
    N100000073746,
    /** **100000073747**

Dip emulsion. */
    N100000073747,
    /** **100000073748**

Concentrate for dip suspension. */
    N100000073748,
    /** **100000073749**

Powder for dip solution. */
    N100000073749,
    /** **100000073750**

Powder for suspension for fish treatment. */
    N100000073750,
    /** **100000073751**

Pour-on suspension. */
    N100000073751,
    /** **100000073752**

Spot-on solution. */
    N100000073752,
    /** **100000073753**

Spot-on emulsion. */
    N100000073753,
    /** **100000073754**

Teat dip suspension. */
    N100000073754,
    /** **100000073755**

Teat spray solution. */
    N100000073755,
    /** **100000073756**

Solution for skin-prick test. */
    N100000073756,
    /** **100000073757**

Plaster for provocation test. */
    N100000073757,
    /** **100000073758**

Eye gel. */
    N100000073758,
    /** **100000073759**

Eye drops, solution. */
    N100000073759,
    /** **100000073760**

Eye drops, suspension. */
    N100000073760,
    /** **100000073761**

Concentrate for dip solution. */
    N100000073761,
    /** **100000073762**

Concentrate for dip emulsion. */
    N100000073762,
    /** **100000073763**

Concentrate for solution for fish treatment. */
    N100000073763,
    /** **100000073764**

Pour-on solution. */
    N100000073764,
    /** **100000073765**

Pour-on emulsion. */
    N100000073765,
    /** **100000073766**

Spot-on suspension. */
    N100000073766,
    /** **100000073767**

Teat dip solution. */
    N100000073767,
    /** **100000073768**

Teat dip emulsion. */
    N100000073768,
    /** **100000073769**

Transdermal system. */
    N100000073769,
    /** **100000073770**

Solution for skin-scratch test. */
    N100000073770,
    /** **100000073771**

Eye cream. */
    N100000073771,
    /** **100000073772**

Eye ointment. */
    N100000073772,
    /** **100000073773**

Eye drops, emulsion. */
    N100000073773,
    /** **100000073775**

Eye drops, solvent for reconstitution. */
    N100000073775,
    /** **100000073776**

Eye lotion. */
    N100000073776,
    /** **100000073777**

Ophthalmic insert. */
    N100000073777,
    /** **100000073778**

Ear cream. */
    N100000073778,
    /** **100000073779**

Ear ointment. */
    N100000073779,
    /** **100000073780**

Ear drops, suspension. */
    N100000073780,
    /** **100000073782**

Eye drops, prolonged-release. */
    N100000073782,
    /** **100000073783**

Eye lotion, solvent for reconstitution. */
    N100000073783,
    /** **100000073784**

Ophthalmic strip. */
    N100000073784,
    /** **100000073785**

Ear gel. */
    N100000073785,
    /** **100000073786**

Ear drops, solution. */
    N100000073786,
    /** **100000073787**

Ear drops, emulsion. */
    N100000073787,
    /** **100000073788**

Ear powder. */
    N100000073788,
    /** **100000073789**

Ear spray, suspension. */
    N100000073789,
    /** **100000073790**

Ear wash, solution. */
    N100000073790,
    /** **100000073791**

Ear tampon. */
    N100000073791,
    /** **100000073792**

Nasal cream. */
    N100000073792,
    /** **100000073793**

Nasal gel. */
    N100000073793,
    /** **100000073794**

Nasal drops, solution. */
    N100000073794,
    /** **100000073795**

Nasal drops, emulsion. */
    N100000073795,
    /** **100000073796**

Nasal spray, solution. */
    N100000073796,
    /** **100000073797**

Nasal spray, emulsion. */
    N100000073797,
    /** **100000073798**

Nasal stick. */
    N100000073798,
    /** **100000073799**

Vaginal gel. */
    N100000073799,
    /** **100000073800**

Vaginal foam. */
    N100000073800,
    /** **100000073802**

Ear spray, solution. */
    N100000073802,
    /** **100000073803**

Ear spray, emulsion. */
    N100000073803,
    /** **100000073804**

Ear wash, emulsion. */
    N100000073804,
    /** **100000073805**

Ear stick. */
    N100000073805,
    /** **100000073806**

Nasal ointment. */
    N100000073806,
    /** **100000073807**

Nasal drops, suspension. */
    N100000073807,
    /** **100000073808**

Nasal powder. */
    N100000073808,
    /** **100000073809**

Nasal spray, suspension. */
    N100000073809,
    /** **100000073810**

Nasal wash. */
    N100000073810,
    /** **100000073811**

Vaginal cream. */
    N100000073811,
    /** **100000073812**

Vaginal ointment. */
    N100000073812,
    /** **100000073813**

Vaginal solution. */
    N100000073813,
    /** **100000073814**

Vaginal emulsion. */
    N100000073814,
    /** **100000073815**

Pessary. */
    N100000073815,
    /** **100000073816**

Vaginal capsule, soft. */
    N100000073816,
    /** **100000073817**

Effervescent vaginal tablet. */
    N100000073817,
    /** **100000073818**

Vaginal delivery system. */
    N100000073818,
    /** **100000073819**

Rectal cream. */
    N100000073819,
    /** **100000073820**

Rectal foam. */
    N100000073820,
    /** **100000073821**

Vaginal suspension. */
    N100000073821,
    /** **100000073822**

Tablet for vaginal solution. */
    N100000073822,
    /** **100000073823**

Vaginal capsule, hard. */
    N100000073823,
    /** **100000073824**

Vaginal tablet. */
    N100000073824,
    /** **100000073825**

Medicated vaginal tampon. */
    N100000073825,
    /** **100000073826**

Vaginal sponge. */
    N100000073826,
    /** **100000073827**

Rectal gel. */
    N100000073827,
    /** **100000073863**

Solution for injection. */
    N100000073863,
}
impl ::core::str::FromStr for ManufacturedDoseForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073362" => Ok(Self::N100000073362),
            "100000073363" => Ok(Self::N100000073363),
            "100000073364" => Ok(Self::N100000073364),
            "100000073365" => Ok(Self::N100000073365),
            "100000073367" => Ok(Self::N100000073367),
            "100000073368" => Ok(Self::N100000073368),
            "100000073369" => Ok(Self::N100000073369),
            "100000073370" => Ok(Self::N100000073370),
            "100000073371" => Ok(Self::N100000073371),
            "100000073372" => Ok(Self::N100000073372),
            "100000073373" => Ok(Self::N100000073373),
            "100000073374" => Ok(Self::N100000073374),
            "100000073375" => Ok(Self::N100000073375),
            "100000073376" => Ok(Self::N100000073376),
            "100000073377" => Ok(Self::N100000073377),
            "100000073378" => Ok(Self::N100000073378),
            "100000073379" => Ok(Self::N100000073379),
            "100000073380" => Ok(Self::N100000073380),
            "100000073642" => Ok(Self::N100000073642),
            "100000073643" => Ok(Self::N100000073643),
            "100000073644" => Ok(Self::N100000073644),
            "100000073645" => Ok(Self::N100000073645),
            "100000073646" => Ok(Self::N100000073646),
            "100000073647" => Ok(Self::N100000073647),
            "100000073648" => Ok(Self::N100000073648),
            "100000073649" => Ok(Self::N100000073649),
            "100000073650" => Ok(Self::N100000073650),
            "100000073652" => Ok(Self::N100000073652),
            "100000073653" => Ok(Self::N100000073653),
            "100000073654" => Ok(Self::N100000073654),
            "100000073655" => Ok(Self::N100000073655),
            "100000073656" => Ok(Self::N100000073656),
            "100000073657" => Ok(Self::N100000073657),
            "100000073658" => Ok(Self::N100000073658),
            "100000073659" => Ok(Self::N100000073659),
            "100000073660" => Ok(Self::N100000073660),
            "100000073661" => Ok(Self::N100000073661),
            "100000073662" => Ok(Self::N100000073662),
            "100000073663" => Ok(Self::N100000073663),
            "100000073664" => Ok(Self::N100000073664),
            "100000073665" => Ok(Self::N100000073665),
            "100000073666" => Ok(Self::N100000073666),
            "100000073667" => Ok(Self::N100000073667),
            "100000073668" => Ok(Self::N100000073668),
            "100000073669" => Ok(Self::N100000073669),
            "100000073670" => Ok(Self::N100000073670),
            "100000073671" => Ok(Self::N100000073671),
            "100000073672" => Ok(Self::N100000073672),
            "100000073673" => Ok(Self::N100000073673),
            "100000073674" => Ok(Self::N100000073674),
            "100000073675" => Ok(Self::N100000073675),
            "100000073676" => Ok(Self::N100000073676),
            "100000073677" => Ok(Self::N100000073677),
            "100000073678" => Ok(Self::N100000073678),
            "100000073679" => Ok(Self::N100000073679),
            "100000073680" => Ok(Self::N100000073680),
            "100000073681" => Ok(Self::N100000073681),
            "100000073682" => Ok(Self::N100000073682),
            "100000073683" => Ok(Self::N100000073683),
            "100000073684" => Ok(Self::N100000073684),
            "100000073685" => Ok(Self::N100000073685),
            "100000073686" => Ok(Self::N100000073686),
            "100000073687" => Ok(Self::N100000073687),
            "100000073688" => Ok(Self::N100000073688),
            "100000073689" => Ok(Self::N100000073689),
            "100000073690" => Ok(Self::N100000073690),
            "100000073691" => Ok(Self::N100000073691),
            "100000073692" => Ok(Self::N100000073692),
            "100000073693" => Ok(Self::N100000073693),
            "100000073694" => Ok(Self::N100000073694),
            "100000073695" => Ok(Self::N100000073695),
            "100000073696" => Ok(Self::N100000073696),
            "100000073697" => Ok(Self::N100000073697),
            "100000073698" => Ok(Self::N100000073698),
            "100000073699" => Ok(Self::N100000073699),
            "100000073700" => Ok(Self::N100000073700),
            "100000073701" => Ok(Self::N100000073701),
            "100000073702" => Ok(Self::N100000073702),
            "100000073703" => Ok(Self::N100000073703),
            "100000073704" => Ok(Self::N100000073704),
            "100000073705" => Ok(Self::N100000073705),
            "100000073706" => Ok(Self::N100000073706),
            "100000073707" => Ok(Self::N100000073707),
            "100000073708" => Ok(Self::N100000073708),
            "100000073709" => Ok(Self::N100000073709),
            "100000073710" => Ok(Self::N100000073710),
            "100000073711" => Ok(Self::N100000073711),
            "100000073712" => Ok(Self::N100000073712),
            "100000073713" => Ok(Self::N100000073713),
            "100000073714" => Ok(Self::N100000073714),
            "100000073715" => Ok(Self::N100000073715),
            "100000073716" => Ok(Self::N100000073716),
            "100000073717" => Ok(Self::N100000073717),
            "100000073718" => Ok(Self::N100000073718),
            "100000073719" => Ok(Self::N100000073719),
            "100000073720" => Ok(Self::N100000073720),
            "100000073721" => Ok(Self::N100000073721),
            "100000073722" => Ok(Self::N100000073722),
            "100000073723" => Ok(Self::N100000073723),
            "100000073724" => Ok(Self::N100000073724),
            "100000073725" => Ok(Self::N100000073725),
            "100000073726" => Ok(Self::N100000073726),
            "100000073727" => Ok(Self::N100000073727),
            "100000073728" => Ok(Self::N100000073728),
            "100000073729" => Ok(Self::N100000073729),
            "100000073730" => Ok(Self::N100000073730),
            "100000073731" => Ok(Self::N100000073731),
            "100000073732" => Ok(Self::N100000073732),
            "100000073733" => Ok(Self::N100000073733),
            "100000073734" => Ok(Self::N100000073734),
            "100000073735" => Ok(Self::N100000073735),
            "100000073736" => Ok(Self::N100000073736),
            "100000073737" => Ok(Self::N100000073737),
            "100000073738" => Ok(Self::N100000073738),
            "100000073739" => Ok(Self::N100000073739),
            "100000073740" => Ok(Self::N100000073740),
            "100000073741" => Ok(Self::N100000073741),
            "100000073742" => Ok(Self::N100000073742),
            "100000073743" => Ok(Self::N100000073743),
            "100000073744" => Ok(Self::N100000073744),
            "100000073745" => Ok(Self::N100000073745),
            "100000073746" => Ok(Self::N100000073746),
            "100000073747" => Ok(Self::N100000073747),
            "100000073748" => Ok(Self::N100000073748),
            "100000073749" => Ok(Self::N100000073749),
            "100000073750" => Ok(Self::N100000073750),
            "100000073751" => Ok(Self::N100000073751),
            "100000073752" => Ok(Self::N100000073752),
            "100000073753" => Ok(Self::N100000073753),
            "100000073754" => Ok(Self::N100000073754),
            "100000073755" => Ok(Self::N100000073755),
            "100000073756" => Ok(Self::N100000073756),
            "100000073757" => Ok(Self::N100000073757),
            "100000073758" => Ok(Self::N100000073758),
            "100000073759" => Ok(Self::N100000073759),
            "100000073760" => Ok(Self::N100000073760),
            "100000073761" => Ok(Self::N100000073761),
            "100000073762" => Ok(Self::N100000073762),
            "100000073763" => Ok(Self::N100000073763),
            "100000073764" => Ok(Self::N100000073764),
            "100000073765" => Ok(Self::N100000073765),
            "100000073766" => Ok(Self::N100000073766),
            "100000073767" => Ok(Self::N100000073767),
            "100000073768" => Ok(Self::N100000073768),
            "100000073769" => Ok(Self::N100000073769),
            "100000073770" => Ok(Self::N100000073770),
            "100000073771" => Ok(Self::N100000073771),
            "100000073772" => Ok(Self::N100000073772),
            "100000073773" => Ok(Self::N100000073773),
            "100000073775" => Ok(Self::N100000073775),
            "100000073776" => Ok(Self::N100000073776),
            "100000073777" => Ok(Self::N100000073777),
            "100000073778" => Ok(Self::N100000073778),
            "100000073779" => Ok(Self::N100000073779),
            "100000073780" => Ok(Self::N100000073780),
            "100000073782" => Ok(Self::N100000073782),
            "100000073783" => Ok(Self::N100000073783),
            "100000073784" => Ok(Self::N100000073784),
            "100000073785" => Ok(Self::N100000073785),
            "100000073786" => Ok(Self::N100000073786),
            "100000073787" => Ok(Self::N100000073787),
            "100000073788" => Ok(Self::N100000073788),
            "100000073789" => Ok(Self::N100000073789),
            "100000073790" => Ok(Self::N100000073790),
            "100000073791" => Ok(Self::N100000073791),
            "100000073792" => Ok(Self::N100000073792),
            "100000073793" => Ok(Self::N100000073793),
            "100000073794" => Ok(Self::N100000073794),
            "100000073795" => Ok(Self::N100000073795),
            "100000073796" => Ok(Self::N100000073796),
            "100000073797" => Ok(Self::N100000073797),
            "100000073798" => Ok(Self::N100000073798),
            "100000073799" => Ok(Self::N100000073799),
            "100000073800" => Ok(Self::N100000073800),
            "100000073802" => Ok(Self::N100000073802),
            "100000073803" => Ok(Self::N100000073803),
            "100000073804" => Ok(Self::N100000073804),
            "100000073805" => Ok(Self::N100000073805),
            "100000073806" => Ok(Self::N100000073806),
            "100000073807" => Ok(Self::N100000073807),
            "100000073808" => Ok(Self::N100000073808),
            "100000073809" => Ok(Self::N100000073809),
            "100000073810" => Ok(Self::N100000073810),
            "100000073811" => Ok(Self::N100000073811),
            "100000073812" => Ok(Self::N100000073812),
            "100000073813" => Ok(Self::N100000073813),
            "100000073814" => Ok(Self::N100000073814),
            "100000073815" => Ok(Self::N100000073815),
            "100000073816" => Ok(Self::N100000073816),
            "100000073817" => Ok(Self::N100000073817),
            "100000073818" => Ok(Self::N100000073818),
            "100000073819" => Ok(Self::N100000073819),
            "100000073820" => Ok(Self::N100000073820),
            "100000073821" => Ok(Self::N100000073821),
            "100000073822" => Ok(Self::N100000073822),
            "100000073823" => Ok(Self::N100000073823),
            "100000073824" => Ok(Self::N100000073824),
            "100000073825" => Ok(Self::N100000073825),
            "100000073826" => Ok(Self::N100000073826),
            "100000073827" => Ok(Self::N100000073827),
            "100000073863" => Ok(Self::N100000073863),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ManufacturedDoseForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073362 => "100000073362",
            Self::N100000073363 => "100000073363",
            Self::N100000073364 => "100000073364",
            Self::N100000073365 => "100000073365",
            Self::N100000073367 => "100000073367",
            Self::N100000073368 => "100000073368",
            Self::N100000073369 => "100000073369",
            Self::N100000073370 => "100000073370",
            Self::N100000073371 => "100000073371",
            Self::N100000073372 => "100000073372",
            Self::N100000073373 => "100000073373",
            Self::N100000073374 => "100000073374",
            Self::N100000073375 => "100000073375",
            Self::N100000073376 => "100000073376",
            Self::N100000073377 => "100000073377",
            Self::N100000073378 => "100000073378",
            Self::N100000073379 => "100000073379",
            Self::N100000073380 => "100000073380",
            Self::N100000073642 => "100000073642",
            Self::N100000073643 => "100000073643",
            Self::N100000073644 => "100000073644",
            Self::N100000073645 => "100000073645",
            Self::N100000073646 => "100000073646",
            Self::N100000073647 => "100000073647",
            Self::N100000073648 => "100000073648",
            Self::N100000073649 => "100000073649",
            Self::N100000073650 => "100000073650",
            Self::N100000073652 => "100000073652",
            Self::N100000073653 => "100000073653",
            Self::N100000073654 => "100000073654",
            Self::N100000073655 => "100000073655",
            Self::N100000073656 => "100000073656",
            Self::N100000073657 => "100000073657",
            Self::N100000073658 => "100000073658",
            Self::N100000073659 => "100000073659",
            Self::N100000073660 => "100000073660",
            Self::N100000073661 => "100000073661",
            Self::N100000073662 => "100000073662",
            Self::N100000073663 => "100000073663",
            Self::N100000073664 => "100000073664",
            Self::N100000073665 => "100000073665",
            Self::N100000073666 => "100000073666",
            Self::N100000073667 => "100000073667",
            Self::N100000073668 => "100000073668",
            Self::N100000073669 => "100000073669",
            Self::N100000073670 => "100000073670",
            Self::N100000073671 => "100000073671",
            Self::N100000073672 => "100000073672",
            Self::N100000073673 => "100000073673",
            Self::N100000073674 => "100000073674",
            Self::N100000073675 => "100000073675",
            Self::N100000073676 => "100000073676",
            Self::N100000073677 => "100000073677",
            Self::N100000073678 => "100000073678",
            Self::N100000073679 => "100000073679",
            Self::N100000073680 => "100000073680",
            Self::N100000073681 => "100000073681",
            Self::N100000073682 => "100000073682",
            Self::N100000073683 => "100000073683",
            Self::N100000073684 => "100000073684",
            Self::N100000073685 => "100000073685",
            Self::N100000073686 => "100000073686",
            Self::N100000073687 => "100000073687",
            Self::N100000073688 => "100000073688",
            Self::N100000073689 => "100000073689",
            Self::N100000073690 => "100000073690",
            Self::N100000073691 => "100000073691",
            Self::N100000073692 => "100000073692",
            Self::N100000073693 => "100000073693",
            Self::N100000073694 => "100000073694",
            Self::N100000073695 => "100000073695",
            Self::N100000073696 => "100000073696",
            Self::N100000073697 => "100000073697",
            Self::N100000073698 => "100000073698",
            Self::N100000073699 => "100000073699",
            Self::N100000073700 => "100000073700",
            Self::N100000073701 => "100000073701",
            Self::N100000073702 => "100000073702",
            Self::N100000073703 => "100000073703",
            Self::N100000073704 => "100000073704",
            Self::N100000073705 => "100000073705",
            Self::N100000073706 => "100000073706",
            Self::N100000073707 => "100000073707",
            Self::N100000073708 => "100000073708",
            Self::N100000073709 => "100000073709",
            Self::N100000073710 => "100000073710",
            Self::N100000073711 => "100000073711",
            Self::N100000073712 => "100000073712",
            Self::N100000073713 => "100000073713",
            Self::N100000073714 => "100000073714",
            Self::N100000073715 => "100000073715",
            Self::N100000073716 => "100000073716",
            Self::N100000073717 => "100000073717",
            Self::N100000073718 => "100000073718",
            Self::N100000073719 => "100000073719",
            Self::N100000073720 => "100000073720",
            Self::N100000073721 => "100000073721",
            Self::N100000073722 => "100000073722",
            Self::N100000073723 => "100000073723",
            Self::N100000073724 => "100000073724",
            Self::N100000073725 => "100000073725",
            Self::N100000073726 => "100000073726",
            Self::N100000073727 => "100000073727",
            Self::N100000073728 => "100000073728",
            Self::N100000073729 => "100000073729",
            Self::N100000073730 => "100000073730",
            Self::N100000073731 => "100000073731",
            Self::N100000073732 => "100000073732",
            Self::N100000073733 => "100000073733",
            Self::N100000073734 => "100000073734",
            Self::N100000073735 => "100000073735",
            Self::N100000073736 => "100000073736",
            Self::N100000073737 => "100000073737",
            Self::N100000073738 => "100000073738",
            Self::N100000073739 => "100000073739",
            Self::N100000073740 => "100000073740",
            Self::N100000073741 => "100000073741",
            Self::N100000073742 => "100000073742",
            Self::N100000073743 => "100000073743",
            Self::N100000073744 => "100000073744",
            Self::N100000073745 => "100000073745",
            Self::N100000073746 => "100000073746",
            Self::N100000073747 => "100000073747",
            Self::N100000073748 => "100000073748",
            Self::N100000073749 => "100000073749",
            Self::N100000073750 => "100000073750",
            Self::N100000073751 => "100000073751",
            Self::N100000073752 => "100000073752",
            Self::N100000073753 => "100000073753",
            Self::N100000073754 => "100000073754",
            Self::N100000073755 => "100000073755",
            Self::N100000073756 => "100000073756",
            Self::N100000073757 => "100000073757",
            Self::N100000073758 => "100000073758",
            Self::N100000073759 => "100000073759",
            Self::N100000073760 => "100000073760",
            Self::N100000073761 => "100000073761",
            Self::N100000073762 => "100000073762",
            Self::N100000073763 => "100000073763",
            Self::N100000073764 => "100000073764",
            Self::N100000073765 => "100000073765",
            Self::N100000073766 => "100000073766",
            Self::N100000073767 => "100000073767",
            Self::N100000073768 => "100000073768",
            Self::N100000073769 => "100000073769",
            Self::N100000073770 => "100000073770",
            Self::N100000073771 => "100000073771",
            Self::N100000073772 => "100000073772",
            Self::N100000073773 => "100000073773",
            Self::N100000073775 => "100000073775",
            Self::N100000073776 => "100000073776",
            Self::N100000073777 => "100000073777",
            Self::N100000073778 => "100000073778",
            Self::N100000073779 => "100000073779",
            Self::N100000073780 => "100000073780",
            Self::N100000073782 => "100000073782",
            Self::N100000073783 => "100000073783",
            Self::N100000073784 => "100000073784",
            Self::N100000073785 => "100000073785",
            Self::N100000073786 => "100000073786",
            Self::N100000073787 => "100000073787",
            Self::N100000073788 => "100000073788",
            Self::N100000073789 => "100000073789",
            Self::N100000073790 => "100000073790",
            Self::N100000073791 => "100000073791",
            Self::N100000073792 => "100000073792",
            Self::N100000073793 => "100000073793",
            Self::N100000073794 => "100000073794",
            Self::N100000073795 => "100000073795",
            Self::N100000073796 => "100000073796",
            Self::N100000073797 => "100000073797",
            Self::N100000073798 => "100000073798",
            Self::N100000073799 => "100000073799",
            Self::N100000073800 => "100000073800",
            Self::N100000073802 => "100000073802",
            Self::N100000073803 => "100000073803",
            Self::N100000073804 => "100000073804",
            Self::N100000073805 => "100000073805",
            Self::N100000073806 => "100000073806",
            Self::N100000073807 => "100000073807",
            Self::N100000073808 => "100000073808",
            Self::N100000073809 => "100000073809",
            Self::N100000073810 => "100000073810",
            Self::N100000073811 => "100000073811",
            Self::N100000073812 => "100000073812",
            Self::N100000073813 => "100000073813",
            Self::N100000073814 => "100000073814",
            Self::N100000073815 => "100000073815",
            Self::N100000073816 => "100000073816",
            Self::N100000073817 => "100000073817",
            Self::N100000073818 => "100000073818",
            Self::N100000073819 => "100000073819",
            Self::N100000073820 => "100000073820",
            Self::N100000073821 => "100000073821",
            Self::N100000073822 => "100000073822",
            Self::N100000073823 => "100000073823",
            Self::N100000073824 => "100000073824",
            Self::N100000073825 => "100000073825",
            Self::N100000073826 => "100000073826",
            Self::N100000073827 => "100000073827",
            Self::N100000073863 => "100000073863",
        }
    }
}
impl ::std::fmt::Display for ManufacturedDoseForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000073362 => "Oral suspension",
            Self::N100000073363 => "Oral gel",
            Self::N100000073364 => "Powder for oral solution",
            Self::N100000073365 => "Granules for oral solution",
            Self::N100000073367 => "Lyophilisate for suspension",
            Self::N100000073368 => "Powder for syrup",
            Self::N100000073369 => "Soluble tablet",
            Self::N100000073370 => "Herbal tea",
            Self::N100000073371 => "Instant herbal tea",
            Self::N100000073372 => "Granules",
            Self::N100000073373 => "Gastro-resistant granules",
            Self::N100000073374 => "Modified-release granules",
            Self::N100000073375 => "Capsule, hard",
            Self::N100000073376 => "Gastro-resistant capsule, hard",
            Self::N100000073377 => "Chewable capsule, soft",
            Self::N100000073378 => "Prolonged-release capsule, soft",
            Self::N100000073379 => "Modified-release capsule, soft",
            Self::N100000073380 => "Coated tablet",
            Self::N100000073642 => "Oral drops, solution",
            Self::N100000073643 => "Oral drops, suspension",
            Self::N100000073644 => "Oral drops, emulsion",
            Self::N100000073645 => "Oral liquid",
            Self::N100000073646 => "Oral solution",
            Self::N100000073647 => "Oral emulsion",
            Self::N100000073648 => "Oral paste",
            Self::N100000073649 => "Powder for oral suspension",
            Self::N100000073650 => "Granules for oral suspension",
            Self::N100000073652 => "Syrup",
            Self::N100000073653 => "Granules for syrup",
            Self::N100000073654 => "Dispersible tablet",
            Self::N100000073655 => "Oral powder",
            Self::N100000073656 => "Effervescent powder",
            Self::N100000073657 => "Effervescent granules",
            Self::N100000073658 => "Prolonged-release granules",
            Self::N100000073659 => "Cachet",
            Self::N100000073660 => "Capsule, soft",
            Self::N100000073661 => "Gastro-resistant capsule, soft",
            Self::N100000073662 => "Prolonged-release capsule, hard",
            Self::N100000073663 => "Modified-release capsule, hard",
            Self::N100000073664 => "Tablet",
            Self::N100000073665 => "Film-coated tablet",
            Self::N100000073666 => "Orodispersible tablet",
            Self::N100000073667 => "Gastro-resistant tablet",
            Self::N100000073668 => "Modified-release tablet",
            Self::N100000073669 => "Medicated chewing-gum",
            Self::N100000073670 => "Pillules",
            Self::N100000073671 => "Pulsatile-release intraruminal device",
            Self::N100000073672 => "Premix for medicated feeding stuff",
            Self::N100000073673 => "Gargle",
            Self::N100000073674 => "Gargle, powder for solution",
            Self::N100000073675 => "Oromucosal suspension",
            Self::N100000073676 => "Oromucosal spray",
            Self::N100000073677 => "Mouthwash",
            Self::N100000073678 => "Gingival solution",
            Self::N100000073679 => "Oromucosal paste",
            Self::N100000073680 => "Gingival gel",
            Self::N100000073681 => "Effervescent tablet",
            Self::N100000073682 => "Oral lyophilisate",
            Self::N100000073683 => "Prolonged-release tablet",
            Self::N100000073684 => "Chewable tablet",
            Self::N100000073685 => "Oral gum",
            Self::N100000073686 => "Continuous-release intraruminal device",
            Self::N100000073687 => "Lick block",
            Self::N100000073688 => "Medicated pellets",
            Self::N100000073689 => "Concentrate for gargle",
            Self::N100000073690 => "Gargle, tablet for solution",
            Self::N100000073691 => "Oromucosal solution",
            Self::N100000073692 => "Oromucosal drops",
            Self::N100000073693 => "Sublingual spray",
            Self::N100000073694 => "Mouthwash, tablet for solution",
            Self::N100000073695 => "Oromucosal gel",
            Self::N100000073696 => "Oromucosal cream",
            Self::N100000073697 => "Gingival paste",
            Self::N100000073698 => "Sublingual tablet",
            Self::N100000073699 => "Buccal tablet",
            Self::N100000073700 => "Compressed lozenge",
            Self::N100000073701 => "Oromucosal capsule",
            Self::N100000073702 => "Muco-adhesive buccal tablet",
            Self::N100000073703 => "Lozenge",
            Self::N100000073704 => "Pastille",
            Self::N100000073705 => "Dental gel",
            Self::N100000073706 => "Dental insert",
            Self::N100000073707 => "Dental powder",
            Self::N100000073708 => "Dental suspension",
            Self::N100000073709 => "Toothpaste",
            Self::N100000073710 => "Periodontal gel",
            Self::N100000073711 => "Bath additive",
            Self::N100000073712 => "Cream",
            Self::N100000073713 => "Ointment",
            Self::N100000073714 => "Medicated plaster",
            Self::N100000073715 => "Shampoo",
            Self::N100000073716 => "Cutaneous spray, suspension",
            Self::N100000073717 => "Cutaneous liquid",
            Self::N100000073718 => "Concentrate for cutaneous solution",
            Self::N100000073719 => "Cutaneous emulsion",
            Self::N100000073720 => "Cutaneous patch",
            Self::N100000073721 => "Periodontal powder",
            Self::N100000073722 => "Dental stick",
            Self::N100000073723 => "Dental solution",
            Self::N100000073724 => "Dental emulsion",
            Self::N100000073725 => "Periodontal insert",
            Self::N100000073726 => "Gel",
            Self::N100000073727 => "Cutaneous paste",
            Self::N100000073728 => "Cutaneous foam",
            Self::N100000073729 => "Cutaneous spray, solution",
            Self::N100000073730 => "Cutaneous spray, powder",
            Self::N100000073731 => "Cutaneous solution",
            Self::N100000073732 => "Cutaneous suspension",
            Self::N100000073733 => "Cutaneous powder",
            Self::N100000073734 => "Solution for iontophoresis",
            Self::N100000073735 => "Collodion",
            Self::N100000073736 => "Poultice",
            Self::N100000073737 => "Cutaneous sponge",
            Self::N100000073738 => "Collar",
            Self::N100000073739 => "Ear tag",
            Self::N100000073740 => "Dip suspension",
            Self::N100000073741 => "Transdermal patch",
            Self::N100000073742 => "Medicated nail lacquer",
            Self::N100000073743 => "Cutaneous stick",
            Self::N100000073744 => "Impregnated dressing",
            Self::N100000073745 => "Medicated pendant",
            Self::N100000073746 => "Dip solution",
            Self::N100000073747 => "Dip emulsion",
            Self::N100000073748 => "Concentrate for dip suspension",
            Self::N100000073749 => "Powder for dip solution",
            Self::N100000073750 => "Powder for suspension for fish treatment",
            Self::N100000073751 => "Pour-on suspension",
            Self::N100000073752 => "Spot-on solution",
            Self::N100000073753 => "Spot-on emulsion",
            Self::N100000073754 => "Teat dip suspension",
            Self::N100000073755 => "Teat spray solution",
            Self::N100000073756 => "Solution for skin-prick test",
            Self::N100000073757 => "Plaster for provocation test",
            Self::N100000073758 => "Eye gel",
            Self::N100000073759 => "Eye drops, solution",
            Self::N100000073760 => "Eye drops, suspension",
            Self::N100000073761 => "Concentrate for dip solution",
            Self::N100000073762 => "Concentrate for dip emulsion",
            Self::N100000073763 => "Concentrate for solution for fish treatment",
            Self::N100000073764 => "Pour-on solution",
            Self::N100000073765 => "Pour-on emulsion",
            Self::N100000073766 => "Spot-on suspension",
            Self::N100000073767 => "Teat dip solution",
            Self::N100000073768 => "Teat dip emulsion",
            Self::N100000073769 => "Transdermal system",
            Self::N100000073770 => "Solution for skin-scratch test",
            Self::N100000073771 => "Eye cream",
            Self::N100000073772 => "Eye ointment",
            Self::N100000073773 => "Eye drops, emulsion",
            Self::N100000073775 => "Eye drops, solvent for reconstitution",
            Self::N100000073776 => "Eye lotion",
            Self::N100000073777 => "Ophthalmic insert",
            Self::N100000073778 => "Ear cream",
            Self::N100000073779 => "Ear ointment",
            Self::N100000073780 => "Ear drops, suspension",
            Self::N100000073782 => "Eye drops, prolonged-release",
            Self::N100000073783 => "Eye lotion, solvent for reconstitution",
            Self::N100000073784 => "Ophthalmic strip",
            Self::N100000073785 => "Ear gel",
            Self::N100000073786 => "Ear drops, solution",
            Self::N100000073787 => "Ear drops, emulsion",
            Self::N100000073788 => "Ear powder",
            Self::N100000073789 => "Ear spray, suspension",
            Self::N100000073790 => "Ear wash, solution",
            Self::N100000073791 => "Ear tampon",
            Self::N100000073792 => "Nasal cream",
            Self::N100000073793 => "Nasal gel",
            Self::N100000073794 => "Nasal drops, solution",
            Self::N100000073795 => "Nasal drops, emulsion",
            Self::N100000073796 => "Nasal spray, solution",
            Self::N100000073797 => "Nasal spray, emulsion",
            Self::N100000073798 => "Nasal stick",
            Self::N100000073799 => "Vaginal gel",
            Self::N100000073800 => "Vaginal foam",
            Self::N100000073802 => "Ear spray, solution",
            Self::N100000073803 => "Ear spray, emulsion",
            Self::N100000073804 => "Ear wash, emulsion",
            Self::N100000073805 => "Ear stick",
            Self::N100000073806 => "Nasal ointment",
            Self::N100000073807 => "Nasal drops, suspension",
            Self::N100000073808 => "Nasal powder",
            Self::N100000073809 => "Nasal spray, suspension",
            Self::N100000073810 => "Nasal wash",
            Self::N100000073811 => "Vaginal cream",
            Self::N100000073812 => "Vaginal ointment",
            Self::N100000073813 => "Vaginal solution",
            Self::N100000073814 => "Vaginal emulsion",
            Self::N100000073815 => "Pessary",
            Self::N100000073816 => "Vaginal capsule, soft",
            Self::N100000073817 => "Effervescent vaginal tablet",
            Self::N100000073818 => "Vaginal delivery system",
            Self::N100000073819 => "Rectal cream",
            Self::N100000073820 => "Rectal foam",
            Self::N100000073821 => "Vaginal suspension",
            Self::N100000073822 => "Tablet for vaginal solution",
            Self::N100000073823 => "Vaginal capsule, hard",
            Self::N100000073824 => "Vaginal tablet",
            Self::N100000073825 => "Medicated vaginal tampon",
            Self::N100000073826 => "Vaginal sponge",
            Self::N100000073827 => "Rectal gel",
            Self::N100000073863 => "Solution for injection",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ManufacturedDoseForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ManufacturedDoseForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ManufacturedDoseForm> for Coding {
    fn from(code: ManufacturedDoseForm) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/manufactured-dose-form".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ManufacturedDoseForm> for CodeableConcept {
    fn from(code: ManufacturedDoseForm) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MeasureAggregateMethod](http://hl7.org/fhir/ValueSet/aggregate-method)**. Aggregation method for a measure (e.g. sum, average, median, minimum, maximum, count)\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureAggregateMethod {
    /** **average**

Average. The measure score is determined by taking the average of the observations derived from the measure population. */
    Average,
    /** **count**

Count. The measure score is determined as the number of observations derived from the measure population. */
    Count,
    /** **maximum**

Maximum. The measure score is determined by taking the maximum of the observations derived from the measure population. */
    Maximum,
    /** **median**

Median. The measure score is determined by taking the median of the observations derived from the measure population. */
    Median,
    /** **minimum**

Minimum. The measure score is determined by taking the minimum of the observations derived from the measure population. */
    Minimum,
    /** **sum**

Sum. The measure score is determined by adding together the observations derived from the measure population. */
    Sum,
}
impl ::core::str::FromStr for MeasureAggregateMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "average" => Ok(Self::Average),
            "count" => Ok(Self::Count),
            "maximum" => Ok(Self::Maximum),
            "median" => Ok(Self::Median),
            "minimum" => Ok(Self::Minimum),
            "sum" => Ok(Self::Sum),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureAggregateMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Average => "average",
            Self::Count => "count",
            Self::Maximum => "maximum",
            Self::Median => "median",
            Self::Minimum => "minimum",
            Self::Sum => "sum",
        }
    }
}
impl ::std::fmt::Display for MeasureAggregateMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Average => "Average",
            Self::Count => "Count",
            Self::Maximum => "Maximum",
            Self::Median => "Median",
            Self::Minimum => "Minimum",
            Self::Sum => "Sum",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MeasureAggregateMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureAggregateMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureAggregateMethod> for Coding {
    fn from(code: MeasureAggregateMethod) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/aggregate-method".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MeasureAggregateMethod> for CodeableConcept {
    fn from(code: MeasureAggregateMethod) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MeasureDefinitionExample](http://hl7.org/fhir/ValueSet/measure-definition-example)**. Example Measure Definitions for the Measure Resource.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureDefinitionExample {
    /** **screening**

Screening. Completion of a clinical or diagnostic tool used to identify people at risk of developing or having a certain disease or condition, even in the absence of symptoms. */
    Screening,
    /** **standardized-depression-screening-tool**

Standardized Depression Screening Tool. A normalized and validated depression screening tool developed for the patient population in which it is being utilized. */
    StandardizedDepressionScreeningTool,
}
impl ::core::str::FromStr for MeasureDefinitionExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "screening" => Ok(Self::Screening),
            "standardized-depression-screening-tool" => {
                Ok(Self::StandardizedDepressionScreeningTool)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureDefinitionExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Screening => "screening",
            Self::StandardizedDepressionScreeningTool => {
                "standardized-depression-screening-tool"
            }
        }
    }
}
impl ::std::fmt::Display for MeasureDefinitionExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Screening => "Screening",
            Self::StandardizedDepressionScreeningTool => {
                "Standardized Depression Screening Tool"
            }
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MeasureDefinitionExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureDefinitionExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureDefinitionExample> for Coding {
    fn from(code: MeasureDefinitionExample) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/measure-definition-example".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MeasureDefinitionExample> for CodeableConcept {
    fn from(code: MeasureDefinitionExample) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MeasureGroupExample](http://hl7.org/fhir/ValueSet/measure-group-example)**. Example Measure Groups for the Measure Resource.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureGroupExample {
    /** **primary-rate**

Primary Rate. Primary Measure Group. */
    PrimaryRate,
    /** **secondary-rate**

Secondary Rate. Secondary Measure Group */
    SecondaryRate,
}
impl ::core::str::FromStr for MeasureGroupExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "primary-rate" => Ok(Self::PrimaryRate),
            "secondary-rate" => Ok(Self::SecondaryRate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureGroupExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::PrimaryRate => "primary-rate",
            Self::SecondaryRate => "secondary-rate",
        }
    }
}
impl ::std::fmt::Display for MeasureGroupExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::PrimaryRate => "Primary Rate",
            Self::SecondaryRate => "Secondary Rate",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MeasureGroupExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureGroupExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureGroupExample> for Coding {
    fn from(code: MeasureGroupExample) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/measure-group-example".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MeasureGroupExample> for CodeableConcept {
    fn from(code: MeasureGroupExample) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MeasureReportStatus](http://hl7.org/fhir/ValueSet/measure-report-status)**. The status of the measure report.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureReportStatus {
    /** **complete**

Complete. The report is complete and ready for use. */
    Complete,
    /** **error**

Error. An error occurred attempting to generate the report. */
    Error,
    /** **pending**

Pending. The report is currently being generated. */
    Pending,
}
impl ::core::str::FromStr for MeasureReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "error" => Ok(Self::Error),
            "pending" => Ok(Self::Pending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Error => "error",
            Self::Pending => "pending",
        }
    }
}
impl ::std::fmt::Display for MeasureReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Complete => "Complete",
            Self::Error => "Error",
            Self::Pending => "Pending",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MeasureReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureReportStatus> for Coding {
    fn from(code: MeasureReportStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/measure-report-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MeasureReportStatus> for CodeableConcept {
    fn from(code: MeasureReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MeasureReportStratifierValueExample](http://hl7.org/fhir/ValueSet/measurereport-stratifier-value-example)**. Example Region Value Measure Groups for the Measure Resource.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureReportStratifierValueExample {
    /** **northeast**

Northeast. Northeast region stratification. */
    Northeast,
    /** **northwest**

Northwest. Northwest region stratification. */
    Northwest,
    /** **southeast**

Southeast. Southeast region stratification. */
    Southeast,
    /** **southwest**

Soutwest. Soutwest region stratification. */
    Southwest,
}
impl ::core::str::FromStr for MeasureReportStratifierValueExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "northeast" => Ok(Self::Northeast),
            "northwest" => Ok(Self::Northwest),
            "southeast" => Ok(Self::Southeast),
            "southwest" => Ok(Self::Southwest),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportStratifierValueExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Northeast => "northeast",
            Self::Northwest => "northwest",
            Self::Southeast => "southeast",
            Self::Southwest => "southwest",
        }
    }
}
impl ::std::fmt::Display for MeasureReportStratifierValueExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Northeast => "Northeast",
            Self::Northwest => "Northwest",
            Self::Southeast => "Southeast",
            Self::Southwest => "Soutwest",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MeasureReportStratifierValueExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportStratifierValueExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureReportStratifierValueExample> for Coding {
    fn from(code: MeasureReportStratifierValueExample) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/measurereport-stratifier-value-example"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MeasureReportStratifierValueExample> for CodeableConcept {
    fn from(code: MeasureReportStratifierValueExample) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MeasureReportType](http://hl7.org/fhir/ValueSet/measure-report-type)**. The type of the measure report.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureReportType {
    /** **data-exchange**

Data Exchange. A data exchange report that contains data-of-interest for the measure (i.e. data that is needed to calculate the measure) */
    DataExchange,
    /** **individual**

Individual. An individual report that provides information on the performance for a given measure with respect to a single subject. */
    Individual,
    /** **subject-list**

Subject List. A subject list report that includes a listing of subjects that satisfied each population criteria in the measure. */
    SubjectList,
    /** **summary**

Summary. A summary report that returns the number of members in each population criteria for the measure. */
    Summary,
}
impl ::core::str::FromStr for MeasureReportType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-exchange" => Ok(Self::DataExchange),
            "individual" => Ok(Self::Individual),
            "subject-list" => Ok(Self::SubjectList),
            "summary" => Ok(Self::Summary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataExchange => "data-exchange",
            Self::Individual => "individual",
            Self::SubjectList => "subject-list",
            Self::Summary => "summary",
        }
    }
}
impl ::std::fmt::Display for MeasureReportType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::DataExchange => "Data Exchange",
            Self::Individual => "Individual",
            Self::SubjectList => "Subject List",
            Self::Summary => "Summary",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MeasureReportType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureReportType> for Coding {
    fn from(code: MeasureReportType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/measure-report-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MeasureReportType> for CodeableConcept {
    fn from(code: MeasureReportType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MeasureStratifierExample](http://hl7.org/fhir/ValueSet/measure-stratifier-example)**. Identifier subgroups in a population for measuring purposes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureStratifierExample {
    /** **age**

Age. Age Stratification. */
    Age,
    /** **gender**

Gender. Gender Stratification. */
    Gender,
    /** **region**

Region. Region Stratification. */
    Region,
}
impl ::core::str::FromStr for MeasureStratifierExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "age" => Ok(Self::Age),
            "gender" => Ok(Self::Gender),
            "region" => Ok(Self::Region),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureStratifierExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Age => "age",
            Self::Gender => "gender",
            Self::Region => "region",
        }
    }
}
impl ::std::fmt::Display for MeasureStratifierExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Age => "Age",
            Self::Gender => "Gender",
            Self::Region => "Region",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MeasureStratifierExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureStratifierExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureStratifierExample> for Coding {
    fn from(code: MeasureStratifierExample) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/measure-stratifier-example".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MeasureStratifierExample> for CodeableConcept {
    fn from(code: MeasureStratifierExample) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MeasureSupplementalDataExample](http://hl7.org/fhir/ValueSet/measure-supplemental-data-example)**. Identifier supplemental data in a population for measuring purposes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureSupplementalDataExample {
    /** **age**

Age. Age Supplemental Data. */
    Age,
    /** **ethnicity**

Ethnicity. Ethnicity Supplemental Data . */
    Ethnicity,
    /** **gender**

Gender. Gender Supplemental Data . */
    Gender,
    /** **payer**

Payer. Payer Supplemental Data. */
    Payer,
}
impl ::core::str::FromStr for MeasureSupplementalDataExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "age" => Ok(Self::Age),
            "ethnicity" => Ok(Self::Ethnicity),
            "gender" => Ok(Self::Gender),
            "payer" => Ok(Self::Payer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureSupplementalDataExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Age => "age",
            Self::Ethnicity => "ethnicity",
            Self::Gender => "gender",
            Self::Payer => "payer",
        }
    }
}
impl ::std::fmt::Display for MeasureSupplementalDataExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Age => "Age",
            Self::Ethnicity => "Ethnicity",
            Self::Gender => "Gender",
            Self::Payer => "Payer",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MeasureSupplementalDataExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureSupplementalDataExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MeasureSupplementalDataExample> for Coding {
    fn from(code: MeasureSupplementalDataExample) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/measure-supplemental-data-example"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MeasureSupplementalDataExample> for CodeableConcept {
    fn from(code: MeasureSupplementalDataExample) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedDispenseAdminLocationCodes](http://hl7.org/fhir/ValueSet/medicationdispense-admin-location)**. Medication Dispense Administration Location Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedDispenseAdminLocationCodes {
    /** **community**

Community. Includes dispenses for medications to be administered or consumed by the patient in their home (this would include long term care or nursing homes, hospices, etc.). */
    Community,
    /** **inpatient**

Inpatient. Includes dispenses for medications to be administered or consumed in an inpatient or acute care setting. */
    Inpatient,
    /** **outpatient**

Outpatient. Includes dispenses for medications to be administered or consumed in an outpatient setting (for example, Emergency Department, Outpatient Clinic, Outpatient Surgery, Doctor's office). */
    Outpatient,
}
impl ::core::str::FromStr for MedDispenseAdminLocationCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "community" => Ok(Self::Community),
            "inpatient" => Ok(Self::Inpatient),
            "outpatient" => Ok(Self::Outpatient),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedDispenseAdminLocationCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Community => "community",
            Self::Inpatient => "inpatient",
            Self::Outpatient => "outpatient",
        }
    }
}
impl ::std::fmt::Display for MedDispenseAdminLocationCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Community => "Community",
            Self::Inpatient => "Inpatient",
            Self::Outpatient => "Outpatient",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedDispenseAdminLocationCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedDispenseAdminLocationCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedDispenseAdminLocationCodes> for Coding {
    fn from(code: MedDispenseAdminLocationCodes) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicationdispense-admin-location"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedDispenseAdminLocationCodes> for CodeableConcept {
    fn from(code: MedDispenseAdminLocationCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationAdministrationStatusCodes](http://hl7.org/fhir/ValueSet/medication-admin-status)**. MedicationAdministration Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationAdministrationStatusCodes {
    /** **completed**

Completed. All actions that are implied by the administration have occurred. */
    Completed,
    /** **entered-in-error**

Entered in Error. The administration was entered in error and therefore nullified. */
    EnteredInError,
    /** **in-progress**

In Progress. The administration has started but has not yet completed. */
    InProgress,
    /** **not-done**

Not Done. The administration was terminated prior to any impact on the subject (though preparatory actions may have been taken) */
    NotDone,
    /** **on-hold**

On Hold. Actions implied by the administration have been temporarily halted, but are expected to continue later. May also be called 'suspended'. */
    OnHold,
    /** **stopped**

Stopped. Actions implied by the administration have been permanently halted, before all of them occurred. */
    Stopped,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this request. Note: This concept is not to be used for 'other' - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for MedicationAdministrationStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "not-done" => Ok(Self::NotDone),
            "on-hold" => Ok(Self::OnHold),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationAdministrationStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::NotDone => "not-done",
            Self::OnHold => "on-hold",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for MedicationAdministrationStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Completed => "Completed",
            Self::EnteredInError => "Entered in Error",
            Self::InProgress => "In Progress",
            Self::NotDone => "Not Done",
            Self::OnHold => "On Hold",
            Self::Stopped => "Stopped",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationAdministrationStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationAdministrationStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationAdministrationStatusCodes> for Coding {
    fn from(code: MedicationAdministrationStatusCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medication-admin-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationAdministrationStatusCodes> for CodeableConcept {
    fn from(code: MedicationAdministrationStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationCostCategoryCodes](http://hl7.org/fhir/ValueSet/medication-cost-category)**. Medication Cost Category Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationCostCategoryCodes {
    /** **banda**

Band A. Tier A cost for this medication */
    Banda,
    /** **bandb**

Band B. Tier B cost for this medication */
    Bandb,
}
impl ::core::str::FromStr for MedicationCostCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "banda" => Ok(Self::Banda),
            "bandb" => Ok(Self::Bandb),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationCostCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Banda => "banda",
            Self::Bandb => "bandb",
        }
    }
}
impl ::std::fmt::Display for MedicationCostCategoryCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Banda => "Band A",
            Self::Bandb => "Band B",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationCostCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationCostCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationCostCategoryCodes> for Coding {
    fn from(code: MedicationCostCategoryCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medication-cost-category".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationCostCategoryCodes> for CodeableConcept {
    fn from(code: MedicationCostCategoryCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationDispenseStatusCodes](http://hl7.org/fhir/ValueSet/medicationDispense-status)**. Medication Dispense Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationDispenseStatusCodes {
    /** **cancelled**

Cancelled. The dispensed product was not and will never be picked up by the patient. */
    Cancelled,
    /** **completed**

Completed. The dispensed product has been picked up. */
    Completed,
    /** **declined**

Declined. The dispense was declined and not performed. */
    Declined,
    /** **entered-in-error**

Entered in Error. The dispense was entered in error and therefore nullified. */
    EnteredInError,
    /** **in-progress**

In Progress. The dispensed product is ready for pickup. */
    InProgress,
    /** **on-hold**

On Hold. The dispense process is paused while waiting for an external event to reactivate the dispense.  For example, new stock has arrived or the prescriber has called. */
    OnHold,
    /** **preparation**

Preparation. The core event has not started yet, but some staging activities have begun (e.g. initial compounding or packaging of medication). Preparation stages may be tracked for billing purposes. */
    Preparation,
    /** **stopped**

Stopped. Actions implied by the dispense have been permanently halted, before all of them occurred. */
    Stopped,
    /** **unknown**

Unknown. The authoring system does not know which of the status values applies for this medication dispense.  Note: this concept is not to be used for other - one of the listed statuses is presumed to apply, it's just now known which one. */
    Unknown,
}
impl ::core::str::FromStr for MedicationDispenseStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "declined" => Ok(Self::Declined),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "preparation" => Ok(Self::Preparation),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationDispenseStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Declined => "declined",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::Preparation => "preparation",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for MedicationDispenseStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Cancelled => "Cancelled",
            Self::Completed => "Completed",
            Self::Declined => "Declined",
            Self::EnteredInError => "Entered in Error",
            Self::InProgress => "In Progress",
            Self::OnHold => "On Hold",
            Self::Preparation => "Preparation",
            Self::Stopped => "Stopped",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationDispenseStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationDispenseStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationDispenseStatusCodes> for Coding {
    fn from(code: MedicationDispenseStatusCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medicationDispense-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationDispenseStatusCodes> for CodeableConcept {
    fn from(code: MedicationDispenseStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationDispenseStatusReasonCodes](http://hl7.org/fhir/ValueSet/medicationdispense-status-reason)**. Medication Dispense Status Reason Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationDispenseStatusReasonCodes {
    /** **altchoice**

Try another treatment first. This therapy has been ordered as a backup to a preferred therapy. This order will be released when and if the preferred therapy is unsuccessful. */
    Altchoice,
    /** **clarif**

Prescription/Request requires clarification. Clarification is required before the order can be acted upon. */
    Clarif,
    /** **drughigh**

Drug level too high. The current level of the medication in the patient's system is too high. The medication is suspended to allow the level to subside to a safer level. */
    Drughigh,
    /** **frr01**

Order Stopped. The order has been stopped by the prescriber but this fact has not necessarily captured electronically. Example: A verbal stop, a fax, etc. */
    Frr01,
    /** **frr02**

Stale-dated Order. Order has not been fulfilled within a reasonable amount of time, and might not be current. */
    Frr02,
    /** **frr03**

Incomplete data. Data needed to safely act on the order which was expected to become available independent of the order is not yet available. Example: Lab results, diagnostic imaging, etc. */
    Frr03,
    /** **frr04**

Product unavailable. Product not available or manufactured. Cannot supply. */
    Frr04,
    /** **frr05**

Ethical/religious. The dispenser has ethical, religious or moral objections to fulfilling the order/dispensing the product. */
    Frr05,
    /** **frr06**

Unable to provide care. Fulfiller not able to provide appropriate care associated with fulfilling the order. Example: Therapy requires ongoing monitoring by fulfiller and fulfiller will be ending practice, leaving town, unable to schedule necessary time, etc. */
    Frr06,
    /** **hospadm**

Admission to hospital. The patient has been admitted to a care facility and their community medications are suspended until hospital discharge. */
    Hospadm,
    /** **labint**

Lab interference issues. The therapy would interfere with a planned lab test and the therapy is being withdrawn until the test is completed. */
    Labint,
    /** **non-avail**

Patient not available. Patient not available for a period of time due to a scheduled therapy, leave of absence or other reason. */
    NonAvail,
    /** **offmarket**

Drug not available - off market. Drug no longer marketed Cannot supply. */
    Offmarket,
    /** **outofstock**

Drug not available - out of stock. Drug out of stock. Cannot supply. */
    Outofstock,
    /** **preg**

Patient is pregnant or breastfeeding. The patient is pregnant or breast feeding. The therapy will be resumed when the pregnancy is complete and the patient is no longer breastfeeding. */
    Preg,
    /** **saig**

Allergy. The patient is believed to be allergic to a substance that is part of the therapy and the therapy is being temporarily withdrawn to confirm. */
    Saig,
    /** **sddi**

Drug interacts with another drug. The drug interacts with a short-term treatment that is more urgently required. This order will be resumed when the short-term treatment is complete. */
    Sddi,
    /** **sdupther**

Duplicate therapy. Another short-term co-occurring therapy fulfills the same purpose as this therapy. This therapy will be resumed when the co-occuring therapy is complete. */
    Sdupther,
    /** **sintol**

Suspected intolerance. The patient is believed to have an intolerance to a substance that is part of the therapy and the therapy is being temporarily withdrawn to confirm. */
    Sintol,
    /** **surg**

Patient scheduled for surgery. The drug is contraindicated for patients receiving surgery and the patient is scheduled to be admitted for surgery in the near future. The drug will be resumed when the patient has sufficiently recovered from the surgery. */
    Surg,
    /** **washout**

Washout. The patient was previously receiving a medication contraindicated with the current medication. The current medication will remain on hold until the prior medication has been cleansed from their system. */
    Washout,
}
impl ::core::str::FromStr for MedicationDispenseStatusReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "altchoice" => Ok(Self::Altchoice),
            "clarif" => Ok(Self::Clarif),
            "drughigh" => Ok(Self::Drughigh),
            "frr01" => Ok(Self::Frr01),
            "frr02" => Ok(Self::Frr02),
            "frr03" => Ok(Self::Frr03),
            "frr04" => Ok(Self::Frr04),
            "frr05" => Ok(Self::Frr05),
            "frr06" => Ok(Self::Frr06),
            "hospadm" => Ok(Self::Hospadm),
            "labint" => Ok(Self::Labint),
            "non-avail" => Ok(Self::NonAvail),
            "offmarket" => Ok(Self::Offmarket),
            "outofstock" => Ok(Self::Outofstock),
            "preg" => Ok(Self::Preg),
            "saig" => Ok(Self::Saig),
            "sddi" => Ok(Self::Sddi),
            "sdupther" => Ok(Self::Sdupther),
            "sintol" => Ok(Self::Sintol),
            "surg" => Ok(Self::Surg),
            "washout" => Ok(Self::Washout),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationDispenseStatusReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Altchoice => "altchoice",
            Self::Clarif => "clarif",
            Self::Drughigh => "drughigh",
            Self::Frr01 => "frr01",
            Self::Frr02 => "frr02",
            Self::Frr03 => "frr03",
            Self::Frr04 => "frr04",
            Self::Frr05 => "frr05",
            Self::Frr06 => "frr06",
            Self::Hospadm => "hospadm",
            Self::Labint => "labint",
            Self::NonAvail => "non-avail",
            Self::Offmarket => "offmarket",
            Self::Outofstock => "outofstock",
            Self::Preg => "preg",
            Self::Saig => "saig",
            Self::Sddi => "sddi",
            Self::Sdupther => "sdupther",
            Self::Sintol => "sintol",
            Self::Surg => "surg",
            Self::Washout => "washout",
        }
    }
}
impl ::std::fmt::Display for MedicationDispenseStatusReasonCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Altchoice => "Try another treatment first",
            Self::Clarif => "Prescription/Request requires clarification",
            Self::Drughigh => "Drug level too high",
            Self::Frr01 => "Order Stopped",
            Self::Frr02 => "Stale-dated Order",
            Self::Frr03 => "Incomplete data",
            Self::Frr04 => "Product unavailable",
            Self::Frr05 => "Ethical/religious",
            Self::Frr06 => "Unable to provide care",
            Self::Hospadm => "Admission to hospital",
            Self::Labint => "Lab interference issues",
            Self::NonAvail => "Patient not available",
            Self::Offmarket => "Drug not available - off market",
            Self::Outofstock => "Drug not available - out of stock",
            Self::Preg => "Patient is pregnant or breastfeeding",
            Self::Saig => "Allergy",
            Self::Sddi => "Drug interacts with another drug",
            Self::Sdupther => "Duplicate therapy",
            Self::Sintol => "Suspected intolerance",
            Self::Surg => "Patient scheduled for surgery",
            Self::Washout => "Washout",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationDispenseStatusReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationDispenseStatusReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationDispenseStatusReasonCodes> for Coding {
    fn from(code: MedicationDispenseStatusReasonCodes) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicationdispense-status-reason"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationDispenseStatusReasonCodes> for CodeableConcept {
    fn from(code: MedicationDispenseStatusReasonCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationDoseAid](http://hl7.org/fhir/ValueSet/medication-dose-aid)**. Medication dose aid\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationDoseAid {
    /** **blisterpack**

Blister Pack. A type of packaging in which a medication is sealed in plastic, often with a cardboard backing. */
    Blisterpack,
    /** **dosette**

Dosette. A box or tray that organizes mediations into separate compartments */
    Dosette,
    /** **sachets**

Sachets. A small packet that contains medication for individual use. */
    Sachets,
}
impl ::core::str::FromStr for MedicationDoseAid {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "blisterpack" => Ok(Self::Blisterpack),
            "dosette" => Ok(Self::Dosette),
            "sachets" => Ok(Self::Sachets),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationDoseAid {
    fn as_ref(&self) -> &str {
        match self {
            Self::Blisterpack => "blisterpack",
            Self::Dosette => "dosette",
            Self::Sachets => "sachets",
        }
    }
}
impl ::std::fmt::Display for MedicationDoseAid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Blisterpack => "Blister Pack",
            Self::Dosette => "Dosette",
            Self::Sachets => "Sachets",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationDoseAid {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationDoseAid {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationDoseAid> for Coding {
    fn from(code: MedicationDoseAid) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medication-dose-aid".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationDoseAid> for CodeableConcept {
    fn from(code: MedicationDoseAid) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationIngredientStrengthCodes](http://hl7.org/fhir/ValueSet/medication-ingredientstrength)**. Medication Ingredient Strength Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationIngredientStrengthCodes {
    /** **qs**

QS. As much as is sufficient. */
    Qs,
    /** **trace**

Trace. Very small amount. */
    Trace,
}
impl ::core::str::FromStr for MedicationIngredientStrengthCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "qs" => Ok(Self::Qs),
            "trace" => Ok(Self::Trace),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationIngredientStrengthCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Qs => "qs",
            Self::Trace => "trace",
        }
    }
}
impl ::std::fmt::Display for MedicationIngredientStrengthCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Qs => "QS",
            Self::Trace => "Trace",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationIngredientStrengthCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationIngredientStrengthCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationIngredientStrengthCodes> for Coding {
    fn from(code: MedicationIngredientStrengthCodes) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medication-ingredientstrength".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationIngredientStrengthCodes> for CodeableConcept {
    fn from(code: MedicationIngredientStrengthCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationIntendedPerformerRole](http://hl7.org/fhir/ValueSet/medication-intended-performer-role)**. Medication Intended Performer Role\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationIntendedPerformerRole {
    /** **oncologynurse**

Oncology Nurse. */
    Oncologynurse,
    /** **paincontrolnurse**

Pain Control Nurse. */
    Paincontrolnurse,
    /** **pharmacist**

Pharmacist. */
    Pharmacist,
    /** **physician**

Physician. */
    Physician,
    /** **registerednurse**

Registered Nurse. */
    Registerednurse,
}
impl ::core::str::FromStr for MedicationIntendedPerformerRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "oncologynurse" => Ok(Self::Oncologynurse),
            "paincontrolnurse" => Ok(Self::Paincontrolnurse),
            "pharmacist" => Ok(Self::Pharmacist),
            "physician" => Ok(Self::Physician),
            "registerednurse" => Ok(Self::Registerednurse),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationIntendedPerformerRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Oncologynurse => "oncologynurse",
            Self::Paincontrolnurse => "paincontrolnurse",
            Self::Pharmacist => "pharmacist",
            Self::Physician => "physician",
            Self::Registerednurse => "registerednurse",
        }
    }
}
impl ::std::fmt::Display for MedicationIntendedPerformerRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Oncologynurse => "Oncology Nurse",
            Self::Paincontrolnurse => "Pain Control Nurse",
            Self::Pharmacist => "Pharmacist",
            Self::Physician => "Physician",
            Self::Registerednurse => "Registered Nurse",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationIntendedPerformerRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationIntendedPerformerRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationIntendedPerformerRole> for Coding {
    fn from(code: MedicationIntendedPerformerRole) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medication-intended-performer-role"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationIntendedPerformerRole> for CodeableConcept {
    fn from(code: MedicationIntendedPerformerRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationKnowledgeStatusCodes](http://hl7.org/fhir/ValueSet/medicationknowledge-status)**. MedicationKnowledge Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationKnowledgeStatusCodes {
    /** **active**

Active. The medication referred to by this MedicationKnowledge is in active use within the drug database or inventory system. */
    Active,
    /** **entered-in-error**

Entered in Error. The medication referred to by this MedicationKnowledge was entered in error within the drug database or inventory system. */
    EnteredInError,
    /** **inactive**

Inactive. The medication referred to by this MedicationKnowledge is not in active use within the drug database or inventory system. */
    Inactive,
}
impl ::core::str::FromStr for MedicationKnowledgeStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationKnowledgeStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Display for MedicationKnowledgeStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in Error",
            Self::Inactive => "Inactive",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationKnowledgeStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationKnowledgeStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationKnowledgeStatusCodes> for Coding {
    fn from(code: MedicationKnowledgeStatusCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medicationknowledge-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationKnowledgeStatusCodes> for CodeableConcept {
    fn from(code: MedicationKnowledgeStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationRequestIntentCodes](http://hl7.org/fhir/ValueSet/medicationrequest-intent)**. MedicationRequest Intent Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationRequestIntentCodes {
    /** **filler-order**

Filler Order. The request represents the view of an authorization instantiated by a fulfilling system representing the details of the fulfiller's intention to act upon a submitted order. */
    FillerOrder,
    /** **instance-order**

Instance Order. The request represents an instance for the particular order and is used to generate a schedule of requests on a medication administration record (MAR). */
    InstanceOrder,
    /** **option**

Option. The request represents a component or option for a RequestOrchestration that establishes timing, conditionality and/or  other constraints among a set of requests. */
    Option,
    /** **order**

Order. The request represents a request/demand and authorization for action */
    Order,
    /** **original-order**

Original Order. The request represents the original authorization for the medication request. */
    OriginalOrder,
    /** **plan**

Plan. The request represents an intention to ensure something occurs without providing an authorization for others to act. */
    Plan,
    /** **proposal**

Proposal. The request is a suggestion made by someone/something that doesn't have an intention to ensure it occurs and without providing an authorization to act */
    Proposal,
    /** **reflex-order**

Reflex Order. The request represents an automatically generated supplemental authorization for action based on a parent authorization together with initial results of the action taken against that parent authorization.. */
    ReflexOrder,
}
impl ::core::str::FromStr for MedicationRequestIntentCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "filler-order" => Ok(Self::FillerOrder),
            "instance-order" => Ok(Self::InstanceOrder),
            "option" => Ok(Self::Option),
            "order" => Ok(Self::Order),
            "original-order" => Ok(Self::OriginalOrder),
            "plan" => Ok(Self::Plan),
            "proposal" => Ok(Self::Proposal),
            "reflex-order" => Ok(Self::ReflexOrder),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationRequestIntentCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::FillerOrder => "filler-order",
            Self::InstanceOrder => "instance-order",
            Self::Option => "option",
            Self::Order => "order",
            Self::OriginalOrder => "original-order",
            Self::Plan => "plan",
            Self::Proposal => "proposal",
            Self::ReflexOrder => "reflex-order",
        }
    }
}
impl ::std::fmt::Display for MedicationRequestIntentCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::FillerOrder => "Filler Order",
            Self::InstanceOrder => "Instance Order",
            Self::Option => "Option",
            Self::Order => "Order",
            Self::OriginalOrder => "Original Order",
            Self::Plan => "Plan",
            Self::Proposal => "Proposal",
            Self::ReflexOrder => "Reflex Order",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationRequestIntentCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationRequestIntentCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationRequestIntentCodes> for Coding {
    fn from(code: MedicationRequestIntentCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medicationrequest-intent".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationRequestIntentCodes> for CodeableConcept {
    fn from(code: MedicationRequestIntentCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationRequestStatusCodes](http://hl7.org/fhir/ValueSet/medicationrequest-status)**. MedicationRequest Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationRequestStatusCodes {
    /** **active**

Active. The request is 'actionable', but not all actions that are implied by it have occurred yet. */
    Active,
    /** **cancelled**

Cancelled. The request has been withdrawn before any administrations have occurred */
    Cancelled,
    /** **completed**

Completed. All actions that are implied by the request have occurred. */
    Completed,
    /** **draft**

Draft. The request is not yet 'actionable', e.g. it is a work in progress, requires sign-off, verification or needs to be run through decision support process. */
    Draft,
    /** **ended**

Ended. The request is no longer active and the subject should no longer be taking the medication. */
    Ended,
    /** **entered-in-error**

Entered in Error. The request was recorded against the wrong patient or for some reason should not have been recorded (e.g. wrong medication, wrong dose, etc.). Some of the actions that are implied by the medication request may have occurred. For example, the medication may have been dispensed and the patient may have taken some of the medication. */
    EnteredInError,
    /** **on-hold**

On Hold. Actions implied by the request are to be temporarily halted. The request might or might not be resumed. May also be called 'suspended'. */
    OnHold,
    /** **stopped**

Stopped. Actions implied by the request are to be permanently halted, before all of the administrations occurred. This should not be used if the original order was entered in error */
    Stopped,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this request. Note: This concept is not to be used for 'other' - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for MedicationRequestStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "ended" => Ok(Self::Ended),
            "entered-in-error" => Ok(Self::EnteredInError),
            "on-hold" => Ok(Self::OnHold),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationRequestStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::Ended => "ended",
            Self::EnteredInError => "entered-in-error",
            Self::OnHold => "on-hold",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for MedicationRequestStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Cancelled => "Cancelled",
            Self::Completed => "Completed",
            Self::Draft => "Draft",
            Self::Ended => "Ended",
            Self::EnteredInError => "Entered in Error",
            Self::OnHold => "On Hold",
            Self::Stopped => "Stopped",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationRequestStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationRequestStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationRequestStatusCodes> for Coding {
    fn from(code: MedicationRequestStatusCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medicationrequest-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationRequestStatusCodes> for CodeableConcept {
    fn from(code: MedicationRequestStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationStatementAdherenceCodes](http://hl7.org/fhir/ValueSet/medication-statement-adherence)**. MedicationStatement Adherence Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationStatementAdherenceCodes {
    /** **not-taking**

Not Taking. The medication is not being taken. */
    NotTaking,
    /** **on-hold**

On Hold. The medication is on hold. */
    OnHold,
    /** **on-hold-as-directed**

On Hold As Directed. The medication is on hold as directed. */
    OnHoldAsDirected,
    /** **on-hold-not-as-directed**

On Hold Not As Directed. The medication is on hold not as directed. */
    OnHoldNotAsDirected,
    /** **stopped**

Stopped. The medication is stopped. */
    Stopped,
    /** **stopped-as-directed**

Stopped As Directed. The medication is stopped as directed. */
    StoppedAsDirected,
    /** **stopped-not-as-directed**

Stopped Not As Directed. The medication is stopped not as directed. */
    StoppedNotAsDirected,
    /** **taking**

Taking. The medication is being taken. */
    Taking,
    /** **taking-as-directed**

Taking As Directed. The medication is being taken as directed. */
    TakingAsDirected,
    /** **taking-not-as-directed**

Taking Not As Directed. The medication is not being taken as directed. */
    TakingNotAsDirected,
    /** **unknown**

Unknown. Whether the medication is being taken or not is not currently known. */
    Unknown,
}
impl ::core::str::FromStr for MedicationStatementAdherenceCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "not-taking" => Ok(Self::NotTaking),
            "on-hold" => Ok(Self::OnHold),
            "on-hold-as-directed" => Ok(Self::OnHoldAsDirected),
            "on-hold-not-as-directed" => Ok(Self::OnHoldNotAsDirected),
            "stopped" => Ok(Self::Stopped),
            "stopped-as-directed" => Ok(Self::StoppedAsDirected),
            "stopped-not-as-directed" => Ok(Self::StoppedNotAsDirected),
            "taking" => Ok(Self::Taking),
            "taking-as-directed" => Ok(Self::TakingAsDirected),
            "taking-not-as-directed" => Ok(Self::TakingNotAsDirected),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationStatementAdherenceCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::NotTaking => "not-taking",
            Self::OnHold => "on-hold",
            Self::OnHoldAsDirected => "on-hold-as-directed",
            Self::OnHoldNotAsDirected => "on-hold-not-as-directed",
            Self::Stopped => "stopped",
            Self::StoppedAsDirected => "stopped-as-directed",
            Self::StoppedNotAsDirected => "stopped-not-as-directed",
            Self::Taking => "taking",
            Self::TakingAsDirected => "taking-as-directed",
            Self::TakingNotAsDirected => "taking-not-as-directed",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for MedicationStatementAdherenceCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::NotTaking => "Not Taking",
            Self::OnHold => "On Hold",
            Self::OnHoldAsDirected => "On Hold As Directed",
            Self::OnHoldNotAsDirected => "On Hold Not As Directed",
            Self::Stopped => "Stopped",
            Self::StoppedAsDirected => "Stopped As Directed",
            Self::StoppedNotAsDirected => "Stopped Not As Directed",
            Self::Taking => "Taking",
            Self::TakingAsDirected => "Taking As Directed",
            Self::TakingNotAsDirected => "Taking Not As Directed",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationStatementAdherenceCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationStatementAdherenceCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationStatementAdherenceCodes> for Coding {
    fn from(code: MedicationStatementAdherenceCodes) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medication-statement-adherence".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationStatementAdherenceCodes> for CodeableConcept {
    fn from(code: MedicationStatementAdherenceCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationStatementStatusCodes](http://hl7.org/fhir/ValueSet/medication-statement-status)**. MedicationStatement Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationStatementStatusCodes {
    /** **draft**

Draft. The medication usage is draft or preliminary. */
    Draft,
    /** **entered-in-error**

Entered in Error. Some of the actions that are implied by the medication usage may have occurred.  For example, the patient may have taken some of the medication.  Clinical decision support systems should take this status into account. */
    EnteredInError,
    /** **recorded**

Recorded. The action of recording the medication statement is finished. */
    Recorded,
}
impl ::core::str::FromStr for MedicationStatementStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "recorded" => Ok(Self::Recorded),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationStatementStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Recorded => "recorded",
        }
    }
}
impl ::std::fmt::Display for MedicationStatementStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Draft => "Draft",
            Self::EnteredInError => "Entered in Error",
            Self::Recorded => "Recorded",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationStatementStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationStatementStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationStatementStatusCodes> for Coding {
    fn from(code: MedicationStatementStatusCodes) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medication-statement-status".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationStatementStatusCodes> for CodeableConcept {
    fn from(code: MedicationStatementStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicationStatusCodes](http://hl7.org/fhir/ValueSet/medication-status)**. Medication Status Codes\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicationStatusCodes {
    /** **active**

Active. The medication record is current and is appropriate for reference in new instances. */
    Active,
    /** **entered-in-error**

Entered in Error. The medication record was created erroneously and is not appropriated for reference in new instances. */
    EnteredInError,
    /** **inactive**

Inactive. The medication record is not current and is not is appropriate for reference in new instances. */
    Inactive,
}
impl ::core::str::FromStr for MedicationStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicationStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Display for MedicationStatusCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in Error",
            Self::Inactive => "Inactive",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicationStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicationStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicationStatusCodes> for Coding {
    fn from(code: MedicationStatusCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medication-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicationStatusCodes> for CodeableConcept {
    fn from(code: MedicationStatusCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicinalProductDomain](http://hl7.org/fhir/ValueSet/medicinal-product-domain)**. Applicable domain for this product (e.g. human, veterinary).\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicinalProductDomain {
    /** **Human**

Human use. Product intended for use with humans */
    Human,
    /** **HumanAndVeterinary**

Human and Veterinary use. Product intended for use with both humans and animals */
    HumanAndVeterinary,
    /** **Veterinary**

Veterinary use. Product intended for use with animals */
    Veterinary,
}
impl ::core::str::FromStr for MedicinalProductDomain {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Human" => Ok(Self::Human),
            "HumanAndVeterinary" => Ok(Self::HumanAndVeterinary),
            "Veterinary" => Ok(Self::Veterinary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicinalProductDomain {
    fn as_ref(&self) -> &str {
        match self {
            Self::Human => "Human",
            Self::HumanAndVeterinary => "HumanAndVeterinary",
            Self::Veterinary => "Veterinary",
        }
    }
}
impl ::std::fmt::Display for MedicinalProductDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Human => "Human use",
            Self::HumanAndVeterinary => "Human and Veterinary use",
            Self::Veterinary => "Veterinary use",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicinalProductDomain {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicinalProductDomain {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicinalProductDomain> for Coding {
    fn from(code: MedicinalProductDomain) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medicinal-product-domain".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicinalProductDomain> for CodeableConcept {
    fn from(code: MedicinalProductDomain) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicinalProductPackageType](http://hl7.org/fhir/ValueSet/medicinal-product-package-type)**. Types of medicinal product packs\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicinalProductPackageType {
    /** **100000073490**

Ampoule. */
    N100000073490,
    /** **100000073491**

Applicator. */
    N100000073491,
    /** **100000073492**

Automatic injection device. */
    N100000073492,
    /** **100000073493**

Bag. */
    N100000073493,
    /** **100000073494**

Balling gun. */
    N100000073494,
    /** **100000073495**

Barrel. */
    N100000073495,
    /** **100000073496**

Blister. */
    N100000073496,
    /** **100000073497**

Bottle. */
    N100000073497,
    /** **100000073498**

Box. */
    N100000073498,
    /** **100000073547**

Sachet. */
    N100000073547,
    /** **100000073563**

Vial. */
    N100000073563,
    /** **100000143555**

Pack. */
    N100000143555,
}
impl ::core::str::FromStr for MedicinalProductPackageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073490" => Ok(Self::N100000073490),
            "100000073491" => Ok(Self::N100000073491),
            "100000073492" => Ok(Self::N100000073492),
            "100000073493" => Ok(Self::N100000073493),
            "100000073494" => Ok(Self::N100000073494),
            "100000073495" => Ok(Self::N100000073495),
            "100000073496" => Ok(Self::N100000073496),
            "100000073497" => Ok(Self::N100000073497),
            "100000073498" => Ok(Self::N100000073498),
            "100000073547" => Ok(Self::N100000073547),
            "100000073563" => Ok(Self::N100000073563),
            "100000143555" => Ok(Self::N100000143555),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicinalProductPackageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073490 => "100000073490",
            Self::N100000073491 => "100000073491",
            Self::N100000073492 => "100000073492",
            Self::N100000073493 => "100000073493",
            Self::N100000073494 => "100000073494",
            Self::N100000073495 => "100000073495",
            Self::N100000073496 => "100000073496",
            Self::N100000073497 => "100000073497",
            Self::N100000073498 => "100000073498",
            Self::N100000073547 => "100000073547",
            Self::N100000073563 => "100000073563",
            Self::N100000143555 => "100000143555",
        }
    }
}
impl ::std::fmt::Display for MedicinalProductPackageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000073490 => "Ampoule",
            Self::N100000073491 => "Applicator",
            Self::N100000073492 => "Automatic injection device",
            Self::N100000073493 => "Bag",
            Self::N100000073494 => "Balling gun",
            Self::N100000073495 => "Barrel",
            Self::N100000073496 => "Blister",
            Self::N100000073497 => "Bottle",
            Self::N100000073498 => "Box",
            Self::N100000073547 => "Sachet",
            Self::N100000073563 => "Vial",
            Self::N100000143555 => "Pack",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicinalProductPackageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicinalProductPackageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicinalProductPackageType> for Coding {
    fn from(code: MedicinalProductPackageType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicinal-product-package-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicinalProductPackageType> for CodeableConcept {
    fn from(code: MedicinalProductPackageType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MedicinalProductType](http://hl7.org/fhir/ValueSet/medicinal-product-type)**. Overall defining type of this Medicinal Product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicinalProductType {
    /** **InvestigationalProduct**

Investigational Medicinal Product. An investigational medicinal product. */
    InvestigationalProduct,
    /** **MedicinalProduct**

Medicinal Product. A standard medicinal product. */
    MedicinalProduct,
}
impl ::core::str::FromStr for MedicinalProductType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "InvestigationalProduct" => Ok(Self::InvestigationalProduct),
            "MedicinalProduct" => Ok(Self::MedicinalProduct),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicinalProductType {
    fn as_ref(&self) -> &str {
        match self {
            Self::InvestigationalProduct => "InvestigationalProduct",
            Self::MedicinalProduct => "MedicinalProduct",
        }
    }
}
impl ::std::fmt::Display for MedicinalProductType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::InvestigationalProduct => "Investigational Medicinal Product",
            Self::MedicinalProduct => "Medicinal Product",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MedicinalProductType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicinalProductType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MedicinalProductType> for Coding {
    fn from(code: MedicinalProductType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/medicinal-product-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MedicinalProductType> for CodeableConcept {
    fn from(code: MedicinalProductType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MessageEvent](http://hl7.org/fhir/message-events)**. One of the message events defined as part of this version of FHIR.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MessageEvent {
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for MessageEvent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for MessageEvent {
    fn as_ref(&self) -> &str {
        match self {
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for MessageEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MessageEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageEvent> for Coding {
    fn from(code: MessageEvent) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/message-events".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MessageEvent> for CodeableConcept {
    fn from(code: MessageEvent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MessageSignificanceCategory](http://hl7.org/fhir/ValueSet/message-significance-category)**. The impact of the content of a message.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MessageSignificanceCategory {
    /** **consequence**

Consequence. The message represents/requests a change that should not be processed more than once; e.g., making a booking for an appointment. */
    Consequence,
    /** **currency**

Currency. The message represents a response to query for current information. Retrospective processing is wrong and/or wasteful. */
    Currency,
    /** **notification**

Notification. The content is not necessarily intended to be current, and it can be reprocessed, though there may be version issues created by processing old notifications. */
    Notification,
}
impl ::core::str::FromStr for MessageSignificanceCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "consequence" => Ok(Self::Consequence),
            "currency" => Ok(Self::Currency),
            "notification" => Ok(Self::Notification),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageSignificanceCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consequence => "consequence",
            Self::Currency => "currency",
            Self::Notification => "notification",
        }
    }
}
impl ::std::fmt::Display for MessageSignificanceCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Consequence => "Consequence",
            Self::Currency => "Currency",
            Self::Notification => "Notification",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MessageSignificanceCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageSignificanceCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageSignificanceCategory> for Coding {
    fn from(code: MessageSignificanceCategory) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/message-significance-category".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MessageSignificanceCategory> for CodeableConcept {
    fn from(code: MessageSignificanceCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MessageTransport](http://hl7.org/fhir/ValueSet/message-transport)**. The protocol used for message transport.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MessageTransport {
    /** **ftp**

FTP. The application sends or receives messages using File Transfer Protocol. */
    Ftp,
    /** **http**

HTTP. The application sends or receives messages using HTTP POST (may be over http: or https:). */
    Http,
    /** **mllp**

MLLP. The application sends or receives messages using HL7's Minimal Lower Level Protocol. */
    Mllp,
}
impl ::core::str::FromStr for MessageTransport {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ftp" => Ok(Self::Ftp),
            "http" => Ok(Self::Http),
            "mllp" => Ok(Self::Mllp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageTransport {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ftp => "ftp",
            Self::Http => "http",
            Self::Mllp => "mllp",
        }
    }
}
impl ::std::fmt::Display for MessageTransport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Ftp => "FTP",
            Self::Http => "HTTP",
            Self::Mllp => "MLLP",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MessageTransport {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageTransport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageTransport> for Coding {
    fn from(code: MessageTransport) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/message-transport".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MessageTransport> for CodeableConcept {
    fn from(code: MessageTransport) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[MessageheaderResponseRequest](http://hl7.org/fhir/ValueSet/messageheader-response-request)**. HL7-defined table of codes which identify conditions under which acknowledgments are required to be returned in response to a message.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MessageheaderResponseRequest {
    /** **always**

Always. initiator expects a response for this message. */
    Always,
    /** **never**

Never. initiator does not expect a response. */
    Never,
    /** **on-error**

Error/reject conditions only. initiator expects a response only if in error. */
    OnError,
    /** **on-success**

Successful completion only. initiator expects a response only if successful. */
    OnSuccess,
}
impl ::core::str::FromStr for MessageheaderResponseRequest {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "always" => Ok(Self::Always),
            "never" => Ok(Self::Never),
            "on-error" => Ok(Self::OnError),
            "on-success" => Ok(Self::OnSuccess),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageheaderResponseRequest {
    fn as_ref(&self) -> &str {
        match self {
            Self::Always => "always",
            Self::Never => "never",
            Self::OnError => "on-error",
            Self::OnSuccess => "on-success",
        }
    }
}
impl ::std::fmt::Display for MessageheaderResponseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Always => "Always",
            Self::Never => "Never",
            Self::OnError => "Error/reject conditions only",
            Self::OnSuccess => "Successful completion only",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for MessageheaderResponseRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageheaderResponseRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<MessageheaderResponseRequest> for Coding {
    fn from(code: MessageheaderResponseRequest) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/messageheader-response-request".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<MessageheaderResponseRequest> for CodeableConcept {
    fn from(code: MessageheaderResponseRequest) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[NameUse](http://hl7.org/fhir/ValueSet/name-use)**. The use of a human name.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NameUse {
    /** **anonymous**

Anonymous. Anonymous assigned name, alias, or pseudonym (used to protect a person's identity for privacy reasons). */
    Anonymous,
    /** **maiden**

Name changed for Marriage. A name used prior to changing name because of marriage. This name use is for use by applications that collect and store names that were used prior to a marriage. Marriage naming customs vary greatly around the world, and are constantly changing. This term is not gender specific. The use of this term does not imply any particular history for a person's name. */
    Maiden,
    /** **nickname**

Nickname. A name that is used to address the person in an informal manner, but is not part of their formal or usual name. */
    Nickname,
    /** **official**

Official. The formal name as registered in an official (government) registry, but which name might not be commonly used. May be called "legal name". */
    Official,
    /** **old**

Old. This name is no longer in use (or was never correct, but retained for records). */
    Old,
    /** **temp**

Temp. A temporary name. Name.period can provide more detailed information. This may also be used for temporary names assigned at birth or in emergency situations. */
    Temp,
    /** **usual**

Usual. Known as/conventional/the one you normally use. */
    Usual,
}
impl ::core::str::FromStr for NameUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "anonymous" => Ok(Self::Anonymous),
            "maiden" => Ok(Self::Maiden),
            "nickname" => Ok(Self::Nickname),
            "official" => Ok(Self::Official),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "usual" => Ok(Self::Usual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NameUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Anonymous => "anonymous",
            Self::Maiden => "maiden",
            Self::Nickname => "nickname",
            Self::Official => "official",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Usual => "usual",
        }
    }
}
impl ::std::fmt::Display for NameUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Anonymous => "Anonymous",
            Self::Maiden => "Name changed for Marriage",
            Self::Nickname => "Nickname",
            Self::Official => "Official",
            Self::Old => "Old",
            Self::Temp => "Temp",
            Self::Usual => "Usual",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for NameUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NameUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NameUse> for Coding {
    fn from(code: NameUse) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/name-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<NameUse> for CodeableConcept {
    fn from(code: NameUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[NamingSystemIdentifierType](http://hl7.org/fhir/ValueSet/namingsystem-identifier-type)**. Identifies the style of unique identifier used to identify a namespace.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NamingSystemIdentifierType {
    /** **iri-stem**

IRI stem. An IRI string that can be prepended to the code to obtain a concept IRI for RDF applications. This should be a valid, absolute IRI as defined in RFC 3987. See rdf.html#iri-stem for details on how this value may be used. */
    IriStem,
    /** **oid**

OID. An ISO object identifier; e.g. 1.2.3.4.5. */
    Oid,
    /** **other**

Other. Some other type of unique identifier; e.g. HL7-assigned reserved string such as LN for LOINC. */
    Other,
    /** **uri**

URI. A uniform resource identifier (ideally a URL - uniform resource locator); e.g. http://unitsofmeasure.org. */
    Uri,
    /** **uuid**

UUID. A universally unique identifier of the form a5afddf4-e880-459b-876e-e4591b0acc11. */
    Uuid,
    /** **v2csmnemonic**

V2CSMNemonic. A short string published by HL7 for use in the V2 family of standsrds to idenfify a code system in the V12 coded data types CWE, CNE, and CF. The code values are also published by HL7 at http://www.hl7.org/Special/committees/vocab/table_0396/index.cfm */
    V2Csmnemonic,
}
impl ::core::str::FromStr for NamingSystemIdentifierType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "iri-stem" => Ok(Self::IriStem),
            "oid" => Ok(Self::Oid),
            "other" => Ok(Self::Other),
            "uri" => Ok(Self::Uri),
            "uuid" => Ok(Self::Uuid),
            "v2csmnemonic" => Ok(Self::V2Csmnemonic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NamingSystemIdentifierType {
    fn as_ref(&self) -> &str {
        match self {
            Self::IriStem => "iri-stem",
            Self::Oid => "oid",
            Self::Other => "other",
            Self::Uri => "uri",
            Self::Uuid => "uuid",
            Self::V2Csmnemonic => "v2csmnemonic",
        }
    }
}
impl ::std::fmt::Display for NamingSystemIdentifierType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::IriStem => "IRI stem",
            Self::Oid => "OID",
            Self::Other => "Other",
            Self::Uri => "URI",
            Self::Uuid => "UUID",
            Self::V2Csmnemonic => "V2CSMNemonic",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for NamingSystemIdentifierType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NamingSystemIdentifierType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NamingSystemIdentifierType> for Coding {
    fn from(code: NamingSystemIdentifierType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/namingsystem-identifier-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<NamingSystemIdentifierType> for CodeableConcept {
    fn from(code: NamingSystemIdentifierType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[NamingSystemType](http://hl7.org/fhir/ValueSet/namingsystem-type)**. Identifies the purpose of the naming system.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NamingSystemType {
    /** **codesystem**

Code System. The naming system is used to define concepts and symbols to represent those concepts; e.g. UCUM, LOINC, NDC code, local lab codes, etc. */
    Codesystem,
    /** **identifier**

Identifier. The naming system is used to manage identifiers (e.g. license numbers, order numbers, etc.). */
    Identifier,
    /** **root**

Root. The naming system is used as the root for other identifiers and naming systems. */
    Root,
}
impl ::core::str::FromStr for NamingSystemType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "codesystem" => Ok(Self::Codesystem),
            "identifier" => Ok(Self::Identifier),
            "root" => Ok(Self::Root),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NamingSystemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Codesystem => "codesystem",
            Self::Identifier => "identifier",
            Self::Root => "root",
        }
    }
}
impl ::std::fmt::Display for NamingSystemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Codesystem => "Code System",
            Self::Identifier => "Identifier",
            Self::Root => "Root",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for NamingSystemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NamingSystemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NamingSystemType> for Coding {
    fn from(code: NamingSystemType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/namingsystem-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<NamingSystemType> for CodeableConcept {
    fn from(code: NamingSystemType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[NarrativeStatus](http://hl7.org/fhir/ValueSet/narrative-status)**. The status of a resource narrative.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NarrativeStatus {
    /** **additional**

Additional. The contents of the narrative may contain additional information not found in the structured data. Note that there is no computable way to determine what the extra information is, other than by human inspection. */
    Additional,
    /** **empty**

Empty. The contents of the narrative are some equivalent of "No human-readable text provided in this case". */
    Empty,
    /** **extensions**

Extensions. The contents of the narrative are entirely generated from the core elements in the content and some of the content is generated from extensions. The narrative SHALL reflect the impact of all modifier extensions. */
    Extensions,
    /** **generated**

Generated. The contents of the narrative are entirely generated from the core elements in the content. */
    Generated,
}
impl ::core::str::FromStr for NarrativeStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "additional" => Ok(Self::Additional),
            "empty" => Ok(Self::Empty),
            "extensions" => Ok(Self::Extensions),
            "generated" => Ok(Self::Generated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NarrativeStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Additional => "additional",
            Self::Empty => "empty",
            Self::Extensions => "extensions",
            Self::Generated => "generated",
        }
    }
}
impl ::std::fmt::Display for NarrativeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Additional => "Additional",
            Self::Empty => "Empty",
            Self::Extensions => "Extensions",
            Self::Generated => "Generated",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for NarrativeStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NarrativeStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NarrativeStatus> for Coding {
    fn from(code: NarrativeStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/narrative-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<NarrativeStatus> for CodeableConcept {
    fn from(code: NarrativeStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[NoteType](http://hl7.org/fhir/ValueSet/note-type)**. The presentation types of notes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NoteType {
    /** **display**

Display. Display the note. */
    Display,
    /** **print**

Print (Form). Print the note on the form. */
    Print,
    /** **printoper**

Print (Operator). Print the note for the operator. */
    Printoper,
}
impl ::core::str::FromStr for NoteType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "display" => Ok(Self::Display),
            "print" => Ok(Self::Print),
            "printoper" => Ok(Self::Printoper),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NoteType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Display => "display",
            Self::Print => "print",
            Self::Printoper => "printoper",
        }
    }
}
impl ::std::fmt::Display for NoteType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Display => "Display",
            Self::Print => "Print (Form)",
            Self::Printoper => "Print (Operator)",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for NoteType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NoteType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NoteType> for Coding {
    fn from(code: NoteType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/note-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<NoteType> for CodeableConcept {
    fn from(code: NoteType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[NutritionProductStatus](http://hl7.org/fhir/ValueSet/nutritionproduct-status)**. Codes identifying the lifecycle stage of a product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NutritionProductStatus {
    /** **active**

Active. The product can be used. */
    Active,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **inactive**

Inactive. The product is not expected or allowed to be used. */
    Inactive,
}
impl ::core::str::FromStr for NutritionProductStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NutritionProductStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl ::std::fmt::Display for NutritionProductStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in Error",
            Self::Inactive => "Inactive",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for NutritionProductStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NutritionProductStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<NutritionProductStatus> for Coding {
    fn from(code: NutritionProductStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/nutritionproduct-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<NutritionProductStatus> for CodeableConcept {
    fn from(code: NutritionProductStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ObservationDataType](http://hl7.org/fhir/ValueSet/permitted-data-type)**. Permitted data type for observation value.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ObservationDataType {
    /** **CodeableConcept**

CodeableConcept. A coded concept from a reference terminology and/or text. */
    CodeableConcept,
    /** **Period**

Period. A time range defined by start and end date/time. */
    Period,
    /** **Quantity**

Quantity. A measured amount. */
    Quantity,
    /** **Range**

Range. A set of values bounded by low and high. */
    Range,
    /** **Ratio**

Ratio. A ratio of two Quantity values - a numerator and a denominator. */
    Ratio,
    /** **SampledData**

SampledData. A series of measurements taken by a device. */
    SampledData,
    /** **boolean**

boolean. true or false. */
    Boolean,
    /** **dateTime**

dateTime. A date, date-time or partial date (e.g. just year or year + month) as used in human communication. */
    DateTime,
    /** **integer**

integer. A signed integer. */
    Integer,
    /** **string**

string. A sequence of Unicode characters. */
    String,
    /** **time**

time. A time during the day, in the format hh:mm:ss. */
    Time,
}
impl ::core::str::FromStr for ObservationDataType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CodeableConcept" => Ok(Self::CodeableConcept),
            "Period" => Ok(Self::Period),
            "Quantity" => Ok(Self::Quantity),
            "Range" => Ok(Self::Range),
            "Ratio" => Ok(Self::Ratio),
            "SampledData" => Ok(Self::SampledData),
            "boolean" => Ok(Self::Boolean),
            "dateTime" => Ok(Self::DateTime),
            "integer" => Ok(Self::Integer),
            "string" => Ok(Self::String),
            "time" => Ok(Self::Time),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationDataType {
    fn as_ref(&self) -> &str {
        match self {
            Self::CodeableConcept => "CodeableConcept",
            Self::Period => "Period",
            Self::Quantity => "Quantity",
            Self::Range => "Range",
            Self::Ratio => "Ratio",
            Self::SampledData => "SampledData",
            Self::Boolean => "boolean",
            Self::DateTime => "dateTime",
            Self::Integer => "integer",
            Self::String => "string",
            Self::Time => "time",
        }
    }
}
impl ::std::fmt::Display for ObservationDataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::CodeableConcept => "CodeableConcept",
            Self::Period => "Period",
            Self::Quantity => "Quantity",
            Self::Range => "Range",
            Self::Ratio => "Ratio",
            Self::SampledData => "SampledData",
            Self::Boolean => "boolean",
            Self::DateTime => "dateTime",
            Self::Integer => "integer",
            Self::String => "string",
            Self::Time => "time",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ObservationDataType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationDataType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationDataType> for Coding {
    fn from(code: ObservationDataType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/permitted-data-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ObservationDataType> for CodeableConcept {
    fn from(code: ObservationDataType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ObservationRangeCategory](http://hl7.org/fhir/ValueSet/observation-range-category)**. Codes identifying the category of observation range.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ObservationRangeCategory {
    /** **absolute**

absolute range. Absolute Range for Ordinal and Continuous Observations. Results outside this range are not possible. */
    Absolute,
    /** **critical**

critical range. Critical Range for Ordinal and Continuous Observations. Results outside this range are critical. */
    Critical,
    /** **reference**

reference range. Reference (Normal) Range for Ordinal and Continuous Observations. */
    Reference,
}
impl ::core::str::FromStr for ObservationRangeCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "absolute" => Ok(Self::Absolute),
            "critical" => Ok(Self::Critical),
            "reference" => Ok(Self::Reference),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationRangeCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Absolute => "absolute",
            Self::Critical => "critical",
            Self::Reference => "reference",
        }
    }
}
impl ::std::fmt::Display for ObservationRangeCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Absolute => "absolute range",
            Self::Critical => "critical range",
            Self::Reference => "reference range",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ObservationRangeCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationRangeCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationRangeCategory> for Coding {
    fn from(code: ObservationRangeCategory) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/observation-range-category".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ObservationRangeCategory> for CodeableConcept {
    fn from(code: ObservationRangeCategory) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ObservationReferenceRangeNormalValue](http://hl7.org/fhir/ValueSet/observation-referencerange-normalvalue)**. Codes that describe the normal value in the reference range.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ObservationReferenceRangeNormalValue {
    /** **absent**

Absent. The expected normal value for the observation is absent. */
    Absent,
    /** **negative**

Negative. The expected normal value for the observation is negative. */
    Negative,
}
impl ::core::str::FromStr for ObservationReferenceRangeNormalValue {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "absent" => Ok(Self::Absent),
            "negative" => Ok(Self::Negative),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationReferenceRangeNormalValue {
    fn as_ref(&self) -> &str {
        match self {
            Self::Absent => "absent",
            Self::Negative => "negative",
        }
    }
}
impl ::std::fmt::Display for ObservationReferenceRangeNormalValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Absent => "Absent",
            Self::Negative => "Negative",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ObservationReferenceRangeNormalValue {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationReferenceRangeNormalValue {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationReferenceRangeNormalValue> for Coding {
    fn from(code: ObservationReferenceRangeNormalValue) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/observation-referencerange-normalvalue"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ObservationReferenceRangeNormalValue> for CodeableConcept {
    fn from(code: ObservationReferenceRangeNormalValue) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ObservationStatus](http://hl7.org/fhir/ValueSet/observation-status)**. Codes providing the status of an observation.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ObservationStatus {
    /** **amended**

Amended. Subsequent to being Final, the observation has been modified subsequent.  This includes updates/new information and corrections. */
    Amended,
    /** **cancelled**

Cancelled. The observation is unavailable because the measurement was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** **corrected**

Corrected. Subsequent to being Final, the observation has been modified to correct an error in the test result. */
    Corrected,
    /** **entered-in-error**

Entered in Error. The observation has been withdrawn following previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **final**

Final. The observation is complete and there are no further actions needed. Additional information such "released", "signed", etc. would be represented using [Provenance](provenance.html) which provides not only the act but also the actors and dates and other related data. These act states would be associated with an observation status of `preliminary` until they are all completed and then a status of `final` would be applied. */
    Final,
    /** **preliminary**

Preliminary. This is an initial or interim observation: data may be incomplete or unverified. */
    Preliminary,
    /** **registered**

Registered. The existence of the observation is registered, but there is no result yet available. */
    Registered,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for ObservationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "cancelled" => Ok(Self::Cancelled),
            "corrected" => Ok(Self::Corrected),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "preliminary" => Ok(Self::Preliminary),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Cancelled => "cancelled",
            Self::Corrected => "corrected",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Preliminary => "preliminary",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for ObservationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Amended => "Amended",
            Self::Cancelled => "Cancelled",
            Self::Corrected => "Corrected",
            Self::EnteredInError => "Entered in Error",
            Self::Final => "Final",
            Self::Preliminary => "Preliminary",
            Self::Registered => "Registered",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ObservationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ObservationStatus> for Coding {
    fn from(code: ObservationStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/observation-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ObservationStatus> for CodeableConcept {
    fn from(code: ObservationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[OperationKind](http://hl7.org/fhir/ValueSet/operation-kind)**. Whether an operation is a normal operation or a query.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum OperationKind {
    /** **operation**

Operation. This operation is invoked as an operation. */
    Operation,
    /** **query**

Query. This operation is a named query, invoked using the search mechanism. */
    Query,
}
impl ::core::str::FromStr for OperationKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "operation" => Ok(Self::Operation),
            "query" => Ok(Self::Query),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OperationKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Operation => "operation",
            Self::Query => "query",
        }
    }
}
impl ::std::fmt::Display for OperationKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Operation => "Operation",
            Self::Query => "Query",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for OperationKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OperationKind> for Coding {
    fn from(code: OperationKind) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/operation-kind".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<OperationKind> for CodeableConcept {
    fn from(code: OperationKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[OperationOutcomeCodes](http://hl7.org/fhir/operation-outcome)**. Operation Outcome codes for translatable phrases used by FHIR test servers (see Implementation file translations.xml)\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum OperationOutcomeCodes {
    /** **DELETE_MULTIPLE_MATCHES**

Error: Multiple matches exist for the conditional delete. */
    DeleteMultipleMatches,
    /** **MSG_AUTH_REQUIRED**

You must authenticate before you can use this service. */
    MsgAuthRequired,
    /** **MSG_BAD_FORMAT**

Bad Syntax: "%s" must be a %s'. */
    MsgBadFormat,
    /** **MSG_BAD_SYNTAX**

Bad Syntax in %s. */
    MsgBadSyntax,
    /** **MSG_CANT_PARSE_CONTENT**

Unable to parse feed (entry content type = "%s"). */
    MsgCantParseContent,
    /** **MSG_CANT_PARSE_ROOT**

Unable to parse feed (root element name = "%s"). */
    MsgCantParseRoot,
    /** **MSG_CREATED**

New resource created. */
    MsgCreated,
    /** **MSG_DATE_FORMAT**

The Date value %s is not in the correct format (Xml Date Format required). */
    MsgDateFormat,
    /** **MSG_DELETED**

This resource has been deleted. */
    MsgDeleted,
    /** **MSG_DELETED_DONE**

Resource deleted. */
    MsgDeletedDone,
    /** **MSG_DELETED_ID**

The resource "%s" has been deleted. */
    MsgDeletedId,
    /** **MSG_DUPLICATE_ID**

Duplicate Id %s for resource type %s. */
    MsgDuplicateId,
    /** **MSG_ERROR_PARSING**

Error parsing resource Xml (%s). */
    MsgErrorParsing,
    /** **MSG_ID_INVALID**

Id "%s" has an invalid character "%s". */
    MsgIdInvalid,
    /** **MSG_ID_TOO_LONG**

Id "%s" too long (length limit 36). */
    MsgIdTooLong,
    /** **MSG_INVALID_ID**

Id not accepted. */
    MsgInvalidId,
    /** **MSG_JSON_OBJECT**

Json Source for a resource should start with an object. */
    MsgJsonObject,
    /** **MSG_LOCAL_FAIL**

Unable to resolve local reference to resource %s. */
    MsgLocalFail,
    /** **MSG_NO_EXIST**

Resource Id "%s" does not exist. */
    MsgNoExist,
    /** **MSG_NO_MATCH**

No Resource found matching the query "%s". */
    MsgNoMatch,
    /** **MSG_NO_MODULE**

No module could be found to handle the request "%s". */
    MsgNoModule,
    /** **MSG_NO_SUMMARY**

No Summary for this resource. */
    MsgNoSummary,
    /** **MSG_OP_NOT_ALLOWED**

Operation %s not allowed for resource %s (due to local configuration). */
    MsgOpNotAllowed,
    /** **MSG_PARAM_CHAINED**

Unknown chained parameter name "%s". */
    MsgParamChained,
    /** **MSG_PARAM_INVALID**

Parameter "%s" content is invalid. */
    MsgParamInvalid,
    /** **MSG_PARAM_MODIFIER_INVALID**

Parameter "%s" modifier is invalid. */
    MsgParamModifierInvalid,
    /** **MSG_PARAM_NO_REPEAT**

Parameter "%s" is not allowed to repeat. */
    MsgParamNoRepeat,
    /** **MSG_PARAM_UNKNOWN**

Parameter "%s" not understood. */
    MsgParamUnknown,
    /** **MSG_REMOTE_FAIL**

Unable to resolve local reference to resource %s. */
    MsgRemoteFail,
    /** **MSG_RESOURCE_EXAMPLE_PROTECTED**

Resources with identity "example" cannot be deleted (for testing/training purposes). */
    MsgResourceExampleProtected,
    /** **MSG_RESOURCE_ID_FAIL**

unable to allocate resource id. */
    MsgResourceIdFail,
    /** **MSG_RESOURCE_ID_MISMATCH**

Resource Id Mismatch. */
    MsgResourceIdMismatch,
    /** **MSG_RESOURCE_ID_MISSING**

Resource Id Missing. */
    MsgResourceIdMissing,
    /** **MSG_RESOURCE_NOT_ALLOWED**

Not allowed to submit a resource for this operation. */
    MsgResourceNotAllowed,
    /** **MSG_RESOURCE_REQUIRED**

A resource is required. */
    MsgResourceRequired,
    /** **MSG_RESOURCE_TYPE_MISMATCH**

Resource Type Mismatch. */
    MsgResourceTypeMismatch,
    /** **MSG_SORT_UNKNOWN**

Unknown sort parameter name "%s". */
    MsgSortUnknown,
    /** **MSG_TRANSACTION_DUPLICATE_ID**

Duplicate Identifier in transaction: %s. */
    MsgTransactionDuplicateId,
    /** **MSG_TRANSACTION_MISSING_ID**

Missing Identifier in transaction - an entry.id must be provided. */
    MsgTransactionMissingId,
    /** **MSG_UNHANDLED_NODE_TYPE**

Unhandled xml node type "%s". */
    MsgUnhandledNodeType,
    /** **MSG_UNKNOWN_CONTENT**

Unknown Content (%s) at %s. */
    MsgUnknownContent,
    /** **MSG_UNKNOWN_OPERATION**

unknown FHIR http operation. */
    MsgUnknownOperation,
    /** **MSG_UNKNOWN_TYPE**

Resource Type "%s" not recognised. */
    MsgUnknownType,
    /** **MSG_UPDATED**

existing resource updated. */
    MsgUpdated,
    /** **MSG_VERSION_AWARE**

Version aware updates are required for this resource. */
    MsgVersionAware,
    /** **MSG_VERSION_AWARE_CONFLICT**

Update Conflict (server current version = "%s", client version referenced = "%s"). */
    MsgVersionAwareConflict,
    /** **MSG_VERSION_AWARE_URL**

Version specific URL not recognised. */
    MsgVersionAwareUrl,
    /** **MSG_WRONG_NS**

This does not appear to be a FHIR element or resource (wrong namespace "%s"). */
    MsgWrongNs,
    /** **SEARCH_MULTIPLE**

Error: Multiple matches exist for %s search parameters "%s". */
    SearchMultiple,
    /** **SEARCH_NONE**

Error: no processable search found for %s search parameters "%s". */
    SearchNone,
    /** **UPDATE_MULTIPLE_MATCHES**

Error: Multiple matches exist for the conditional update. */
    UpdateMultipleMatches,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for OperationOutcomeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "DELETE_MULTIPLE_MATCHES" => Ok(Self::DeleteMultipleMatches),
            "MSG_AUTH_REQUIRED" => Ok(Self::MsgAuthRequired),
            "MSG_BAD_FORMAT" => Ok(Self::MsgBadFormat),
            "MSG_BAD_SYNTAX" => Ok(Self::MsgBadSyntax),
            "MSG_CANT_PARSE_CONTENT" => Ok(Self::MsgCantParseContent),
            "MSG_CANT_PARSE_ROOT" => Ok(Self::MsgCantParseRoot),
            "MSG_CREATED" => Ok(Self::MsgCreated),
            "MSG_DATE_FORMAT" => Ok(Self::MsgDateFormat),
            "MSG_DELETED" => Ok(Self::MsgDeleted),
            "MSG_DELETED_DONE" => Ok(Self::MsgDeletedDone),
            "MSG_DELETED_ID" => Ok(Self::MsgDeletedId),
            "MSG_DUPLICATE_ID" => Ok(Self::MsgDuplicateId),
            "MSG_ERROR_PARSING" => Ok(Self::MsgErrorParsing),
            "MSG_ID_INVALID" => Ok(Self::MsgIdInvalid),
            "MSG_ID_TOO_LONG" => Ok(Self::MsgIdTooLong),
            "MSG_INVALID_ID" => Ok(Self::MsgInvalidId),
            "MSG_JSON_OBJECT" => Ok(Self::MsgJsonObject),
            "MSG_LOCAL_FAIL" => Ok(Self::MsgLocalFail),
            "MSG_NO_EXIST" => Ok(Self::MsgNoExist),
            "MSG_NO_MATCH" => Ok(Self::MsgNoMatch),
            "MSG_NO_MODULE" => Ok(Self::MsgNoModule),
            "MSG_NO_SUMMARY" => Ok(Self::MsgNoSummary),
            "MSG_OP_NOT_ALLOWED" => Ok(Self::MsgOpNotAllowed),
            "MSG_PARAM_CHAINED" => Ok(Self::MsgParamChained),
            "MSG_PARAM_INVALID" => Ok(Self::MsgParamInvalid),
            "MSG_PARAM_MODIFIER_INVALID" => Ok(Self::MsgParamModifierInvalid),
            "MSG_PARAM_NO_REPEAT" => Ok(Self::MsgParamNoRepeat),
            "MSG_PARAM_UNKNOWN" => Ok(Self::MsgParamUnknown),
            "MSG_REMOTE_FAIL" => Ok(Self::MsgRemoteFail),
            "MSG_RESOURCE_EXAMPLE_PROTECTED" => Ok(Self::MsgResourceExampleProtected),
            "MSG_RESOURCE_ID_FAIL" => Ok(Self::MsgResourceIdFail),
            "MSG_RESOURCE_ID_MISMATCH" => Ok(Self::MsgResourceIdMismatch),
            "MSG_RESOURCE_ID_MISSING" => Ok(Self::MsgResourceIdMissing),
            "MSG_RESOURCE_NOT_ALLOWED" => Ok(Self::MsgResourceNotAllowed),
            "MSG_RESOURCE_REQUIRED" => Ok(Self::MsgResourceRequired),
            "MSG_RESOURCE_TYPE_MISMATCH" => Ok(Self::MsgResourceTypeMismatch),
            "MSG_SORT_UNKNOWN" => Ok(Self::MsgSortUnknown),
            "MSG_TRANSACTION_DUPLICATE_ID" => Ok(Self::MsgTransactionDuplicateId),
            "MSG_TRANSACTION_MISSING_ID" => Ok(Self::MsgTransactionMissingId),
            "MSG_UNHANDLED_NODE_TYPE" => Ok(Self::MsgUnhandledNodeType),
            "MSG_UNKNOWN_CONTENT" => Ok(Self::MsgUnknownContent),
            "MSG_UNKNOWN_OPERATION" => Ok(Self::MsgUnknownOperation),
            "MSG_UNKNOWN_TYPE" => Ok(Self::MsgUnknownType),
            "MSG_UPDATED" => Ok(Self::MsgUpdated),
            "MSG_VERSION_AWARE" => Ok(Self::MsgVersionAware),
            "MSG_VERSION_AWARE_CONFLICT" => Ok(Self::MsgVersionAwareConflict),
            "MSG_VERSION_AWARE_URL" => Ok(Self::MsgVersionAwareUrl),
            "MSG_WRONG_NS" => Ok(Self::MsgWrongNs),
            "SEARCH_MULTIPLE" => Ok(Self::SearchMultiple),
            "SEARCH_NONE" => Ok(Self::SearchNone),
            "UPDATE_MULTIPLE_MATCHES" => Ok(Self::UpdateMultipleMatches),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for OperationOutcomeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::DeleteMultipleMatches => "DELETE_MULTIPLE_MATCHES",
            Self::MsgAuthRequired => "MSG_AUTH_REQUIRED",
            Self::MsgBadFormat => "MSG_BAD_FORMAT",
            Self::MsgBadSyntax => "MSG_BAD_SYNTAX",
            Self::MsgCantParseContent => "MSG_CANT_PARSE_CONTENT",
            Self::MsgCantParseRoot => "MSG_CANT_PARSE_ROOT",
            Self::MsgCreated => "MSG_CREATED",
            Self::MsgDateFormat => "MSG_DATE_FORMAT",
            Self::MsgDeleted => "MSG_DELETED",
            Self::MsgDeletedDone => "MSG_DELETED_DONE",
            Self::MsgDeletedId => "MSG_DELETED_ID",
            Self::MsgDuplicateId => "MSG_DUPLICATE_ID",
            Self::MsgErrorParsing => "MSG_ERROR_PARSING",
            Self::MsgIdInvalid => "MSG_ID_INVALID",
            Self::MsgIdTooLong => "MSG_ID_TOO_LONG",
            Self::MsgInvalidId => "MSG_INVALID_ID",
            Self::MsgJsonObject => "MSG_JSON_OBJECT",
            Self::MsgLocalFail => "MSG_LOCAL_FAIL",
            Self::MsgNoExist => "MSG_NO_EXIST",
            Self::MsgNoMatch => "MSG_NO_MATCH",
            Self::MsgNoModule => "MSG_NO_MODULE",
            Self::MsgNoSummary => "MSG_NO_SUMMARY",
            Self::MsgOpNotAllowed => "MSG_OP_NOT_ALLOWED",
            Self::MsgParamChained => "MSG_PARAM_CHAINED",
            Self::MsgParamInvalid => "MSG_PARAM_INVALID",
            Self::MsgParamModifierInvalid => "MSG_PARAM_MODIFIER_INVALID",
            Self::MsgParamNoRepeat => "MSG_PARAM_NO_REPEAT",
            Self::MsgParamUnknown => "MSG_PARAM_UNKNOWN",
            Self::MsgRemoteFail => "MSG_REMOTE_FAIL",
            Self::MsgResourceExampleProtected => "MSG_RESOURCE_EXAMPLE_PROTECTED",
            Self::MsgResourceIdFail => "MSG_RESOURCE_ID_FAIL",
            Self::MsgResourceIdMismatch => "MSG_RESOURCE_ID_MISMATCH",
            Self::MsgResourceIdMissing => "MSG_RESOURCE_ID_MISSING",
            Self::MsgResourceNotAllowed => "MSG_RESOURCE_NOT_ALLOWED",
            Self::MsgResourceRequired => "MSG_RESOURCE_REQUIRED",
            Self::MsgResourceTypeMismatch => "MSG_RESOURCE_TYPE_MISMATCH",
            Self::MsgSortUnknown => "MSG_SORT_UNKNOWN",
            Self::MsgTransactionDuplicateId => "MSG_TRANSACTION_DUPLICATE_ID",
            Self::MsgTransactionMissingId => "MSG_TRANSACTION_MISSING_ID",
            Self::MsgUnhandledNodeType => "MSG_UNHANDLED_NODE_TYPE",
            Self::MsgUnknownContent => "MSG_UNKNOWN_CONTENT",
            Self::MsgUnknownOperation => "MSG_UNKNOWN_OPERATION",
            Self::MsgUnknownType => "MSG_UNKNOWN_TYPE",
            Self::MsgUpdated => "MSG_UPDATED",
            Self::MsgVersionAware => "MSG_VERSION_AWARE",
            Self::MsgVersionAwareConflict => "MSG_VERSION_AWARE_CONFLICT",
            Self::MsgVersionAwareUrl => "MSG_VERSION_AWARE_URL",
            Self::MsgWrongNs => "MSG_WRONG_NS",
            Self::SearchMultiple => "SEARCH_MULTIPLE",
            Self::SearchNone => "SEARCH_NONE",
            Self::UpdateMultipleMatches => "UPDATE_MULTIPLE_MATCHES",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for OperationOutcomeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::DeleteMultipleMatches => {
                "Error: Multiple matches exist for the conditional delete"
            }
            Self::MsgAuthRequired => {
                "You must authenticate before you can use this service"
            }
            Self::MsgBadFormat => "Bad Syntax: \"%s\" must be a %s'",
            Self::MsgBadSyntax => "Bad Syntax in %s",
            Self::MsgCantParseContent => {
                "Unable to parse feed (entry content type = \"%s\")"
            }
            Self::MsgCantParseRoot => "Unable to parse feed (root element name = \"%s\")",
            Self::MsgCreated => "New resource created",
            Self::MsgDateFormat => {
                "The Date value %s is not in the correct format (Xml Date Format required)"
            }
            Self::MsgDeleted => "This resource has been deleted",
            Self::MsgDeletedDone => "Resource deleted",
            Self::MsgDeletedId => "The resource \"%s\" has been deleted",
            Self::MsgDuplicateId => "Duplicate Id %s for resource type %s",
            Self::MsgErrorParsing => "Error parsing resource Xml (%s)",
            Self::MsgIdInvalid => "Id \"%s\" has an invalid character \"%s\"",
            Self::MsgIdTooLong => "Id \"%s\" too long (length limit 36)",
            Self::MsgInvalidId => "Id not accepted",
            Self::MsgJsonObject => {
                "Json Source for a resource should start with an object"
            }
            Self::MsgLocalFail => "Unable to resolve local reference to resource %s",
            Self::MsgNoExist => "Resource Id \"%s\" does not exist",
            Self::MsgNoMatch => "No Resource found matching the query \"%s\"",
            Self::MsgNoModule => "No module could be found to handle the request \"%s\"",
            Self::MsgNoSummary => "No Summary for this resource",
            Self::MsgOpNotAllowed => {
                "Operation %s not allowed for resource %s (due to local configuration)"
            }
            Self::MsgParamChained => "Unknown chained parameter name \"%s\"",
            Self::MsgParamInvalid => "Parameter \"%s\" content is invalid",
            Self::MsgParamModifierInvalid => "Parameter \"%s\" modifier is invalid",
            Self::MsgParamNoRepeat => "Parameter \"%s\" is not allowed to repeat",
            Self::MsgParamUnknown => "Parameter \"%s\" not understood",
            Self::MsgRemoteFail => "Unable to resolve local reference to resource %s",
            Self::MsgResourceExampleProtected => {
                "Resources with identity \"example\" cannot be deleted (for testing/training purposes)"
            }
            Self::MsgResourceIdFail => "unable to allocate resource id",
            Self::MsgResourceIdMismatch => "Resource Id Mismatch",
            Self::MsgResourceIdMissing => "Resource Id Missing",
            Self::MsgResourceNotAllowed => {
                "Not allowed to submit a resource for this operation"
            }
            Self::MsgResourceRequired => "A resource is required",
            Self::MsgResourceTypeMismatch => "Resource Type Mismatch",
            Self::MsgSortUnknown => "Unknown sort parameter name \"%s\"",
            Self::MsgTransactionDuplicateId => "Duplicate Identifier in transaction: %s",
            Self::MsgTransactionMissingId => {
                "Missing Identifier in transaction - an entry.id must be provided"
            }
            Self::MsgUnhandledNodeType => "Unhandled xml node type \"%s\"",
            Self::MsgUnknownContent => "Unknown Content (%s) at %s",
            Self::MsgUnknownOperation => "unknown FHIR http operation",
            Self::MsgUnknownType => "Resource Type \"%s\" not recognised",
            Self::MsgUpdated => "existing resource updated",
            Self::MsgVersionAware => {
                "Version aware updates are required for this resource"
            }
            Self::MsgVersionAwareConflict => {
                "Update Conflict (server current version = \"%s\", client version referenced = \"%s\")"
            }
            Self::MsgVersionAwareUrl => "Version specific URL not recognised",
            Self::MsgWrongNs => {
                "This does not appear to be a FHIR element or resource (wrong namespace \"%s\")"
            }
            Self::SearchMultiple => {
                "Error: Multiple matches exist for %s search parameters \"%s\""
            }
            Self::SearchNone => {
                "Error: no processable search found for %s search parameters \"%s\""
            }
            Self::UpdateMultipleMatches => {
                "Error: Multiple matches exist for the conditional update"
            }
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for OperationOutcomeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationOutcomeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OperationOutcomeCodes> for Coding {
    fn from(code: OperationOutcomeCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/operation-outcome".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<OperationOutcomeCodes> for CodeableConcept {
    fn from(code: OperationOutcomeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[OperationParameterScope](http://hl7.org/fhir/ValueSet/operation-parameter-scope)**. Indicates that a parameter applies when the operation is being invoked at the specified level\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum OperationParameterScope {
    /** **instance**

Instance. This is a parameter that can be used at the instance level. */
    Instance,
    /** **system**

System. This is a parameter that can be used at the system level. */
    System,
    /** **type**

Type. This is a parameter that can be used at the type level. */
    Type,
}
impl ::core::str::FromStr for OperationParameterScope {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "instance" => Ok(Self::Instance),
            "system" => Ok(Self::System),
            "type" => Ok(Self::Type),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OperationParameterScope {
    fn as_ref(&self) -> &str {
        match self {
            Self::Instance => "instance",
            Self::System => "system",
            Self::Type => "type",
        }
    }
}
impl ::std::fmt::Display for OperationParameterScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Instance => "Instance",
            Self::System => "System",
            Self::Type => "Type",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for OperationParameterScope {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationParameterScope {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OperationParameterScope> for Coding {
    fn from(code: OperationParameterScope) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/operation-parameter-scope".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<OperationParameterScope> for CodeableConcept {
    fn from(code: OperationParameterScope) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[OperationParameterUse](http://hl7.org/fhir/ValueSet/operation-parameter-use)**. Whether an operation parameter is an input or an output parameter.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum OperationParameterUse {
    /** **in**

In. This is an input parameter. */
    In,
    /** **out**

Out. This is an output parameter. */
    Out,
}
impl ::core::str::FromStr for OperationParameterUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OperationParameterUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::In => "in",
            Self::Out => "out",
        }
    }
}
impl ::std::fmt::Display for OperationParameterUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::In => "In",
            Self::Out => "Out",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for OperationParameterUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationParameterUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OperationParameterUse> for Coding {
    fn from(code: OperationParameterUse) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/operation-parameter-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<OperationParameterUse> for CodeableConcept {
    fn from(code: OperationParameterUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[OrganizationAffiliationRole](http://hl7.org/fhir/organization-role)**. This example value set defines a set of codes that can be used to indicate the role of one Organization in relation to its affiliation with another.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum OrganizationAffiliationRole {
    /** **HIE/HIO**

HIE/HIO. An organization that facilitates electronic clinical data exchange between entities */
    HieHio,
    /** **agency**

Agency. An organization such as a public health agency, community/social services provider, etc. */
    Agency,
    /** **diagnostics**

Diagnostics. An organization providing diagnostic testing/laboratory services */
    Diagnostics,
    /** **member**

Member. A type of non-ownership relationship between entities (encompasses partnerships, collaboration, joint ventures, etc.) */
    Member,
    /** **payer**

Payer. An organization providing reimbursement, payment, or related services */
    Payer,
    /** **provider**

Provider. An organization that delivers care services (e.g. hospitals, clinics, community and social services, etc.). */
    Provider,
    /** **research**

Research. An organization providing research-related services such as conducting research, recruiting research participants, analyzing data, etc. */
    Research,
    /** **supplier**

Supplier. An organization that provides medical supplies (e.g. medical devices, equipment, pharmaceutical products, etc.) */
    Supplier,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for OrganizationAffiliationRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "HIE/HIO" => Ok(Self::HieHio),
            "agency" => Ok(Self::Agency),
            "diagnostics" => Ok(Self::Diagnostics),
            "member" => Ok(Self::Member),
            "payer" => Ok(Self::Payer),
            "provider" => Ok(Self::Provider),
            "research" => Ok(Self::Research),
            "supplier" => Ok(Self::Supplier),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for OrganizationAffiliationRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::HieHio => "HIE/HIO",
            Self::Agency => "agency",
            Self::Diagnostics => "diagnostics",
            Self::Member => "member",
            Self::Payer => "payer",
            Self::Provider => "provider",
            Self::Research => "research",
            Self::Supplier => "supplier",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for OrganizationAffiliationRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::HieHio => "HIE/HIO",
            Self::Agency => "Agency",
            Self::Diagnostics => "Diagnostics",
            Self::Member => "Member",
            Self::Payer => "Payer",
            Self::Provider => "Provider",
            Self::Research => "Research",
            Self::Supplier => "Supplier",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for OrganizationAffiliationRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OrganizationAffiliationRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OrganizationAffiliationRole> for Coding {
    fn from(code: OrganizationAffiliationRole) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/organization-role".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<OrganizationAffiliationRole> for CodeableConcept {
    fn from(code: OrganizationAffiliationRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[OrientationType](http://hl7.org/fhir/ValueSet/orientation-type)**. Type for orientation.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum OrientationType {
    /** **antisense**

Antisense orientation of referenceSeq. Antisense orientation of reference sequence. */
    Antisense,
    /** **sense**

Sense orientation of referenceSeq. Sense orientation of reference sequence. */
    Sense,
}
impl ::core::str::FromStr for OrientationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "antisense" => Ok(Self::Antisense),
            "sense" => Ok(Self::Sense),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OrientationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Antisense => "antisense",
            Self::Sense => "sense",
        }
    }
}
impl ::std::fmt::Display for OrientationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Antisense => "Antisense orientation of referenceSeq",
            Self::Sense => "Sense orientation of referenceSeq",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for OrientationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OrientationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<OrientationType> for Coding {
    fn from(code: OrientationType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/orientation-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<OrientationType> for CodeableConcept {
    fn from(code: OrientationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PackageMaterial](http://hl7.org/fhir/ValueSet/package-material)**. A material used in the construction of packages and their components.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PackageMaterial {
    /** **200000003200**

Aluminium. */
    N200000003200,
    /** **200000003201**

Cyclic Olefin Copolymer. */
    N200000003201,
    /** **200000003202**

Epoxyphenol. */
    N200000003202,
    /** **200000003203**

Glass. */
    N200000003203,
    /** **200000003204**

Glass type I. */
    N200000003204,
    /** **200000003205**

Glass type II. */
    N200000003205,
    /** **200000003206**

Glass type III. */
    N200000003206,
    /** **200000003207**

Paper. */
    N200000003207,
    /** **200000003208**

Plastic. */
    N200000003208,
    /** **200000003209**

PolyAmide. */
    N200000003209,
    /** **200000003210**

Orientated PolyAmide. */
    N200000003210,
    /** **200000003211**

PolyCarbonate. */
    N200000003211,
    /** **200000003212**

PolyChloroTriFluoroEthylene. */
    N200000003212,
    /** **200000003213**

Polyester. */
    N200000003213,
    /** **200000003214**

PolyEthylene. */
    N200000003214,
    /** **200000003215**

High Density PolyEthylene. */
    N200000003215,
    /** **200000003216**

Low Density PolyEthylene. */
    N200000003216,
    /** **200000003217**

PolyEthylene TerePhthalate. */
    N200000003217,
    /** **200000003218**

Polyolefin. */
    N200000003218,
    /** **200000003219**

PolyPropylene. */
    N200000003219,
    /** **200000003220**

PolyStyrene. */
    N200000003220,
    /** **200000003221**

PolyVinyl Acetate. */
    N200000003221,
    /** **200000003222**

PolyVinyl Chloride. */
    N200000003222,
    /** **200000003223**

Plasticised PolyVinyl Chloride. */
    N200000003223,
    /** **200000003224**

Non-plasticised PolyVinyl Chloride / Unplasticised PolyVinyl Chloride. */
    N200000003224,
    /** **200000003225**

PolyVinylidene Chloride. */
    N200000003225,
    /** **200000003226**

Rubber. */
    N200000003226,
    /** **200000003227**

Silicone oil. */
    N200000003227,
    /** **200000003228**

Silicone elastomer. */
    N200000003228,
    /** **200000003229**

Steel. */
    N200000003229,
    /** **200000003529**

Cardboard. */
    N200000003529,
    /** **200000012514**

PolyAcryloNitrile. */
    N200000012514,
    /** **200000012515**

Ethylene acrylic acid copolymer. */
    N200000012515,
    /** **200000012521**

Ethylene meta-acrylic acid. */
    N200000012521,
    /** **200000012522**

Ethylene-Vinyl Alcohol copolymer. */
    N200000012522,
    /** **200000012523**

PolyVinylidene Fluoride. */
    N200000012523,
    /** **200000012524**

Medium Density PolyEthylene. */
    N200000012524,
    /** **200000012538**

Syndiotactic Polypropylene. */
    N200000012538,
    /** **200000015521**

PolyEthylene copolymer. */
    N200000015521,
    /** **200000023330**

Expanded Polyethylene. */
    N200000023330,
    /** **200000023332**

Cyclic Olefin Polymer. */
    N200000023332,
    /** **200000025255**

Silica gel. */
    N200000025255,
    /** **200000025257**

Linear Low Density PolyEthylene. */
    N200000025257,
}
impl ::core::str::FromStr for PackageMaterial {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "200000003200" => Ok(Self::N200000003200),
            "200000003201" => Ok(Self::N200000003201),
            "200000003202" => Ok(Self::N200000003202),
            "200000003203" => Ok(Self::N200000003203),
            "200000003204" => Ok(Self::N200000003204),
            "200000003205" => Ok(Self::N200000003205),
            "200000003206" => Ok(Self::N200000003206),
            "200000003207" => Ok(Self::N200000003207),
            "200000003208" => Ok(Self::N200000003208),
            "200000003209" => Ok(Self::N200000003209),
            "200000003210" => Ok(Self::N200000003210),
            "200000003211" => Ok(Self::N200000003211),
            "200000003212" => Ok(Self::N200000003212),
            "200000003213" => Ok(Self::N200000003213),
            "200000003214" => Ok(Self::N200000003214),
            "200000003215" => Ok(Self::N200000003215),
            "200000003216" => Ok(Self::N200000003216),
            "200000003217" => Ok(Self::N200000003217),
            "200000003218" => Ok(Self::N200000003218),
            "200000003219" => Ok(Self::N200000003219),
            "200000003220" => Ok(Self::N200000003220),
            "200000003221" => Ok(Self::N200000003221),
            "200000003222" => Ok(Self::N200000003222),
            "200000003223" => Ok(Self::N200000003223),
            "200000003224" => Ok(Self::N200000003224),
            "200000003225" => Ok(Self::N200000003225),
            "200000003226" => Ok(Self::N200000003226),
            "200000003227" => Ok(Self::N200000003227),
            "200000003228" => Ok(Self::N200000003228),
            "200000003229" => Ok(Self::N200000003229),
            "200000003529" => Ok(Self::N200000003529),
            "200000012514" => Ok(Self::N200000012514),
            "200000012515" => Ok(Self::N200000012515),
            "200000012521" => Ok(Self::N200000012521),
            "200000012522" => Ok(Self::N200000012522),
            "200000012523" => Ok(Self::N200000012523),
            "200000012524" => Ok(Self::N200000012524),
            "200000012538" => Ok(Self::N200000012538),
            "200000015521" => Ok(Self::N200000015521),
            "200000023330" => Ok(Self::N200000023330),
            "200000023332" => Ok(Self::N200000023332),
            "200000025255" => Ok(Self::N200000025255),
            "200000025257" => Ok(Self::N200000025257),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackageMaterial {
    fn as_ref(&self) -> &str {
        match self {
            Self::N200000003200 => "200000003200",
            Self::N200000003201 => "200000003201",
            Self::N200000003202 => "200000003202",
            Self::N200000003203 => "200000003203",
            Self::N200000003204 => "200000003204",
            Self::N200000003205 => "200000003205",
            Self::N200000003206 => "200000003206",
            Self::N200000003207 => "200000003207",
            Self::N200000003208 => "200000003208",
            Self::N200000003209 => "200000003209",
            Self::N200000003210 => "200000003210",
            Self::N200000003211 => "200000003211",
            Self::N200000003212 => "200000003212",
            Self::N200000003213 => "200000003213",
            Self::N200000003214 => "200000003214",
            Self::N200000003215 => "200000003215",
            Self::N200000003216 => "200000003216",
            Self::N200000003217 => "200000003217",
            Self::N200000003218 => "200000003218",
            Self::N200000003219 => "200000003219",
            Self::N200000003220 => "200000003220",
            Self::N200000003221 => "200000003221",
            Self::N200000003222 => "200000003222",
            Self::N200000003223 => "200000003223",
            Self::N200000003224 => "200000003224",
            Self::N200000003225 => "200000003225",
            Self::N200000003226 => "200000003226",
            Self::N200000003227 => "200000003227",
            Self::N200000003228 => "200000003228",
            Self::N200000003229 => "200000003229",
            Self::N200000003529 => "200000003529",
            Self::N200000012514 => "200000012514",
            Self::N200000012515 => "200000012515",
            Self::N200000012521 => "200000012521",
            Self::N200000012522 => "200000012522",
            Self::N200000012523 => "200000012523",
            Self::N200000012524 => "200000012524",
            Self::N200000012538 => "200000012538",
            Self::N200000015521 => "200000015521",
            Self::N200000023330 => "200000023330",
            Self::N200000023332 => "200000023332",
            Self::N200000025255 => "200000025255",
            Self::N200000025257 => "200000025257",
        }
    }
}
impl ::std::fmt::Display for PackageMaterial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N200000003200 => "Aluminium",
            Self::N200000003201 => "Cyclic Olefin Copolymer",
            Self::N200000003202 => "Epoxyphenol",
            Self::N200000003203 => "Glass",
            Self::N200000003204 => "Glass type I",
            Self::N200000003205 => "Glass type II",
            Self::N200000003206 => "Glass type III",
            Self::N200000003207 => "Paper",
            Self::N200000003208 => "Plastic",
            Self::N200000003209 => "PolyAmide",
            Self::N200000003210 => "Orientated PolyAmide",
            Self::N200000003211 => "PolyCarbonate",
            Self::N200000003212 => "PolyChloroTriFluoroEthylene",
            Self::N200000003213 => "Polyester",
            Self::N200000003214 => "PolyEthylene",
            Self::N200000003215 => "High Density PolyEthylene",
            Self::N200000003216 => "Low Density PolyEthylene",
            Self::N200000003217 => "PolyEthylene TerePhthalate",
            Self::N200000003218 => "Polyolefin",
            Self::N200000003219 => "PolyPropylene",
            Self::N200000003220 => "PolyStyrene",
            Self::N200000003221 => "PolyVinyl Acetate",
            Self::N200000003222 => "PolyVinyl Chloride",
            Self::N200000003223 => "Plasticised PolyVinyl Chloride",
            Self::N200000003224 => {
                "Non-plasticised PolyVinyl Chloride / Unplasticised PolyVinyl Chloride"
            }
            Self::N200000003225 => "PolyVinylidene Chloride",
            Self::N200000003226 => "Rubber",
            Self::N200000003227 => "Silicone oil",
            Self::N200000003228 => "Silicone elastomer",
            Self::N200000003229 => "Steel",
            Self::N200000003529 => "Cardboard",
            Self::N200000012514 => "PolyAcryloNitrile",
            Self::N200000012515 => "Ethylene acrylic acid copolymer",
            Self::N200000012521 => "Ethylene meta-acrylic acid",
            Self::N200000012522 => "Ethylene-Vinyl Alcohol copolymer",
            Self::N200000012523 => "PolyVinylidene Fluoride",
            Self::N200000012524 => "Medium Density PolyEthylene",
            Self::N200000012538 => "Syndiotactic Polypropylene",
            Self::N200000015521 => "PolyEthylene copolymer",
            Self::N200000023330 => "Expanded Polyethylene",
            Self::N200000023332 => "Cyclic Olefin Polymer",
            Self::N200000025255 => "Silica gel",
            Self::N200000025257 => "Linear Low Density PolyEthylene",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PackageMaterial {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackageMaterial {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PackageMaterial> for Coding {
    fn from(code: PackageMaterial) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/package-material".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PackageMaterial> for CodeableConcept {
    fn from(code: PackageMaterial) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PackageType](http://hl7.org/fhir/ValueSet/package-type)**. A high level categorisation of a package.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PackageType {
    /** **MedicinalProductPack**

Medicinal product pack. */
    MedicinalProductPack,
    /** **RawMaterialPackage**

Raw material package. */
    RawMaterialPackage,
    /** **Shipping-TransportContainer**

Shipping or transport container. */
    ShippingTransportContainer,
}
impl ::core::str::FromStr for PackageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "MedicinalProductPack" => Ok(Self::MedicinalProductPack),
            "RawMaterialPackage" => Ok(Self::RawMaterialPackage),
            "Shipping-TransportContainer" => Ok(Self::ShippingTransportContainer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MedicinalProductPack => "MedicinalProductPack",
            Self::RawMaterialPackage => "RawMaterialPackage",
            Self::ShippingTransportContainer => "Shipping-TransportContainer",
        }
    }
}
impl ::std::fmt::Display for PackageType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::MedicinalProductPack => "Medicinal product pack",
            Self::RawMaterialPackage => "Raw material package",
            Self::ShippingTransportContainer => "Shipping or transport container",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PackageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PackageType> for Coding {
    fn from(code: PackageType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/package-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PackageType> for CodeableConcept {
    fn from(code: PackageType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PackagingType](http://hl7.org/fhir/ValueSet/packaging-type)**. A type of packaging.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PackagingType {
    /** **100000073490**

Ampoule. */
    N100000073490,
    /** **100000073491**

Applicator. */
    N100000073491,
    /** **100000073492**

Automatic injection device. */
    N100000073492,
    /** **100000073493**

Bag. */
    N100000073493,
    /** **100000073494**

Balling gun. */
    N100000073494,
    /** **100000073495**

Barrel. */
    N100000073495,
    /** **100000073496**

Blister. */
    N100000073496,
    /** **100000073497**

Bottle. */
    N100000073497,
    /** **100000073498**

Box. */
    N100000073498,
    /** **100000073499**

Brush. */
    N100000073499,
    /** **100000073500**

Brush applicator. */
    N100000073500,
    /** **100000073501**

Cannula. */
    N100000073501,
    /** **100000073502**

Cap. */
    N100000073502,
    /** **100000073503**

Cartridge. */
    N100000073503,
    /** **100000073504**

Child-resistant closure. */
    N100000073504,
    /** **100000073505**

Cup. */
    N100000073505,
    /** **100000073506**

Dabbing applicator. */
    N100000073506,
    /** **100000073507**

Dart. */
    N100000073507,
    /** **100000073508**

Dredging applicator. */
    N100000073508,
    /** **100000073509**

Dredging container. */
    N100000073509,
    /** **100000073510**

Drench gun. */
    N100000073510,
    /** **100000073511**

Dropper applicator. */
    N100000073511,
    /** **100000073512**

Dropper container. */
    N100000073512,
    /** **100000073513**

Fixed cryogenic vessel. */
    N100000073513,
    /** **100000073514**

Gas cylinder. */
    N100000073514,
    /** **100000073515**

High pressure transdermal delivery device. */
    N100000073515,
    /** **100000073516**

Implanter. */
    N100000073516,
    /** **100000073517**

Inhaler. */
    N100000073517,
    /** **100000073518**

In-ovo injection device. */
    N100000073518,
    /** **100000073519**

Injection needle. */
    N100000073519,
    /** **100000073520**

Injection syringe. */
    N100000073520,
    /** **100000073521**

Internal graduated calibration chamber. */
    N100000073521,
    /** **100000073522**

Intramammary syringe. */
    N100000073522,
    /** **100000073523**

Jar. */
    N100000073523,
    /** **100000073524**

Measuring device. */
    N100000073524,
    /** **100000073525**

Measuring spoon. */
    N100000073525,
    /** **100000073526**

Metering pump. */
    N100000073526,
    /** **100000073527**

Metering valve. */
    N100000073527,
    /** **100000073528**

Mobile cryogenic vessel. */
    N100000073528,
    /** **100000073529**

Mouthpiece. */
    N100000073529,
    /** **100000073530**

Multidose container. */
    N100000073530,
    /** **100000073531**

Multidose container with airless pump. */
    N100000073531,
    /** **100000073532**

Multipuncturer. */
    N100000073532,
    /** **100000073533**

Nasal applicator. */
    N100000073533,
    /** **100000073534**

Nebuliser. */
    N100000073534,
    /** **100000073535**

Needle applicator. */
    N100000073535,
    /** **100000073536**

Nozzle. */
    N100000073536,
    /** **100000073537**

Oral syringe. */
    N100000073537,
    /** **100000073538**

Pipette. */
    N100000073538,
    /** **100000073539**

Pipette applicator. */
    N100000073539,
    /** **100000073540**

Pouch. */
    N100000073540,
    /** **100000073541**

Pour-on container. */
    N100000073541,
    /** **100000073542**

Pre-filled gastroenteral tube. */
    N100000073542,
    /** **100000073543**

Pre-filled pen. */
    N100000073543,
    /** **100000073544**

Pre-filled syringe. */
    N100000073544,
    /** **100000073545**

Pressurised container. */
    N100000073545,
    /** **100000073546**

Prick test applicator. */
    N100000073546,
    /** **100000073547**

Sachet. */
    N100000073547,
    /** **100000073548**

Scarifier. */
    N100000073548,
    /** **100000073549**

Screw cap. */
    N100000073549,
    /** **100000073550**

Single-dose container. */
    N100000073550,
    /** **100000073551**

Spatula. */
    N100000073551,
    /** **100000073552**

Spot-on applicator. */
    N100000073552,
    /** **100000073553**

Spray container. */
    N100000073553,
    /** **100000073554**

Spray pump. */
    N100000073554,
    /** **100000073555**

Spray valve. */
    N100000073555,
    /** **100000073556**

Stab vaccinator. */
    N100000073556,
    /** **100000073557**

Stopper. */
    N100000073557,
    /** **100000073558**

Straw. */
    N100000073558,
    /** **100000073559**

Strip. */
    N100000073559,
    /** **100000073560**

Tablet container. */
    N100000073560,
    /** **100000073561**

Tube. */
    N100000073561,
    /** **100000073562**

Vaginal sponge applicator. */
    N100000073562,
    /** **100000073563**

Vial. */
    N100000073563,
    /** **100000075664**

Administration system. */
    N100000075664,
    /** **100000116195**

Calendar package. */
    N100000116195,
    /** **100000116196**

Needle-free injector. */
    N100000116196,
    /** **100000116197**

Roll-on container. */
    N100000116197,
    /** **100000125779**

Multidose container with pump. */
    N100000125779,
    /** **100000137702**

Container. */
    N100000137702,
    /** **100000137703**

Oral applicator. */
    N100000137703,
    /** **100000143554**

Multidose container with metering pump. */
    N100000143554,
    /** **100000143555**

Pack. */
    N100000143555,
    /** **100000163233**

disk. */
    N100000163233,
    /** **100000163234**

plunger. */
    N100000163234,
    /** **100000164143**

infusion port. */
    N100000164143,
    /** **100000166980**

Valve. */
    N100000166980,
    /** **100000169899**

Jerrycan. */
    N100000169899,
    /** **100000173982**

Oral applicator. */
    N100000173982,
    /** **100000173983**

Dose dispenser. */
    N100000173983,
    /** **100000174066**

Unit-dose blister. */
    N100000174066,
    /** **100000174067**

Pre-filled injector. */
    N100000174067,
    /** **100000174068**

Pre-filled oral syringe. */
    N100000174068,
    /** **100000174069**

Pre-filled oral applicator. */
    N100000174069,
    /** **100000174070**

Dose-dispenser cartridge. */
    N100000174070,
    /** **200000005068**

Pen. */
    N200000005068,
    /** **200000005585**

Wrapper. */
    N200000005585,
    /** **200000010647**

Lid. */
    N200000010647,
    /** **200000011726**

Capsule for opening. */
    N200000011726,
    /** **200000012539**

Child-resistant sachet. */
    N200000012539,
    /** **200000013191**

Tamper-evident closure. */
    N200000013191,
    /** **200000024874**

Tablet tube. */
    N200000024874,
}
impl ::core::str::FromStr for PackagingType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073490" => Ok(Self::N100000073490),
            "100000073491" => Ok(Self::N100000073491),
            "100000073492" => Ok(Self::N100000073492),
            "100000073493" => Ok(Self::N100000073493),
            "100000073494" => Ok(Self::N100000073494),
            "100000073495" => Ok(Self::N100000073495),
            "100000073496" => Ok(Self::N100000073496),
            "100000073497" => Ok(Self::N100000073497),
            "100000073498" => Ok(Self::N100000073498),
            "100000073499" => Ok(Self::N100000073499),
            "100000073500" => Ok(Self::N100000073500),
            "100000073501" => Ok(Self::N100000073501),
            "100000073502" => Ok(Self::N100000073502),
            "100000073503" => Ok(Self::N100000073503),
            "100000073504" => Ok(Self::N100000073504),
            "100000073505" => Ok(Self::N100000073505),
            "100000073506" => Ok(Self::N100000073506),
            "100000073507" => Ok(Self::N100000073507),
            "100000073508" => Ok(Self::N100000073508),
            "100000073509" => Ok(Self::N100000073509),
            "100000073510" => Ok(Self::N100000073510),
            "100000073511" => Ok(Self::N100000073511),
            "100000073512" => Ok(Self::N100000073512),
            "100000073513" => Ok(Self::N100000073513),
            "100000073514" => Ok(Self::N100000073514),
            "100000073515" => Ok(Self::N100000073515),
            "100000073516" => Ok(Self::N100000073516),
            "100000073517" => Ok(Self::N100000073517),
            "100000073518" => Ok(Self::N100000073518),
            "100000073519" => Ok(Self::N100000073519),
            "100000073520" => Ok(Self::N100000073520),
            "100000073521" => Ok(Self::N100000073521),
            "100000073522" => Ok(Self::N100000073522),
            "100000073523" => Ok(Self::N100000073523),
            "100000073524" => Ok(Self::N100000073524),
            "100000073525" => Ok(Self::N100000073525),
            "100000073526" => Ok(Self::N100000073526),
            "100000073527" => Ok(Self::N100000073527),
            "100000073528" => Ok(Self::N100000073528),
            "100000073529" => Ok(Self::N100000073529),
            "100000073530" => Ok(Self::N100000073530),
            "100000073531" => Ok(Self::N100000073531),
            "100000073532" => Ok(Self::N100000073532),
            "100000073533" => Ok(Self::N100000073533),
            "100000073534" => Ok(Self::N100000073534),
            "100000073535" => Ok(Self::N100000073535),
            "100000073536" => Ok(Self::N100000073536),
            "100000073537" => Ok(Self::N100000073537),
            "100000073538" => Ok(Self::N100000073538),
            "100000073539" => Ok(Self::N100000073539),
            "100000073540" => Ok(Self::N100000073540),
            "100000073541" => Ok(Self::N100000073541),
            "100000073542" => Ok(Self::N100000073542),
            "100000073543" => Ok(Self::N100000073543),
            "100000073544" => Ok(Self::N100000073544),
            "100000073545" => Ok(Self::N100000073545),
            "100000073546" => Ok(Self::N100000073546),
            "100000073547" => Ok(Self::N100000073547),
            "100000073548" => Ok(Self::N100000073548),
            "100000073549" => Ok(Self::N100000073549),
            "100000073550" => Ok(Self::N100000073550),
            "100000073551" => Ok(Self::N100000073551),
            "100000073552" => Ok(Self::N100000073552),
            "100000073553" => Ok(Self::N100000073553),
            "100000073554" => Ok(Self::N100000073554),
            "100000073555" => Ok(Self::N100000073555),
            "100000073556" => Ok(Self::N100000073556),
            "100000073557" => Ok(Self::N100000073557),
            "100000073558" => Ok(Self::N100000073558),
            "100000073559" => Ok(Self::N100000073559),
            "100000073560" => Ok(Self::N100000073560),
            "100000073561" => Ok(Self::N100000073561),
            "100000073562" => Ok(Self::N100000073562),
            "100000073563" => Ok(Self::N100000073563),
            "100000075664" => Ok(Self::N100000075664),
            "100000116195" => Ok(Self::N100000116195),
            "100000116196" => Ok(Self::N100000116196),
            "100000116197" => Ok(Self::N100000116197),
            "100000125779" => Ok(Self::N100000125779),
            "100000137702" => Ok(Self::N100000137702),
            "100000137703" => Ok(Self::N100000137703),
            "100000143554" => Ok(Self::N100000143554),
            "100000143555" => Ok(Self::N100000143555),
            "100000163233" => Ok(Self::N100000163233),
            "100000163234" => Ok(Self::N100000163234),
            "100000164143" => Ok(Self::N100000164143),
            "100000166980" => Ok(Self::N100000166980),
            "100000169899" => Ok(Self::N100000169899),
            "100000173982" => Ok(Self::N100000173982),
            "100000173983" => Ok(Self::N100000173983),
            "100000174066" => Ok(Self::N100000174066),
            "100000174067" => Ok(Self::N100000174067),
            "100000174068" => Ok(Self::N100000174068),
            "100000174069" => Ok(Self::N100000174069),
            "100000174070" => Ok(Self::N100000174070),
            "200000005068" => Ok(Self::N200000005068),
            "200000005585" => Ok(Self::N200000005585),
            "200000010647" => Ok(Self::N200000010647),
            "200000011726" => Ok(Self::N200000011726),
            "200000012539" => Ok(Self::N200000012539),
            "200000013191" => Ok(Self::N200000013191),
            "200000024874" => Ok(Self::N200000024874),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackagingType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073490 => "100000073490",
            Self::N100000073491 => "100000073491",
            Self::N100000073492 => "100000073492",
            Self::N100000073493 => "100000073493",
            Self::N100000073494 => "100000073494",
            Self::N100000073495 => "100000073495",
            Self::N100000073496 => "100000073496",
            Self::N100000073497 => "100000073497",
            Self::N100000073498 => "100000073498",
            Self::N100000073499 => "100000073499",
            Self::N100000073500 => "100000073500",
            Self::N100000073501 => "100000073501",
            Self::N100000073502 => "100000073502",
            Self::N100000073503 => "100000073503",
            Self::N100000073504 => "100000073504",
            Self::N100000073505 => "100000073505",
            Self::N100000073506 => "100000073506",
            Self::N100000073507 => "100000073507",
            Self::N100000073508 => "100000073508",
            Self::N100000073509 => "100000073509",
            Self::N100000073510 => "100000073510",
            Self::N100000073511 => "100000073511",
            Self::N100000073512 => "100000073512",
            Self::N100000073513 => "100000073513",
            Self::N100000073514 => "100000073514",
            Self::N100000073515 => "100000073515",
            Self::N100000073516 => "100000073516",
            Self::N100000073517 => "100000073517",
            Self::N100000073518 => "100000073518",
            Self::N100000073519 => "100000073519",
            Self::N100000073520 => "100000073520",
            Self::N100000073521 => "100000073521",
            Self::N100000073522 => "100000073522",
            Self::N100000073523 => "100000073523",
            Self::N100000073524 => "100000073524",
            Self::N100000073525 => "100000073525",
            Self::N100000073526 => "100000073526",
            Self::N100000073527 => "100000073527",
            Self::N100000073528 => "100000073528",
            Self::N100000073529 => "100000073529",
            Self::N100000073530 => "100000073530",
            Self::N100000073531 => "100000073531",
            Self::N100000073532 => "100000073532",
            Self::N100000073533 => "100000073533",
            Self::N100000073534 => "100000073534",
            Self::N100000073535 => "100000073535",
            Self::N100000073536 => "100000073536",
            Self::N100000073537 => "100000073537",
            Self::N100000073538 => "100000073538",
            Self::N100000073539 => "100000073539",
            Self::N100000073540 => "100000073540",
            Self::N100000073541 => "100000073541",
            Self::N100000073542 => "100000073542",
            Self::N100000073543 => "100000073543",
            Self::N100000073544 => "100000073544",
            Self::N100000073545 => "100000073545",
            Self::N100000073546 => "100000073546",
            Self::N100000073547 => "100000073547",
            Self::N100000073548 => "100000073548",
            Self::N100000073549 => "100000073549",
            Self::N100000073550 => "100000073550",
            Self::N100000073551 => "100000073551",
            Self::N100000073552 => "100000073552",
            Self::N100000073553 => "100000073553",
            Self::N100000073554 => "100000073554",
            Self::N100000073555 => "100000073555",
            Self::N100000073556 => "100000073556",
            Self::N100000073557 => "100000073557",
            Self::N100000073558 => "100000073558",
            Self::N100000073559 => "100000073559",
            Self::N100000073560 => "100000073560",
            Self::N100000073561 => "100000073561",
            Self::N100000073562 => "100000073562",
            Self::N100000073563 => "100000073563",
            Self::N100000075664 => "100000075664",
            Self::N100000116195 => "100000116195",
            Self::N100000116196 => "100000116196",
            Self::N100000116197 => "100000116197",
            Self::N100000125779 => "100000125779",
            Self::N100000137702 => "100000137702",
            Self::N100000137703 => "100000137703",
            Self::N100000143554 => "100000143554",
            Self::N100000143555 => "100000143555",
            Self::N100000163233 => "100000163233",
            Self::N100000163234 => "100000163234",
            Self::N100000164143 => "100000164143",
            Self::N100000166980 => "100000166980",
            Self::N100000169899 => "100000169899",
            Self::N100000173982 => "100000173982",
            Self::N100000173983 => "100000173983",
            Self::N100000174066 => "100000174066",
            Self::N100000174067 => "100000174067",
            Self::N100000174068 => "100000174068",
            Self::N100000174069 => "100000174069",
            Self::N100000174070 => "100000174070",
            Self::N200000005068 => "200000005068",
            Self::N200000005585 => "200000005585",
            Self::N200000010647 => "200000010647",
            Self::N200000011726 => "200000011726",
            Self::N200000012539 => "200000012539",
            Self::N200000013191 => "200000013191",
            Self::N200000024874 => "200000024874",
        }
    }
}
impl ::std::fmt::Display for PackagingType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000073490 => "Ampoule",
            Self::N100000073491 => "Applicator",
            Self::N100000073492 => "Automatic injection device",
            Self::N100000073493 => "Bag",
            Self::N100000073494 => "Balling gun",
            Self::N100000073495 => "Barrel",
            Self::N100000073496 => "Blister",
            Self::N100000073497 => "Bottle",
            Self::N100000073498 => "Box",
            Self::N100000073499 => "Brush",
            Self::N100000073500 => "Brush applicator",
            Self::N100000073501 => "Cannula",
            Self::N100000073502 => "Cap",
            Self::N100000073503 => "Cartridge",
            Self::N100000073504 => "Child-resistant closure",
            Self::N100000073505 => "Cup",
            Self::N100000073506 => "Dabbing applicator",
            Self::N100000073507 => "Dart",
            Self::N100000073508 => "Dredging applicator",
            Self::N100000073509 => "Dredging container",
            Self::N100000073510 => "Drench gun",
            Self::N100000073511 => "Dropper applicator",
            Self::N100000073512 => "Dropper container",
            Self::N100000073513 => "Fixed cryogenic vessel",
            Self::N100000073514 => "Gas cylinder",
            Self::N100000073515 => "High pressure transdermal delivery device",
            Self::N100000073516 => "Implanter",
            Self::N100000073517 => "Inhaler",
            Self::N100000073518 => "In-ovo injection device",
            Self::N100000073519 => "Injection needle",
            Self::N100000073520 => "Injection syringe",
            Self::N100000073521 => "Internal graduated calibration chamber",
            Self::N100000073522 => "Intramammary syringe",
            Self::N100000073523 => "Jar",
            Self::N100000073524 => "Measuring device",
            Self::N100000073525 => "Measuring spoon",
            Self::N100000073526 => "Metering pump",
            Self::N100000073527 => "Metering valve",
            Self::N100000073528 => "Mobile cryogenic vessel",
            Self::N100000073529 => "Mouthpiece",
            Self::N100000073530 => "Multidose container",
            Self::N100000073531 => "Multidose container with airless pump",
            Self::N100000073532 => "Multipuncturer",
            Self::N100000073533 => "Nasal applicator",
            Self::N100000073534 => "Nebuliser",
            Self::N100000073535 => "Needle applicator",
            Self::N100000073536 => "Nozzle",
            Self::N100000073537 => "Oral syringe",
            Self::N100000073538 => "Pipette",
            Self::N100000073539 => "Pipette applicator",
            Self::N100000073540 => "Pouch",
            Self::N100000073541 => "Pour-on container",
            Self::N100000073542 => "Pre-filled gastroenteral tube",
            Self::N100000073543 => "Pre-filled pen",
            Self::N100000073544 => "Pre-filled syringe",
            Self::N100000073545 => "Pressurised container",
            Self::N100000073546 => "Prick test applicator",
            Self::N100000073547 => "Sachet",
            Self::N100000073548 => "Scarifier",
            Self::N100000073549 => "Screw cap",
            Self::N100000073550 => "Single-dose container",
            Self::N100000073551 => "Spatula",
            Self::N100000073552 => "Spot-on applicator",
            Self::N100000073553 => "Spray container",
            Self::N100000073554 => "Spray pump",
            Self::N100000073555 => "Spray valve",
            Self::N100000073556 => "Stab vaccinator",
            Self::N100000073557 => "Stopper",
            Self::N100000073558 => "Straw",
            Self::N100000073559 => "Strip",
            Self::N100000073560 => "Tablet container",
            Self::N100000073561 => "Tube",
            Self::N100000073562 => "Vaginal sponge applicator",
            Self::N100000073563 => "Vial",
            Self::N100000075664 => "Administration system",
            Self::N100000116195 => "Calendar package",
            Self::N100000116196 => "Needle-free injector",
            Self::N100000116197 => "Roll-on container",
            Self::N100000125779 => "Multidose container with pump",
            Self::N100000137702 => "Container",
            Self::N100000137703 => "Oral applicator",
            Self::N100000143554 => "Multidose container with metering pump",
            Self::N100000143555 => "Pack",
            Self::N100000163233 => "disk",
            Self::N100000163234 => "plunger",
            Self::N100000164143 => "infusion port",
            Self::N100000166980 => "Valve",
            Self::N100000169899 => "Jerrycan",
            Self::N100000173982 => "Oral applicator",
            Self::N100000173983 => "Dose dispenser",
            Self::N100000174066 => "Unit-dose blister",
            Self::N100000174067 => "Pre-filled injector",
            Self::N100000174068 => "Pre-filled oral syringe",
            Self::N100000174069 => "Pre-filled oral applicator",
            Self::N100000174070 => "Dose-dispenser cartridge",
            Self::N200000005068 => "Pen",
            Self::N200000005585 => "Wrapper",
            Self::N200000010647 => "Lid",
            Self::N200000011726 => "Capsule for opening",
            Self::N200000012539 => "Child-resistant sachet",
            Self::N200000013191 => "Tamper-evident closure",
            Self::N200000024874 => "Tablet tube",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PackagingType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackagingType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PackagingType> for Coding {
    fn from(code: PackagingType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/packaging-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PackagingType> for CodeableConcept {
    fn from(code: PackagingType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ParticipationStatus](http://hl7.org/fhir/ValueSet/participationstatus)**. The Participation status of an appointment.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ParticipationStatus {
    /** **accepted**

Accepted. The participant has accepted the appointment. */
    Accepted,
    /** **declined**

Declined. The participant has declined the appointment and will not participate in the appointment. */
    Declined,
    /** **needs-action**

Needs Action. The participant needs to indicate if they accept the appointment by changing this status to one of the other statuses. */
    NeedsAction,
    /** **tentative**

Tentative. The participant has  tentatively accepted the appointment. This could be automatically created by a system and requires further processing before it can be accepted. There is no commitment that attendance will occur. */
    Tentative,
}
impl ::core::str::FromStr for ParticipationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "declined" => Ok(Self::Declined),
            "needs-action" => Ok(Self::NeedsAction),
            "tentative" => Ok(Self::Tentative),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ParticipationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Declined => "declined",
            Self::NeedsAction => "needs-action",
            Self::Tentative => "tentative",
        }
    }
}
impl ::std::fmt::Display for ParticipationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Accepted => "Accepted",
            Self::Declined => "Declined",
            Self::NeedsAction => "Needs Action",
            Self::Tentative => "Tentative",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ParticipationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ParticipationStatus> for Coding {
    fn from(code: ParticipationStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/participationstatus".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ParticipationStatus> for CodeableConcept {
    fn from(code: ParticipationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PatientMedicineChangeTypes](http://hl7.org/fhir/ValueSet/list-item-flag)**. Example Item Flags for the List Resource. In this case, these are the kind of flags that would be used on a medication list at the end of a consultation.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PatientMedicineChangeTypes {
    /** **01**

Unchanged. No change has been made to the status of this medicine item. */
    N01,
    /** **02**

Changed. The medicine item has changed. The change may be described in an extension (not defined yet) */
    N02,
    /** **03**

Cancelled. The prescription for this medicine item was cancelled by an authorized health care provider. The patient may be advised to complete the course of the prescribed medicine. This advice is a clinical decision made based on assessment of the patient's clinical condition. */
    N03,
    /** **04**

Prescribed. A new medicine item has been prescribed */
    N04,
    /** **05**

Ceased. Administration of this medication item that the patient is currently taking is stopped or recommended to be stopped (i.e. instructed to be ceased by a health care provider). This cessation is anticipated to be permanent. The Change Description should describe the reason for cessation. Example uses: the medication in question is considered ineffective or has caused serious adverse effects. This value applies both to the cessation of a medication that is prescribed by another healthcare provider or patient self-administration of OTC medicines. */
    N05,
    /** **06**

Suspended. Administration of this medication item that the patient is currently taking is on hold, or instructed or recommended by a health care provider to be temporarily stopped, or subject to clinical review (i.e. the stop may be temporary or permanent depending on the outcome of clinical review), or temporarily suspended as a pre-requisite to certain surgical or diagnostic procedures. */
    N06,
}
impl ::core::str::FromStr for PatientMedicineChangeTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "01" => Ok(Self::N01),
            "02" => Ok(Self::N02),
            "03" => Ok(Self::N03),
            "04" => Ok(Self::N04),
            "05" => Ok(Self::N05),
            "06" => Ok(Self::N06),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PatientMedicineChangeTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N01 => "01",
            Self::N02 => "02",
            Self::N03 => "03",
            Self::N04 => "04",
            Self::N05 => "05",
            Self::N06 => "06",
        }
    }
}
impl ::std::fmt::Display for PatientMedicineChangeTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N01 => "Unchanged",
            Self::N02 => "Changed",
            Self::N03 => "Cancelled",
            Self::N04 => "Prescribed",
            Self::N05 => "Ceased",
            Self::N06 => "Suspended",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PatientMedicineChangeTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PatientMedicineChangeTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PatientMedicineChangeTypes> for Coding {
    fn from(code: PatientMedicineChangeTypes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/list-item-flag".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PatientMedicineChangeTypes> for CodeableConcept {
    fn from(code: PatientMedicineChangeTypes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PaymentIssuerTypeCodes](http://hl7.org/fhir/ValueSet/payment-issuertype)**. This value set contains codes for the type of payment issuers.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PaymentIssuerTypeCodes {
    /** **insurance**

Insurance. An insurer, or party acting on their behalf, which is making payment following a contract, direct or indirect, with the patient to pay for healthcare-related services. */
    Insurance,
    /** **patient**

Patient. The patient or a party issuing payment on behalf of the patient. */
    Patient,
}
impl ::core::str::FromStr for PaymentIssuerTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "insurance" => Ok(Self::Insurance),
            "patient" => Ok(Self::Patient),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PaymentIssuerTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Insurance => "insurance",
            Self::Patient => "patient",
        }
    }
}
impl ::std::fmt::Display for PaymentIssuerTypeCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Insurance => "Insurance",
            Self::Patient => "Patient",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PaymentIssuerTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PaymentIssuerTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PaymentIssuerTypeCodes> for Coding {
    fn from(code: PaymentIssuerTypeCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/payment-issuertype".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PaymentIssuerTypeCodes> for CodeableConcept {
    fn from(code: PaymentIssuerTypeCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PaymentKindCodes](http://hl7.org/fhir/ValueSet/payment-kind)**. This value set contains codes for the type of workflow from which payments arise.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PaymentKindCodes {
    /** **deposit**

Deposit on Account. The payment or adjustment is to an indicated account not to a specific charge. */
    Deposit,
    /** **kiosk**

Kiosk Payment. Payment made at an authorized Kiosk. */
    Kiosk,
    /** **online**

Online Bill Payment. Payment, full or partial, of an invoice or statement provided to the payment issuer. */
    Online,
    /** **periodic-payment**

Periodic Payment. The payment is one of a set of previously agreed payments, for example in fullfilment of a payment plan. */
    PeriodicPayment,
}
impl ::core::str::FromStr for PaymentKindCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deposit" => Ok(Self::Deposit),
            "kiosk" => Ok(Self::Kiosk),
            "online" => Ok(Self::Online),
            "periodic-payment" => Ok(Self::PeriodicPayment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PaymentKindCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deposit => "deposit",
            Self::Kiosk => "kiosk",
            Self::Online => "online",
            Self::PeriodicPayment => "periodic-payment",
        }
    }
}
impl ::std::fmt::Display for PaymentKindCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Deposit => "Deposit on Account",
            Self::Kiosk => "Kiosk Payment",
            Self::Online => "Online Bill Payment",
            Self::PeriodicPayment => "Periodic Payment",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PaymentKindCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PaymentKindCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PaymentKindCodes> for Coding {
    fn from(code: PaymentKindCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/payment-kind".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PaymentKindCodes> for CodeableConcept {
    fn from(code: PaymentKindCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PediatricUse](http://hl7.org/fhir/ValueSet/medicinal-product-pediatric-use)**. Suitability for age groups, in particular children.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PediatricUse {
    /** **Adolescents**

Adolescents (12 to < 18 years). Adolescents (12 to < 18 years) */
    Adolescents,
    /** **Adults**

Adults (18 to < 65 years). Adults (18 to < 65 years) */
    Adults,
    /** **AdultsAndElderly**

Adult and elderly population (> 18 years). Adult and elderly population (> 18 years) */
    AdultsAndElderly,
    /** **All**

All. All */
    All,
    /** **Children**

Children (2 to < 12 years). Children (2 to < 12 years) */
    Children,
    /** **Elderly**

Elderly (≥ 65 years). Elderly (≥ 65 years) */
    Elderly,
    /** **InUtero**

In utero. In utero */
    InUtero,
    /** **Infants**

Infants and toddlers (28 days – 23 months). Infants and toddlers (28 days – 23 months) */
    Infants,
    /** **Neonate**

Neonate. Neonate */
    Neonate,
    /** **PediatricPopulation**

Pediatric Population (< 18 years). Pediatric Population (< 18 years) */
    PediatricPopulation,
    /** **Prepubertal**

Prepubertal children (2 years to onset of puberty). Prepubertal children (2 years to onset of puberty) */
    Prepubertal,
    /** **PretermNewborn**

Preterm newborn infants (0 – 27 days). Preterm newborn infants (0 – 27 days) */
    PretermNewborn,
    /** **PubertalAndPostpubertal**

Pubertal and postpubertal adolescents (onset of puberty to < 18 years). Pubertal and postpubertal adolescents (onset of puberty to < 18 years) */
    PubertalAndPostpubertal,
    /** **TermNewborn**

Term newborn infants (0 – 27 days). Term newborn infants (0 – 27 days) */
    TermNewborn,
}
impl ::core::str::FromStr for PediatricUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Adolescents" => Ok(Self::Adolescents),
            "Adults" => Ok(Self::Adults),
            "AdultsAndElderly" => Ok(Self::AdultsAndElderly),
            "All" => Ok(Self::All),
            "Children" => Ok(Self::Children),
            "Elderly" => Ok(Self::Elderly),
            "InUtero" => Ok(Self::InUtero),
            "Infants" => Ok(Self::Infants),
            "Neonate" => Ok(Self::Neonate),
            "PediatricPopulation" => Ok(Self::PediatricPopulation),
            "Prepubertal" => Ok(Self::Prepubertal),
            "PretermNewborn" => Ok(Self::PretermNewborn),
            "PubertalAndPostpubertal" => Ok(Self::PubertalAndPostpubertal),
            "TermNewborn" => Ok(Self::TermNewborn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PediatricUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adolescents => "Adolescents",
            Self::Adults => "Adults",
            Self::AdultsAndElderly => "AdultsAndElderly",
            Self::All => "All",
            Self::Children => "Children",
            Self::Elderly => "Elderly",
            Self::InUtero => "InUtero",
            Self::Infants => "Infants",
            Self::Neonate => "Neonate",
            Self::PediatricPopulation => "PediatricPopulation",
            Self::Prepubertal => "Prepubertal",
            Self::PretermNewborn => "PretermNewborn",
            Self::PubertalAndPostpubertal => "PubertalAndPostpubertal",
            Self::TermNewborn => "TermNewborn",
        }
    }
}
impl ::std::fmt::Display for PediatricUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Adolescents => "Adolescents (12 to < 18 years)",
            Self::Adults => "Adults (18 to < 65 years)",
            Self::AdultsAndElderly => "Adult and elderly population (> 18 years)",
            Self::All => "All",
            Self::Children => "Children (2 to < 12 years)",
            Self::Elderly => "Elderly (≥ 65 years)",
            Self::InUtero => "In utero",
            Self::Infants => "Infants and toddlers (28 days – 23 months)",
            Self::Neonate => "Neonate",
            Self::PediatricPopulation => "Pediatric Population (< 18 years)",
            Self::Prepubertal => "Prepubertal children (2 years to onset of puberty)",
            Self::PretermNewborn => "Preterm newborn infants (0 – 27 days)",
            Self::PubertalAndPostpubertal => {
                "Pubertal and postpubertal adolescents (onset of puberty to < 18 years)"
            }
            Self::TermNewborn => "Term newborn infants (0 – 27 days)",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PediatricUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PediatricUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PediatricUse> for Coding {
    fn from(code: PediatricUse) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicinal-product-pediatric-use".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PediatricUse> for CodeableConcept {
    fn from(code: PediatricUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PermissionRuleCombining](http://hl7.org/fhir/permission-rule-combining)**. Codes identifying the rule combining. See XACML Combining algorithms  http://docs.oasis-open.org/xacml/3.0/xacml-3.0-core-spec-cos01-en.html\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PermissionRuleCombining {
    /** **deny-overrides**

Deny-overrides. The deny overrides combining algorithm is intended for those cases where a deny decision should have priority over a permit decision. */
    DenyOverrides,
    /** **deny-unless-permit**

Deny-unless-permit. The “Deny-unless-permit” combining algorithm is intended for those cases where a permit decision should have priority over a deny decision, and an “Indeterminate” or “NotApplicable” must never be the result. It is particularly useful at the top level in a policy structure to ensure that a PDP will always return a definite “Permit” or “Deny” result. */
    DenyUnlessPermit,
    /** **ordered-deny-overrides**

Ordered-deny-overrides. The behavior of this algorithm is identical to that of the “Deny-overrides” rule-combining algorithm with one exception.  The order in which the collection of rules is evaluated SHALL match the order as listed in the permission. */
    OrderedDenyOverrides,
    /** **ordered-permit-overrides**

Ordered-permit-overrides. The behavior of this algorithm is identical to that of the “Permit-overrides” rule-combining algorithm with one exception.  The order in which the collection of rules is evaluated SHALL match the order as listed in the permission. */
    OrderedPermitOverrides,
    /** **permit-overrides**

Permit-overrides. The permit overrides combining algorithm is intended for those cases where a permit decision should have priority over a deny decision. */
    PermitOverrides,
    /** **permit-unless-deny**

Permit-unless-deny. The “Permit-unless-deny” combining algorithm is intended for those cases where a deny decision should have priority over a permit decision, and an “Indeterminate” or “NotApplicable” must never be the result. It is particularly useful at the top level in a policy structure to ensure that a PDP will always return a definite “Permit” or “Deny” result. This algorithm has the following behavior. */
    PermitUnlessDeny,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PermissionRuleCombining {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deny-overrides" => Ok(Self::DenyOverrides),
            "deny-unless-permit" => Ok(Self::DenyUnlessPermit),
            "ordered-deny-overrides" => Ok(Self::OrderedDenyOverrides),
            "ordered-permit-overrides" => Ok(Self::OrderedPermitOverrides),
            "permit-overrides" => Ok(Self::PermitOverrides),
            "permit-unless-deny" => Ok(Self::PermitUnlessDeny),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PermissionRuleCombining {
    fn as_ref(&self) -> &str {
        match self {
            Self::DenyOverrides => "deny-overrides",
            Self::DenyUnlessPermit => "deny-unless-permit",
            Self::OrderedDenyOverrides => "ordered-deny-overrides",
            Self::OrderedPermitOverrides => "ordered-permit-overrides",
            Self::PermitOverrides => "permit-overrides",
            Self::PermitUnlessDeny => "permit-unless-deny",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for PermissionRuleCombining {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::DenyOverrides => "Deny-overrides",
            Self::DenyUnlessPermit => "Deny-unless-permit",
            Self::OrderedDenyOverrides => "Ordered-deny-overrides",
            Self::OrderedPermitOverrides => "Ordered-permit-overrides",
            Self::PermitOverrides => "Permit-overrides",
            Self::PermitUnlessDeny => "Permit-unless-deny",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PermissionRuleCombining {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PermissionRuleCombining {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PermissionRuleCombining> for Coding {
    fn from(code: PermissionRuleCombining) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/permission-rule-combining".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PermissionRuleCombining> for CodeableConcept {
    fn from(code: PermissionRuleCombining) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PermissionStatus](http://hl7.org/fhir/ValueSet/permission-status)**. Codes identifying the lifecycle stage of a product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PermissionStatus {
    /** **active**

Active. Permission is given. */
    Active,
    /** **draft**

Draft. Permission is being defined. */
    Draft,
    /** **entered-in-error**

Entered in Error. Permission was entered in error and is not active. */
    EnteredInError,
    /** **rejected**

Rejected. Permission not granted. */
    Rejected,
}
impl ::core::str::FromStr for PermissionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "rejected" => Ok(Self::Rejected),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PermissionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Rejected => "rejected",
        }
    }
}
impl ::std::fmt::Display for PermissionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Draft => "Draft",
            Self::EnteredInError => "Entered in Error",
            Self::Rejected => "Rejected",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PermissionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PermissionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PermissionStatus> for Coding {
    fn from(code: PermissionStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/permission-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PermissionStatus> for CodeableConcept {
    fn from(code: PermissionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PriceComponentType](http://hl7.org/fhir/ValueSet/price-component-type)**. Codes indicating the kind of the price component.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PriceComponentType {
    /** **base**

base price. the amount is the base price used for calculating the total price before applying surcharges, discount or taxes. */
    Base,
    /** **deduction**

deduction. the amount is a deduction applied on the base price. */
    Deduction,
    /** **discount**

discount. the amount is a discount applied on the base price. */
    Discount,
    /** **informational**

informational. the amount is of informational character, it has not been applied in the calculation of the total price. */
    Informational,
    /** **surcharge**

surcharge. the amount is a surcharge applied on the base price. */
    Surcharge,
    /** **tax**

tax. the amount is the tax component of the total price. */
    Tax,
}
impl ::core::str::FromStr for PriceComponentType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "base" => Ok(Self::Base),
            "deduction" => Ok(Self::Deduction),
            "discount" => Ok(Self::Discount),
            "informational" => Ok(Self::Informational),
            "surcharge" => Ok(Self::Surcharge),
            "tax" => Ok(Self::Tax),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PriceComponentType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Base => "base",
            Self::Deduction => "deduction",
            Self::Discount => "discount",
            Self::Informational => "informational",
            Self::Surcharge => "surcharge",
            Self::Tax => "tax",
        }
    }
}
impl ::std::fmt::Display for PriceComponentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Base => "base price",
            Self::Deduction => "deduction",
            Self::Discount => "discount",
            Self::Informational => "informational",
            Self::Surcharge => "surcharge",
            Self::Tax => "tax",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PriceComponentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PriceComponentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PriceComponentType> for Coding {
    fn from(code: PriceComponentType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/price-component-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PriceComponentType> for CodeableConcept {
    fn from(code: PriceComponentType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ProcedureDeviceActionCodes](http://hl7.org/fhir/device-action)**. Example value set for Procedure Device Action code (what happened to a device during a procedure.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ProcedureDeviceActionCodes {
    /** **explanted**

Explanted. The device was explanted from the patient during the procedure. */
    Explanted,
    /** **implanted**

Implanted. The device was implanted in the patient during the procedure. */
    Implanted,
    /** **manipulated**

Manipulated. The device remains in the patient, but its location, settings, or functionality was changed. */
    Manipulated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ProcedureDeviceActionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "explanted" => Ok(Self::Explanted),
            "implanted" => Ok(Self::Implanted),
            "manipulated" => Ok(Self::Manipulated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ProcedureDeviceActionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Explanted => "explanted",
            Self::Implanted => "implanted",
            Self::Manipulated => "manipulated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ProcedureDeviceActionCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Explanted => "Explanted",
            Self::Implanted => "Implanted",
            Self::Manipulated => "Manipulated",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ProcedureDeviceActionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProcedureDeviceActionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProcedureDeviceActionCodes> for Coding {
    fn from(code: ProcedureDeviceActionCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/device-action".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ProcedureDeviceActionCodes> for CodeableConcept {
    fn from(code: ProcedureDeviceActionCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ProductConfidentiality](http://hl7.org/fhir/ValueSet/medicinal-product-confidentiality)**. Confidentiality rating, e.g. commercial sensitivity for a Medicinal Product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductConfidentiality {
    /** **CommerciallySensitive**

Commercially Sensitive. Commercially Sensitive */
    CommerciallySensitive,
    /** **NotCommerciallySensitive**

Not Commercially Sensitive. Not Commercially Sensitive */
    NotCommerciallySensitive,
}
impl ::core::str::FromStr for ProductConfidentiality {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CommerciallySensitive" => Ok(Self::CommerciallySensitive),
            "NotCommerciallySensitive" => Ok(Self::NotCommerciallySensitive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductConfidentiality {
    fn as_ref(&self) -> &str {
        match self {
            Self::CommerciallySensitive => "CommerciallySensitive",
            Self::NotCommerciallySensitive => "NotCommerciallySensitive",
        }
    }
}
impl ::std::fmt::Display for ProductConfidentiality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::CommerciallySensitive => "Commercially Sensitive",
            Self::NotCommerciallySensitive => "Not Commercially Sensitive",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ProductConfidentiality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductConfidentiality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductConfidentiality> for Coding {
    fn from(code: ProductConfidentiality) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicinal-product-confidentiality"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ProductConfidentiality> for CodeableConcept {
    fn from(code: ProductConfidentiality) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ProductContactType](http://hl7.org/fhir/ValueSet/medicinal-product-contact-type)**. Contact type for a Medicinal Product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductContactType {
    /** **PVEnquiries**

Pharmacovigilance Enquiry Information. Pharmacovigilance Enquiry Information */
    Pvenquiries,
    /** **ProcedureContactAfter**

Person/Company authorised for Communication after procedure. Person/Company authorised for Communication between MAH and Authorities after Authorization */
    ProcedureContactAfter,
    /** **ProcedureContactDuring**

Person/Company authorised for Communication during procedure. Person/Company authorised for Communication on behalf of the Applicant during the Procedure */
    ProcedureContactDuring,
    /** **ProposedMAH**

Proposed Marketing Authorization Holder/Person. Proposed Marketing Authorization Holder/Person */
    ProposedMAH,
    /** **QPPV**

Qualified Person Responsible for Pharmacovigilance. Qualified Person Responsible for Pharmacovigilance */
    Qppv,
}
impl ::core::str::FromStr for ProductContactType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "PVEnquiries" => Ok(Self::Pvenquiries),
            "ProcedureContactAfter" => Ok(Self::ProcedureContactAfter),
            "ProcedureContactDuring" => Ok(Self::ProcedureContactDuring),
            "ProposedMAH" => Ok(Self::ProposedMAH),
            "QPPV" => Ok(Self::Qppv),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductContactType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Pvenquiries => "PVEnquiries",
            Self::ProcedureContactAfter => "ProcedureContactAfter",
            Self::ProcedureContactDuring => "ProcedureContactDuring",
            Self::ProposedMAH => "ProposedMAH",
            Self::Qppv => "QPPV",
        }
    }
}
impl ::std::fmt::Display for ProductContactType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Pvenquiries => "Pharmacovigilance Enquiry Information",
            Self::ProcedureContactAfter => {
                "Person/Company authorised for Communication after procedure"
            }
            Self::ProcedureContactDuring => {
                "Person/Company authorised for Communication during procedure"
            }
            Self::ProposedMAH => "Proposed Marketing Authorization Holder/Person",
            Self::Qppv => "Qualified Person Responsible for Pharmacovigilance",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ProductContactType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductContactType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductContactType> for Coding {
    fn from(code: ProductContactType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicinal-product-contact-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ProductContactType> for CodeableConcept {
    fn from(code: ProductContactType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ProductCrossReferenceType](http://hl7.org/fhir/ValueSet/medicinal-product-cross-reference-type)**. Relationship to another Medicinal Product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductCrossReferenceType {
    /** **ActualProduct**

Link Virtual to Actual Product. Link Virtual to Actual Product */
    ActualProduct,
    /** **BrandedProduct**

Link Generic to Branded Product. Link Generic to Branded Product */
    BrandedProduct,
    /** **GenericProduct**

Link Branded to Generic Product. Link Branded to Generic Product */
    GenericProduct,
    /** **InvestigationalProduct**

Link to Investigational Product. Link to Investigational (Development) Product */
    InvestigationalProduct,
    /** **Parallel**

Link to Parallel Import Product. Link to Parallel Import Product */
    Parallel,
    /** **VirtualProduct**

Link Actual to Virtual Product. Link Actual to Virtual Product */
    VirtualProduct,
}
impl ::core::str::FromStr for ProductCrossReferenceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActualProduct" => Ok(Self::ActualProduct),
            "BrandedProduct" => Ok(Self::BrandedProduct),
            "GenericProduct" => Ok(Self::GenericProduct),
            "InvestigationalProduct" => Ok(Self::InvestigationalProduct),
            "Parallel" => Ok(Self::Parallel),
            "VirtualProduct" => Ok(Self::VirtualProduct),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductCrossReferenceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActualProduct => "ActualProduct",
            Self::BrandedProduct => "BrandedProduct",
            Self::GenericProduct => "GenericProduct",
            Self::InvestigationalProduct => "InvestigationalProduct",
            Self::Parallel => "Parallel",
            Self::VirtualProduct => "VirtualProduct",
        }
    }
}
impl ::std::fmt::Display for ProductCrossReferenceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ActualProduct => "Link Virtual to Actual Product",
            Self::BrandedProduct => "Link Generic to Branded Product",
            Self::GenericProduct => "Link Branded to Generic Product",
            Self::InvestigationalProduct => "Link to Investigational Product",
            Self::Parallel => "Link to Parallel Import Product",
            Self::VirtualProduct => "Link Actual to Virtual Product",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ProductCrossReferenceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductCrossReferenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductCrossReferenceType> for Coding {
    fn from(code: ProductCrossReferenceType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicinal-product-cross-reference-type"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ProductCrossReferenceType> for CodeableConcept {
    fn from(code: ProductCrossReferenceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ProductIntendedUse](http://hl7.org/fhir/ValueSet/product-intended-use)**. ProductIntendedUse\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductIntendedUse {
    /** **Alleviation**

Alleviation. */
    Alleviation,
    /** **Diagnosis**

Diagnosis. */
    Diagnosis,
    /** **Monitoring**

Monitoring. */
    Monitoring,
    /** **Prevention**

Prevention. */
    Prevention,
    /** **Treatment**

Treatment. */
    Treatment,
}
impl ::core::str::FromStr for ProductIntendedUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Alleviation" => Ok(Self::Alleviation),
            "Diagnosis" => Ok(Self::Diagnosis),
            "Monitoring" => Ok(Self::Monitoring),
            "Prevention" => Ok(Self::Prevention),
            "Treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductIntendedUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alleviation => "Alleviation",
            Self::Diagnosis => "Diagnosis",
            Self::Monitoring => "Monitoring",
            Self::Prevention => "Prevention",
            Self::Treatment => "Treatment",
        }
    }
}
impl ::std::fmt::Display for ProductIntendedUse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Alleviation => "Alleviation",
            Self::Diagnosis => "Diagnosis",
            Self::Monitoring => "Monitoring",
            Self::Prevention => "Prevention",
            Self::Treatment => "Treatment",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ProductIntendedUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductIntendedUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductIntendedUse> for Coding {
    fn from(code: ProductIntendedUse) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/product-intended-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ProductIntendedUse> for CodeableConcept {
    fn from(code: ProductIntendedUse) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ProductNamePartType](http://hl7.org/fhir/ValueSet/medicinal-product-name-part-type)**. Type of part of a name for a Medicinal Product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductNamePartType {
    /** **ContainerPart**

Container or pack part. */
    ContainerPart,
    /** **DelimiterPart**

Delimiter part. */
    DelimiterPart,
    /** **DevicePart**

Device part. */
    DevicePart,
    /** **DoseFormPart**

Pharmaceutical dose form part. */
    DoseFormPart,
    /** **FlavorPart**

Flavor part. */
    FlavorPart,
    /** **FormulationPart**

Formulation part. */
    FormulationPart,
    /** **FullName**

Full name. */
    FullName,
    /** **IntendedUsePart**

Intended use part. */
    IntendedUsePart,
    /** **InventedNamePart**

Invented name part. */
    InventedNamePart,
    /** **LegacyNamePart**

Legacy name. */
    LegacyNamePart,
    /** **PopulationPart**

Target population part. */
    PopulationPart,
    /** **ScientificNamePart**

Scientific name part. */
    ScientificNamePart,
    /** **SpeciesNamePart**

Target species name part. */
    SpeciesNamePart,
    /** **StrengthPart**

Strength part. */
    StrengthPart,
    /** **TimeOrPeriodPart**

Time/Period part. */
    TimeOrPeriodPart,
    /** **TrademarkOrCompanyPart**

Trademark or company name part. */
    TrademarkOrCompanyPart,
}
impl ::core::str::FromStr for ProductNamePartType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ContainerPart" => Ok(Self::ContainerPart),
            "DelimiterPart" => Ok(Self::DelimiterPart),
            "DevicePart" => Ok(Self::DevicePart),
            "DoseFormPart" => Ok(Self::DoseFormPart),
            "FlavorPart" => Ok(Self::FlavorPart),
            "FormulationPart" => Ok(Self::FormulationPart),
            "FullName" => Ok(Self::FullName),
            "IntendedUsePart" => Ok(Self::IntendedUsePart),
            "InventedNamePart" => Ok(Self::InventedNamePart),
            "LegacyNamePart" => Ok(Self::LegacyNamePart),
            "PopulationPart" => Ok(Self::PopulationPart),
            "ScientificNamePart" => Ok(Self::ScientificNamePart),
            "SpeciesNamePart" => Ok(Self::SpeciesNamePart),
            "StrengthPart" => Ok(Self::StrengthPart),
            "TimeOrPeriodPart" => Ok(Self::TimeOrPeriodPart),
            "TrademarkOrCompanyPart" => Ok(Self::TrademarkOrCompanyPart),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductNamePartType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ContainerPart => "ContainerPart",
            Self::DelimiterPart => "DelimiterPart",
            Self::DevicePart => "DevicePart",
            Self::DoseFormPart => "DoseFormPart",
            Self::FlavorPart => "FlavorPart",
            Self::FormulationPart => "FormulationPart",
            Self::FullName => "FullName",
            Self::IntendedUsePart => "IntendedUsePart",
            Self::InventedNamePart => "InventedNamePart",
            Self::LegacyNamePart => "LegacyNamePart",
            Self::PopulationPart => "PopulationPart",
            Self::ScientificNamePart => "ScientificNamePart",
            Self::SpeciesNamePart => "SpeciesNamePart",
            Self::StrengthPart => "StrengthPart",
            Self::TimeOrPeriodPart => "TimeOrPeriodPart",
            Self::TrademarkOrCompanyPart => "TrademarkOrCompanyPart",
        }
    }
}
impl ::std::fmt::Display for ProductNamePartType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ContainerPart => "Container or pack part",
            Self::DelimiterPart => "Delimiter part",
            Self::DevicePart => "Device part",
            Self::DoseFormPart => "Pharmaceutical dose form part",
            Self::FlavorPart => "Flavor part",
            Self::FormulationPart => "Formulation part",
            Self::FullName => "Full name",
            Self::IntendedUsePart => "Intended use part",
            Self::InventedNamePart => "Invented name part",
            Self::LegacyNamePart => "Legacy name",
            Self::PopulationPart => "Target population part",
            Self::ScientificNamePart => "Scientific name part",
            Self::SpeciesNamePart => "Target species name part",
            Self::StrengthPart => "Strength part",
            Self::TimeOrPeriodPart => "Time/Period part",
            Self::TrademarkOrCompanyPart => "Trademark or company name part",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ProductNamePartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductNamePartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductNamePartType> for Coding {
    fn from(code: ProductNamePartType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicinal-product-name-part-type"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ProductNamePartType> for CodeableConcept {
    fn from(code: ProductNamePartType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ProductNameType](http://hl7.org/fhir/ValueSet/medicinal-product-name-type)**. Type of a name for a Medicinal Product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductNameType {
    /** **BAN**

British Approved Name. */
    Ban,
    /** **INN**

International Non-Proprietary Name. */
    Inn,
    /** **INNM**

Modified International Non-Proprietary Name. */
    Innm,
    /** **pINN**

Proposed International Non-Proprietary Name. */
    Pinn,
    /** **rINN**

Recommended International Non-Proprietary Name. */
    Rinn,
}
impl ::core::str::FromStr for ProductNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BAN" => Ok(Self::Ban),
            "INN" => Ok(Self::Inn),
            "INNM" => Ok(Self::Innm),
            "pINN" => Ok(Self::Pinn),
            "rINN" => Ok(Self::Rinn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ban => "BAN",
            Self::Inn => "INN",
            Self::Innm => "INNM",
            Self::Pinn => "pINN",
            Self::Rinn => "rINN",
        }
    }
}
impl ::std::fmt::Display for ProductNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Ban => "British Approved Name",
            Self::Inn => "International Non-Proprietary Name",
            Self::Innm => "Modified International Non-Proprietary Name",
            Self::Pinn => "Proposed International Non-Proprietary Name",
            Self::Rinn => "Recommended International Non-Proprietary Name",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ProductNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductNameType> for Coding {
    fn from(code: ProductNameType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicinal-product-name-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ProductNameType> for CodeableConcept {
    fn from(code: ProductNameType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ProductStatus](http://hl7.org/fhir/ValueSet/product-status)**. Codes identifying the lifecycle stage of a product.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductStatus {
    /** **active**

Active. The product can be used. */
    Active,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
}
impl ::core::str::FromStr for ProductStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
        }
    }
}
impl ::std::fmt::Display for ProductStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in Error",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ProductStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProductStatus> for Coding {
    fn from(code: ProductStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/product-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ProductStatus> for CodeableConcept {
    fn from(code: ProductStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PropertyRepresentation](http://hl7.org/fhir/ValueSet/property-representation)**. How a property is represented when serialized.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PropertyRepresentation {
    /** **cdaText**

CDA Text Format. Use CDA narrative instead of XHTML. */
    CdaText,
    /** **typeAttr**

Type Attribute. The type of this element is indicated using xsi:type. */
    TypeAttr,
    /** **xhtml**

XHTML. The property is represented using XHTML. */
    Xhtml,
    /** **xmlAttr**

XML Attribute. In XML, this property is represented as an attribute not an element. */
    XmlAttr,
    /** **xmlText**

XML Text. This element is represented using the XML text attribute (primitives only). */
    XmlText,
}
impl ::core::str::FromStr for PropertyRepresentation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cdaText" => Ok(Self::CdaText),
            "typeAttr" => Ok(Self::TypeAttr),
            "xhtml" => Ok(Self::Xhtml),
            "xmlAttr" => Ok(Self::XmlAttr),
            "xmlText" => Ok(Self::XmlText),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PropertyRepresentation {
    fn as_ref(&self) -> &str {
        match self {
            Self::CdaText => "cdaText",
            Self::TypeAttr => "typeAttr",
            Self::Xhtml => "xhtml",
            Self::XmlAttr => "xmlAttr",
            Self::XmlText => "xmlText",
        }
    }
}
impl ::std::fmt::Display for PropertyRepresentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::CdaText => "CDA Text Format",
            Self::TypeAttr => "Type Attribute",
            Self::Xhtml => "XHTML",
            Self::XmlAttr => "XML Attribute",
            Self::XmlText => "XML Text",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PropertyRepresentation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PropertyRepresentation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PropertyRepresentation> for Coding {
    fn from(code: PropertyRepresentation) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/property-representation".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PropertyRepresentation> for CodeableConcept {
    fn from(code: PropertyRepresentation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PropertyType](http://hl7.org/fhir/ValueSet/concept-property-type)**. The type of a property value.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PropertyType {
    /** **Coding**

Coding (external reference). The property  value is a code defined in an external code system. This may be used for translations, but is not the intent. */
    Coding,
    /** **boolean**

boolean. The property value is a boolean true | false. */
    Boolean,
    /** **code**

code (internal reference). The property value is a code that identifies a concept defined in the code system. */
    Code,
    /** **dateTime**

dateTime. The property is a date or a date + time. */
    DateTime,
    /** **decimal**

decimal. The property value is a decimal number. */
    Decimal,
    /** **integer**

integer. The property value is an integer (often used to assign ranking values to concepts for supporting score assessments). */
    Integer,
    /** **string**

string. The property value is a string. */
    String,
}
impl ::core::str::FromStr for PropertyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Coding" => Ok(Self::Coding),
            "boolean" => Ok(Self::Boolean),
            "code" => Ok(Self::Code),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "integer" => Ok(Self::Integer),
            "string" => Ok(Self::String),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PropertyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Coding => "Coding",
            Self::Boolean => "boolean",
            Self::Code => "code",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Integer => "integer",
            Self::String => "string",
        }
    }
}
impl ::std::fmt::Display for PropertyType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Coding => "Coding (external reference)",
            Self::Boolean => "boolean",
            Self::Code => "code (internal reference)",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Integer => "integer",
            Self::String => "string",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PropertyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PropertyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PropertyType> for Coding {
    fn from(code: PropertyType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/concept-property-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PropertyType> for CodeableConcept {
    fn from(code: PropertyType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ProvenanceEntityRole](http://hl7.org/fhir/ValueSet/provenance-entity-role)**. How an entity was used in an activity.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProvenanceEntityRole {
    /** **instantiates**

Instantiates. The record resulting from this event adheres to the protocol, guideline, order set or other definition represented by this entity. */
    Instantiates,
    /** **quotation**

Quotation. An entity that is copied in full or part by an agent that is not the author of the entity. */
    Quotation,
    /** **removal**

Removal. An entity that is removed from accessibility, usually through the DELETE operator. */
    Removal,
    /** **revision**

Revision. An entity that is used by the activity to produce a new version of that entity. */
    Revision,
    /** **source**

Source. An entity that is used as input to the activity that produced the target. */
    Source,
}
impl ::core::str::FromStr for ProvenanceEntityRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "instantiates" => Ok(Self::Instantiates),
            "quotation" => Ok(Self::Quotation),
            "removal" => Ok(Self::Removal),
            "revision" => Ok(Self::Revision),
            "source" => Ok(Self::Source),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProvenanceEntityRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Instantiates => "instantiates",
            Self::Quotation => "quotation",
            Self::Removal => "removal",
            Self::Revision => "revision",
            Self::Source => "source",
        }
    }
}
impl ::std::fmt::Display for ProvenanceEntityRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Instantiates => "Instantiates",
            Self::Quotation => "Quotation",
            Self::Removal => "Removal",
            Self::Revision => "Revision",
            Self::Source => "Source",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ProvenanceEntityRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProvenanceEntityRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ProvenanceEntityRole> for Coding {
    fn from(code: ProvenanceEntityRole) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/provenance-entity-role".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ProvenanceEntityRole> for CodeableConcept {
    fn from(code: ProvenanceEntityRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PublicationStatus](http://hl7.org/fhir/ValueSet/publication-status)**. The lifecycle status of an artifact.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PublicationStatus {
    /** **active**

Active. This resource is ready for normal use. */
    Active,
    /** **draft**

Draft. This resource is still under development and is not yet considered to be ready for normal use. */
    Draft,
    /** **retired**

Retired. This resource has been withdrawn or superseded and should no longer be used. */
    Retired,
    /** **unknown**

Unknown. The authoring system does not know which of the status values currently applies for this resource.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for PublicationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "retired" => Ok(Self::Retired),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PublicationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::Retired => "retired",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for PublicationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Draft => "Draft",
            Self::Retired => "Retired",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PublicationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PublicationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PublicationStatus> for Coding {
    fn from(code: PublicationStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/publication-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PublicationStatus> for CodeableConcept {
    fn from(code: PublicationStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[PublishedInType](http://hl7.org/fhir/ValueSet/published-in-type)**. The type of publication such as book, database, or journal.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PublishedInType {
    /** **D001877**

Book. Non-periodical written or printed works consisting of sheets of pages fastened or bound together within covers. */
    D001877,
    /** **D019991**

Database. A structured file of information or a set of logically related data stored and retrieved using computer-based means. */
    D019991,
    /** **D020492**

Periodical. Publication intended to be issued on an ongoing basis, generally more frequently than annually, containing separate articles, stories, or writings. */
    D020492,
    /** **D064886**

Dataset. Works consisting of organized collections of data, which have been stored permanently in a formalized manner suitable for communication, interpretation, or processing. */
    D064886,
}
impl ::core::str::FromStr for PublishedInType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "D001877" => Ok(Self::D001877),
            "D019991" => Ok(Self::D019991),
            "D020492" => Ok(Self::D020492),
            "D064886" => Ok(Self::D064886),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PublishedInType {
    fn as_ref(&self) -> &str {
        match self {
            Self::D001877 => "D001877",
            Self::D019991 => "D019991",
            Self::D020492 => "D020492",
            Self::D064886 => "D064886",
        }
    }
}
impl ::std::fmt::Display for PublishedInType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::D001877 => "Book",
            Self::D019991 => "Database",
            Self::D020492 => "Periodical",
            Self::D064886 => "Dataset",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for PublishedInType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PublishedInType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<PublishedInType> for Coding {
    fn from(code: PublishedInType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/published-in-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<PublishedInType> for CodeableConcept {
    fn from(code: PublishedInType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[QuantityComparator](http://hl7.org/fhir/ValueSet/quantity-comparator)**. How the Quantity should be understood and represented.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuantityComparator {
    /** **<**

Less than. The actual value is less than the given value. */
    Less,
    /** **<=**

Less or Equal to. The actual value is less than or equal to the given value. */
    LessOrEqual,
    /** **>**

Greater than. The actual value is greater than the given value. */
    Greater,
    /** **>=**

Greater or Equal to. The actual value is greater than or equal to the given value. */
    GreaterOrEqual,
    /** **ad**

Sufficient to achieve this total quantity. The actual value is sufficient for the total quantity to equal the given value. */
    Ad,
}
impl ::core::str::FromStr for QuantityComparator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "<" => Ok(Self::Less),
            "<=" => Ok(Self::LessOrEqual),
            ">" => Ok(Self::Greater),
            ">=" => Ok(Self::GreaterOrEqual),
            "ad" => Ok(Self::Ad),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuantityComparator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Less => "<",
            Self::LessOrEqual => "<=",
            Self::Greater => ">",
            Self::GreaterOrEqual => ">=",
            Self::Ad => "ad",
        }
    }
}
impl ::std::fmt::Display for QuantityComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Less => "Less than",
            Self::LessOrEqual => "Less or Equal to",
            Self::Greater => "Greater than",
            Self::GreaterOrEqual => "Greater or Equal to",
            Self::Ad => "Sufficient to achieve this total quantity",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for QuantityComparator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuantityComparator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuantityComparator> for Coding {
    fn from(code: QuantityComparator) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/quantity-comparator".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<QuantityComparator> for CodeableConcept {
    fn from(code: QuantityComparator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[QuestionnaireAnswerConstraint](http://hl7.org/fhir/questionnaire-answer-constraint)**. Codes that describe the types of constraints possible on a question item that has a list of permitted answers\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum QuestionnaireAnswerConstraint {
    /** **optionsOnly**

Options only. Only values listed as answerOption or in the expansion of the answerValueSet are permitted */
    OptionsOnly,
    /** **optionsOrString**

Options or string. In addition to the values listed as answerOption or in the expansion of the answerValueSet, free-text strings are permitted.  Answers will have a type of 'string'. */
    OptionsOrString,
    /** **optionsOrType**

Options or 'type'. In addition to the values listed as answerOption or in the expansion of the answerValueSet, any other values that correspond to the specified item.type are permitted */
    OptionsOrType,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for QuestionnaireAnswerConstraint {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "optionsOnly" => Ok(Self::OptionsOnly),
            "optionsOrString" => Ok(Self::OptionsOrString),
            "optionsOrType" => Ok(Self::OptionsOrType),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for QuestionnaireAnswerConstraint {
    fn as_ref(&self) -> &str {
        match self {
            Self::OptionsOnly => "optionsOnly",
            Self::OptionsOrString => "optionsOrString",
            Self::OptionsOrType => "optionsOrType",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for QuestionnaireAnswerConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::OptionsOnly => "Options only",
            Self::OptionsOrString => "Options or string",
            Self::OptionsOrType => "Options or 'type'",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for QuestionnaireAnswerConstraint {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireAnswerConstraint {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireAnswerConstraint> for Coding {
    fn from(code: QuestionnaireAnswerConstraint) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/questionnaire-answer-constraint".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<QuestionnaireAnswerConstraint> for CodeableConcept {
    fn from(code: QuestionnaireAnswerConstraint) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[QuestionnaireItemDisabledDisplay](http://hl7.org/fhir/questionnaire-disabled-display)**. QuestionnaireItemDisabledDisplay\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum QuestionnaireItemDisabledDisplay {
    /** **hidden**

Hidden. The item (and its children) should not be visible to the user at all. */
    Hidden,
    /** **protected**

Protected. The item (and possibly its children) should not be selectable or editable but should still be visible - to allow the user to see what questions *could* have been completed had other answers caused the item to be enabled. */
    Protected,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for QuestionnaireItemDisabledDisplay {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "hidden" => Ok(Self::Hidden),
            "protected" => Ok(Self::Protected),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for QuestionnaireItemDisabledDisplay {
    fn as_ref(&self) -> &str {
        match self {
            Self::Hidden => "hidden",
            Self::Protected => "protected",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for QuestionnaireItemDisabledDisplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Hidden => "Hidden",
            Self::Protected => "Protected",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemDisabledDisplay {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemDisabledDisplay {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireItemDisabledDisplay> for Coding {
    fn from(code: QuestionnaireItemDisabledDisplay) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/questionnaire-disabled-display".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<QuestionnaireItemDisabledDisplay> for CodeableConcept {
    fn from(code: QuestionnaireItemDisabledDisplay) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[QuestionnaireItemOperator](http://hl7.org/fhir/ValueSet/questionnaire-enable-operator)**. The criteria by which a question is enabled.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuestionnaireItemOperator {
    /** **!=**

Not Equals. True if no answer has a value that is equal to the enableWhen answer. */
    NotEqual,
    /** **<**

Less Than. True if at least one answer has a value that is less than the enableWhen answer. */
    Less,
    /** **<=**

Less or Equals. True if at least one answer has a value that is less or equal to the enableWhen answer. */
    LessOrEqual,
    /** **=**

Equals. True if at least one answer has a value that is equal to the enableWhen answer. */
    Equal,
    /** **>**

Greater Than. True if at least one answer has a value that is greater than the enableWhen answer. */
    Greater,
    /** **>=**

Greater or Equals. True if at least one answer has a value that is greater or equal to the enableWhen answer. */
    GreaterOrEqual,
    /** **exists**

Exists. True if the determination of 'whether an answer exists for the question' is equal to the enableWhen answer (which must be a boolean). */
    Exists,
}
impl ::core::str::FromStr for QuestionnaireItemOperator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "!=" => Ok(Self::NotEqual),
            "<" => Ok(Self::Less),
            "<=" => Ok(Self::LessOrEqual),
            "=" => Ok(Self::Equal),
            ">" => Ok(Self::Greater),
            ">=" => Ok(Self::GreaterOrEqual),
            "exists" => Ok(Self::Exists),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemOperator {
    fn as_ref(&self) -> &str {
        match self {
            Self::NotEqual => "!=",
            Self::Less => "<",
            Self::LessOrEqual => "<=",
            Self::Equal => "=",
            Self::Greater => ">",
            Self::GreaterOrEqual => ">=",
            Self::Exists => "exists",
        }
    }
}
impl ::std::fmt::Display for QuestionnaireItemOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::NotEqual => "Not Equals",
            Self::Less => "Less Than",
            Self::LessOrEqual => "Less or Equals",
            Self::Equal => "Equals",
            Self::Greater => "Greater Than",
            Self::GreaterOrEqual => "Greater or Equals",
            Self::Exists => "Exists",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemOperator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireItemOperator> for Coding {
    fn from(code: QuestionnaireItemOperator) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/questionnaire-enable-operator".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<QuestionnaireItemOperator> for CodeableConcept {
    fn from(code: QuestionnaireItemOperator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[QuestionnaireItemType](http://hl7.org/fhir/ValueSet/item-type)**. Distinguishes groups from questions and display text and indicates data type for questions.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuestionnaireItemType {
    /** **attachment**

Attachment. Question with binary content such as an image, PDF, etc. as an answer (valueAttachment). */
    Attachment,
    /** **boolean**

Boolean. Question with a yes/no answer (valueBoolean). */
    Boolean,
    /** **coding**

Coding. Question with a Coding - generally drawn from a list of possible answers (valueCoding) */
    Coding,
    /** **date**

Date. Question with a date answer (valueDate). */
    Date,
    /** **dateTime**

Date Time. Question with a date and time answer (valueDateTime). */
    DateTime,
    /** **decimal**

Decimal. Question with is a real number answer (valueDecimal).  There is an extension 'http://hl7.org/fhir/StructureDefinition/questionnaire-unit' that can be used to computably convey the unit of measure associated with the answer for use when performing data extraction to an element of type Quantity. */
    Decimal,
    /** **display**

Display. Text for display that will not capture an answer or have child items. */
    Display,
    /** **group**

Group. An item with no direct answer but should have at least one child item. */
    Group,
    /** **integer**

Integer. Question with an integer answer (valueInteger).  There is an extension 'http://hl7.org/fhir/StructureDefinition/questionnaire-unit' that can be used to computably convey the unit of measure associated with the answer for use when performing data extraction to an element of type Quantity. */
    Integer,
    /** **quantity**

Quantity. Question with a combination of a numeric value and unit as an answer. (valueSimpleQuantity)  There are two extensions ('http://hl7.org/fhir/StructureDefinition/questionnaire-unitOption' and 'http://hl7.org/fhir/StructureDefinition/questionnaire-unitValueSet')  that can be used to define what unit should be selected for the Quantity.code and Quantity.system. */
    Quantity,
    /** **question**

Question. An item that defines a specific answer to be captured, and which may have child items. (the answer provided in the QuestionnaireResponse should be of the defined datatype). */
    Question,
    /** **reference**

Reference. Question with a reference to another resource (practitioner, organization, etc.) as an answer (valueReference). */
    Reference,
    /** **string**

String. Question with a short (few words to short sentence) free-text entry answer (valueString).  Strings SHOULD NOT contain carriage return or newline characters.  If multi-line answers are needed, use the 'text' type. */
    String,
    /** **text**

Text. Question with a long (potentially multi-paragraph) free-text entry answer (valueString). */
    Text,
    /** **time**

Time. Question with a time (hour:minute:second) answer independent of date. (valueTime). */
    Time,
    /** **url**

Url. Question with a URL (website, FTP site, etc.) answer (valueUri). */
    Url,
}
impl ::core::str::FromStr for QuestionnaireItemType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "attachment" => Ok(Self::Attachment),
            "boolean" => Ok(Self::Boolean),
            "coding" => Ok(Self::Coding),
            "date" => Ok(Self::Date),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "display" => Ok(Self::Display),
            "group" => Ok(Self::Group),
            "integer" => Ok(Self::Integer),
            "quantity" => Ok(Self::Quantity),
            "question" => Ok(Self::Question),
            "reference" => Ok(Self::Reference),
            "string" => Ok(Self::String),
            "text" => Ok(Self::Text),
            "time" => Ok(Self::Time),
            "url" => Ok(Self::Url),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attachment => "attachment",
            Self::Boolean => "boolean",
            Self::Coding => "coding",
            Self::Date => "date",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Display => "display",
            Self::Group => "group",
            Self::Integer => "integer",
            Self::Quantity => "quantity",
            Self::Question => "question",
            Self::Reference => "reference",
            Self::String => "string",
            Self::Text => "text",
            Self::Time => "time",
            Self::Url => "url",
        }
    }
}
impl ::std::fmt::Display for QuestionnaireItemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Attachment => "Attachment",
            Self::Boolean => "Boolean",
            Self::Coding => "Coding",
            Self::Date => "Date",
            Self::DateTime => "Date Time",
            Self::Decimal => "Decimal",
            Self::Display => "Display",
            Self::Group => "Group",
            Self::Integer => "Integer",
            Self::Quantity => "Quantity",
            Self::Question => "Question",
            Self::Reference => "Reference",
            Self::String => "String",
            Self::Text => "Text",
            Self::Time => "Time",
            Self::Url => "Url",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireItemType> for Coding {
    fn from(code: QuestionnaireItemType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/item-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<QuestionnaireItemType> for CodeableConcept {
    fn from(code: QuestionnaireItemType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[QuestionnaireResponseStatus](http://hl7.org/fhir/ValueSet/questionnaire-answers-status)**. Lifecycle status of the questionnaire response.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuestionnaireResponseStatus {
    /** **amended**

Amended. This QuestionnaireResponse has been filled out with answers, then marked as complete, yet changes or additions have been made to it afterwards. */
    Amended,
    /** **completed**

Completed. This QuestionnaireResponse has been filled out with answers and the current content is regarded as definitive. */
    Completed,
    /** **entered-in-error**

Entered in Error. This QuestionnaireResponse was entered in error and voided. */
    EnteredInError,
    /** **in-progress**

In Progress. This QuestionnaireResponse has been partially filled out with answers but changes or additions are still expected to be made to it. */
    InProgress,
    /** **stopped**

Stopped. This QuestionnaireResponse has been partially filled out with answers but has been abandoned. No subsequent changes can be made. */
    Stopped,
}
impl ::core::str::FromStr for QuestionnaireResponseStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireResponseStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Stopped => "stopped",
        }
    }
}
impl ::std::fmt::Display for QuestionnaireResponseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Amended => "Amended",
            Self::Completed => "Completed",
            Self::EnteredInError => "Entered in Error",
            Self::InProgress => "In Progress",
            Self::Stopped => "Stopped",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for QuestionnaireResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<QuestionnaireResponseStatus> for Coding {
    fn from(code: QuestionnaireResponseStatus) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/questionnaire-answers-status".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<QuestionnaireResponseStatus> for CodeableConcept {
    fn from(code: QuestionnaireResponseStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ReasonMedicationNotGivenCodes](http://hl7.org/fhir/reason-medication-not-given)**. This value set is provided as an example. The value set to instantiate this attribute should be drawn from a robust terminology code system that consists of or contains concepts to support the medication process.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ReasonMedicationNotGivenCodes {
    /** **a**

None. No reason known. */
    A,
    /** **b**

Away. The patient was not available when the dose was scheduled. */
    B,
    /** **c**

Asleep. The patient was asleep when the dose was scheduled. */
    C,
    /** **d**

Vomit. The patient was given the medication and immediately vomited it back. */
    D,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ReasonMedicationNotGivenCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a" => Ok(Self::A),
            "b" => Ok(Self::B),
            "c" => Ok(Self::C),
            "d" => Ok(Self::D),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ReasonMedicationNotGivenCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::A => "a",
            Self::B => "b",
            Self::C => "c",
            Self::D => "d",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ReasonMedicationNotGivenCodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::A => "None",
            Self::B => "Away",
            Self::C => "Asleep",
            Self::D => "Vomit",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ReasonMedicationNotGivenCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReasonMedicationNotGivenCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReasonMedicationNotGivenCodes> for Coding {
    fn from(code: ReasonMedicationNotGivenCodes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/reason-medication-not-given".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ReasonMedicationNotGivenCodes> for CodeableConcept {
    fn from(code: ReasonMedicationNotGivenCodes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ReferenceHandlingPolicy](http://hl7.org/fhir/ValueSet/reference-handling-policy)**. A set of flags that defines how references are supported.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ReferenceHandlingPolicy {
    /** **enforced**

Reference Integrity Enforced. The server enforces that references have integrity - e.g. it ensures that references can always be resolved. This is typically the case for clinical record systems, but often not the case for middleware/proxy systems. */
    Enforced,
    /** **literal**

Literal References. The server supports and populates Literal references (i.e. using Reference.reference) where they are known (this code does not guarantee that all references are literal; see 'enforced'). */
    Literal,
    /** **local**

Local References Only. The server does not support references that point to other servers. */
    Local,
    /** **logical**

Logical References. The server allows logical references (i.e. using Reference.identifier). */
    Logical,
    /** **resolves**

Resolves References. The server will attempt to resolve logical references to literal references - i.e. converting Reference.identifier to Reference.reference (if resolution fails, the server may still accept resources; see logical). */
    Resolves,
}
impl ::core::str::FromStr for ReferenceHandlingPolicy {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "enforced" => Ok(Self::Enforced),
            "literal" => Ok(Self::Literal),
            "local" => Ok(Self::Local),
            "logical" => Ok(Self::Logical),
            "resolves" => Ok(Self::Resolves),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferenceHandlingPolicy {
    fn as_ref(&self) -> &str {
        match self {
            Self::Enforced => "enforced",
            Self::Literal => "literal",
            Self::Local => "local",
            Self::Logical => "logical",
            Self::Resolves => "resolves",
        }
    }
}
impl ::std::fmt::Display for ReferenceHandlingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Enforced => "Reference Integrity Enforced",
            Self::Literal => "Literal References",
            Self::Local => "Local References Only",
            Self::Logical => "Logical References",
            Self::Resolves => "Resolves References",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ReferenceHandlingPolicy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferenceHandlingPolicy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReferenceHandlingPolicy> for Coding {
    fn from(code: ReferenceHandlingPolicy) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/reference-handling-policy".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ReferenceHandlingPolicy> for CodeableConcept {
    fn from(code: ReferenceHandlingPolicy) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ReferenceVersionRules](http://hl7.org/fhir/ValueSet/reference-version-rules)**. Whether a reference needs to be version specific or version independent, or whether either can be used.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ReferenceVersionRules {
    /** **either**

Either Specific or independent. The reference may be either version independent or version specific. */
    Either,
    /** **independent**

Version independent. The reference must be version independent. */
    Independent,
    /** **specific**

Version Specific. The reference must be version specific. */
    Specific,
}
impl ::core::str::FromStr for ReferenceVersionRules {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "either" => Ok(Self::Either),
            "independent" => Ok(Self::Independent),
            "specific" => Ok(Self::Specific),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferenceVersionRules {
    fn as_ref(&self) -> &str {
        match self {
            Self::Either => "either",
            Self::Independent => "independent",
            Self::Specific => "specific",
        }
    }
}
impl ::std::fmt::Display for ReferenceVersionRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Either => "Either Specific or independent",
            Self::Independent => "Version independent",
            Self::Specific => "Version Specific",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ReferenceVersionRules {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferenceVersionRules {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReferenceVersionRules> for Coding {
    fn from(code: ReferenceVersionRules) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/reference-version-rules".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ReferenceVersionRules> for CodeableConcept {
    fn from(code: ReferenceVersionRules) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RegulatedAuthorizationBasis](http://hl7.org/fhir/ValueSet/regulated-authorization-basis)**. RegulatedAuthorizationBasis\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RegulatedAuthorizationBasis {
    /** **Bibliographical**

Bibliographical application (stand-alone). */
    Bibliographical,
    /** **Full**

Full application. */
    Full,
    /** **KnownHumanBlood**

Known human blood/plasma derived ancillary medicinal substance. */
    KnownHumanBlood,
    /** **KnownSubstance**

Known active substance. */
    KnownSubstance,
    /** **NewSubstance**

New active substance. */
    NewSubstance,
    /** **ParallelTrade**

Parallel traded products. */
    ParallelTrade,
    /** **SimilarBiological**

Similar biological application. */
    SimilarBiological,
    /** **TemporaryUse**

Authorizations for temporary use. */
    TemporaryUse,
    /** **TraditionalUse**

Traditional use registration for herbal medicinal product application. */
    TraditionalUse,
    /** **Well-establishedUse**

Well-established use application. */
    WellEstablishedUse,
}
impl ::core::str::FromStr for RegulatedAuthorizationBasis {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Bibliographical" => Ok(Self::Bibliographical),
            "Full" => Ok(Self::Full),
            "KnownHumanBlood" => Ok(Self::KnownHumanBlood),
            "KnownSubstance" => Ok(Self::KnownSubstance),
            "NewSubstance" => Ok(Self::NewSubstance),
            "ParallelTrade" => Ok(Self::ParallelTrade),
            "SimilarBiological" => Ok(Self::SimilarBiological),
            "TemporaryUse" => Ok(Self::TemporaryUse),
            "TraditionalUse" => Ok(Self::TraditionalUse),
            "Well-establishedUse" => Ok(Self::WellEstablishedUse),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RegulatedAuthorizationBasis {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bibliographical => "Bibliographical",
            Self::Full => "Full",
            Self::KnownHumanBlood => "KnownHumanBlood",
            Self::KnownSubstance => "KnownSubstance",
            Self::NewSubstance => "NewSubstance",
            Self::ParallelTrade => "ParallelTrade",
            Self::SimilarBiological => "SimilarBiological",
            Self::TemporaryUse => "TemporaryUse",
            Self::TraditionalUse => "TraditionalUse",
            Self::WellEstablishedUse => "Well-establishedUse",
        }
    }
}
impl ::std::fmt::Display for RegulatedAuthorizationBasis {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Bibliographical => "Bibliographical application (stand-alone)",
            Self::Full => "Full application",
            Self::KnownHumanBlood => {
                "Known human blood/plasma derived ancillary medicinal substance"
            }
            Self::KnownSubstance => "Known active substance",
            Self::NewSubstance => "New active substance",
            Self::ParallelTrade => "Parallel traded products",
            Self::SimilarBiological => "Similar biological application",
            Self::TemporaryUse => "Authorizations for temporary use",
            Self::TraditionalUse => {
                "Traditional use registration for herbal medicinal product application"
            }
            Self::WellEstablishedUse => "Well-established use application",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RegulatedAuthorizationBasis {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RegulatedAuthorizationBasis {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RegulatedAuthorizationBasis> for Coding {
    fn from(code: RegulatedAuthorizationBasis) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/regulated-authorization-basis".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RegulatedAuthorizationBasis> for CodeableConcept {
    fn from(code: RegulatedAuthorizationBasis) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RegulatedAuthorizationCaseType](http://hl7.org/fhir/ValueSet/regulated-authorization-case-type)**. RegulatedAuthorizationCaseType\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RegulatedAuthorizationCaseType {
    /** **100000155699**

Specific Obligation. */
    N100000155699,
    /** **AnnualReassessment**

Annual Reassessment. */
    AnnualReassessment,
    /** **FLU**

FLU STRAIN UPDATE. */
    Flu,
    /** **Follow-up**

Follow-up Measure. */
    FollowUp,
    /** **InitialMAA**

Initial Marketing Authorization Application. */
    InitialMAA,
    /** **LiftingSuspension**

Lifting of a Suspension. */
    LiftingSuspension,
    /** **LineExtension**

Line Extension. */
    LineExtension,
    /** **Orphan**

Orphan Designation Application. */
    Orphan,
    /** **PANDEMIC**

PANDEMIC UPDATE. */
    Pandemic,
    /** **PSUR**

Periodic Safety Update Report. */
    Psur,
    /** **PaediatricSubmission**

Paediatric Submission. */
    PaediatricSubmission,
    /** **RMP**

Risk Management Plan. */
    Rmp,
    /** **Reformatting**

Reformatting. */
    Reformatting,
    /** **Renewal**

Renewal. */
    Renewal,
    /** **RepeatUse**

Repeat Use Procedure. */
    RepeatUse,
    /** **ReviewSuspension**

Review of a Suspension of MA. */
    ReviewSuspension,
    /** **SignalDetection**

Signal detection. */
    SignalDetection,
    /** **SupplementalInformation**

Supplemental Information. */
    SupplementalInformation,
    /** **TransferMA**

Transfer of a marketing authorization. */
    TransferMA,
    /** **UrgentSafetyRestriction**

Urgent Safety Restriction. */
    UrgentSafetyRestriction,
    /** **Variation**

Variation. */
    Variation,
    /** **Withdrawal**

Withdrawal. */
    Withdrawal,
}
impl ::core::str::FromStr for RegulatedAuthorizationCaseType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000155699" => Ok(Self::N100000155699),
            "AnnualReassessment" => Ok(Self::AnnualReassessment),
            "FLU" => Ok(Self::Flu),
            "Follow-up" => Ok(Self::FollowUp),
            "InitialMAA" => Ok(Self::InitialMAA),
            "LiftingSuspension" => Ok(Self::LiftingSuspension),
            "LineExtension" => Ok(Self::LineExtension),
            "Orphan" => Ok(Self::Orphan),
            "PANDEMIC" => Ok(Self::Pandemic),
            "PSUR" => Ok(Self::Psur),
            "PaediatricSubmission" => Ok(Self::PaediatricSubmission),
            "RMP" => Ok(Self::Rmp),
            "Reformatting" => Ok(Self::Reformatting),
            "Renewal" => Ok(Self::Renewal),
            "RepeatUse" => Ok(Self::RepeatUse),
            "ReviewSuspension" => Ok(Self::ReviewSuspension),
            "SignalDetection" => Ok(Self::SignalDetection),
            "SupplementalInformation" => Ok(Self::SupplementalInformation),
            "TransferMA" => Ok(Self::TransferMA),
            "UrgentSafetyRestriction" => Ok(Self::UrgentSafetyRestriction),
            "Variation" => Ok(Self::Variation),
            "Withdrawal" => Ok(Self::Withdrawal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RegulatedAuthorizationCaseType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000155699 => "100000155699",
            Self::AnnualReassessment => "AnnualReassessment",
            Self::Flu => "FLU",
            Self::FollowUp => "Follow-up",
            Self::InitialMAA => "InitialMAA",
            Self::LiftingSuspension => "LiftingSuspension",
            Self::LineExtension => "LineExtension",
            Self::Orphan => "Orphan",
            Self::Pandemic => "PANDEMIC",
            Self::Psur => "PSUR",
            Self::PaediatricSubmission => "PaediatricSubmission",
            Self::Rmp => "RMP",
            Self::Reformatting => "Reformatting",
            Self::Renewal => "Renewal",
            Self::RepeatUse => "RepeatUse",
            Self::ReviewSuspension => "ReviewSuspension",
            Self::SignalDetection => "SignalDetection",
            Self::SupplementalInformation => "SupplementalInformation",
            Self::TransferMA => "TransferMA",
            Self::UrgentSafetyRestriction => "UrgentSafetyRestriction",
            Self::Variation => "Variation",
            Self::Withdrawal => "Withdrawal",
        }
    }
}
impl ::std::fmt::Display for RegulatedAuthorizationCaseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000155699 => "Specific Obligation",
            Self::AnnualReassessment => "Annual Reassessment",
            Self::Flu => "FLU STRAIN UPDATE",
            Self::FollowUp => "Follow-up Measure",
            Self::InitialMAA => "Initial Marketing Authorization Application",
            Self::LiftingSuspension => "Lifting of a Suspension",
            Self::LineExtension => "Line Extension",
            Self::Orphan => "Orphan Designation Application",
            Self::Pandemic => "PANDEMIC UPDATE",
            Self::Psur => "Periodic Safety Update Report",
            Self::PaediatricSubmission => "Paediatric Submission",
            Self::Rmp => "Risk Management Plan",
            Self::Reformatting => "Reformatting",
            Self::Renewal => "Renewal",
            Self::RepeatUse => "Repeat Use Procedure",
            Self::ReviewSuspension => "Review of a Suspension of MA",
            Self::SignalDetection => "Signal detection",
            Self::SupplementalInformation => "Supplemental Information",
            Self::TransferMA => "Transfer of a marketing authorization",
            Self::UrgentSafetyRestriction => "Urgent Safety Restriction",
            Self::Variation => "Variation",
            Self::Withdrawal => "Withdrawal",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RegulatedAuthorizationCaseType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RegulatedAuthorizationCaseType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RegulatedAuthorizationCaseType> for Coding {
    fn from(code: RegulatedAuthorizationCaseType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/regulated-authorization-case-type"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RegulatedAuthorizationCaseType> for CodeableConcept {
    fn from(code: RegulatedAuthorizationCaseType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RegulatedAuthorizationType](http://hl7.org/fhir/ValueSet/regulated-authorization-type)**. RegulatedAuthorizationType\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RegulatedAuthorizationType {
    /** **MarketingAuth**

Marketing Authorization. */
    MarketingAuth,
    /** **Orphan**

Orphan Drug Authorization. */
    Orphan,
    /** **Pediatric**

Pediatric Use Drug Authorization. */
    Pediatric,
}
impl ::core::str::FromStr for RegulatedAuthorizationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "MarketingAuth" => Ok(Self::MarketingAuth),
            "Orphan" => Ok(Self::Orphan),
            "Pediatric" => Ok(Self::Pediatric),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RegulatedAuthorizationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MarketingAuth => "MarketingAuth",
            Self::Orphan => "Orphan",
            Self::Pediatric => "Pediatric",
        }
    }
}
impl ::std::fmt::Display for RegulatedAuthorizationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::MarketingAuth => "Marketing Authorization",
            Self::Orphan => "Orphan Drug Authorization",
            Self::Pediatric => "Pediatric Use Drug Authorization",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RegulatedAuthorizationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RegulatedAuthorizationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RegulatedAuthorizationType> for Coding {
    fn from(code: RegulatedAuthorizationType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/regulated-authorization-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RegulatedAuthorizationType> for CodeableConcept {
    fn from(code: RegulatedAuthorizationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RelatedArtifactType](http://hl7.org/fhir/ValueSet/related-artifact-type)**. The type of relationship to the related artifact.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RelatedArtifactType {
    /** **amended-with**

Amended With. This artifact is amended with or changed by the target artifact. There is information in this artifact that should be functionally replaced with information in the target artifact. */
    AmendedWith,
    /** **amends**

Amends. This artifact amends or changes the target artifact. This artifact adds additional information that is functionally expected to replace information in the target artifact. This artifact replaces a part but not all of the target artifact. */
    Amends,
    /** **appended-with**

Appended With. This artifact has additional information in the target artifact. */
    AppendedWith,
    /** **appends**

Appends. This artifact adds additional information to the target artifact. The additional information does not replace or change information in the target artifact. */
    Appends,
    /** **citation**

Citation. Bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource. */
    Citation,
    /** **cite-as**

Cite As. The related artifact is the citation for this artifact. */
    CiteAs,
    /** **cited-by**

Cited By. This artifact is cited by the target artifact. */
    CitedBy,
    /** **cites**

Cites. This artifact cites the target artifact. This may be a bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource. */
    Cites,
    /** **comment-in**

Has Comment In. This artifact has comments about it in the target artifact.  The type of comments may be expressed in the targetClassifier element such as reply, review, editorial, feedback, solicited, unsolicited, structured, unstructured. */
    CommentIn,
    /** **comments-on**

Is Comment On. This artifact contains comments about the target artifact. */
    CommentsOn,
    /** **composed-of**

Composed Of. This artifact is composed of the target artifact. This artifact is constructed with the target artifact as a component. The target artifact is a part of this artifact. (A dataset is composed of data.). */
    ComposedOf,
    /** **contained-in**

Contained In. This artifact is contained in the target artifact. The target artifact is a data structure whose instances are collections of other objects. */
    ContainedIn,
    /** **contains**

Contains. This artifact is a container in which the target artifact is contained. A container is a data structure whose instances are collections of other objects. (A database contains the dataset.). */
    Contains,
    /** **correction-in**

Correction In. This artifact has corrections to it in the target artifact. The target artifact identifies errors and replacement content for this artifact. */
    CorrectionIn,
    /** **corrects**

Corrects. This artifact identifies errors and replacement content for the target artifact. */
    Corrects,
    /** **created-with**

Created With. This artifact was created with the target artifact. The target artifact is a tool or support material used in the creation of the artifact, and not content that the artifact was derived from. */
    CreatedWith,
    /** **depends-on**

Depends On. This artifact depends on the target artifact. There is a requirement to use the target artifact in the creation or interpretation of this artifact. */
    DependsOn,
    /** **derived-from**

Derived From. This artifact is derived from the target artifact. This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but is modified to capture either a different set of overall requirements, or a more specific set of requirements such as those involved in a particular institution or clinical setting. The artifact may be derived from one or more target artifacts. */
    DerivedFrom,
    /** **documentation**

Documentation. Additional documentation for the knowledge resource. This would include additional instructions on usage as well as additional information on clinical context or appropriateness. */
    Documentation,
    /** **documents**

Documents. This artifact provides additional documentation for the target artifact. This could include additional instructions on usage as well as additional information on clinical context or appropriateness. */
    Documents,
    /** **justification**

Justification. The target artifact is a summary of the justification for the knowledge resource including supporting evidence, relevant guidelines, or other clinically important information. This information is intended to provide a way to make the justification for the knowledge resource available to the consumer of interventions or results produced by the knowledge resource. */
    Justification,
    /** **part-of**

Part Of. This artifact is a part of the target artifact. The target artifact is composed of this artifact (and possibly other artifacts). */
    PartOf,
    /** **predecessor**

Predecessor. The previous version of the knowledge artifact, used to establish an ordering of versions of an artifact, independent of the status of each version. */
    Predecessor,
    /** **replaced-with**

Replaced With. This artifact is replaced with or superseded by the target artifact. This artifact may be considered deprecated. */
    ReplacedWith,
    /** **replaces**

Replaces. This artifact replaces or supersedes the target artifact. The target artifact may be considered deprecated. */
    Replaces,
    /** **retracted-by**

Retracted By. This artifact is retracted by the target artifact. The content that was published in this artifact should be considered removed from publication and should no longer be considered part of the public record. */
    RetractedBy,
    /** **retracts**

Retracts. This artifact retracts the target artifact. The content that was published in the target artifact should be considered removed from publication and should no longer be considered part of the public record. */
    Retracts,
    /** **signs**

Signs. This artifact is a signature of the target artifact. */
    Signs,
    /** **similar-to**

Similar To. This artifact has characteristics in common with the target artifact. This relationship may be used in systems to “deduplicate” knowledge artifacts from different sources, or in systems to show “similar items”. */
    SimilarTo,
    /** **specification-of**

Specification Of. The target artifact is a precise description of a concept in this artifact. This may be used when the RelatedArtifact datatype is used in elements contained in this artifact. */
    SpecificationOf,
    /** **successor**

Successor. The subsequent version of the knowledge artfact, used to establish an ordering of versions of an artifact, independent of the status of each version. */
    Successor,
    /** **supported-with**

Supported With. The target artifact contains additional information related to the knowledge artifact but is not documentation as the additional information does not describe, explain, or instruct regarding the knowledge artifact content or application. This could include an associated dataset. */
    SupportedWith,
    /** **supports**

Supports. This artifact provides additional support for the target artifact. The type of support  is not documentation as it does not describe, explain, or instruct regarding the target artifact. */
    Supports,
    /** **transformed-into**

Transformed Into. This artifact was transformed into the target artifact (e.g., by format or language conversion). */
    TransformedInto,
    /** **transformed-with**

Transformed With. This artifact was generated by transforming a related artifact (e.g., format or language conversion), noted separately with the “transforms” relationship type. This transformation used the target artifact to inform the transformation. The target artifact may be a conversion script or translation guide. */
    TransformedWith,
    /** **transforms**

Transforms. This artifact was generated by transforming the target artifact (e.g., format or language conversion). This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but changes are only apparent in form and there is only one target artifact with the “transforms” relationship type. */
    Transforms,
}
impl ::core::str::FromStr for RelatedArtifactType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended-with" => Ok(Self::AmendedWith),
            "amends" => Ok(Self::Amends),
            "appended-with" => Ok(Self::AppendedWith),
            "appends" => Ok(Self::Appends),
            "citation" => Ok(Self::Citation),
            "cite-as" => Ok(Self::CiteAs),
            "cited-by" => Ok(Self::CitedBy),
            "cites" => Ok(Self::Cites),
            "comment-in" => Ok(Self::CommentIn),
            "comments-on" => Ok(Self::CommentsOn),
            "composed-of" => Ok(Self::ComposedOf),
            "contained-in" => Ok(Self::ContainedIn),
            "contains" => Ok(Self::Contains),
            "correction-in" => Ok(Self::CorrectionIn),
            "corrects" => Ok(Self::Corrects),
            "created-with" => Ok(Self::CreatedWith),
            "depends-on" => Ok(Self::DependsOn),
            "derived-from" => Ok(Self::DerivedFrom),
            "documentation" => Ok(Self::Documentation),
            "documents" => Ok(Self::Documents),
            "justification" => Ok(Self::Justification),
            "part-of" => Ok(Self::PartOf),
            "predecessor" => Ok(Self::Predecessor),
            "replaced-with" => Ok(Self::ReplacedWith),
            "replaces" => Ok(Self::Replaces),
            "retracted-by" => Ok(Self::RetractedBy),
            "retracts" => Ok(Self::Retracts),
            "signs" => Ok(Self::Signs),
            "similar-to" => Ok(Self::SimilarTo),
            "specification-of" => Ok(Self::SpecificationOf),
            "successor" => Ok(Self::Successor),
            "supported-with" => Ok(Self::SupportedWith),
            "supports" => Ok(Self::Supports),
            "transformed-into" => Ok(Self::TransformedInto),
            "transformed-with" => Ok(Self::TransformedWith),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RelatedArtifactType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AmendedWith => "amended-with",
            Self::Amends => "amends",
            Self::AppendedWith => "appended-with",
            Self::Appends => "appends",
            Self::Citation => "citation",
            Self::CiteAs => "cite-as",
            Self::CitedBy => "cited-by",
            Self::Cites => "cites",
            Self::CommentIn => "comment-in",
            Self::CommentsOn => "comments-on",
            Self::ComposedOf => "composed-of",
            Self::ContainedIn => "contained-in",
            Self::Contains => "contains",
            Self::CorrectionIn => "correction-in",
            Self::Corrects => "corrects",
            Self::CreatedWith => "created-with",
            Self::DependsOn => "depends-on",
            Self::DerivedFrom => "derived-from",
            Self::Documentation => "documentation",
            Self::Documents => "documents",
            Self::Justification => "justification",
            Self::PartOf => "part-of",
            Self::Predecessor => "predecessor",
            Self::ReplacedWith => "replaced-with",
            Self::Replaces => "replaces",
            Self::RetractedBy => "retracted-by",
            Self::Retracts => "retracts",
            Self::Signs => "signs",
            Self::SimilarTo => "similar-to",
            Self::SpecificationOf => "specification-of",
            Self::Successor => "successor",
            Self::SupportedWith => "supported-with",
            Self::Supports => "supports",
            Self::TransformedInto => "transformed-into",
            Self::TransformedWith => "transformed-with",
            Self::Transforms => "transforms",
        }
    }
}
impl ::std::fmt::Display for RelatedArtifactType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AmendedWith => "Amended With",
            Self::Amends => "Amends",
            Self::AppendedWith => "Appended With",
            Self::Appends => "Appends",
            Self::Citation => "Citation",
            Self::CiteAs => "Cite As",
            Self::CitedBy => "Cited By",
            Self::Cites => "Cites",
            Self::CommentIn => "Has Comment In",
            Self::CommentsOn => "Is Comment On",
            Self::ComposedOf => "Composed Of",
            Self::ContainedIn => "Contained In",
            Self::Contains => "Contains",
            Self::CorrectionIn => "Correction In",
            Self::Corrects => "Corrects",
            Self::CreatedWith => "Created With",
            Self::DependsOn => "Depends On",
            Self::DerivedFrom => "Derived From",
            Self::Documentation => "Documentation",
            Self::Documents => "Documents",
            Self::Justification => "Justification",
            Self::PartOf => "Part Of",
            Self::Predecessor => "Predecessor",
            Self::ReplacedWith => "Replaced With",
            Self::Replaces => "Replaces",
            Self::RetractedBy => "Retracted By",
            Self::Retracts => "Retracts",
            Self::Signs => "Signs",
            Self::SimilarTo => "Similar To",
            Self::SpecificationOf => "Specification Of",
            Self::Successor => "Successor",
            Self::SupportedWith => "Supported With",
            Self::Supports => "Supports",
            Self::TransformedInto => "Transformed Into",
            Self::TransformedWith => "Transformed With",
            Self::Transforms => "Transforms",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RelatedArtifactType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RelatedArtifactType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RelatedArtifactType> for Coding {
    fn from(code: RelatedArtifactType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/related-artifact-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RelatedArtifactType> for CodeableConcept {
    fn from(code: RelatedArtifactType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RelatedArtifactTypeExpanded](http://hl7.org/fhir/ValueSet/related-artifact-type-expanded)**. The type of relationship to the cited artifact.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RelatedArtifactTypeExpanded {
    /** **amended-with**

Amended With. This artifact is amended with or changed by the target artifact. There is information in this artifact that should be functionally replaced with information in the target artifact. */
    AmendedWith,
    /** **amends**

Amends. This artifact amends or changes the target artifact. This artifact adds additional information that is functionally expected to replace information in the target artifact. This artifact replaces a part but not all of the target artifact. */
    Amends,
    /** **appended-with**

Appended With. This artifact has additional information in the target artifact. */
    AppendedWith,
    /** **appends**

Appends. This artifact adds additional information to the target artifact. The additional information does not replace or change information in the target artifact. */
    Appends,
    /** **citation**

Citation. Bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource. */
    Citation,
    /** **cite-as**

Cite As. The related artifact is the citation for this artifact. */
    CiteAs,
    /** **cited-by**

Cited By. This artifact is cited by the target artifact. */
    CitedBy,
    /** **cites**

Cites. This artifact cites the target artifact. This may be a bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource. */
    Cites,
    /** **comment-in**

Has Comment In. This artifact has comments about it in the target artifact.  The type of comments may be expressed in the targetClassifier element such as reply, review, editorial, feedback, solicited, unsolicited, structured, unstructured. */
    CommentIn,
    /** **comments-on**

Is Comment On. This artifact contains comments about the target artifact. */
    CommentsOn,
    /** **composed-of**

Composed Of. This artifact is composed of the target artifact. This artifact is constructed with the target artifact as a component. The target artifact is a part of this artifact. (A dataset is composed of data.). */
    ComposedOf,
    /** **contained-in**

Contained In. This artifact is contained in the target artifact. The target artifact is a data structure whose instances are collections of other objects. */
    ContainedIn,
    /** **contains**

Contains. This artifact is a container in which the target artifact is contained. A container is a data structure whose instances are collections of other objects. (A database contains the dataset.). */
    Contains,
    /** **correction-in**

Correction In. This artifact has corrections to it in the target artifact. The target artifact identifies errors and replacement content for this artifact. */
    CorrectionIn,
    /** **corrects**

Corrects. This artifact identifies errors and replacement content for the target artifact. */
    Corrects,
    /** **created-with**

Created With. This artifact was created with the target artifact. The target artifact is a tool or support material used in the creation of the artifact, and not content that the artifact was derived from. */
    CreatedWith,
    /** **depends-on**

Depends On. This artifact depends on the target artifact. There is a requirement to use the target artifact in the creation or interpretation of this artifact. */
    DependsOn,
    /** **derived-from**

Derived From. This artifact is derived from the target artifact. This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but is modified to capture either a different set of overall requirements, or a more specific set of requirements such as those involved in a particular institution or clinical setting. The artifact may be derived from one or more target artifacts. */
    DerivedFrom,
    /** **documentation**

Documentation. Additional documentation for the knowledge resource. This would include additional instructions on usage as well as additional information on clinical context or appropriateness. */
    Documentation,
    /** **documents**

Documents. This artifact provides additional documentation for the target artifact. This could include additional instructions on usage as well as additional information on clinical context or appropriateness. */
    Documents,
    /** **justification**

Justification. The target artifact is a summary of the justification for the knowledge resource including supporting evidence, relevant guidelines, or other clinically important information. This information is intended to provide a way to make the justification for the knowledge resource available to the consumer of interventions or results produced by the knowledge resource. */
    Justification,
    /** **part-of**

Part Of. This artifact is a part of the target artifact. The target artifact is composed of this artifact (and possibly other artifacts). */
    PartOf,
    /** **predecessor**

Predecessor. The previous version of the knowledge artifact, used to establish an ordering of versions of an artifact, independent of the status of each version. */
    Predecessor,
    /** **replaced-with**

Replaced With. This artifact is replaced with or superseded by the target artifact. This artifact may be considered deprecated. */
    ReplacedWith,
    /** **replaces**

Replaces. This artifact replaces or supersedes the target artifact. The target artifact may be considered deprecated. */
    Replaces,
    /** **reprint**

Reprint. A copy of the artifact in a publication with a different artifact identifier. */
    Reprint,
    /** **reprint-of**

Reprint Of. The original version of record for which the current artifact is a copy. */
    ReprintOf,
    /** **retracted-by**

Retracted By. This artifact is retracted by the target artifact. The content that was published in this artifact should be considered removed from publication and should no longer be considered part of the public record. */
    RetractedBy,
    /** **retracts**

Retracts. This artifact retracts the target artifact. The content that was published in the target artifact should be considered removed from publication and should no longer be considered part of the public record. */
    Retracts,
    /** **signs**

Signs. This artifact is a signature of the target artifact. */
    Signs,
    /** **similar-to**

Similar To. This artifact has characteristics in common with the target artifact. This relationship may be used in systems to “deduplicate” knowledge artifacts from different sources, or in systems to show “similar items”. */
    SimilarTo,
    /** **specification-of**

Specification Of. The target artifact is a precise description of a concept in this artifact. This may be used when the RelatedArtifact datatype is used in elements contained in this artifact. */
    SpecificationOf,
    /** **successor**

Successor. The subsequent version of the knowledge artfact, used to establish an ordering of versions of an artifact, independent of the status of each version. */
    Successor,
    /** **supported-with**

Supported With. The target artifact contains additional information related to the knowledge artifact but is not documentation as the additional information does not describe, explain, or instruct regarding the knowledge artifact content or application. This could include an associated dataset. */
    SupportedWith,
    /** **supports**

Supports. This artifact provides additional support for the target artifact. The type of support  is not documentation as it does not describe, explain, or instruct regarding the target artifact. */
    Supports,
    /** **transformed-into**

Transformed Into. This artifact was transformed into the target artifact (e.g., by format or language conversion). */
    TransformedInto,
    /** **transformed-with**

Transformed With. This artifact was generated by transforming a related artifact (e.g., format or language conversion), noted separately with the “transforms” relationship type. This transformation used the target artifact to inform the transformation. The target artifact may be a conversion script or translation guide. */
    TransformedWith,
    /** **transforms**

Transforms. This artifact was generated by transforming the target artifact (e.g., format or language conversion). This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but changes are only apparent in form and there is only one target artifact with the “transforms” relationship type. */
    Transforms,
}
impl ::core::str::FromStr for RelatedArtifactTypeExpanded {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended-with" => Ok(Self::AmendedWith),
            "amends" => Ok(Self::Amends),
            "appended-with" => Ok(Self::AppendedWith),
            "appends" => Ok(Self::Appends),
            "citation" => Ok(Self::Citation),
            "cite-as" => Ok(Self::CiteAs),
            "cited-by" => Ok(Self::CitedBy),
            "cites" => Ok(Self::Cites),
            "comment-in" => Ok(Self::CommentIn),
            "comments-on" => Ok(Self::CommentsOn),
            "composed-of" => Ok(Self::ComposedOf),
            "contained-in" => Ok(Self::ContainedIn),
            "contains" => Ok(Self::Contains),
            "correction-in" => Ok(Self::CorrectionIn),
            "corrects" => Ok(Self::Corrects),
            "created-with" => Ok(Self::CreatedWith),
            "depends-on" => Ok(Self::DependsOn),
            "derived-from" => Ok(Self::DerivedFrom),
            "documentation" => Ok(Self::Documentation),
            "documents" => Ok(Self::Documents),
            "justification" => Ok(Self::Justification),
            "part-of" => Ok(Self::PartOf),
            "predecessor" => Ok(Self::Predecessor),
            "replaced-with" => Ok(Self::ReplacedWith),
            "replaces" => Ok(Self::Replaces),
            "reprint" => Ok(Self::Reprint),
            "reprint-of" => Ok(Self::ReprintOf),
            "retracted-by" => Ok(Self::RetractedBy),
            "retracts" => Ok(Self::Retracts),
            "signs" => Ok(Self::Signs),
            "similar-to" => Ok(Self::SimilarTo),
            "specification-of" => Ok(Self::SpecificationOf),
            "successor" => Ok(Self::Successor),
            "supported-with" => Ok(Self::SupportedWith),
            "supports" => Ok(Self::Supports),
            "transformed-into" => Ok(Self::TransformedInto),
            "transformed-with" => Ok(Self::TransformedWith),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RelatedArtifactTypeExpanded {
    fn as_ref(&self) -> &str {
        match self {
            Self::AmendedWith => "amended-with",
            Self::Amends => "amends",
            Self::AppendedWith => "appended-with",
            Self::Appends => "appends",
            Self::Citation => "citation",
            Self::CiteAs => "cite-as",
            Self::CitedBy => "cited-by",
            Self::Cites => "cites",
            Self::CommentIn => "comment-in",
            Self::CommentsOn => "comments-on",
            Self::ComposedOf => "composed-of",
            Self::ContainedIn => "contained-in",
            Self::Contains => "contains",
            Self::CorrectionIn => "correction-in",
            Self::Corrects => "corrects",
            Self::CreatedWith => "created-with",
            Self::DependsOn => "depends-on",
            Self::DerivedFrom => "derived-from",
            Self::Documentation => "documentation",
            Self::Documents => "documents",
            Self::Justification => "justification",
            Self::PartOf => "part-of",
            Self::Predecessor => "predecessor",
            Self::ReplacedWith => "replaced-with",
            Self::Replaces => "replaces",
            Self::Reprint => "reprint",
            Self::ReprintOf => "reprint-of",
            Self::RetractedBy => "retracted-by",
            Self::Retracts => "retracts",
            Self::Signs => "signs",
            Self::SimilarTo => "similar-to",
            Self::SpecificationOf => "specification-of",
            Self::Successor => "successor",
            Self::SupportedWith => "supported-with",
            Self::Supports => "supports",
            Self::TransformedInto => "transformed-into",
            Self::TransformedWith => "transformed-with",
            Self::Transforms => "transforms",
        }
    }
}
impl ::std::fmt::Display for RelatedArtifactTypeExpanded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AmendedWith => "Amended With",
            Self::Amends => "Amends",
            Self::AppendedWith => "Appended With",
            Self::Appends => "Appends",
            Self::Citation => "Citation",
            Self::CiteAs => "Cite As",
            Self::CitedBy => "Cited By",
            Self::Cites => "Cites",
            Self::CommentIn => "Has Comment In",
            Self::CommentsOn => "Is Comment On",
            Self::ComposedOf => "Composed Of",
            Self::ContainedIn => "Contained In",
            Self::Contains => "Contains",
            Self::CorrectionIn => "Correction In",
            Self::Corrects => "Corrects",
            Self::CreatedWith => "Created With",
            Self::DependsOn => "Depends On",
            Self::DerivedFrom => "Derived From",
            Self::Documentation => "Documentation",
            Self::Documents => "Documents",
            Self::Justification => "Justification",
            Self::PartOf => "Part Of",
            Self::Predecessor => "Predecessor",
            Self::ReplacedWith => "Replaced With",
            Self::Replaces => "Replaces",
            Self::Reprint => "Reprint",
            Self::ReprintOf => "Reprint Of",
            Self::RetractedBy => "Retracted By",
            Self::Retracts => "Retracts",
            Self::Signs => "Signs",
            Self::SimilarTo => "Similar To",
            Self::SpecificationOf => "Specification Of",
            Self::Successor => "Successor",
            Self::SupportedWith => "Supported With",
            Self::Supports => "Supports",
            Self::TransformedInto => "Transformed Into",
            Self::TransformedWith => "Transformed With",
            Self::Transforms => "Transforms",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RelatedArtifactTypeExpanded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RelatedArtifactTypeExpanded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RelatedArtifactTypeExpanded> for Coding {
    fn from(code: RelatedArtifactTypeExpanded) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/related-artifact-type-expanded".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RelatedArtifactTypeExpanded> for CodeableConcept {
    fn from(code: RelatedArtifactTypeExpanded) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RemittanceOutcome](http://hl7.org/fhir/ValueSet/remittance-outcome)**. The outcome of the processing.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RemittanceOutcome {
    /** **complete**

Complete. The processing completed without errors. */
    Complete,
    /** **error**

Error. The processing identified errors. */
    Error,
    /** **partial**

Partial. No errors have been detected and some of the adjudication has been performed. */
    Partial,
}
impl ::core::str::FromStr for RemittanceOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "error" => Ok(Self::Error),
            "partial" => Ok(Self::Partial),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RemittanceOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Error => "error",
            Self::Partial => "partial",
        }
    }
}
impl ::std::fmt::Display for RemittanceOutcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Complete => "Complete",
            Self::Error => "Error",
            Self::Partial => "Partial",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RemittanceOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RemittanceOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RemittanceOutcome> for Coding {
    fn from(code: RemittanceOutcome) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/remittance-outcome".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RemittanceOutcome> for CodeableConcept {
    fn from(code: RemittanceOutcome) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ReportRelationshipType](http://hl7.org/fhir/ValueSet/report-relation-type)**. The type of relationship between reports.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ReportRelationshipType {
    /** **amendedWith**

Amended With. This document was. */
    AmendedWith,
    /** **amends**

Amends. This document notes corrections or changes to replace or supersede parts of the target document. */
    Amends,
    /** **appendedWith**

Appended With. This document was. */
    AppendedWith,
    /** **appends**

Appends. This document adds additional information to the target document. */
    Appends,
    /** **replacedWith**

Replaced With. This document was. */
    ReplacedWith,
    /** **replaces**

Replaces. This document replaces or supersedes the target document. */
    Replaces,
    /** **transformedWith**

Transformed With. This document was. */
    TransformedWith,
    /** **transforms**

Transforms. This document was generated by transforming the target document (eg format or language conversion). */
    Transforms,
}
impl ::core::str::FromStr for ReportRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amendedWith" => Ok(Self::AmendedWith),
            "amends" => Ok(Self::Amends),
            "appendedWith" => Ok(Self::AppendedWith),
            "appends" => Ok(Self::Appends),
            "replacedWith" => Ok(Self::ReplacedWith),
            "replaces" => Ok(Self::Replaces),
            "transformedWith" => Ok(Self::TransformedWith),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReportRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AmendedWith => "amendedWith",
            Self::Amends => "amends",
            Self::AppendedWith => "appendedWith",
            Self::Appends => "appends",
            Self::ReplacedWith => "replacedWith",
            Self::Replaces => "replaces",
            Self::TransformedWith => "transformedWith",
            Self::Transforms => "transforms",
        }
    }
}
impl ::std::fmt::Display for ReportRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AmendedWith => "Amended With",
            Self::Amends => "Amends",
            Self::AppendedWith => "Appended With",
            Self::Appends => "Appends",
            Self::ReplacedWith => "Replaced With",
            Self::Replaces => "Replaces",
            Self::TransformedWith => "Transformed With",
            Self::Transforms => "Transforms",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ReportRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReportRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReportRelationshipType> for Coding {
    fn from(code: ReportRelationshipType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/report-relation-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ReportRelationshipType> for CodeableConcept {
    fn from(code: ReportRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ReportSectionType](http://hl7.org/fhir/ValueSet/evidence-report-section)**. Evidence Report Section Type.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ReportSectionType {
    /** **Assertion**

Assertion. Assertion. */
    Assertion,
    /** **Certainty-of-Evidence**

Certainty of Evidence. Certainty of Evidence. */
    CertaintyOfEvidence,
    /** **Column-Header**

Column Header. Denotes the header to use for the column for a tabular report. */
    ColumnHeader,
    /** **Column-Headers**

Column Headers. Denotes a section specifying column headers for a tabular report. */
    ColumnHeaders,
    /** **Control-group-alone-Evidence**

Evidence Results for the control exposure only. Evidence Results for the control exposure only. */
    ControlGroupAloneEvidence,
    /** **Efficacy-outcomes**

Efficacy-outcomes. Outcomes related to efficacy or potential benefits of interventions. */
    EfficacyOutcomes,
    /** **Evidence**

Evidence Results. Evidence Results. */
    Evidence,
    /** **Evidence-Classifier**

Evidence Classifier section. This section is used for classifiers of the evidence. */
    EvidenceClassifier,
    /** **EvidenceVariable**

Evidence Variables used. Evidence Variables used. */
    EvidenceVariable,
    /** **EvidenceVariable-exposure**

Evidence Variable in variable role Exposure. Evidence Variable in variable role Exposure. */
    EvidenceVariableExposure,
    /** **EvidenceVariable-intended**

Evidence Variables intended for interpretation. Evidence Variables intended for interpretation. */
    EvidenceVariableIntended,
    /** **EvidenceVariable-observed**

Evidence Variables actually observed. Evidence Variables as observed in the research data. */
    EvidenceVariableObserved,
    /** **EvidenceVariable-outcome**

Evidence Variable in variable role Outcome (MeasuredVariable). Evidence Variable in variable role Outcome (MeasuredVariable). */
    EvidenceVariableOutcome,
    /** **EvidenceVariable-population**

Evidence Variable in variable role Population. Evidence Variable in variable role Population. */
    EvidenceVariablePopulation,
    /** **Harms-outcomes**

Harms outcomes. Outcomes related to adverse effects or potential harms of interventions. */
    HarmsOutcomes,
    /** **Header**

Header. Denotes the header to use for a Text Summary or above a Table. */
    Header,
    /** **Intervention-group-alone-Evidence**

Evidence Results for the intervention exposure only. Evidence Results for the intervention exposure only. */
    InterventionGroupAloneEvidence,
    /** **Intervention-vs-Control-Evidence**

Evidence Results for comparison of Intervention and Control. Evidence Results for comparison of Intervention and Control. */
    InterventionVsControlEvidence,
    /** **Reasons**

Reasons. Reasons. */
    Reasons,
    /** **References**

References. References. */
    References,
    /** **Row-Headers**

Row Headers. Denotes a section specifying row headers for a tabular report. */
    RowHeaders,
    /** **SampleSize**

Sample Size. Sample Size. */
    SampleSize,
    /** **SummaryOfBodyOfEvidenceFindings**

Summary of Body of Evidence Findings. Summary of Body of Evidence Findings. */
    SummaryOfBodyOfEvidenceFindings,
    /** **SummaryOfIndividualStudyFindings**

Summary of Individual Study Findings. Summary of Individual Study Findings. */
    SummaryOfIndividualStudyFindings,
    /** **Table**

Table. */
    Table,
    /** **Tables**

Tables. Tables. */
    Tables,
    /** **Text-Summary**

Text Summary. Denotes a section specifying text summary for a report. */
    TextSummary,
    /** **Warnings**

Warnings. Warnings. */
    Warnings,
}
impl ::core::str::FromStr for ReportSectionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Assertion" => Ok(Self::Assertion),
            "Certainty-of-Evidence" => Ok(Self::CertaintyOfEvidence),
            "Column-Header" => Ok(Self::ColumnHeader),
            "Column-Headers" => Ok(Self::ColumnHeaders),
            "Control-group-alone-Evidence" => Ok(Self::ControlGroupAloneEvidence),
            "Efficacy-outcomes" => Ok(Self::EfficacyOutcomes),
            "Evidence" => Ok(Self::Evidence),
            "Evidence-Classifier" => Ok(Self::EvidenceClassifier),
            "EvidenceVariable" => Ok(Self::EvidenceVariable),
            "EvidenceVariable-exposure" => Ok(Self::EvidenceVariableExposure),
            "EvidenceVariable-intended" => Ok(Self::EvidenceVariableIntended),
            "EvidenceVariable-observed" => Ok(Self::EvidenceVariableObserved),
            "EvidenceVariable-outcome" => Ok(Self::EvidenceVariableOutcome),
            "EvidenceVariable-population" => Ok(Self::EvidenceVariablePopulation),
            "Harms-outcomes" => Ok(Self::HarmsOutcomes),
            "Header" => Ok(Self::Header),
            "Intervention-group-alone-Evidence" => {
                Ok(Self::InterventionGroupAloneEvidence)
            }
            "Intervention-vs-Control-Evidence" => Ok(Self::InterventionVsControlEvidence),
            "Reasons" => Ok(Self::Reasons),
            "References" => Ok(Self::References),
            "Row-Headers" => Ok(Self::RowHeaders),
            "SampleSize" => Ok(Self::SampleSize),
            "SummaryOfBodyOfEvidenceFindings" => {
                Ok(Self::SummaryOfBodyOfEvidenceFindings)
            }
            "SummaryOfIndividualStudyFindings" => {
                Ok(Self::SummaryOfIndividualStudyFindings)
            }
            "Table" => Ok(Self::Table),
            "Tables" => Ok(Self::Tables),
            "Text-Summary" => Ok(Self::TextSummary),
            "Warnings" => Ok(Self::Warnings),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReportSectionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assertion => "Assertion",
            Self::CertaintyOfEvidence => "Certainty-of-Evidence",
            Self::ColumnHeader => "Column-Header",
            Self::ColumnHeaders => "Column-Headers",
            Self::ControlGroupAloneEvidence => "Control-group-alone-Evidence",
            Self::EfficacyOutcomes => "Efficacy-outcomes",
            Self::Evidence => "Evidence",
            Self::EvidenceClassifier => "Evidence-Classifier",
            Self::EvidenceVariable => "EvidenceVariable",
            Self::EvidenceVariableExposure => "EvidenceVariable-exposure",
            Self::EvidenceVariableIntended => "EvidenceVariable-intended",
            Self::EvidenceVariableObserved => "EvidenceVariable-observed",
            Self::EvidenceVariableOutcome => "EvidenceVariable-outcome",
            Self::EvidenceVariablePopulation => "EvidenceVariable-population",
            Self::HarmsOutcomes => "Harms-outcomes",
            Self::Header => "Header",
            Self::InterventionGroupAloneEvidence => "Intervention-group-alone-Evidence",
            Self::InterventionVsControlEvidence => "Intervention-vs-Control-Evidence",
            Self::Reasons => "Reasons",
            Self::References => "References",
            Self::RowHeaders => "Row-Headers",
            Self::SampleSize => "SampleSize",
            Self::SummaryOfBodyOfEvidenceFindings => "SummaryOfBodyOfEvidenceFindings",
            Self::SummaryOfIndividualStudyFindings => "SummaryOfIndividualStudyFindings",
            Self::Table => "Table",
            Self::Tables => "Tables",
            Self::TextSummary => "Text-Summary",
            Self::Warnings => "Warnings",
        }
    }
}
impl ::std::fmt::Display for ReportSectionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Assertion => "Assertion",
            Self::CertaintyOfEvidence => "Certainty of Evidence",
            Self::ColumnHeader => "Column Header",
            Self::ColumnHeaders => "Column Headers",
            Self::ControlGroupAloneEvidence => {
                "Evidence Results for the control exposure only"
            }
            Self::EfficacyOutcomes => "Efficacy-outcomes",
            Self::Evidence => "Evidence Results",
            Self::EvidenceClassifier => "Evidence Classifier section",
            Self::EvidenceVariable => "Evidence Variables used",
            Self::EvidenceVariableExposure => {
                "Evidence Variable in variable role Exposure"
            }
            Self::EvidenceVariableIntended => {
                "Evidence Variables intended for interpretation"
            }
            Self::EvidenceVariableObserved => "Evidence Variables actually observed",
            Self::EvidenceVariableOutcome => {
                "Evidence Variable in variable role Outcome (MeasuredVariable)"
            }
            Self::EvidenceVariablePopulation => {
                "Evidence Variable in variable role Population"
            }
            Self::HarmsOutcomes => "Harms outcomes",
            Self::Header => "Header",
            Self::InterventionGroupAloneEvidence => {
                "Evidence Results for the intervention exposure only"
            }
            Self::InterventionVsControlEvidence => {
                "Evidence Results for comparison of Intervention and Control"
            }
            Self::Reasons => "Reasons",
            Self::References => "References",
            Self::RowHeaders => "Row Headers",
            Self::SampleSize => "Sample Size",
            Self::SummaryOfBodyOfEvidenceFindings => {
                "Summary of Body of Evidence Findings"
            }
            Self::SummaryOfIndividualStudyFindings => {
                "Summary of Individual Study Findings"
            }
            Self::Table => "Table",
            Self::Tables => "Tables",
            Self::TextSummary => "Text Summary",
            Self::Warnings => "Warnings",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ReportSectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReportSectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ReportSectionType> for Coding {
    fn from(code: ReportSectionType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/evidence-report-section".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ReportSectionType> for CodeableConcept {
    fn from(code: ReportSectionType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RequestIntent](http://hl7.org/fhir/ValueSet/request-intent)**. Codes indicating the degree of authority/intentionality associated with a request.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RequestIntent {
    /** **directive**

Directive. The request represents a legally binding instruction authored by a Patient or RelatedPerson. */
    Directive,
    /** **filler-order**

Filler Order. The request represents the view of an authorization instantiated by a fulfilling system representing the details of the fulfiller's intention to act upon a submitted order. */
    FillerOrder,
    /** **instance-order**

Instance Order. An order created in fulfillment of a broader order that represents the authorization for a single activity occurrence.  E.g. The administration of a single dose of a drug. */
    InstanceOrder,
    /** **option**

Option. The request represents a component or option for a RequestOrchestration that establishes timing, conditionality and/or other constraints among a set of requests.  Refer to [[[RequestOrchestration]]] for additional information on how this status is used. */
    Option,
    /** **order**

Order. The request represents a request/demand and authorization for action by the requestor. */
    Order,
    /** **original-order**

Original Order. The request represents an original authorization for action. */
    OriginalOrder,
    /** **plan**

Plan. The request represents an intention to ensure something occurs without providing an authorization for others to act. */
    Plan,
    /** **proposal**

Proposal. The request is a suggestion made by someone/something that does not have an intention to ensure it occurs and without providing an authorization to act. */
    Proposal,
    /** **reflex-order**

Reflex Order. The request represents an automatically generated supplemental authorization for action based on a parent authorization together with initial results of the action taken against that parent authorization. */
    ReflexOrder,
}
impl ::core::str::FromStr for RequestIntent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "directive" => Ok(Self::Directive),
            "filler-order" => Ok(Self::FillerOrder),
            "instance-order" => Ok(Self::InstanceOrder),
            "option" => Ok(Self::Option),
            "order" => Ok(Self::Order),
            "original-order" => Ok(Self::OriginalOrder),
            "plan" => Ok(Self::Plan),
            "proposal" => Ok(Self::Proposal),
            "reflex-order" => Ok(Self::ReflexOrder),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Directive => "directive",
            Self::FillerOrder => "filler-order",
            Self::InstanceOrder => "instance-order",
            Self::Option => "option",
            Self::Order => "order",
            Self::OriginalOrder => "original-order",
            Self::Plan => "plan",
            Self::Proposal => "proposal",
            Self::ReflexOrder => "reflex-order",
        }
    }
}
impl ::std::fmt::Display for RequestIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Directive => "Directive",
            Self::FillerOrder => "Filler Order",
            Self::InstanceOrder => "Instance Order",
            Self::Option => "Option",
            Self::Order => "Order",
            Self::OriginalOrder => "Original Order",
            Self::Plan => "Plan",
            Self::Proposal => "Proposal",
            Self::ReflexOrder => "Reflex Order",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RequestIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestIntent> for Coding {
    fn from(code: RequestIntent) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/request-intent".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RequestIntent> for CodeableConcept {
    fn from(code: RequestIntent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RequestPriority](http://hl7.org/fhir/ValueSet/request-priority)**. Identifies the level of importance to be assigned to actioning the request.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RequestPriority {
    /** **asap**

ASAP. The request should be actioned as soon as possible - higher priority than urgent. */
    Asap,
    /** **routine**

Routine. The request has normal priority. */
    Routine,
    /** **stat**

STAT. The request should be actioned immediately - highest possible priority.  E.g. an emergency. */
    Stat,
    /** **urgent**

Urgent. The request should be actioned promptly - higher priority than routine. */
    Urgent,
}
impl ::core::str::FromStr for RequestPriority {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "asap" => Ok(Self::Asap),
            "routine" => Ok(Self::Routine),
            "stat" => Ok(Self::Stat),
            "urgent" => Ok(Self::Urgent),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestPriority {
    fn as_ref(&self) -> &str {
        match self {
            Self::Asap => "asap",
            Self::Routine => "routine",
            Self::Stat => "stat",
            Self::Urgent => "urgent",
        }
    }
}
impl ::std::fmt::Display for RequestPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Asap => "ASAP",
            Self::Routine => "Routine",
            Self::Stat => "STAT",
            Self::Urgent => "Urgent",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RequestPriority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestPriority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestPriority> for Coding {
    fn from(code: RequestPriority) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/request-priority".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RequestPriority> for CodeableConcept {
    fn from(code: RequestPriority) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RequestStatus](http://hl7.org/fhir/ValueSet/request-status)**. Codes identifying the lifecycle stage of a request.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RequestStatus {
    /** **active**

Active. The request is in force and ready to be acted upon. */
    Active,
    /** **completed**

Completed. The activity described by the request has been fully performed.  No further activity will occur. */
    Completed,
    /** **draft**

Draft. The request has been created but is not yet complete or ready for action. */
    Draft,
    /** **entered-in-error**

Entered in Error. This request should never have existed and should be considered 'void'.  (It is possible that real-world decisions were based on it.  If real-world activity has occurred, the status should be "revoked" rather than "entered-in-error".). */
    EnteredInError,
    /** **on-hold**

On Hold. The request (and any implicit authorization to act) has been temporarily withdrawn but is expected to resume in the future. */
    OnHold,
    /** **revoked**

Revoked. The request (and any implicit authorization to act) has been terminated prior to the known full completion of the intended actions.  No further activity should occur. */
    Revoked,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this request.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply,  but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for RequestStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "on-hold" => Ok(Self::OnHold),
            "revoked" => Ok(Self::Revoked),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::OnHold => "on-hold",
            Self::Revoked => "revoked",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for RequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Completed => "Completed",
            Self::Draft => "Draft",
            Self::EnteredInError => "Entered in Error",
            Self::OnHold => "On Hold",
            Self::Revoked => "Revoked",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RequestStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RequestStatus> for Coding {
    fn from(code: RequestStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/request-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RequestStatus> for CodeableConcept {
    fn from(code: RequestStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyArmType](http://hl7.org/fhir/ValueSet/research-study-arm-type)**. Codes for the main intent of the study.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyArmType {
    /** **active-comparator**

Active Comparator. */
    ActiveComparator,
    /** **experimental**

Experimental. */
    Experimental,
    /** **no-intervention**

No Intervention. */
    NoIntervention,
    /** **other-arm-type**

Other Arm Type. */
    OtherArmType,
    /** **placebo-comparator**

Placebo Comparator. */
    PlaceboComparator,
    /** **sham-comparator**

Sham Comparator. */
    ShamComparator,
}
impl ::core::str::FromStr for ResearchStudyArmType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active-comparator" => Ok(Self::ActiveComparator),
            "experimental" => Ok(Self::Experimental),
            "no-intervention" => Ok(Self::NoIntervention),
            "other-arm-type" => Ok(Self::OtherArmType),
            "placebo-comparator" => Ok(Self::PlaceboComparator),
            "sham-comparator" => Ok(Self::ShamComparator),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyArmType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActiveComparator => "active-comparator",
            Self::Experimental => "experimental",
            Self::NoIntervention => "no-intervention",
            Self::OtherArmType => "other-arm-type",
            Self::PlaceboComparator => "placebo-comparator",
            Self::ShamComparator => "sham-comparator",
        }
    }
}
impl ::std::fmt::Display for ResearchStudyArmType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ActiveComparator => "Active Comparator",
            Self::Experimental => "Experimental",
            Self::NoIntervention => "No Intervention",
            Self::OtherArmType => "Other Arm Type",
            Self::PlaceboComparator => "Placebo Comparator",
            Self::ShamComparator => "Sham Comparator",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyArmType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyArmType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyArmType> for Coding {
    fn from(code: ResearchStudyArmType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/research-study-arm-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyArmType> for CodeableConcept {
    fn from(code: ResearchStudyArmType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyClassifiers](http://hl7.org/fhir/ValueSet/research-study-classifiers)**. Codes for use in ResearchStudy Resource. This resource (this entire set of content) is being used for active development of a ResearchStudyClassifiers CodeSystem for use for supporting multiple value sets in the FHIR ResearchStudy StructureDefinition.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyClassifiers {
    /** **fda-regulated-device**

FDA regulated device. A medical device regulated by the U.S. Food and Drug Administration. */
    FdaRegulatedDevice,
    /** **fda-regulated-drug**

FDA regulated drug. A medication regulated by the U.S. Food and Drug Administration. */
    FdaRegulatedDrug,
    /** **irb-exempt**

IRB-exempt. Human subjects research that is excempt from oversight and monitoring by an institutional review board (IRB). */
    IrbExempt,
    /** **mpg-paragraph-23b**

MPG Paragraph 23b. Research regulated by a specific German legal requirement (Medizinproduktegesetz MPG Paragraph 23b). */
    MpgParagraph23B,
}
impl ::core::str::FromStr for ResearchStudyClassifiers {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fda-regulated-device" => Ok(Self::FdaRegulatedDevice),
            "fda-regulated-drug" => Ok(Self::FdaRegulatedDrug),
            "irb-exempt" => Ok(Self::IrbExempt),
            "mpg-paragraph-23b" => Ok(Self::MpgParagraph23B),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyClassifiers {
    fn as_ref(&self) -> &str {
        match self {
            Self::FdaRegulatedDevice => "fda-regulated-device",
            Self::FdaRegulatedDrug => "fda-regulated-drug",
            Self::IrbExempt => "irb-exempt",
            Self::MpgParagraph23B => "mpg-paragraph-23b",
        }
    }
}
impl ::std::fmt::Display for ResearchStudyClassifiers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::FdaRegulatedDevice => "FDA regulated device",
            Self::FdaRegulatedDrug => "FDA regulated drug",
            Self::IrbExempt => "IRB-exempt",
            Self::MpgParagraph23B => "MPG Paragraph 23b",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyClassifiers {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyClassifiers {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyClassifiers> for Coding {
    fn from(code: ResearchStudyClassifiers) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/research-study-classifiers".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyClassifiers> for CodeableConcept {
    fn from(code: ResearchStudyClassifiers) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyFocusType](http://hl7.org/fhir/ValueSet/research-study-focus-type)**. Codes for the main intent of the study.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyFocusType {
    /** **device**

Device. */
    Device,
    /** **factor**

Factor. */
    Factor,
    /** **intervention**

Intervention. */
    Intervention,
    /** **medication**

Medication. */
    Medication,
}
impl ::core::str::FromStr for ResearchStudyFocusType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "device" => Ok(Self::Device),
            "factor" => Ok(Self::Factor),
            "intervention" => Ok(Self::Intervention),
            "medication" => Ok(Self::Medication),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyFocusType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "device",
            Self::Factor => "factor",
            Self::Intervention => "intervention",
            Self::Medication => "medication",
        }
    }
}
impl ::std::fmt::Display for ResearchStudyFocusType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Device => "Device",
            Self::Factor => "Factor",
            Self::Intervention => "Intervention",
            Self::Medication => "Medication",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyFocusType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyFocusType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyFocusType> for Coding {
    fn from(code: ResearchStudyFocusType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/research-study-focus-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyFocusType> for CodeableConcept {
    fn from(code: ResearchStudyFocusType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyObjectiveType](http://hl7.org/fhir/ValueSet/research-study-objective-type)**. Codes for the kind of study objective.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyObjectiveType {
    /** **exploratory**

Exploratory. Exploratory questions to be answered in the study. */
    Exploratory,
    /** **primary**

Primary. The main question to be answered, and the one that drives any statistical planning for the study—e.g., calculation of the sample size to provide the appropriate power for statistical testing. */
    Primary,
    /** **secondary**

Secondary. Question to be answered in the study that is of lesser importance than the primary objective. */
    Secondary,
}
impl ::core::str::FromStr for ResearchStudyObjectiveType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exploratory" => Ok(Self::Exploratory),
            "primary" => Ok(Self::Primary),
            "secondary" => Ok(Self::Secondary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyObjectiveType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exploratory => "exploratory",
            Self::Primary => "primary",
            Self::Secondary => "secondary",
        }
    }
}
impl ::std::fmt::Display for ResearchStudyObjectiveType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Exploratory => "Exploratory",
            Self::Primary => "Primary",
            Self::Secondary => "Secondary",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyObjectiveType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyObjectiveType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyObjectiveType> for Coding {
    fn from(code: ResearchStudyObjectiveType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/research-study-objective-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyObjectiveType> for CodeableConcept {
    fn from(code: ResearchStudyObjectiveType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyPartyOrganizationType](http://hl7.org/fhir/ValueSet/research-study-party-organization-type)**. This is a ResearchStudy's party organization type.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyPartyOrganizationType {
    /** **academic**

Academic. */
    Academic,
    /** **fda**

FDA. */
    Fda,
    /** **government**

Government. */
    Government,
    /** **industry**

Industry. */
    Industry,
    /** **nih**

NIH. */
    Nih,
    /** **nonprofit**

Nonprofit. */
    Nonprofit,
}
impl ::core::str::FromStr for ResearchStudyPartyOrganizationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "academic" => Ok(Self::Academic),
            "fda" => Ok(Self::Fda),
            "government" => Ok(Self::Government),
            "industry" => Ok(Self::Industry),
            "nih" => Ok(Self::Nih),
            "nonprofit" => Ok(Self::Nonprofit),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyPartyOrganizationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Academic => "academic",
            Self::Fda => "fda",
            Self::Government => "government",
            Self::Industry => "industry",
            Self::Nih => "nih",
            Self::Nonprofit => "nonprofit",
        }
    }
}
impl ::std::fmt::Display for ResearchStudyPartyOrganizationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Academic => "Academic",
            Self::Fda => "FDA",
            Self::Government => "Government",
            Self::Industry => "Industry",
            Self::Nih => "NIH",
            Self::Nonprofit => "Nonprofit",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyPartyOrganizationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyPartyOrganizationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyPartyOrganizationType> for Coding {
    fn from(code: ResearchStudyPartyOrganizationType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/research-study-party-organization-type"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyPartyOrganizationType> for CodeableConcept {
    fn from(code: ResearchStudyPartyOrganizationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyPartyRole](http://hl7.org/fhir/ValueSet/research-study-party-role)**. This is a ResearchStudy's party role.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyPartyRole {
    /** **collaborator**

collaborator. collaborator */
    Collaborator,
    /** **funding-source**

funding-source. funding-source */
    FundingSource,
    /** **general-contact**

general-contact. general-contact */
    GeneralContact,
    /** **irb**

Institutional Review Board. */
    Irb,
    /** **lead-sponsor**

lead-sponsor. lead-sponsor */
    LeadSponsor,
    /** **primary-investigator**

primary-investigator. primary-investigator */
    PrimaryInvestigator,
    /** **recruitment-contact**

recruitment-contact. recruitment-contact */
    RecruitmentContact,
    /** **sponsor**

sponsor. sponsor */
    Sponsor,
    /** **sponsor-investigator**

sponsor-investigator. sponsor-investigator */
    SponsorInvestigator,
    /** **study-chair**

study-chair. study-chair */
    StudyChair,
    /** **study-director**

study-director. study-director */
    StudyDirector,
    /** **sub-investigator**

sub-investigator. sub-investigator */
    SubInvestigator,
}
impl ::core::str::FromStr for ResearchStudyPartyRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "collaborator" => Ok(Self::Collaborator),
            "funding-source" => Ok(Self::FundingSource),
            "general-contact" => Ok(Self::GeneralContact),
            "irb" => Ok(Self::Irb),
            "lead-sponsor" => Ok(Self::LeadSponsor),
            "primary-investigator" => Ok(Self::PrimaryInvestigator),
            "recruitment-contact" => Ok(Self::RecruitmentContact),
            "sponsor" => Ok(Self::Sponsor),
            "sponsor-investigator" => Ok(Self::SponsorInvestigator),
            "study-chair" => Ok(Self::StudyChair),
            "study-director" => Ok(Self::StudyDirector),
            "sub-investigator" => Ok(Self::SubInvestigator),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyPartyRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Collaborator => "collaborator",
            Self::FundingSource => "funding-source",
            Self::GeneralContact => "general-contact",
            Self::Irb => "irb",
            Self::LeadSponsor => "lead-sponsor",
            Self::PrimaryInvestigator => "primary-investigator",
            Self::RecruitmentContact => "recruitment-contact",
            Self::Sponsor => "sponsor",
            Self::SponsorInvestigator => "sponsor-investigator",
            Self::StudyChair => "study-chair",
            Self::StudyDirector => "study-director",
            Self::SubInvestigator => "sub-investigator",
        }
    }
}
impl ::std::fmt::Display for ResearchStudyPartyRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Collaborator => "collaborator",
            Self::FundingSource => "funding-source",
            Self::GeneralContact => "general-contact",
            Self::Irb => "Institutional Review Board",
            Self::LeadSponsor => "lead-sponsor",
            Self::PrimaryInvestigator => "primary-investigator",
            Self::RecruitmentContact => "recruitment-contact",
            Self::Sponsor => "sponsor",
            Self::SponsorInvestigator => "sponsor-investigator",
            Self::StudyChair => "study-chair",
            Self::StudyDirector => "study-director",
            Self::SubInvestigator => "sub-investigator",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyPartyRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyPartyRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyPartyRole> for Coding {
    fn from(code: ResearchStudyPartyRole) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/research-study-party-role".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyPartyRole> for CodeableConcept {
    fn from(code: ResearchStudyPartyRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyPhase](http://hl7.org/fhir/ValueSet/research-study-phase)**. Codes for the stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyPhase {
    /** **early-phase-1**

Early Phase 1. Designation for optional exploratory trials conducted in accordance with the United States Food and Drug Administration's (FDA) 2006 Guidance on Exploratory Investigational New Drug (IND) Studies. Formerly called Phase 0. */
    EarlyPhase1,
    /** **n-a**

N/A. Trials without phases (for example, studies of devices or behavioral interventions). */
    NA,
    /** **phase-1**

Phase 1. Includes initial studies to determine the metabolism and pharmacologic actions of drugs in humans, the side effects associated with increasing doses, and to gain early evidence of effectiveness; may include healthy participants and/or patients. */
    Phase1,
    /** **phase-1-phase-2**

Phase 1/Phase 2. Trials that are a combination of phases 1 and 2. */
    Phase1Phase2,
    /** **phase-2**

Phase 2. Includes controlled clinical studies conducted to evaluate the effectiveness of the drug for a particular indication or indications in participants with the disease or condition under study and to determine the common short-term side effects and risks. */
    Phase2,
    /** **phase-2-phase-3**

Phase 2/Phase 3. Trials that are a combination of phases 2 and 3. */
    Phase2Phase3,
    /** **phase-3**

Phase 3. Includes trials conducted after preliminary evidence suggesting effectiveness of the drug has been obtained, and are intended to gather additional information to evaluate the overall benefit-risk relationship of the drug. */
    Phase3,
    /** **phase-4**

Phase 4. Studies of FDA-approved drugs to delineate additional information including the drug's risks, benefits, and optimal use. */
    Phase4,
}
impl ::core::str::FromStr for ResearchStudyPhase {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "early-phase-1" => Ok(Self::EarlyPhase1),
            "n-a" => Ok(Self::NA),
            "phase-1" => Ok(Self::Phase1),
            "phase-1-phase-2" => Ok(Self::Phase1Phase2),
            "phase-2" => Ok(Self::Phase2),
            "phase-2-phase-3" => Ok(Self::Phase2Phase3),
            "phase-3" => Ok(Self::Phase3),
            "phase-4" => Ok(Self::Phase4),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyPhase {
    fn as_ref(&self) -> &str {
        match self {
            Self::EarlyPhase1 => "early-phase-1",
            Self::NA => "n-a",
            Self::Phase1 => "phase-1",
            Self::Phase1Phase2 => "phase-1-phase-2",
            Self::Phase2 => "phase-2",
            Self::Phase2Phase3 => "phase-2-phase-3",
            Self::Phase3 => "phase-3",
            Self::Phase4 => "phase-4",
        }
    }
}
impl ::std::fmt::Display for ResearchStudyPhase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::EarlyPhase1 => "Early Phase 1",
            Self::NA => "N/A",
            Self::Phase1 => "Phase 1",
            Self::Phase1Phase2 => "Phase 1/Phase 2",
            Self::Phase2 => "Phase 2",
            Self::Phase2Phase3 => "Phase 2/Phase 3",
            Self::Phase3 => "Phase 3",
            Self::Phase4 => "Phase 4",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyPhase {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyPhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyPhase> for Coding {
    fn from(code: ResearchStudyPhase) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/research-study-phase".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyPhase> for CodeableConcept {
    fn from(code: ResearchStudyPhase) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyPrimaryPurposeType](http://hl7.org/fhir/ValueSet/research-study-prim-purp-type)**. Codes for the main intent of a research study.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyPrimaryPurposeType {
    /** **basic-science**

Basic Science. One or more interventions for examining the basic mechanism of action (for example, physiology or biomechanics of an intervention). */
    BasicScience,
    /** **device-feasibility**

Device Feasibility. An intervention of a device product is being evaluated to determine the feasibility of the product or to test a prototype device and not health outcomes. Such studies are conducted to confirm the design and operating specifications of a device before beginning a full clinical trial. */
    DeviceFeasibility,
    /** **diagnostic**

Diagnostic. One or more interventions are being evaluated for identifying a disease or health condition. */
    Diagnostic,
    /** **health-services-research**

Health Services Research. One or more interventions for evaluating the delivery, processes, management, organization, or financing of healthcare. */
    HealthServicesResearch,
    /** **prevention**

Prevention. One or more interventions are being assessed for preventing the development of a specific disease or health condition. */
    Prevention,
    /** **screening**

Screening. One or more interventions are assessed or examined for identifying a condition, or risk factors for a condition, in people who are not yet known to have the condition or risk factor. */
    Screening,
    /** **supportive-care**

Supportive Care. One or more interventions are evaluated for maximizing comfort, minimizing side effects, or mitigating against a decline in the participant's health or function. */
    SupportiveCare,
    /** **treatment**

Treatment. One or more interventions are being evaluated for treating a disease, syndrome, or condition. */
    Treatment,
}
impl ::core::str::FromStr for ResearchStudyPrimaryPurposeType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "basic-science" => Ok(Self::BasicScience),
            "device-feasibility" => Ok(Self::DeviceFeasibility),
            "diagnostic" => Ok(Self::Diagnostic),
            "health-services-research" => Ok(Self::HealthServicesResearch),
            "prevention" => Ok(Self::Prevention),
            "screening" => Ok(Self::Screening),
            "supportive-care" => Ok(Self::SupportiveCare),
            "treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyPrimaryPurposeType {
    fn as_ref(&self) -> &str {
        match self {
            Self::BasicScience => "basic-science",
            Self::DeviceFeasibility => "device-feasibility",
            Self::Diagnostic => "diagnostic",
            Self::HealthServicesResearch => "health-services-research",
            Self::Prevention => "prevention",
            Self::Screening => "screening",
            Self::SupportiveCare => "supportive-care",
            Self::Treatment => "treatment",
        }
    }
}
impl ::std::fmt::Display for ResearchStudyPrimaryPurposeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::BasicScience => "Basic Science",
            Self::DeviceFeasibility => "Device Feasibility",
            Self::Diagnostic => "Diagnostic",
            Self::HealthServicesResearch => "Health Services Research",
            Self::Prevention => "Prevention",
            Self::Screening => "Screening",
            Self::SupportiveCare => "Supportive Care",
            Self::Treatment => "Treatment",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyPrimaryPurposeType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyPrimaryPurposeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyPrimaryPurposeType> for Coding {
    fn from(code: ResearchStudyPrimaryPurposeType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/research-study-prim-purp-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyPrimaryPurposeType> for CodeableConcept {
    fn from(code: ResearchStudyPrimaryPurposeType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyReasonStopped](http://hl7.org/fhir/ValueSet/research-study-reason-stopped)**. Codes for why the study ended prematurely.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyReasonStopped {
    /** **accrual-goal-met**

Accrual Goal Met. The study prematurely ended because the accrual goal was met. */
    AccrualGoalMet,
    /** **closed-due-to-lack-of-study-progress**

Closed due to lack of study progress. The study prematurely ended due to lack of study progress. */
    ClosedDueToLackOfStudyProgress,
    /** **closed-due-to-toxicity**

Closed due to toxicity. The study prematurely ended due to toxicity. */
    ClosedDueToToxicity,
    /** **temporarily-closed-per-study-design**

Temporarily closed per study design. The study prematurely ended temporarily per study design. */
    TemporarilyClosedPerStudyDesign,
}
impl ::core::str::FromStr for ResearchStudyReasonStopped {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accrual-goal-met" => Ok(Self::AccrualGoalMet),
            "closed-due-to-lack-of-study-progress" => {
                Ok(Self::ClosedDueToLackOfStudyProgress)
            }
            "closed-due-to-toxicity" => Ok(Self::ClosedDueToToxicity),
            "temporarily-closed-per-study-design" => {
                Ok(Self::TemporarilyClosedPerStudyDesign)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyReasonStopped {
    fn as_ref(&self) -> &str {
        match self {
            Self::AccrualGoalMet => "accrual-goal-met",
            Self::ClosedDueToLackOfStudyProgress => {
                "closed-due-to-lack-of-study-progress"
            }
            Self::ClosedDueToToxicity => "closed-due-to-toxicity",
            Self::TemporarilyClosedPerStudyDesign => {
                "temporarily-closed-per-study-design"
            }
        }
    }
}
impl ::std::fmt::Display for ResearchStudyReasonStopped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::AccrualGoalMet => "Accrual Goal Met",
            Self::ClosedDueToLackOfStudyProgress => {
                "Closed due to lack of study progress"
            }
            Self::ClosedDueToToxicity => "Closed due to toxicity",
            Self::TemporarilyClosedPerStudyDesign => {
                "Temporarily closed per study design"
            }
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyReasonStopped {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyReasonStopped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyReasonStopped> for Coding {
    fn from(code: ResearchStudyReasonStopped) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/research-study-reason-stopped".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyReasonStopped> for CodeableConcept {
    fn from(code: ResearchStudyReasonStopped) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResearchStudyStatus](http://hl7.org/fhir/ValueSet/research-study-status)**. Codes that convey the current status of the research study.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyStatus {
    /** **active**

Active. Study is opened for accrual. */
    Active,
    /** **active-but-not-recruiting**

Active, not recruiting. The study is ongoing, and participants are receiving an intervention or being examined, but potential participants are not currently being recruited or enrolled. */
    ActiveButNotRecruiting,
    /** **administratively-completed**

Administratively Completed. Study is completed prematurely and will not resume; patients are no longer examined nor treated. */
    AdministrativelyCompleted,
    /** **approved**

Approved. Protocol is approved by the review board. */
    Approved,
    /** **closed-to-accrual**

Closed to Accrual. Study is closed for accrual; patients can be examined and treated. */
    ClosedToAccrual,
    /** **closed-to-accrual-and-intervention**

Closed to Accrual and Intervention. Study is closed to accrual and intervention, i.e. the study is closed to enrollment, all study subjects have completed treatment or intervention but are still being followed according to the primary objective of the study. */
    ClosedToAccrualAndIntervention,
    /** **completed**

Completed. The study closed according to the study plan. There will be no further treatments, interventions or data collection. */
    Completed,
    /** **disapproved**

Disapproved. Protocol was disapproved by the review board. */
    Disapproved,
    /** **enrolling-by-invitation**

Enrolling by invitation. The study is selecting its participants from a population, or group of people, decided on by the researchers in advance. These studies are not open to everyone who meets the eligibility criteria but only to people in that particular population, who are specifically invited to participate. */
    EnrollingByInvitation,
    /** **in-review**

In Review. Protocol is submitted to the review board for approval. */
    InReview,
    /** **not-yet-recruiting**

Not yet recruiting. The study has not started recruiting participants. */
    NotYetRecruiting,
    /** **overall-study**

Overall study. Used for documenting the start and end of the overall study, distinct from progress states. */
    OverallStudy,
    /** **recruiting**

Recruiting. The study is currently recruiting participants. */
    Recruiting,
    /** **temporarily-closed-to-accrual**

Temporarily Closed to Accrual. Study is temporarily closed for accrual; can be potentially resumed in the future; patients can be examined and treated. */
    TemporarilyClosedToAccrual,
    /** **temporarily-closed-to-accrual-and-intervention**

Temporarily Closed to Accrual and Intervention. Study is temporarily closed for accrual and intervention and potentially can be resumed in the future. */
    TemporarilyClosedToAccrualAndIntervention,
    /** **terminated**

Terminated. The study has stopped early and will not start again. Participants are no longer being examined or treated. */
    Terminated,
    /** **withdrawn**

Withdrawn. Protocol was withdrawn by the lead organization. */
    Withdrawn,
}
impl ::core::str::FromStr for ResearchStudyStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "active-but-not-recruiting" => Ok(Self::ActiveButNotRecruiting),
            "administratively-completed" => Ok(Self::AdministrativelyCompleted),
            "approved" => Ok(Self::Approved),
            "closed-to-accrual" => Ok(Self::ClosedToAccrual),
            "closed-to-accrual-and-intervention" => {
                Ok(Self::ClosedToAccrualAndIntervention)
            }
            "completed" => Ok(Self::Completed),
            "disapproved" => Ok(Self::Disapproved),
            "enrolling-by-invitation" => Ok(Self::EnrollingByInvitation),
            "in-review" => Ok(Self::InReview),
            "not-yet-recruiting" => Ok(Self::NotYetRecruiting),
            "overall-study" => Ok(Self::OverallStudy),
            "recruiting" => Ok(Self::Recruiting),
            "temporarily-closed-to-accrual" => Ok(Self::TemporarilyClosedToAccrual),
            "temporarily-closed-to-accrual-and-intervention" => {
                Ok(Self::TemporarilyClosedToAccrualAndIntervention)
            }
            "terminated" => Ok(Self::Terminated),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::ActiveButNotRecruiting => "active-but-not-recruiting",
            Self::AdministrativelyCompleted => "administratively-completed",
            Self::Approved => "approved",
            Self::ClosedToAccrual => "closed-to-accrual",
            Self::ClosedToAccrualAndIntervention => "closed-to-accrual-and-intervention",
            Self::Completed => "completed",
            Self::Disapproved => "disapproved",
            Self::EnrollingByInvitation => "enrolling-by-invitation",
            Self::InReview => "in-review",
            Self::NotYetRecruiting => "not-yet-recruiting",
            Self::OverallStudy => "overall-study",
            Self::Recruiting => "recruiting",
            Self::TemporarilyClosedToAccrual => "temporarily-closed-to-accrual",
            Self::TemporarilyClosedToAccrualAndIntervention => {
                "temporarily-closed-to-accrual-and-intervention"
            }
            Self::Terminated => "terminated",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl ::std::fmt::Display for ResearchStudyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::ActiveButNotRecruiting => "Active, not recruiting",
            Self::AdministrativelyCompleted => "Administratively Completed",
            Self::Approved => "Approved",
            Self::ClosedToAccrual => "Closed to Accrual",
            Self::ClosedToAccrualAndIntervention => "Closed to Accrual and Intervention",
            Self::Completed => "Completed",
            Self::Disapproved => "Disapproved",
            Self::EnrollingByInvitation => "Enrolling by invitation",
            Self::InReview => "In Review",
            Self::NotYetRecruiting => "Not yet recruiting",
            Self::OverallStudy => "Overall study",
            Self::Recruiting => "Recruiting",
            Self::TemporarilyClosedToAccrual => "Temporarily Closed to Accrual",
            Self::TemporarilyClosedToAccrualAndIntervention => {
                "Temporarily Closed to Accrual and Intervention"
            }
            Self::Terminated => "Terminated",
            Self::Withdrawn => "Withdrawn",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResearchStudyStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResearchStudyStatus> for Coding {
    fn from(code: ResearchStudyStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/research-study-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResearchStudyStatus> for CodeableConcept {
    fn from(code: ResearchStudyStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResourceValidationMode](http://hl7.org/fhir/resource-validation-mode)**. ResourceValidationMode\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ResourceValidationMode {
    /** **create**

Validate for Create. The server checks the content, and then checks that the content would be acceptable as a create (e.g. that the content would not violate any uniqueness constraints). */
    Create,
    /** **delete**

Validate for Delete. The server ignores the content and checks that the nominated resource is allowed to be deleted (e.g. checking referential integrity rules). */
    Delete,
    /** **profile**

Validate Against a Profile. The server checks an existing resource (must be nominated by id, not provided as a parameter) as valid against the nominated profile. */
    Profile,
    /** **update**

Validate for Update. The server checks the content, and then checks that it would accept it as an update against the nominated specific resource (e.g. that there are no changes to immutable fields the server does not allow to change and checking version integrity if appropriate). */
    Update,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ResourceValidationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "profile" => Ok(Self::Profile),
            "update" => Ok(Self::Update),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ResourceValidationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Create => "create",
            Self::Delete => "delete",
            Self::Profile => "profile",
            Self::Update => "update",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for ResourceValidationMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Create => "Validate for Create",
            Self::Delete => "Validate for Delete",
            Self::Profile => "Validate Against a Profile",
            Self::Update => "Validate for Update",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResourceValidationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceValidationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResourceValidationMode> for Coding {
    fn from(code: ResourceValidationMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/resource-validation-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResourceValidationMode> for CodeableConcept {
    fn from(code: ResourceValidationMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResourceVersionPolicy](http://hl7.org/fhir/ValueSet/versioning-policy)**. How the system supports versioning for a resource.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResourceVersionPolicy {
    /** **no-version**

No VersionId Support. VersionId meta-property is not supported (server) or used (client). */
    NoVersion,
    /** **versioned**

Versioned. VersionId meta-property is supported (server) or used (client). */
    Versioned,
    /** **versioned-update**

VersionId tracked fully. Supports version-aware updates (server) or will be specified (If-match header) for updates (client). */
    VersionedUpdate,
}
impl ::core::str::FromStr for ResourceVersionPolicy {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "no-version" => Ok(Self::NoVersion),
            "versioned" => Ok(Self::Versioned),
            "versioned-update" => Ok(Self::VersionedUpdate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResourceVersionPolicy {
    fn as_ref(&self) -> &str {
        match self {
            Self::NoVersion => "no-version",
            Self::Versioned => "versioned",
            Self::VersionedUpdate => "versioned-update",
        }
    }
}
impl ::std::fmt::Display for ResourceVersionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::NoVersion => "No VersionId Support",
            Self::Versioned => "Versioned",
            Self::VersionedUpdate => "VersionId tracked fully",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResourceVersionPolicy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceVersionPolicy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResourceVersionPolicy> for Coding {
    fn from(code: ResourceVersionPolicy) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/versioning-policy".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResourceVersionPolicy> for CodeableConcept {
    fn from(code: ResourceVersionPolicy) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ResponseType](http://hl7.org/fhir/ValueSet/response-code)**. The kind of response to a message.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResponseType {
    /** **fatal-error**

Fatal Error. The message was rejected because of a problem with the content. There is no point in re-sending without change. The response narrative SHALL describe the issue. */
    FatalError,
    /** **ok**

OK. The message was accepted and processed without error. */
    Ok,
    /** **transient-error**

Transient Error. Some internal unexpected error occurred - wait and try again. Note - this is usually used for things like database unavailable, which may be expected to resolve, though human intervention may be required. */
    TransientError,
}
impl ::core::str::FromStr for ResponseType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fatal-error" => Ok(Self::FatalError),
            "ok" => Ok(Self::Ok),
            "transient-error" => Ok(Self::TransientError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResponseType {
    fn as_ref(&self) -> &str {
        match self {
            Self::FatalError => "fatal-error",
            Self::Ok => "ok",
            Self::TransientError => "transient-error",
        }
    }
}
impl ::std::fmt::Display for ResponseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::FatalError => "Fatal Error",
            Self::Ok => "OK",
            Self::TransientError => "Transient Error",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ResponseType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResponseType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ResponseType> for Coding {
    fn from(code: ResponseType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/response-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ResponseType> for CodeableConcept {
    fn from(code: ResponseType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RestfulCapabilityMode](http://hl7.org/fhir/ValueSet/restful-capability-mode)**. The mode of a RESTful capability statement.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RestfulCapabilityMode {
    /** **client**

Client. The application acts as a client for this resource. */
    Client,
    /** **server**

Server. The application acts as a server for this resource. */
    Server,
}
impl ::core::str::FromStr for RestfulCapabilityMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client" => Ok(Self::Client),
            "server" => Ok(Self::Server),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RestfulCapabilityMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Client => "client",
            Self::Server => "server",
        }
    }
}
impl ::std::fmt::Display for RestfulCapabilityMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Client => "Client",
            Self::Server => "Server",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RestfulCapabilityMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RestfulCapabilityMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RestfulCapabilityMode> for Coding {
    fn from(code: RestfulCapabilityMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/restful-capability-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RestfulCapabilityMode> for CodeableConcept {
    fn from(code: RestfulCapabilityMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[RestfulSecurityService](http://hl7.org/fhir/ValueSet/restful-security-service)**. Types of security services used with FHIR.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RestfulSecurityService {
    /** **Basic**

Basic. Basic authentication defined in HTTP specification. */
    Basic,
    /** **Certificates**

Certificates. SSL where client must have a certificate registered with the server. */
    Certificates,
    /** **Kerberos**

Kerberos. see http://www.ietf.org/rfc/rfc4120.txt. */
    Kerberos,
    /** **NTLM**

NTLM. Microsoft NTLM Authentication. */
    Ntlm,
    /** **OAuth**

OAuth. OAuth (unspecified version see oauth.net). */
    Oauth,
    /** **SMART-on-FHIR**

SMART-on-FHIR. OAuth2 using SMART-on-FHIR profile (see http://docs.smarthealthit.org/). */
    SmartOnFHIR,
}
impl ::core::str::FromStr for RestfulSecurityService {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Basic" => Ok(Self::Basic),
            "Certificates" => Ok(Self::Certificates),
            "Kerberos" => Ok(Self::Kerberos),
            "NTLM" => Ok(Self::Ntlm),
            "OAuth" => Ok(Self::Oauth),
            "SMART-on-FHIR" => Ok(Self::SmartOnFHIR),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RestfulSecurityService {
    fn as_ref(&self) -> &str {
        match self {
            Self::Basic => "Basic",
            Self::Certificates => "Certificates",
            Self::Kerberos => "Kerberos",
            Self::Ntlm => "NTLM",
            Self::Oauth => "OAuth",
            Self::SmartOnFHIR => "SMART-on-FHIR",
        }
    }
}
impl ::std::fmt::Display for RestfulSecurityService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Basic => "Basic",
            Self::Certificates => "Certificates",
            Self::Kerberos => "Kerberos",
            Self::Ntlm => "NTLM",
            Self::Oauth => "OAuth",
            Self::SmartOnFHIR => "SMART-on-FHIR",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for RestfulSecurityService {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RestfulSecurityService {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<RestfulSecurityService> for Coding {
    fn from(code: RestfulSecurityService) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/restful-security-service".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<RestfulSecurityService> for CodeableConcept {
    fn from(code: RestfulSecurityService) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SampleSecurityStructuralRoles](http://hl7.org/fhir/sample-security-structural-roles)**. This codeSystem contains example structural roles. In general, two types of roles can be distinguished: structural roles and functional roles. Structural Roles reflect human or organizational categories (hierarchies), and describe prerequisites, feasibilities, or competences for actions. Functional roles are bound to the realization or performance of actions..\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SampleSecurityStructuralRoles {
    /** **business-manager**

Business Manager. */
    BusinessManager,
    /** **claims-adjudicator**

Claims Adjudicator. */
    ClaimsAdjudicator,
    /** **dentist**

Dentist. The specialty relating to the function and diseases of the teeth, mouth, and gums. */
    Dentist,
    /** **dietician**

Dietician. The health profession concerned with the practical application of diet in the prophylaxis and treatment of disease. */
    Dietician,
    /** **general-medicine**

General Medicine. The branch of medicine involving the study and treatment of general diseases or those affecting the internal parts of the body, especially those not usually requiring surgical intervention */
    GeneralMedicine,
    /** **general-nursing**

General Nursing. The branch of healthcare concerned with caring for the sick or injured in any environment. */
    GeneralNursing,
    /** **non-regulated-health-professionals**

Non-Regulated health Professionals. person employed by a healthcare organization who is not a health professional */
    NonRegulatedHealthProfessionals,
    /** **pediatrics**

Pediatrics. The medical specialty concerned with the study of treatment of children in health and disease during development from birth through adolescence. */
    Pediatrics,
    /** **pharmacy**

Pharmacy. The branch of medical science that deals with drugs and their uses. */
    Pharmacy,
    /** **receptionist**

Receptionist. */
    Receptionist,
    /** **regulated-health-professionals**

Regulated Health Professionals. A person who is authorized by a national recognized body to be qualified to perform health services */
    RegulatedHealthProfessionals,
    /** **transcriptionist**

Transcriptionist. */
    Transcriptionist,
    /** **veterinarian**

Veterinarian. The specialty relating to non-human subjects. */
    Veterinarian,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SampleSecurityStructuralRoles {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "business-manager" => Ok(Self::BusinessManager),
            "claims-adjudicator" => Ok(Self::ClaimsAdjudicator),
            "dentist" => Ok(Self::Dentist),
            "dietician" => Ok(Self::Dietician),
            "general-medicine" => Ok(Self::GeneralMedicine),
            "general-nursing" => Ok(Self::GeneralNursing),
            "non-regulated-health-professionals" => {
                Ok(Self::NonRegulatedHealthProfessionals)
            }
            "pediatrics" => Ok(Self::Pediatrics),
            "pharmacy" => Ok(Self::Pharmacy),
            "receptionist" => Ok(Self::Receptionist),
            "regulated-health-professionals" => Ok(Self::RegulatedHealthProfessionals),
            "transcriptionist" => Ok(Self::Transcriptionist),
            "veterinarian" => Ok(Self::Veterinarian),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SampleSecurityStructuralRoles {
    fn as_ref(&self) -> &str {
        match self {
            Self::BusinessManager => "business-manager",
            Self::ClaimsAdjudicator => "claims-adjudicator",
            Self::Dentist => "dentist",
            Self::Dietician => "dietician",
            Self::GeneralMedicine => "general-medicine",
            Self::GeneralNursing => "general-nursing",
            Self::NonRegulatedHealthProfessionals => "non-regulated-health-professionals",
            Self::Pediatrics => "pediatrics",
            Self::Pharmacy => "pharmacy",
            Self::Receptionist => "receptionist",
            Self::RegulatedHealthProfessionals => "regulated-health-professionals",
            Self::Transcriptionist => "transcriptionist",
            Self::Veterinarian => "veterinarian",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for SampleSecurityStructuralRoles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::BusinessManager => "Business Manager",
            Self::ClaimsAdjudicator => "Claims Adjudicator",
            Self::Dentist => "Dentist",
            Self::Dietician => "Dietician",
            Self::GeneralMedicine => "General Medicine",
            Self::GeneralNursing => "General Nursing",
            Self::NonRegulatedHealthProfessionals => "Non-Regulated health Professionals",
            Self::Pediatrics => "Pediatrics",
            Self::Pharmacy => "Pharmacy",
            Self::Receptionist => "Receptionist",
            Self::RegulatedHealthProfessionals => "Regulated Health Professionals",
            Self::Transcriptionist => "Transcriptionist",
            Self::Veterinarian => "Veterinarian",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SampleSecurityStructuralRoles {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SampleSecurityStructuralRoles {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SampleSecurityStructuralRoles> for Coding {
    fn from(code: SampleSecurityStructuralRoles) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/sample-security-structural-roles".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SampleSecurityStructuralRoles> for CodeableConcept {
    fn from(code: SampleSecurityStructuralRoles) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SearchComparator](http://hl7.org/fhir/ValueSet/search-comparator)**. What Search Comparator Codes are supported in search.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SearchComparator {
    /** **ap**

Approximately. the value for the parameter in the resource is approximately the same to the provided value. */
    Ap,
    /** **eb**

Ends Before. the value for the parameter in the resource ends before the provided value. */
    Eb,
    /** **eq**

Equals. the value for the parameter in the resource is equal to the provided value. */
    Eq,
    /** **ge**

Greater or Equals. the value for the parameter in the resource is greater or equal to the provided value. */
    Ge,
    /** **gt**

Greater Than. the value for the parameter in the resource is greater than the provided value. */
    Gt,
    /** **le**

Less of Equal. the value for the parameter in the resource is less or equal to the provided value. */
    Le,
    /** **lt**

Less Than. the value for the parameter in the resource is less than the provided value. */
    Lt,
    /** **ne**

Not Equals. the value for the parameter in the resource is not equal to the provided value. */
    Ne,
    /** **sa**

Starts After. the value for the parameter in the resource starts after the provided value. */
    Sa,
}
impl ::core::str::FromStr for SearchComparator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ap" => Ok(Self::Ap),
            "eb" => Ok(Self::Eb),
            "eq" => Ok(Self::Eq),
            "ge" => Ok(Self::Ge),
            "gt" => Ok(Self::Gt),
            "le" => Ok(Self::Le),
            "lt" => Ok(Self::Lt),
            "ne" => Ok(Self::Ne),
            "sa" => Ok(Self::Sa),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchComparator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ap => "ap",
            Self::Eb => "eb",
            Self::Eq => "eq",
            Self::Ge => "ge",
            Self::Gt => "gt",
            Self::Le => "le",
            Self::Lt => "lt",
            Self::Ne => "ne",
            Self::Sa => "sa",
        }
    }
}
impl ::std::fmt::Display for SearchComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Ap => "Approximately",
            Self::Eb => "Ends Before",
            Self::Eq => "Equals",
            Self::Ge => "Greater or Equals",
            Self::Gt => "Greater Than",
            Self::Le => "Less of Equal",
            Self::Lt => "Less Than",
            Self::Ne => "Not Equals",
            Self::Sa => "Starts After",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SearchComparator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchComparator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchComparator> for Coding {
    fn from(code: SearchComparator) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/search-comparator".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SearchComparator> for CodeableConcept {
    fn from(code: SearchComparator) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SearchEntryMode](http://hl7.org/fhir/ValueSet/search-entry-mode)**. Why an entry is in the result set - whether it's included as a match or because of an _include requirement, or to convey information or warning information about the search process.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SearchEntryMode {
    /** **include**

Include. This resource is returned because it is referred to from another resource in the search set. */
    Include,
    /** **match**

Match. This resource matched the search specification. */
    Match,
    /** **outcome**

Outcome. An OperationOutcome that provides additional information about the processing of a search. */
    Outcome,
}
impl ::core::str::FromStr for SearchEntryMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "include" => Ok(Self::Include),
            "match" => Ok(Self::Match),
            "outcome" => Ok(Self::Outcome),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchEntryMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Include => "include",
            Self::Match => "match",
            Self::Outcome => "outcome",
        }
    }
}
impl ::std::fmt::Display for SearchEntryMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Include => "Include",
            Self::Match => "Match",
            Self::Outcome => "Outcome",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SearchEntryMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchEntryMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchEntryMode> for Coding {
    fn from(code: SearchEntryMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/search-entry-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SearchEntryMode> for CodeableConcept {
    fn from(code: SearchEntryMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SearchModifierCode](http://hl7.org/fhir/ValueSet/search-modifier-code)**. A supported modifier for a search parameter.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SearchModifierCode {
    /** **above**

Above. The search parameter tests whether the value in a resource subsumes the specified value (is-a, or hierarchical relationships). */
    Above,
    /** **below**

Below. The search parameter tests whether the value in a resource is subsumed by the specified value (is-a, or hierarchical relationships). */
    Below,
    /** **code-text**

Code Text. Tests whether the textual display value in a resource (e.g., CodeableConcept.text, Coding.display, or Reference.display) matches the supplied parameter value. */
    CodeText,
    /** **contains**

Contains. The search parameter returns resources that include the supplied parameter value anywhere within the field being searched. */
    Contains,
    /** **exact**

Exact. The search parameter returns resources that have a value that exactly matches the supplied parameter (the whole string, including casing and accents). */
    Exact,
    /** **identifier**

Identifier. The search parameter applies to the identifier on the resource, not the reference. */
    Identifier,
    /** **in**

In. The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is in the specified value set. */
    In,
    /** **iterate**

Iterate. The search parameter indicates an inclusion directive (_include, _revinclude) that is applied to an included resource instead of the matching resource. */
    Iterate,
    /** **missing**

Missing. The search parameter returns resources that have a value or not. */
    Missing,
    /** **not**

Not. The search parameter returns resources that do not contain a match. */
    Not,
    /** **not-in**

Not In. The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is not in the specified value set. */
    NotIn,
    /** **of-type**

Of Type. The search parameter has the format system|code|value, where the system and code refer to an Identifier.type.coding.system and .code, and match if any of the type codes match. All 3 parts must be present. */
    OfType,
    /** **text**

Text. The search parameter is processed as a string that searches text associated with the code/value - either CodeableConcept.text, Coding.display, Identifier.type.text, or Reference.display. */
    Text,
    /** **text-advanced**

Text Advanced. Tests whether the value in a resource matches the supplied parameter value using advanced text handling that searches text associated with the code/value - e.g., CodeableConcept.text, Coding.display, or Identifier.type.text. */
    TextAdvanced,
    /** **type**

Type. The search parameter only applies to the Resource Type specified as a modifier (e.g. the modifier is not actually :type, but :Patient etc.). */
    Type,
}
impl ::core::str::FromStr for SearchModifierCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "above" => Ok(Self::Above),
            "below" => Ok(Self::Below),
            "code-text" => Ok(Self::CodeText),
            "contains" => Ok(Self::Contains),
            "exact" => Ok(Self::Exact),
            "identifier" => Ok(Self::Identifier),
            "in" => Ok(Self::In),
            "iterate" => Ok(Self::Iterate),
            "missing" => Ok(Self::Missing),
            "not" => Ok(Self::Not),
            "not-in" => Ok(Self::NotIn),
            "of-type" => Ok(Self::OfType),
            "text" => Ok(Self::Text),
            "text-advanced" => Ok(Self::TextAdvanced),
            "type" => Ok(Self::Type),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchModifierCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Above => "above",
            Self::Below => "below",
            Self::CodeText => "code-text",
            Self::Contains => "contains",
            Self::Exact => "exact",
            Self::Identifier => "identifier",
            Self::In => "in",
            Self::Iterate => "iterate",
            Self::Missing => "missing",
            Self::Not => "not",
            Self::NotIn => "not-in",
            Self::OfType => "of-type",
            Self::Text => "text",
            Self::TextAdvanced => "text-advanced",
            Self::Type => "type",
        }
    }
}
impl ::std::fmt::Display for SearchModifierCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Above => "Above",
            Self::Below => "Below",
            Self::CodeText => "Code Text",
            Self::Contains => "Contains",
            Self::Exact => "Exact",
            Self::Identifier => "Identifier",
            Self::In => "In",
            Self::Iterate => "Iterate",
            Self::Missing => "Missing",
            Self::Not => "Not",
            Self::NotIn => "Not In",
            Self::OfType => "Of Type",
            Self::Text => "Text",
            Self::TextAdvanced => "Text Advanced",
            Self::Type => "Type",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SearchModifierCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchModifierCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchModifierCode> for Coding {
    fn from(code: SearchModifierCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/search-modifier-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SearchModifierCode> for CodeableConcept {
    fn from(code: SearchModifierCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SearchParamType](http://hl7.org/fhir/ValueSet/search-param-type)**. Data types allowed to be used for search parameters.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SearchParamType {
    /** **composite**

Composite. A composite search parameter that combines a search on two values together. */
    Composite,
    /** **date**

Date/DateTime. Search parameter is on a date/time. The date format is the standard XML format, though other formats may be supported. */
    Date,
    /** **number**

Number. Search parameter SHALL be a number (a whole number, or a decimal). */
    Number,
    /** **quantity**

Quantity. A search parameter that searches on a quantity. */
    Quantity,
    /** **reference**

Reference. A reference to another resource (Reference or canonical). */
    Reference,
    /** **special**

Special. Special logic applies to this parameter per the description of the search parameter. */
    Special,
    /** **string**

String. Search parameter is a simple string, like a name part. Search is case-insensitive and accent-insensitive. May match just the start of a string. String parameters may contain spaces. */
    String,
    /** **token**

Token. Search parameter on a coded element or identifier. May be used to search through the text, display, code and code/codesystem (for codes) and label, system and key (for identifier). Its value is either a string or a pair of namespace and value, separated by a "|", depending on the modifier used. */
    Token,
    /** **uri**

URI. A search parameter that searches on a URI (RFC 3986). */
    Uri,
}
impl ::core::str::FromStr for SearchParamType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "composite" => Ok(Self::Composite),
            "date" => Ok(Self::Date),
            "number" => Ok(Self::Number),
            "quantity" => Ok(Self::Quantity),
            "reference" => Ok(Self::Reference),
            "special" => Ok(Self::Special),
            "string" => Ok(Self::String),
            "token" => Ok(Self::Token),
            "uri" => Ok(Self::Uri),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchParamType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Composite => "composite",
            Self::Date => "date",
            Self::Number => "number",
            Self::Quantity => "quantity",
            Self::Reference => "reference",
            Self::Special => "special",
            Self::String => "string",
            Self::Token => "token",
            Self::Uri => "uri",
        }
    }
}
impl ::std::fmt::Display for SearchParamType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Composite => "Composite",
            Self::Date => "Date/DateTime",
            Self::Number => "Number",
            Self::Quantity => "Quantity",
            Self::Reference => "Reference",
            Self::Special => "Special",
            Self::String => "String",
            Self::Token => "Token",
            Self::Uri => "URI",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SearchParamType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchParamType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchParamType> for Coding {
    fn from(code: SearchParamType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/search-param-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SearchParamType> for CodeableConcept {
    fn from(code: SearchParamType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SearchProcessingModeType](http://hl7.org/fhir/ValueSet/search-processingmode)**. How a search parameter relates to the set of elements returned by evaluating its expression query.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SearchProcessingModeType {
    /** **normal**

Normal. The search parameter is derived directly from the selected nodes based on the type definitions. */
    Normal,
    /** **other**

Other. The interpretation of the xpath statement is unknown (and can't be automated). */
    Other,
    /** **phonetic**

Phonetic. The search parameter is derived by a phonetic transform from the selected nodes. */
    Phonetic,
}
impl ::core::str::FromStr for SearchProcessingModeType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "normal" => Ok(Self::Normal),
            "other" => Ok(Self::Other),
            "phonetic" => Ok(Self::Phonetic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchProcessingModeType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Normal => "normal",
            Self::Other => "other",
            Self::Phonetic => "phonetic",
        }
    }
}
impl ::std::fmt::Display for SearchProcessingModeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Normal => "Normal",
            Self::Other => "Other",
            Self::Phonetic => "Phonetic",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SearchProcessingModeType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchProcessingModeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SearchProcessingModeType> for Coding {
    fn from(code: SearchProcessingModeType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/search-processingmode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SearchProcessingModeType> for CodeableConcept {
    fn from(code: SearchProcessingModeType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SequenceType](http://hl7.org/fhir/ValueSet/sequence-type)**. Type if a sequence -- DNA, RNA, or amino acid sequence.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SequenceType {
    /** **aa**

AA Sequence. Amino acid sequence. */
    Aa,
    /** **dna**

DNA Sequence. DNA Sequence. */
    Dna,
    /** **rna**

RNA Sequence. RNA Sequence. */
    Rna,
}
impl ::core::str::FromStr for SequenceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aa" => Ok(Self::Aa),
            "dna" => Ok(Self::Dna),
            "rna" => Ok(Self::Rna),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SequenceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aa => "aa",
            Self::Dna => "dna",
            Self::Rna => "rna",
        }
    }
}
impl ::std::fmt::Display for SequenceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Aa => "AA Sequence",
            Self::Dna => "DNA Sequence",
            Self::Rna => "RNA Sequence",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SequenceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SequenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SequenceType> for Coding {
    fn from(code: SequenceType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/sequence-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SequenceType> for CodeableConcept {
    fn from(code: SequenceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ServiceMode](http://hl7.org/fhir/ValueSet/service-mode)**. An example set of Service Modes that could be applicable to use to characterize HealthcareServices or PractitionerRoles while searching\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ServiceMode {
    /** **chat**

Chat/Messaging. This service will be provided via a realtime chat/messaging conversation */
    Chat,
    /** **in-person**

In Person. The service will be provided in person */
    InPerson,
    /** **telephone**

Telephone. The service will be provided by a teleconferencing facility or regular telephone */
    Telephone,
    /** **videoconference**

Video Conference. The service will be provided over a video-conference facility */
    Videoconference,
}
impl ::core::str::FromStr for ServiceMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "chat" => Ok(Self::Chat),
            "in-person" => Ok(Self::InPerson),
            "telephone" => Ok(Self::Telephone),
            "videoconference" => Ok(Self::Videoconference),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ServiceMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Chat => "chat",
            Self::InPerson => "in-person",
            Self::Telephone => "telephone",
            Self::Videoconference => "videoconference",
        }
    }
}
impl ::std::fmt::Display for ServiceMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Chat => "Chat/Messaging",
            Self::InPerson => "In Person",
            Self::Telephone => "Telephone",
            Self::Videoconference => "Video Conference",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ServiceMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ServiceMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ServiceMode> for Coding {
    fn from(code: ServiceMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/service-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ServiceMode> for CodeableConcept {
    fn from(code: ServiceMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[ServiceRequestOrderDetailParameterCode](http://hl7.org/fhir/ValueSet/servicerequest-orderdetail-parameter-code)**. Codes providing the parameter codes for service request details.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ServiceRequestOrderDetailParameterCode {
    /** **body-elevation**

Body Elevation. Describes elevation instructions. */
    BodyElevation,
    /** **catheter-insertion**

Catheter Insertion. Describes insertion instructions. */
    CatheterInsertion,
    /** **device-configuration**

Device Configuration. Describes configuration details */
    DeviceConfiguration,
    /** **device-settings**

Device Settings. Describes setting details. */
    DeviceSettings,
}
impl ::core::str::FromStr for ServiceRequestOrderDetailParameterCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "body-elevation" => Ok(Self::BodyElevation),
            "catheter-insertion" => Ok(Self::CatheterInsertion),
            "device-configuration" => Ok(Self::DeviceConfiguration),
            "device-settings" => Ok(Self::DeviceSettings),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ServiceRequestOrderDetailParameterCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::BodyElevation => "body-elevation",
            Self::CatheterInsertion => "catheter-insertion",
            Self::DeviceConfiguration => "device-configuration",
            Self::DeviceSettings => "device-settings",
        }
    }
}
impl ::std::fmt::Display for ServiceRequestOrderDetailParameterCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::BodyElevation => "Body Elevation",
            Self::CatheterInsertion => "Catheter Insertion",
            Self::DeviceConfiguration => "Device Configuration",
            Self::DeviceSettings => "Device Settings",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for ServiceRequestOrderDetailParameterCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ServiceRequestOrderDetailParameterCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<ServiceRequestOrderDetailParameterCode> for Coding {
    fn from(code: ServiceRequestOrderDetailParameterCode) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/servicerequest-orderdetail-parameter-code"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<ServiceRequestOrderDetailParameterCode> for CodeableConcept {
    fn from(code: ServiceRequestOrderDetailParameterCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SlicingRules](http://hl7.org/fhir/ValueSet/resource-slicing-rules)**. How slices are interpreted when evaluating an instance.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SlicingRules {
    /** **closed**

Closed. No additional content is allowed other than that described by the slices in this profile. */
    Closed,
    /** **open**

Open. Additional content is allowed anywhere in the list. */
    Open,
    /** **openAtEnd**

Open at End. Additional content is allowed, but only at the end of the list. Note that using this requires that the slices be ordered, which makes it hard to share uses. This should only be done where absolutely required. */
    OpenAtEnd,
}
impl ::core::str::FromStr for SlicingRules {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "closed" => Ok(Self::Closed),
            "open" => Ok(Self::Open),
            "openAtEnd" => Ok(Self::OpenAtEnd),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SlicingRules {
    fn as_ref(&self) -> &str {
        match self {
            Self::Closed => "closed",
            Self::Open => "open",
            Self::OpenAtEnd => "openAtEnd",
        }
    }
}
impl ::std::fmt::Display for SlicingRules {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Closed => "Closed",
            Self::Open => "Open",
            Self::OpenAtEnd => "Open at End",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SlicingRules {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SlicingRules {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SlicingRules> for Coding {
    fn from(code: SlicingRules) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/resource-slicing-rules".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SlicingRules> for CodeableConcept {
    fn from(code: SlicingRules) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SlotStatus](http://hl7.org/fhir/ValueSet/slotstatus)**. The free/busy status of the slot.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SlotStatus {
    /** **busy**

Busy. Indicates that the time interval is busy because one  or more events have been scheduled for that interval. */
    Busy,
    /** **busy-tentative**

Busy (Tentative). Indicates that the time interval is busy because one or more events have been tentatively scheduled for that interval. */
    BusyTentative,
    /** **busy-unavailable**

Busy (Unavailable). Indicates that the time interval is busy and that the interval cannot be scheduled. */
    BusyUnavailable,
    /** **entered-in-error**

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** **free**

Free. Indicates that the time interval is free for scheduling. */
    Free,
}
impl ::core::str::FromStr for SlotStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "busy" => Ok(Self::Busy),
            "busy-tentative" => Ok(Self::BusyTentative),
            "busy-unavailable" => Ok(Self::BusyUnavailable),
            "entered-in-error" => Ok(Self::EnteredInError),
            "free" => Ok(Self::Free),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SlotStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Busy => "busy",
            Self::BusyTentative => "busy-tentative",
            Self::BusyUnavailable => "busy-unavailable",
            Self::EnteredInError => "entered-in-error",
            Self::Free => "free",
        }
    }
}
impl ::std::fmt::Display for SlotStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Busy => "Busy",
            Self::BusyTentative => "Busy (Tentative)",
            Self::BusyUnavailable => "Busy (Unavailable)",
            Self::EnteredInError => "Entered in error",
            Self::Free => "Free",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SlotStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SlotStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SlotStatus> for Coding {
    fn from(code: SlotStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/slotstatus".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SlotStatus> for CodeableConcept {
    fn from(code: SlotStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SortDirection](http://hl7.org/fhir/ValueSet/sort-direction)**. The possible sort directions, ascending or descending.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SortDirection {
    /** **ascending**

Ascending. Sort by the value ascending, so that lower values appear first. */
    Ascending,
    /** **descending**

Descending. Sort by the value descending, so that lower values appear last. */
    Descending,
}
impl ::core::str::FromStr for SortDirection {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ascending" => Ok(Self::Ascending),
            "descending" => Ok(Self::Descending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SortDirection {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ascending => "ascending",
            Self::Descending => "descending",
        }
    }
}
impl ::std::fmt::Display for SortDirection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Ascending => "Ascending",
            Self::Descending => "Descending",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SortDirection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SortDirection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SortDirection> for Coding {
    fn from(code: SortDirection) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/sort-direction".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SortDirection> for CodeableConcept {
    fn from(code: SortDirection) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SpecialMeasures](http://hl7.org/fhir/ValueSet/medicinal-product-special-measures)**. Extra measures defined for a Medicinal Product, such as requirement to conduct post-authorization studies.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SpecialMeasures {
    /** **Post-authorizationStudies**

Requirement to conduct post-authorization studies. Requirement to conduct post-authorization studies */
    PostAuthorizationStudies,
}
impl ::core::str::FromStr for SpecialMeasures {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Post-authorizationStudies" => Ok(Self::PostAuthorizationStudies),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecialMeasures {
    fn as_ref(&self) -> &str {
        match self {
            Self::PostAuthorizationStudies => "Post-authorizationStudies",
        }
    }
}
impl ::std::fmt::Display for SpecialMeasures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::PostAuthorizationStudies => {
                "Requirement to conduct post-authorization studies"
            }
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SpecialMeasures {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecialMeasures {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecialMeasures> for Coding {
    fn from(code: SpecialMeasures) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/medicinal-product-special-measures"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SpecialMeasures> for CodeableConcept {
    fn from(code: SpecialMeasures) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SpecimenCombined](http://hl7.org/fhir/ValueSet/specimen-combined)**. Codes providing the combined status of the specimen.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SpecimenCombined {
    /** **grouped**

Grouped. The specimen is in a group. */
    Grouped,
    /** **pooled**

Pooled. The specimen is pooled. */
    Pooled,
}
impl ::core::str::FromStr for SpecimenCombined {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "grouped" => Ok(Self::Grouped),
            "pooled" => Ok(Self::Pooled),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecimenCombined {
    fn as_ref(&self) -> &str {
        match self {
            Self::Grouped => "grouped",
            Self::Pooled => "pooled",
        }
    }
}
impl ::std::fmt::Display for SpecimenCombined {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Grouped => "Grouped",
            Self::Pooled => "Pooled",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SpecimenCombined {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecimenCombined {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecimenCombined> for Coding {
    fn from(code: SpecimenCombined) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/specimen-combined".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SpecimenCombined> for CodeableConcept {
    fn from(code: SpecimenCombined) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SpecimenContainedPreference](http://hl7.org/fhir/ValueSet/specimen-contained-preference)**. Degree of preference of a type of conditioned specimen.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SpecimenContainedPreference {
    /** **alternate**

Alternate. This type of conditioned specimen is an alternate. */
    Alternate,
    /** **preferred**

Preferred. This type of contained specimen is preferred to collect this kind of specimen. */
    Preferred,
}
impl ::core::str::FromStr for SpecimenContainedPreference {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alternate" => Ok(Self::Alternate),
            "preferred" => Ok(Self::Preferred),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecimenContainedPreference {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alternate => "alternate",
            Self::Preferred => "preferred",
        }
    }
}
impl ::std::fmt::Display for SpecimenContainedPreference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Alternate => "Alternate",
            Self::Preferred => "Preferred",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SpecimenContainedPreference {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecimenContainedPreference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecimenContainedPreference> for Coding {
    fn from(code: SpecimenContainedPreference) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/specimen-contained-preference".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SpecimenContainedPreference> for CodeableConcept {
    fn from(code: SpecimenContainedPreference) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SpecimenRole](http://hl7.org/fhir/ValueSet/specimen-role)**. Codes providing the combined status of the specimen.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SpecimenRole {
    /** **b**

Blind Sample. Used to test the validity of the measurement process, where the composition of the sample is unknown except to the person submitting it. */
    B,
    /** **c**

Calibrator. Used for initial setting of calibration of the instrument. */
    C,
    /** **e**

Electronic QC. Used with manufactured reference providing signals that simulate QC results. */
    E,
    /** **f**

Filler Organization Proficiency. Specimen used for testing proficiency of the organization performing the testing (Filler). */
    F,
    /** **o**

Operator Proficiency. Specimen used for testing Operator Proficiency. */
    O,
    /** **p**

Patient. Used for any patient sample. */
    P,
    /** **q**

Control specimen. Used when specimen is the control specimen (either positive or negative). */
    Q,
    /** **r**

Replicate (of patient sample as a control). Used when a patient sample is re-run as a control for a repeat test. */
    R,
    /** **v**

Verifying Calibrator. Used for periodic calibration checks. */
    V,
}
impl ::core::str::FromStr for SpecimenRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "b" => Ok(Self::B),
            "c" => Ok(Self::C),
            "e" => Ok(Self::E),
            "f" => Ok(Self::F),
            "o" => Ok(Self::O),
            "p" => Ok(Self::P),
            "q" => Ok(Self::Q),
            "r" => Ok(Self::R),
            "v" => Ok(Self::V),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecimenRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::B => "b",
            Self::C => "c",
            Self::E => "e",
            Self::F => "f",
            Self::O => "o",
            Self::P => "p",
            Self::Q => "q",
            Self::R => "r",
            Self::V => "v",
        }
    }
}
impl ::std::fmt::Display for SpecimenRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::B => "Blind Sample",
            Self::C => "Calibrator",
            Self::E => "Electronic QC",
            Self::F => "Filler Organization Proficiency",
            Self::O => "Operator Proficiency",
            Self::P => "Patient",
            Self::Q => "Control specimen",
            Self::R => "Replicate (of patient sample as a control)",
            Self::V => "Verifying Calibrator",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SpecimenRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecimenRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecimenRole> for Coding {
    fn from(code: SpecimenRole) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/specimen-role".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SpecimenRole> for CodeableConcept {
    fn from(code: SpecimenRole) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SpecimenStatus](http://hl7.org/fhir/ValueSet/specimen-status)**. Codes providing the status/availability of a specimen.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SpecimenStatus {
    /** **available**

Available. The physical specimen is present and in good condition. */
    Available,
    /** **entered-in-error**

Entered in Error. The specimen was entered in error and therefore nullified. */
    EnteredInError,
    /** **unavailable**

Unavailable. There is no physical specimen because it is either lost, destroyed or consumed. */
    Unavailable,
    /** **unsatisfactory**

Unsatisfactory. The specimen cannot be used because of a quality issue such as a broken container, contamination, or too old. */
    Unsatisfactory,
}
impl ::core::str::FromStr for SpecimenStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "entered-in-error" => Ok(Self::EnteredInError),
            "unavailable" => Ok(Self::Unavailable),
            "unsatisfactory" => Ok(Self::Unsatisfactory),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecimenStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::EnteredInError => "entered-in-error",
            Self::Unavailable => "unavailable",
            Self::Unsatisfactory => "unsatisfactory",
        }
    }
}
impl ::std::fmt::Display for SpecimenStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Available => "Available",
            Self::EnteredInError => "Entered in Error",
            Self::Unavailable => "Unavailable",
            Self::Unsatisfactory => "Unsatisfactory",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SpecimenStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecimenStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SpecimenStatus> for Coding {
    fn from(code: SpecimenStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/specimen-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SpecimenStatus> for CodeableConcept {
    fn from(code: SpecimenStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StatisticModelCode](http://hl7.org/fhir/ValueSet/statistic-model-code)**. The role that the assertion variable plays.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StatisticModelCode {
    /** **adjusted**

Adjusted analysis. Used for adjusted analysis, paired with variable element(s) */
    Adjusted,
    /** **anova**

ANOVA (ANalysis Of VAriance). Used for ANOVA method of analysis, may be paired with "value" to express degrees of freedom */
    Anova,
    /** **anovaOneWay**

one-way ANOVA. Used for one-way ANOVA method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaOneWay,
    /** **anovaThreeWay**

3-way ANOVA. Used for 3-way ANOVA method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaThreeWay,
    /** **anovaTwoWay**

2-way ANOVA without replication. Used for 2-way ANOVA without replication method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaTwoWay,
    /** **anovaTwoWayReplication**

2-way ANOVA with replication. Used for 2-way ANOVA with replication method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaTwoWayReplication,
    /** **binomialDistributionRegression**

Binomial Distribution for Regression. Used for Binomial Distribution for Regression, no additional elements needed */
    BinomialDistributionRegression,
    /** **chiSquareTest**

Chi-square test. Used for Chi-square test, may be paired with "value" to express degrees of freedom */
    ChiSquareTest,
    /** **chiSquareTestHomogeneity**

Chi-square test for homogeneity. Used for Chi-square test for homogeneity, may be paired with "value" to express degrees of freedom */
    ChiSquareTestHomogeneity,
    /** **chiSquareTestTrend**

Chi-square test for trend. Used for Chi-square test for trend, may be paired with "value" to express degrees of freedom */
    ChiSquareTestTrend,
    /** **coxProportionalHazards**

Cox Proportional Hazards. Used for Cox proportional hazards method of analysis, no additional elements needed */
    CoxProportionalHazards,
    /** **dersimonianLairdMethod**

Dersimonian-Laird method. Used for Dersimonian-Laird method of tau estimation, no additional elements needed */
    DersimonianLairdMethod,
    /** **effectsFixed**

Fixed-effects. From a fixed-effects analysis, no additional elements needed */
    EffectsFixed,
    /** **effectsRandom**

Random-effects. From a random-effects analysis, no additional elements needed */
    EffectsRandom,
    /** **empiricalBayes**

Empirical Bayes method. Used for Empirical Bayes method of tau estimation, no additional elements needed */
    EmpiricalBayes,
    /** **fishersExactTest**

Fisher’s exact test. Used for Fisher's exact test, may be paired with "value" to express degrees of freedom */
    FishersExactTest,
    /** **friedmanTest**

Friedman test. Used for Friedman test, no additional elements needed */
    FriedmanTest,
    /** **glm**

GLM (Generalized Linear Model). Used for GLM (Generalized Linear Model), no additional elements needed */
    Glm,
    /** **glmGeneralizedLogit**

GLM with generalized logit link. Used for GLM with generalized logit link, no additional elements needed */
    GlmGeneralizedLogit,
    /** **glmIdentity**

GLM with identity link. Used for GLM with identity link, no additional elements needed */
    GlmIdentity,
    /** **glmLog**

GLM with log link. Used for GLM with log link, no additional elements needed */
    GlmLog,
    /** **glmLogit**

GLM with logit link. Used for GLM with logit link, no additional elements needed */
    GlmLogit,
    /** **glmProbit**

GLM with probit link. Used for GLM with probit link, no additional elements needed */
    GlmProbit,
    /** **glmm**

Generalized linear mixed model (GLMM). Used for Generalized linear mixed model (GLMM), no additional elements needed */
    Glmm,
    /** **glmmGeneralizedLogit**

GLMM with generalized logit link. Used for GLMM with generalized logit link, no additional elements needed */
    GlmmGeneralizedLogit,
    /** **glmmIdentity**

GLMM with identity link. Used for GLMM with identity link, no additional elements needed */
    GlmmIdentity,
    /** **glmmLog**

GLMM with log link. Used for GLMM with log link, no additional elements needed */
    GlmmLog,
    /** **glmmLogit**

GLMM with logit link. Used for GLMM with logit link, no additional elements needed */
    GlmmLogit,
    /** **glmmProbit**

GLMM with probit link. Used for GLMM with probit link, no additional elements needed */
    GlmmProbit,
    /** **goodmanKruskasGamma**

Goodman Kruska’s Gamma. Used for Goodman Kruska’s Gamma, no additional elements needed */
    GoodmanKruskasGamma,
    /** **hartungKnapp**

Hartung-Knapp adjustment. Hartung-Knapp/Hartung-Knapp-Sidik-Jonkman adjustment used in meta-analysis, no additional elements needed */
    HartungKnapp,
    /** **hedgesMethod**

Hedges method. Used for Hedges method of tau estimation, no additional elements needed */
    HedgesMethod,
    /** **hunterSchmidt**

Hunter-Schmidt method. Used for Hunter-Schmidt method of tau estimation, no additional elements needed */
    HunterSchmidt,
    /** **interactionTerm**

Interaction term. Used for interaction term, paired with "value" and two or more variable elements */
    InteractionTerm,
    /** **inverseVariance**

Inverse variance method. Used for inverse variance method of meta-analysis, no additional elements needed */
    InverseVariance,
    /** **kendallCorrelation**

Kendall correlation. Used for Kendall correlation, no additional elements needed */
    KendallCorrelation,
    /** **kruskalWallisTest**

Kruskal Wallis test. Used for Kruskal Wallis test, may be paired with "value" to express degrees of freedom */
    KruskalWallisTest,
    /** **linearRegression**

Linear Regression. Used for linear regression method of analysis, no additional elements needed */
    LinearRegression,
    /** **logisticRegression**

Logistic Regression. Used for logistic regression method of analysis, no additional elements needed */
    LogisticRegression,
    /** **mannWhitneyUTest**

Mann-Whitney U test. Used for Mann-Whitney U test, no additional elements needed */
    MannWhitneyUTest,
    /** **manova**

multivariate ANOVA (MANOVA). Used for multivariate ANOVA (MANOVA) method of analysis, may be paired with "value" to express degrees of freedom */
    Manova,
    /** **manteHaenszelMethod**

Mantel-Haenszel method. Used for Mantel-Haenszel method, no additional elements needed */
    ManteHaenszelMethod,
    /** **maximumLikelihood**

Maximum Likelihood method. Used for Maximum Likelihood method of tau estimation, no additional elements needed */
    MaximumLikelihood,
    /** **mcnemarsTest**

McNemar’s test. Used for McNemar's test, no additional elements needed */
    McnemarsTest,
    /** **metaAnalysis**

Meta-analysis. Used for meta-analysis, no additional elements needed */
    MetaAnalysis,
    /** **modifiedHartungKnapp**

Modified Hartung-Knapp adjustment. Modified Hartung-Knapp/Hartung-Knapp-Sidik-Jonkman adjustment used in meta-analysis, no additional elements needed */
    ModifiedHartungKnapp,
    /** **multinomialDistributionRegression**

Multinomial Distribution for Regression. Used for Multinomial Distribution for Regression, no additional elements needed */
    MultinomialDistributionRegression,
    /** **negativeBinomialRegression**

Negative Binomial Regression. Used for Negative Binomial Regression, no additional elements needed */
    NegativeBinomialRegression,
    /** **oneSampleTTest**

1-sample t-test. Used for 1-sample t-test, may be paired with "value" to express degrees of freedom */
    OneSampleTTest,
    /** **oneTailedTest**

one-tailed test (1 threshold). Used for one-tailed test (1 threshold), no additional elements needed */
    OneTailedTest,
    /** **pairedTTest**

paired t-test. Used for paired t-test, may be paired with "value" to express degrees of freedom */
    PairedTTest,
    /** **pauleMandelMethod**

Paule-Mandel method. Used for Paule-Mandel method of tau estimation, no additional elements needed */
    PauleMandelMethod,
    /** **pearsonCorrelation**

Pearson correlation. Used for Pearson correlation, no additional elements needed */
    PearsonCorrelation,
    /** **petoMethod**

Peto method. Used for Peto method of meta-analysis, no additional elements needed */
    PetoMethod,
    /** **poissonRegression**

Poisson Regression. Used for Poisson Regression, no additional elements needed */
    PoissonRegression,
    /** **polynomialRegression**

Polynomial Regression. Used for Polynomial regression method of analysis, no additional elements needed */
    PolynomialRegression,
    /** **poolGeneralizedLinearMixedModel**

Generalized linear mixed model (GLMM). Generalized linear mixed model (GLMM) method for pooling in meta-analysis */
    PoolGeneralizedLinearMixedModel,
    /** **poolInverseVariance**

Inverse variance method. Inverse variance method for pooling in meta-analysis */
    PoolInverseVariance,
    /** **poolMantelHaenzsel**

Mantel-Haenszel method. Mantel-Haenszel method for pooling in meta-analysis */
    PoolMantelHaenzsel,
    /** **poolPeto**

Peto method. Peto method for pooling in meta-analysis */
    PoolPeto,
    /** **restrictedLikelihood**

Restricted Maximum Likelihood method. Used for Restricted Maximum Likelihood method of tau estimation, no additional elements needed */
    RestrictedLikelihood,
    /** **sidikJonkman**

Sidik-Jonkman method. Used for Sidik-Jonkman method of tau estimation, no additional elements needed */
    SidikJonkman,
    /** **signTest**

sign test. Used for sign test, no additional elements needed */
    SignTest,
    /** **spearmanCorrelation**

Spearman correlation. Used for Spearman correlation, no additional elements needed */
    SpearmanCorrelation,
    /** **tauDersimonianLaird**

Dersimonian-Laird method. Dersimonian-Laird method for tau squared */
    TauDersimonianLaird,
    /** **tauEmpiricalBayes**

Empirical Bayes method. Empirical Bayes method for tau squared */
    TauEmpiricalBayes,
    /** **tauHedges**

Hedges method. Hedges method for tau squared */
    TauHedges,
    /** **tauHunterSchmidt**

Hunter-Schmidt method. Hunter-Schmidt method for tau squared */
    TauHunterSchmidt,
    /** **tauMaximumLikelihood**

Maximum Likelihood method. Maximum Likelihood method for tau squared */
    TauMaximumLikelihood,
    /** **tauPauleMandel**

Paule-Mandel method. Paule-Mandel method for tau squared */
    TauPauleMandel,
    /** **tauRestrictedMaximumLikelihood**

Restricted Maximum Likelihood method. Restricted Maximum Likelihood method for tau squared */
    TauRestrictedMaximumLikelihood,
    /** **tauSidikJonkman**

Sidik-Jonkman method. Sidik-Jonkman method for tau squared */
    TauSidikJonkman,
    /** **twoSampleTTest**

2-sample t-test. Used for 2-sample t-test, may be paired with "value" to express degrees of freedom */
    TwoSampleTTest,
    /** **twoTailedTest**

two-tailed test (2 thresholds). Used for two-tailed test (2 threshold), no additional elements needed */
    TwoTailedTest,
    /** **wilcoxonRankSumTest**

Wilcoxon rank-sum test. Used for Wilcoxon rank-sum test, no additional elements needed */
    WilcoxonRankSumTest,
    /** **wilcoxonSignedRankTest**

Wilcoxon signed-rank test. Used for Wilcoxon signed-rank test, no additional elements needed */
    WilcoxonSignedRankTest,
    /** **zTest**

z-test. Used for z-test, no additional elements needed */
    Ztest,
    /** **zeroCellConstant**

Zero-cell adjustment with constant. Zero-cell adjustment done by adding a constant to all cells of affected studies, paired with "value" to define the constant */
    ZeroCellConstant,
    /** **zeroCellContinuityCorrection**

Zero-cell adjustment with continuity correction. Zero-cell adjustment done by treatment arm continuity correction, no additional elements needed */
    ZeroCellContinuityCorrection,
}
impl ::core::str::FromStr for StatisticModelCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "adjusted" => Ok(Self::Adjusted),
            "anova" => Ok(Self::Anova),
            "anovaOneWay" => Ok(Self::AnovaOneWay),
            "anovaThreeWay" => Ok(Self::AnovaThreeWay),
            "anovaTwoWay" => Ok(Self::AnovaTwoWay),
            "anovaTwoWayReplication" => Ok(Self::AnovaTwoWayReplication),
            "binomialDistributionRegression" => Ok(Self::BinomialDistributionRegression),
            "chiSquareTest" => Ok(Self::ChiSquareTest),
            "chiSquareTestHomogeneity" => Ok(Self::ChiSquareTestHomogeneity),
            "chiSquareTestTrend" => Ok(Self::ChiSquareTestTrend),
            "coxProportionalHazards" => Ok(Self::CoxProportionalHazards),
            "dersimonianLairdMethod" => Ok(Self::DersimonianLairdMethod),
            "effectsFixed" => Ok(Self::EffectsFixed),
            "effectsRandom" => Ok(Self::EffectsRandom),
            "empiricalBayes" => Ok(Self::EmpiricalBayes),
            "fishersExactTest" => Ok(Self::FishersExactTest),
            "friedmanTest" => Ok(Self::FriedmanTest),
            "glm" => Ok(Self::Glm),
            "glmGeneralizedLogit" => Ok(Self::GlmGeneralizedLogit),
            "glmIdentity" => Ok(Self::GlmIdentity),
            "glmLog" => Ok(Self::GlmLog),
            "glmLogit" => Ok(Self::GlmLogit),
            "glmProbit" => Ok(Self::GlmProbit),
            "glmm" => Ok(Self::Glmm),
            "glmmGeneralizedLogit" => Ok(Self::GlmmGeneralizedLogit),
            "glmmIdentity" => Ok(Self::GlmmIdentity),
            "glmmLog" => Ok(Self::GlmmLog),
            "glmmLogit" => Ok(Self::GlmmLogit),
            "glmmProbit" => Ok(Self::GlmmProbit),
            "goodmanKruskasGamma" => Ok(Self::GoodmanKruskasGamma),
            "hartungKnapp" => Ok(Self::HartungKnapp),
            "hedgesMethod" => Ok(Self::HedgesMethod),
            "hunterSchmidt" => Ok(Self::HunterSchmidt),
            "interactionTerm" => Ok(Self::InteractionTerm),
            "inverseVariance" => Ok(Self::InverseVariance),
            "kendallCorrelation" => Ok(Self::KendallCorrelation),
            "kruskalWallisTest" => Ok(Self::KruskalWallisTest),
            "linearRegression" => Ok(Self::LinearRegression),
            "logisticRegression" => Ok(Self::LogisticRegression),
            "mannWhitneyUTest" => Ok(Self::MannWhitneyUTest),
            "manova" => Ok(Self::Manova),
            "manteHaenszelMethod" => Ok(Self::ManteHaenszelMethod),
            "maximumLikelihood" => Ok(Self::MaximumLikelihood),
            "mcnemarsTest" => Ok(Self::McnemarsTest),
            "metaAnalysis" => Ok(Self::MetaAnalysis),
            "modifiedHartungKnapp" => Ok(Self::ModifiedHartungKnapp),
            "multinomialDistributionRegression" => {
                Ok(Self::MultinomialDistributionRegression)
            }
            "negativeBinomialRegression" => Ok(Self::NegativeBinomialRegression),
            "oneSampleTTest" => Ok(Self::OneSampleTTest),
            "oneTailedTest" => Ok(Self::OneTailedTest),
            "pairedTTest" => Ok(Self::PairedTTest),
            "pauleMandelMethod" => Ok(Self::PauleMandelMethod),
            "pearsonCorrelation" => Ok(Self::PearsonCorrelation),
            "petoMethod" => Ok(Self::PetoMethod),
            "poissonRegression" => Ok(Self::PoissonRegression),
            "polynomialRegression" => Ok(Self::PolynomialRegression),
            "poolGeneralizedLinearMixedModel" => {
                Ok(Self::PoolGeneralizedLinearMixedModel)
            }
            "poolInverseVariance" => Ok(Self::PoolInverseVariance),
            "poolMantelHaenzsel" => Ok(Self::PoolMantelHaenzsel),
            "poolPeto" => Ok(Self::PoolPeto),
            "restrictedLikelihood" => Ok(Self::RestrictedLikelihood),
            "sidikJonkman" => Ok(Self::SidikJonkman),
            "signTest" => Ok(Self::SignTest),
            "spearmanCorrelation" => Ok(Self::SpearmanCorrelation),
            "tauDersimonianLaird" => Ok(Self::TauDersimonianLaird),
            "tauEmpiricalBayes" => Ok(Self::TauEmpiricalBayes),
            "tauHedges" => Ok(Self::TauHedges),
            "tauHunterSchmidt" => Ok(Self::TauHunterSchmidt),
            "tauMaximumLikelihood" => Ok(Self::TauMaximumLikelihood),
            "tauPauleMandel" => Ok(Self::TauPauleMandel),
            "tauRestrictedMaximumLikelihood" => Ok(Self::TauRestrictedMaximumLikelihood),
            "tauSidikJonkman" => Ok(Self::TauSidikJonkman),
            "twoSampleTTest" => Ok(Self::TwoSampleTTest),
            "twoTailedTest" => Ok(Self::TwoTailedTest),
            "wilcoxonRankSumTest" => Ok(Self::WilcoxonRankSumTest),
            "wilcoxonSignedRankTest" => Ok(Self::WilcoxonSignedRankTest),
            "zTest" => Ok(Self::Ztest),
            "zeroCellConstant" => Ok(Self::ZeroCellConstant),
            "zeroCellContinuityCorrection" => Ok(Self::ZeroCellContinuityCorrection),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StatisticModelCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adjusted => "adjusted",
            Self::Anova => "anova",
            Self::AnovaOneWay => "anovaOneWay",
            Self::AnovaThreeWay => "anovaThreeWay",
            Self::AnovaTwoWay => "anovaTwoWay",
            Self::AnovaTwoWayReplication => "anovaTwoWayReplication",
            Self::BinomialDistributionRegression => "binomialDistributionRegression",
            Self::ChiSquareTest => "chiSquareTest",
            Self::ChiSquareTestHomogeneity => "chiSquareTestHomogeneity",
            Self::ChiSquareTestTrend => "chiSquareTestTrend",
            Self::CoxProportionalHazards => "coxProportionalHazards",
            Self::DersimonianLairdMethod => "dersimonianLairdMethod",
            Self::EffectsFixed => "effectsFixed",
            Self::EffectsRandom => "effectsRandom",
            Self::EmpiricalBayes => "empiricalBayes",
            Self::FishersExactTest => "fishersExactTest",
            Self::FriedmanTest => "friedmanTest",
            Self::Glm => "glm",
            Self::GlmGeneralizedLogit => "glmGeneralizedLogit",
            Self::GlmIdentity => "glmIdentity",
            Self::GlmLog => "glmLog",
            Self::GlmLogit => "glmLogit",
            Self::GlmProbit => "glmProbit",
            Self::Glmm => "glmm",
            Self::GlmmGeneralizedLogit => "glmmGeneralizedLogit",
            Self::GlmmIdentity => "glmmIdentity",
            Self::GlmmLog => "glmmLog",
            Self::GlmmLogit => "glmmLogit",
            Self::GlmmProbit => "glmmProbit",
            Self::GoodmanKruskasGamma => "goodmanKruskasGamma",
            Self::HartungKnapp => "hartungKnapp",
            Self::HedgesMethod => "hedgesMethod",
            Self::HunterSchmidt => "hunterSchmidt",
            Self::InteractionTerm => "interactionTerm",
            Self::InverseVariance => "inverseVariance",
            Self::KendallCorrelation => "kendallCorrelation",
            Self::KruskalWallisTest => "kruskalWallisTest",
            Self::LinearRegression => "linearRegression",
            Self::LogisticRegression => "logisticRegression",
            Self::MannWhitneyUTest => "mannWhitneyUTest",
            Self::Manova => "manova",
            Self::ManteHaenszelMethod => "manteHaenszelMethod",
            Self::MaximumLikelihood => "maximumLikelihood",
            Self::McnemarsTest => "mcnemarsTest",
            Self::MetaAnalysis => "metaAnalysis",
            Self::ModifiedHartungKnapp => "modifiedHartungKnapp",
            Self::MultinomialDistributionRegression => {
                "multinomialDistributionRegression"
            }
            Self::NegativeBinomialRegression => "negativeBinomialRegression",
            Self::OneSampleTTest => "oneSampleTTest",
            Self::OneTailedTest => "oneTailedTest",
            Self::PairedTTest => "pairedTTest",
            Self::PauleMandelMethod => "pauleMandelMethod",
            Self::PearsonCorrelation => "pearsonCorrelation",
            Self::PetoMethod => "petoMethod",
            Self::PoissonRegression => "poissonRegression",
            Self::PolynomialRegression => "polynomialRegression",
            Self::PoolGeneralizedLinearMixedModel => "poolGeneralizedLinearMixedModel",
            Self::PoolInverseVariance => "poolInverseVariance",
            Self::PoolMantelHaenzsel => "poolMantelHaenzsel",
            Self::PoolPeto => "poolPeto",
            Self::RestrictedLikelihood => "restrictedLikelihood",
            Self::SidikJonkman => "sidikJonkman",
            Self::SignTest => "signTest",
            Self::SpearmanCorrelation => "spearmanCorrelation",
            Self::TauDersimonianLaird => "tauDersimonianLaird",
            Self::TauEmpiricalBayes => "tauEmpiricalBayes",
            Self::TauHedges => "tauHedges",
            Self::TauHunterSchmidt => "tauHunterSchmidt",
            Self::TauMaximumLikelihood => "tauMaximumLikelihood",
            Self::TauPauleMandel => "tauPauleMandel",
            Self::TauRestrictedMaximumLikelihood => "tauRestrictedMaximumLikelihood",
            Self::TauSidikJonkman => "tauSidikJonkman",
            Self::TwoSampleTTest => "twoSampleTTest",
            Self::TwoTailedTest => "twoTailedTest",
            Self::WilcoxonRankSumTest => "wilcoxonRankSumTest",
            Self::WilcoxonSignedRankTest => "wilcoxonSignedRankTest",
            Self::Ztest => "zTest",
            Self::ZeroCellConstant => "zeroCellConstant",
            Self::ZeroCellContinuityCorrection => "zeroCellContinuityCorrection",
        }
    }
}
impl ::std::fmt::Display for StatisticModelCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Adjusted => "Adjusted analysis",
            Self::Anova => "ANOVA (ANalysis Of VAriance)",
            Self::AnovaOneWay => "one-way ANOVA",
            Self::AnovaThreeWay => "3-way ANOVA",
            Self::AnovaTwoWay => "2-way ANOVA without replication",
            Self::AnovaTwoWayReplication => "2-way ANOVA with replication",
            Self::BinomialDistributionRegression => {
                "Binomial Distribution for Regression"
            }
            Self::ChiSquareTest => "Chi-square test",
            Self::ChiSquareTestHomogeneity => "Chi-square test for homogeneity",
            Self::ChiSquareTestTrend => "Chi-square test for trend",
            Self::CoxProportionalHazards => "Cox Proportional Hazards",
            Self::DersimonianLairdMethod => "Dersimonian-Laird method",
            Self::EffectsFixed => "Fixed-effects",
            Self::EffectsRandom => "Random-effects",
            Self::EmpiricalBayes => "Empirical Bayes method",
            Self::FishersExactTest => "Fisher’s exact test",
            Self::FriedmanTest => "Friedman test",
            Self::Glm => "GLM (Generalized Linear Model)",
            Self::GlmGeneralizedLogit => "GLM with generalized logit link",
            Self::GlmIdentity => "GLM with identity link",
            Self::GlmLog => "GLM with log link",
            Self::GlmLogit => "GLM with logit link",
            Self::GlmProbit => "GLM with probit link",
            Self::Glmm => "Generalized linear mixed model (GLMM)",
            Self::GlmmGeneralizedLogit => "GLMM with generalized logit link",
            Self::GlmmIdentity => "GLMM with identity link",
            Self::GlmmLog => "GLMM with log link",
            Self::GlmmLogit => "GLMM with logit link",
            Self::GlmmProbit => "GLMM with probit link",
            Self::GoodmanKruskasGamma => "Goodman Kruska’s Gamma",
            Self::HartungKnapp => "Hartung-Knapp adjustment",
            Self::HedgesMethod => "Hedges method",
            Self::HunterSchmidt => "Hunter-Schmidt method",
            Self::InteractionTerm => "Interaction term",
            Self::InverseVariance => "Inverse variance method",
            Self::KendallCorrelation => "Kendall correlation",
            Self::KruskalWallisTest => "Kruskal Wallis test",
            Self::LinearRegression => "Linear Regression",
            Self::LogisticRegression => "Logistic Regression",
            Self::MannWhitneyUTest => "Mann-Whitney U test",
            Self::Manova => "multivariate ANOVA (MANOVA)",
            Self::ManteHaenszelMethod => "Mantel-Haenszel method",
            Self::MaximumLikelihood => "Maximum Likelihood method",
            Self::McnemarsTest => "McNemar’s test",
            Self::MetaAnalysis => "Meta-analysis",
            Self::ModifiedHartungKnapp => "Modified Hartung-Knapp adjustment",
            Self::MultinomialDistributionRegression => {
                "Multinomial Distribution for Regression"
            }
            Self::NegativeBinomialRegression => "Negative Binomial Regression",
            Self::OneSampleTTest => "1-sample t-test",
            Self::OneTailedTest => "one-tailed test (1 threshold)",
            Self::PairedTTest => "paired t-test",
            Self::PauleMandelMethod => "Paule-Mandel method",
            Self::PearsonCorrelation => "Pearson correlation",
            Self::PetoMethod => "Peto method",
            Self::PoissonRegression => "Poisson Regression",
            Self::PolynomialRegression => "Polynomial Regression",
            Self::PoolGeneralizedLinearMixedModel => {
                "Generalized linear mixed model (GLMM)"
            }
            Self::PoolInverseVariance => "Inverse variance method",
            Self::PoolMantelHaenzsel => "Mantel-Haenszel method",
            Self::PoolPeto => "Peto method",
            Self::RestrictedLikelihood => "Restricted Maximum Likelihood method",
            Self::SidikJonkman => "Sidik-Jonkman method",
            Self::SignTest => "sign test",
            Self::SpearmanCorrelation => "Spearman correlation",
            Self::TauDersimonianLaird => "Dersimonian-Laird method",
            Self::TauEmpiricalBayes => "Empirical Bayes method",
            Self::TauHedges => "Hedges method",
            Self::TauHunterSchmidt => "Hunter-Schmidt method",
            Self::TauMaximumLikelihood => "Maximum Likelihood method",
            Self::TauPauleMandel => "Paule-Mandel method",
            Self::TauRestrictedMaximumLikelihood => {
                "Restricted Maximum Likelihood method"
            }
            Self::TauSidikJonkman => "Sidik-Jonkman method",
            Self::TwoSampleTTest => "2-sample t-test",
            Self::TwoTailedTest => "two-tailed test (2 thresholds)",
            Self::WilcoxonRankSumTest => "Wilcoxon rank-sum test",
            Self::WilcoxonSignedRankTest => "Wilcoxon signed-rank test",
            Self::Ztest => "z-test",
            Self::ZeroCellConstant => "Zero-cell adjustment with constant",
            Self::ZeroCellContinuityCorrection => {
                "Zero-cell adjustment with continuity correction"
            }
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StatisticModelCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StatisticModelCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StatisticModelCode> for Coding {
    fn from(code: StatisticModelCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/statistic-model-code".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StatisticModelCode> for CodeableConcept {
    fn from(code: StatisticModelCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StatisticsCode](http://hl7.org/fhir/ValueSet/observation-statistics)**. The statistical operation parameter -\"statistic\" codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StatisticsCode {
    /** **20-percent**

20th Percentile. The 20th [Percentile](https://en.wikipedia.org/wiki/Percentile) of N measurements over the stated period. */
    N20Percent,
    /** **4-dev**

Quartile Deviation. The difference between the upper and lower [Quartiles](https://en.wikipedia.org/wiki/Quartile) is called the Interquartile range. (IQR = Q3-Q1) Quartile deviation or Semi-interquartile range is one-half the difference between the first and the third quartiles. */
    N4Dev,
    /** **4-lower**

Lower Quartile. The lower [Quartile](https://en.wikipedia.org/wiki/Quartile) Boundary of N measurements over the stated period. */
    N4Lower,
    /** **4-upper**

Upper Quartile. The upper [Quartile](https://en.wikipedia.org/wiki/Quartile) Boundary of N measurements over the stated period. */
    N4Upper,
    /** **5-1**

1st Quintile. The lowest of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N51,
    /** **5-2**

2nd Quintile. The second of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N52,
    /** **5-3**

3rd Quintile. The third of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N53,
    /** **5-4**

4th Quintile. The fourth of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N54,
    /** **80-percent**

80th Percentile. The 80th [Percentile](https://en.wikipedia.org/wiki/Percentile) of N measurements over the stated period. */
    N80Percent,
    /** **average**

Average. The [mean](https://en.wikipedia.org/wiki/Arithmetic_mean) of N measurements over the stated period. */
    Average,
    /** **count**

Count. The [number] of valid measurements over the stated period that contributed to the other statistical outputs. */
    Count,
    /** **kurtosis**

Kurtosis. Kurtosis  is a measure of the "tailedness" of the probability distribution of a real-valued random variable.   Source: [Wikipedia](https://en.wikipedia.org/wiki/Kurtosis). */
    Kurtosis,
    /** **maximum**

Maximum. The [maximum](https://en.wikipedia.org/wiki/Maximal_element) value of N measurements over the stated period. */
    Maximum,
    /** **median**

Median. The [median](https://en.wikipedia.org/wiki/Median) of N measurements over the stated period. */
    Median,
    /** **minimum**

Minimum. The [minimum](https://en.wikipedia.org/wiki/Minimal_element) value of N measurements over the stated period. */
    Minimum,
    /** **regression**

Regression. Linear regression is an approach for modeling two-dimensional sample points with one independent variable and one dependent variable (conventionally, the x and y coordinates in a Cartesian coordinate system) and finds a linear function (a non-vertical straight line) that, as accurately as possible, predicts the dependent variable values as a function of the independent variables. Source: [Wikipedia](https://en.wikipedia.org/wiki/Simple_linear_regression)  This Statistic code will return both a gradient and an intercept value. */
    Regression,
    /** **skew**

Skew. Skewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean. The skewness value can be positive or negative, or even undefined.  Source: [Wikipedia](https://en.wikipedia.org/wiki/Skewness). */
    Skew,
    /** **std-dev**

Standard Deviation. The [standard deviation](https://en.wikipedia.org/wiki/Standard_deviation) of N measurements over the stated period. */
    StdDev,
    /** **sum**

Sum. The [sum](https://en.wikipedia.org/wiki/Summation) of N measurements over the stated period. */
    Sum,
    /** **total-count**

Total Count. The total [number] of valid measurements over the stated period, including observations that were ignored because they did not contain valid result values. */
    TotalCount,
    /** **variance**

Variance. The [variance](https://en.wikipedia.org/wiki/Variance) of N measurements over the stated period. */
    Variance,
}
impl ::core::str::FromStr for StatisticsCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "20-percent" => Ok(Self::N20Percent),
            "4-dev" => Ok(Self::N4Dev),
            "4-lower" => Ok(Self::N4Lower),
            "4-upper" => Ok(Self::N4Upper),
            "5-1" => Ok(Self::N51),
            "5-2" => Ok(Self::N52),
            "5-3" => Ok(Self::N53),
            "5-4" => Ok(Self::N54),
            "80-percent" => Ok(Self::N80Percent),
            "average" => Ok(Self::Average),
            "count" => Ok(Self::Count),
            "kurtosis" => Ok(Self::Kurtosis),
            "maximum" => Ok(Self::Maximum),
            "median" => Ok(Self::Median),
            "minimum" => Ok(Self::Minimum),
            "regression" => Ok(Self::Regression),
            "skew" => Ok(Self::Skew),
            "std-dev" => Ok(Self::StdDev),
            "sum" => Ok(Self::Sum),
            "total-count" => Ok(Self::TotalCount),
            "variance" => Ok(Self::Variance),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StatisticsCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::N20Percent => "20-percent",
            Self::N4Dev => "4-dev",
            Self::N4Lower => "4-lower",
            Self::N4Upper => "4-upper",
            Self::N51 => "5-1",
            Self::N52 => "5-2",
            Self::N53 => "5-3",
            Self::N54 => "5-4",
            Self::N80Percent => "80-percent",
            Self::Average => "average",
            Self::Count => "count",
            Self::Kurtosis => "kurtosis",
            Self::Maximum => "maximum",
            Self::Median => "median",
            Self::Minimum => "minimum",
            Self::Regression => "regression",
            Self::Skew => "skew",
            Self::StdDev => "std-dev",
            Self::Sum => "sum",
            Self::TotalCount => "total-count",
            Self::Variance => "variance",
        }
    }
}
impl ::std::fmt::Display for StatisticsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N20Percent => "20th Percentile",
            Self::N4Dev => "Quartile Deviation",
            Self::N4Lower => "Lower Quartile",
            Self::N4Upper => "Upper Quartile",
            Self::N51 => "1st Quintile",
            Self::N52 => "2nd Quintile",
            Self::N53 => "3rd Quintile",
            Self::N54 => "4th Quintile",
            Self::N80Percent => "80th Percentile",
            Self::Average => "Average",
            Self::Count => "Count",
            Self::Kurtosis => "Kurtosis",
            Self::Maximum => "Maximum",
            Self::Median => "Median",
            Self::Minimum => "Minimum",
            Self::Regression => "Regression",
            Self::Skew => "Skew",
            Self::StdDev => "Standard Deviation",
            Self::Sum => "Sum",
            Self::TotalCount => "Total Count",
            Self::Variance => "Variance",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StatisticsCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StatisticsCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StatisticsCode> for Coding {
    fn from(code: StatisticsCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/observation-statistics".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StatisticsCode> for CodeableConcept {
    fn from(code: StatisticsCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[Status](http://hl7.org/fhir/ValueSet/status)**. The validation status of the target\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum Status {
    /** **attested**

Attested. ***TODO*** */
    Attested,
    /** **entered-in-error**

Entered in Error. The VerificationResult record was created erroneously and is not appropriated for use. */
    EnteredInError,
    /** **in-process**

In process. ***TODO*** */
    InProcess,
    /** **req-revalid**

Requires revalidation. ***TODO*** */
    ReqRevalid,
    /** **reval-fail**

Re-Validation failed. ***TODO*** */
    RevalFail,
    /** **val-fail**

Validation failed. ***TODO*** */
    ValFail,
    /** **validated**

Validated. ***TODO*** */
    Validated,
}
impl ::core::str::FromStr for Status {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "attested" => Ok(Self::Attested),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-process" => Ok(Self::InProcess),
            "req-revalid" => Ok(Self::ReqRevalid),
            "reval-fail" => Ok(Self::RevalFail),
            "val-fail" => Ok(Self::ValFail),
            "validated" => Ok(Self::Validated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Status {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attested => "attested",
            Self::EnteredInError => "entered-in-error",
            Self::InProcess => "in-process",
            Self::ReqRevalid => "req-revalid",
            Self::RevalFail => "reval-fail",
            Self::ValFail => "val-fail",
            Self::Validated => "validated",
        }
    }
}
impl ::std::fmt::Display for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Attested => "Attested",
            Self::EnteredInError => "Entered in Error",
            Self::InProcess => "In process",
            Self::ReqRevalid => "Requires revalidation",
            Self::RevalFail => "Re-Validation failed",
            Self::ValFail => "Validation failed",
            Self::Validated => "Validated",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for Status {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Status {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<Status> for Coding {
    fn from(code: Status) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<Status> for CodeableConcept {
    fn from(code: Status) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StrandType](http://hl7.org/fhir/ValueSet/strand-type)**. Type for strand.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StrandType {
    /** **crick**

Crick strand of starting sequence. Crick strand of starting sequence. */
    Crick,
    /** **watson**

Watson strand of starting sequence. Watson strand of starting sequence. */
    Watson,
}
impl ::core::str::FromStr for StrandType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "crick" => Ok(Self::Crick),
            "watson" => Ok(Self::Watson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StrandType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Crick => "crick",
            Self::Watson => "watson",
        }
    }
}
impl ::std::fmt::Display for StrandType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Crick => "Crick strand of starting sequence",
            Self::Watson => "Watson strand of starting sequence",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StrandType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StrandType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StrandType> for Coding {
    fn from(code: StrandType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/strand-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StrandType> for CodeableConcept {
    fn from(code: StrandType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StructureDefinitionKind](http://hl7.org/fhir/ValueSet/structure-definition-kind)**. Defines the type of structure that a definition is describing.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureDefinitionKind {
    /** **complex-type**

Complex Data Type. A  complex structure that defines a set of data elements that is suitable for use in 'resources'. The base specification defines a number of complex types, and other specifications can define additional types. These structures do not have a maintained identity. */
    ComplexType,
    /** **logical**

Logical. A pattern or a template that is not intended to be a real resource or complex type. */
    Logical,
    /** **primitive-type**

Primitive Data Type. A primitive type that has a value and an extension. These can be used throughout complex datatype, Resource and extension definitions. Only the base specification can define primitive types. */
    PrimitiveType,
    /** **resource**

Resource. A 'resource' - a directed acyclic graph of elements that aggregrates other types into an identifiable entity. The base FHIR resources are defined by the FHIR specification itself but other 'resources' can be defined in additional specifications (though these will not be recognized as 'resources' by the FHIR specification; i.e. they do not get end-points etc., or act as the targets of references in FHIR defined resources - though other specifications can treat them this way). */
    Resource,
}
impl ::core::str::FromStr for StructureDefinitionKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complex-type" => Ok(Self::ComplexType),
            "logical" => Ok(Self::Logical),
            "primitive-type" => Ok(Self::PrimitiveType),
            "resource" => Ok(Self::Resource),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureDefinitionKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::ComplexType => "complex-type",
            Self::Logical => "logical",
            Self::PrimitiveType => "primitive-type",
            Self::Resource => "resource",
        }
    }
}
impl ::std::fmt::Display for StructureDefinitionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ComplexType => "Complex Data Type",
            Self::Logical => "Logical",
            Self::PrimitiveType => "Primitive Data Type",
            Self::Resource => "Resource",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StructureDefinitionKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureDefinitionKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureDefinitionKind> for Coding {
    fn from(code: StructureDefinitionKind) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/structure-definition-kind".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StructureDefinitionKind> for CodeableConcept {
    fn from(code: StructureDefinitionKind) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StructureMapGroupTypeMode](http://hl7.org/fhir/ValueSet/map-group-type-mode)**. If this is the default rule set to apply for the source type, or this combination of types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapGroupTypeMode {
    /** **type-and-types**

Default for type + combination. This group is a default mapping group for the specified types. */
    TypeAndTypes,
    /** **types**

Default for Type Combination. This group is a default mapping group for the specified types and for the primary source type. */
    Types,
}
impl ::core::str::FromStr for StructureMapGroupTypeMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "type-and-types" => Ok(Self::TypeAndTypes),
            "types" => Ok(Self::Types),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapGroupTypeMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::TypeAndTypes => "type-and-types",
            Self::Types => "types",
        }
    }
}
impl ::std::fmt::Display for StructureMapGroupTypeMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::TypeAndTypes => "Default for type + combination",
            Self::Types => "Default for Type Combination",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StructureMapGroupTypeMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapGroupTypeMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapGroupTypeMode> for Coding {
    fn from(code: StructureMapGroupTypeMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/map-group-type-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StructureMapGroupTypeMode> for CodeableConcept {
    fn from(code: StructureMapGroupTypeMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StructureMapInputMode](http://hl7.org/fhir/ValueSet/map-input-mode)**. Mode for this instance of data.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapInputMode {
    /** **source**

Source Instance. Names an input instance used a source for mapping. */
    Source,
    /** **target**

Target Instance. Names an instance that is being populated. */
    Target,
}
impl ::core::str::FromStr for StructureMapInputMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "source" => Ok(Self::Source),
            "target" => Ok(Self::Target),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapInputMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Source => "source",
            Self::Target => "target",
        }
    }
}
impl ::std::fmt::Display for StructureMapInputMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Source => "Source Instance",
            Self::Target => "Target Instance",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StructureMapInputMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapInputMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapInputMode> for Coding {
    fn from(code: StructureMapInputMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/map-input-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StructureMapInputMode> for CodeableConcept {
    fn from(code: StructureMapInputMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StructureMapModelMode](http://hl7.org/fhir/ValueSet/map-model-mode)**. How the referenced structure is used in this mapping.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapModelMode {
    /** **produced**

Produced Structure Definition. This structure describes an instance that the mapping engine may ask to create that is used a target of data. */
    Produced,
    /** **queried**

Queried Structure Definition. This structure describes an instance that the mapping engine may ask for that is used a source of data. */
    Queried,
    /** **source**

Source Structure Definition. This structure describes an instance passed to the mapping engine that is used a source of data. */
    Source,
    /** **target**

Target Structure Definition. This structure describes an instance passed to the mapping engine that is used a target of data. */
    Target,
}
impl ::core::str::FromStr for StructureMapModelMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "produced" => Ok(Self::Produced),
            "queried" => Ok(Self::Queried),
            "source" => Ok(Self::Source),
            "target" => Ok(Self::Target),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapModelMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Produced => "produced",
            Self::Queried => "queried",
            Self::Source => "source",
            Self::Target => "target",
        }
    }
}
impl ::std::fmt::Display for StructureMapModelMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Produced => "Produced Structure Definition",
            Self::Queried => "Queried Structure Definition",
            Self::Source => "Source Structure Definition",
            Self::Target => "Target Structure Definition",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StructureMapModelMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapModelMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapModelMode> for Coding {
    fn from(code: StructureMapModelMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/map-model-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StructureMapModelMode> for CodeableConcept {
    fn from(code: StructureMapModelMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StructureMapSourceListMode](http://hl7.org/fhir/ValueSet/map-source-list-mode)**. If field is a list, how to manage the source.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapSourceListMode {
    /** **first**

First. Only process this rule for the first in the list. */
    First,
    /** **last**

Last. Only process this rule for the last in the list. */
    Last,
    /** **not_first**

All but the first. Process this rule for all but the first. */
    NotFirst,
    /** **not_last**

All but the last. Process this rule for all but the last. */
    NotLast,
    /** **only_one**

Enforce only one. Only process this rule is there is only item. */
    OnlyOne,
}
impl ::core::str::FromStr for StructureMapSourceListMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "first" => Ok(Self::First),
            "last" => Ok(Self::Last),
            "not_first" => Ok(Self::NotFirst),
            "not_last" => Ok(Self::NotLast),
            "only_one" => Ok(Self::OnlyOne),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapSourceListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::First => "first",
            Self::Last => "last",
            Self::NotFirst => "not_first",
            Self::NotLast => "not_last",
            Self::OnlyOne => "only_one",
        }
    }
}
impl ::std::fmt::Display for StructureMapSourceListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::First => "First",
            Self::Last => "Last",
            Self::NotFirst => "All but the first",
            Self::NotLast => "All but the last",
            Self::OnlyOne => "Enforce only one",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StructureMapSourceListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapSourceListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapSourceListMode> for Coding {
    fn from(code: StructureMapSourceListMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/map-source-list-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StructureMapSourceListMode> for CodeableConcept {
    fn from(code: StructureMapSourceListMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StructureMapTargetListMode](http://hl7.org/fhir/ValueSet/map-target-list-mode)**. If field is a list, how to manage the production.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapTargetListMode {
    /** **first**

First. when the target list is being assembled, the items for this rule go first. If more than one rule defines a first item (for a given instance of mapping) then this is an error. */
    First,
    /** **last**

Last. when the target list is being assembled, the items for this rule go last. If more than one rule defines a last item (for a given instance of mapping) then this is an error. */
    Last,
    /** **share**

Share. the target instance is shared with the target instances generated by another rule (up to the first common n items, then create new ones). */
    Share,
    /** **single**

single. the target instance is shared with a number of target instances generated by another rule (up to the first common n items, then create new ones). */
    Single,
}
impl ::core::str::FromStr for StructureMapTargetListMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "first" => Ok(Self::First),
            "last" => Ok(Self::Last),
            "share" => Ok(Self::Share),
            "single" => Ok(Self::Single),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapTargetListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::First => "first",
            Self::Last => "last",
            Self::Share => "share",
            Self::Single => "single",
        }
    }
}
impl ::std::fmt::Display for StructureMapTargetListMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::First => "First",
            Self::Last => "Last",
            Self::Share => "Share",
            Self::Single => "single",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StructureMapTargetListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapTargetListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapTargetListMode> for Coding {
    fn from(code: StructureMapTargetListMode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/map-target-list-mode".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StructureMapTargetListMode> for CodeableConcept {
    fn from(code: StructureMapTargetListMode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StructureMapTransform](http://hl7.org/fhir/ValueSet/map-transform)**. How data is copied/created.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapTransform {
    /** **append**

append. append(source...) - source is element or string. */
    Append,
    /** **c**

c. Create a Coding. Parameters = (system. Code[, display]). */
    C,
    /** **cast**

cast. cast(source, type?) - cast (convert) source from one type to another. Target type can be left as implicit if there is one and only one target type known. The default namespace for the type is 'FHIR' (see [FHIRPath type specifiers](http://hl7.org/fhirpath/N1/#is-type-specifier)) */
    Cast,
    /** **cc**

cc. Create a CodeableConcept. Parameters = (text) or (system. Code[, display]). */
    Cc,
    /** **copy**

copy. copy(source). */
    Copy,
    /** **cp**

cp. Create a contact details. Parameters = (value) or (system, value). If no system is provided, the system should be inferred from the content of the value. */
    Cp,
    /** **create**

create. create(type : string) - type is passed through to the application on the standard API, and must be known by it. */
    Create,
    /** **dateOp**

dateOp. Perform a date operation. *Parameters to be documented*. */
    DateOp,
    /** **escape**

escape. escape(source, fmt1, fmt2) - change source from one kind of escaping to another (plain, java, xml, json). note that this is for when the string itself is escaped. */
    Escape,
    /** **evaluate**

evaluate. Execute the supplied FHIRPath expression and use the value returned by that. */
    Evaluate,
    /** **id**

id. Create an identifier. Parameters = (system, value[, type]) where type is a code from the identifier type value set. */
    Id,
    /** **pointer**

pointer. Return the appropriate string to put in a reference that refers to the resource provided as a parameter. */
    Pointer,
    /** **qty**

qty. Create a quantity. Parameters = (text) or (value, unit, [system, code]) where text is the natural representation e.g. [comparator]value[space]unit. */
    Qty,
    /** **reference**

reference. reference(source : object) - return a string that references the provided tree properly. */
    Reference,
    /** **translate**

translate. translate(source, uri_of_map) - use the translate operation. */
    Translate,
    /** **truncate**

truncate. truncate(source, length) - source must be stringy type. */
    Truncate,
    /** **uuid**

uuid. Generate a random UUID (in lowercase). No Parameters. */
    Uuid,
}
impl ::core::str::FromStr for StructureMapTransform {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "append" => Ok(Self::Append),
            "c" => Ok(Self::C),
            "cast" => Ok(Self::Cast),
            "cc" => Ok(Self::Cc),
            "copy" => Ok(Self::Copy),
            "cp" => Ok(Self::Cp),
            "create" => Ok(Self::Create),
            "dateOp" => Ok(Self::DateOp),
            "escape" => Ok(Self::Escape),
            "evaluate" => Ok(Self::Evaluate),
            "id" => Ok(Self::Id),
            "pointer" => Ok(Self::Pointer),
            "qty" => Ok(Self::Qty),
            "reference" => Ok(Self::Reference),
            "translate" => Ok(Self::Translate),
            "truncate" => Ok(Self::Truncate),
            "uuid" => Ok(Self::Uuid),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapTransform {
    fn as_ref(&self) -> &str {
        match self {
            Self::Append => "append",
            Self::C => "c",
            Self::Cast => "cast",
            Self::Cc => "cc",
            Self::Copy => "copy",
            Self::Cp => "cp",
            Self::Create => "create",
            Self::DateOp => "dateOp",
            Self::Escape => "escape",
            Self::Evaluate => "evaluate",
            Self::Id => "id",
            Self::Pointer => "pointer",
            Self::Qty => "qty",
            Self::Reference => "reference",
            Self::Translate => "translate",
            Self::Truncate => "truncate",
            Self::Uuid => "uuid",
        }
    }
}
impl ::std::fmt::Display for StructureMapTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Append => "append",
            Self::C => "c",
            Self::Cast => "cast",
            Self::Cc => "cc",
            Self::Copy => "copy",
            Self::Cp => "cp",
            Self::Create => "create",
            Self::DateOp => "dateOp",
            Self::Escape => "escape",
            Self::Evaluate => "evaluate",
            Self::Id => "id",
            Self::Pointer => "pointer",
            Self::Qty => "qty",
            Self::Reference => "reference",
            Self::Translate => "translate",
            Self::Truncate => "truncate",
            Self::Uuid => "uuid",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StructureMapTransform {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapTransform {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StructureMapTransform> for Coding {
    fn from(code: StructureMapTransform) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/map-transform".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StructureMapTransform> for CodeableConcept {
    fn from(code: StructureMapTransform) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[StudyDesign](http://hl7.org/fhir/ValueSet/study-design)**. This is a set of terms for study design characteristics.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StudyDesign {
    /** **SEVCO:01001**

Interventional research. A study design in which an independent variable (an exposure or intervention) is prospectively assigned or modified by the investigator to evaluate a response in the dependent variable (an effect or outcome). */
    Sevco01001,
    /** **SEVCO:01002**

Observational research. A study design in which the independent variables (exposures or interventions) are not prospectively assigned or modified by the investigator.  */
    Sevco01002,
    /** **SEVCO:01003**

randomized assignment. An interventional study design in which an independent variable (an exposure or intervention) is prospectively assigned or modified by random chance to separate groups. */
    Sevco01003,
    /** **SEVCO:01004**

Quasi-Randomized assignment. An interventional study design with a method of allocation that is not limited to random chance but is intended to produce similar baseline groups for experimentation. */
    Sevco01004,
    /** **SEVCO:01005**

Non-randomized assignment. An interventional study design in which an independent variable (an exposure or intervention) is prospectively assigned or modified by methods other than random chance to separate groups. */
    Sevco01005,
    /** **SEVCO:01006**

simple randomization. A randomized assignment in which each participant has the same prespecified likelihood of being assigned to a group as all other participants, independent of the assignment of any other participant. */
    Sevco01006,
    /** **SEVCO:01007**

stratified randomization. A randomized assignment in which participants are stratified into groups based on prognostic variables and then randomized into balanced treatment groups */
    Sevco01007,
    /** **SEVCO:01008**

block randomization. A randomized assignment in which a pre-specified number of subjects is assigned to a block containing the same pre-specified ratio of group assignments in random order. */
    Sevco01008,
    /** **SEVCO:01009**

adaptive randomization. A randomized assignment in which a participant’s group assignment probability is adjusted based on any factor such that the likelihood of assignment is not the same for all participants. */
    Sevco01009,
    /** **SEVCO:01010**

Comparative study design. A study design in which two or more groups are compared. */
    Sevco01010,
    /** **SEVCO:01011**

Parallel cohort design. A comparative study design in which the groups are compared concurrently and participants are expected to remain in the groups being compared for the entire duration of participation in the study. */
    Sevco01011,
    /** **SEVCO:01012**

Crossover cohort design. A comparative study design in which participants receive two or more alternative exposures during separate periods of time. */
    Sevco01012,
    /** **SEVCO:01013**

Case control design. A comparative study design in which the groups being compared are defined by outcome presence (case) or absence (control). */
    Sevco01013,
    /** **SEVCO:01014**

Matching for comparison. A comparative study design in which individual participants in different groups being compared are paired or matched into sets based on selected attributes for within-set analysis. */
    Sevco01014,
    /** **SEVCO:01015**

Cluster as unit of allocation. A comparative study design in which participants are allocated to exposures (interventions) by their membership in groups (called clusters) rather than by individualized assignments. */
    Sevco01015,
    /** **SEVCO:01016**

Uncontrolled cohort design. A non-comparative study design in which two or more participants are evaluated in a single group (or cohort). */
    Sevco01016,
    /** **SEVCO:01017**

Case report. A non-comparative study design in which a single participant is evaluated. */
    Sevco01017,
    /** **SEVCO:01018**

Time series design. A longitudinal data collection which includes a set of time-ordered observations. */
    Sevco01018,
    /** **SEVCO:01019**

Before and after comparison. A time series design which includes comparisons of observations before and after an event or exposure. */
    Sevco01019,
    /** **SEVCO:01020**

Family study design. A matched study design in which related or non-related family members are compared. */
    Sevco01020,
    /** **SEVCO:01021**

Twin study design. A family study design in which twin siblings are compared. */
    Sevco01021,
    /** **SEVCO:01022**

Population-based design. A study design in which the unit of observation is a population or community.  */
    Sevco01022,
    /** **SEVCO:01023**

Non-comparative study design. A study design with no comparisons between groups with different exposures and no comparisons between groups with different outcomes. */
    Sevco01023,
    /** **SEVCO:01024**

Controlled crossover cohort design. A crossover cohort design in which two or more cohorts have different orders of exposures. */
    Sevco01024,
    /** **SEVCO:01025**

Single-arm crossover design. A crossover cohort design in which all participants are in a single cohort with the same order of exposures. */
    Sevco01025,
    /** **SEVCO:01026**

Real world data collection. A study design process in which the study data are obtained from a source of data collected during a routine process in the natural environment rather than using a process designed or controlled by the researcher. */
    Sevco01026,
    /** **SEVCO:01027**

Cross sectional data collection . A study design process in which data is collected at a single point in time. */
    Sevco01027,
    /** **SEVCO:01028**

Longitudinal data collection. A study design process in which data is collected at two or more points in time. */
    Sevco01028,
    /** **SEVCO:01029**

Clinical trial. Interventional research in which one or more healthcare-related actions (i.e., a diagnostic, prognostic, therapeutic, preventive or screening method or intervention) is evaluated for effects on health-related biomedical or behavioral processes and/or outcomes. */
    Sevco01029,
    /** **SEVCO:01030**

Phase 1 trial. A clinical trial to gather initial evidence in humans to support further investigation of an intervention. */
    Sevco01030,
    /** **SEVCO:01031**

Exploratory investigational new drug study. A clinical trial that is conducted early in phase 1, involves very limited human exposure, and has no therapeutic or diagnostic intent (e.g., screening studies, microdose studies).  */
    Sevco01031,
    /** **SEVCO:01032**

Phase 1/Phase 2 trial.  A clinical trial with a component meeting the definition of phase 1 trial and a component meeting the definition of phase 2 trial. */
    Sevco01032,
    /** **SEVCO:01033**

Phase 2 trial. A clinical trial to gather evidence of effectiveness and safety for an intervention in patients with the disease or condition under study, but not intended to provide an adequate basis for regulatory approval for clinical use. */
    Sevco01033,
    /** **SEVCO:01034**

Phase 2/Phase 3 trial. A clinical trial with a component meeting the definition of phase 2 trial and a component meeting the definition of phase 3 trial. */
    Sevco01034,
    /** **SEVCO:01035**

Phase 3 Trial. A clinical trial to gather the evidence of effectiveness and safety of an intervention, intended to provide an adequate basis for regulatory approval for clinical use. */
    Sevco01035,
    /** **SEVCO:01036**

Post-marketing study. A clinical trial to gather additional evidence of effectiveness and safety of an intervention for an already approved clinical use. */
    Sevco01036,
    /** **SEVCO:01037**

Post-Marketing Surveillance study. An observational study to identify adverse events related to the use of an approved clinical intervention. */
    Sevco01037,
    /** **SEVCO:01038**

Expanded Access study. A clinical trial that provides a means for obtaining an experimental drug or device for patients who are not adequately treated by existing therapy, who do not meet the eligibility criteria for enrollment, or who are otherwise unable to participate in another clinical study.  */
    Sevco01038,
    /** **SEVCO:01039**

Real world data collection from healthcare records. Real world data collection from data obtained routinely for a purpose of recording healthcare delivery in a record controlled by a healthcare professional. */
    Sevco01039,
    /** **SEVCO:01040**

Real world data collection from healthcare financing records. Real world data collection from data obtained routinely for a purpose of recording healthcare financing. */
    Sevco01040,
    /** **SEVCO:01041**

Pragmatic clinical trial. A clinical trial conducted under conditions of routine clinical practice. */
    Sevco01041,
    /** **SEVCO:01042**

Secondary data collection from a registry. A study design process in which the data are collected from a system organized to obtain and maintain uniform data for discovery and analysis, and this system is organized prior to the current study. */
    Sevco01042,
    /** **SEVCO:01043**

Multicentric. A study design feature in which two or more institutions are responsible for the conduct of the study. */
    Sevco01043,
    /** **SEVCO:01044**

Ecological design. A study design in which the unit of observation is a population or community defined by social relationships or physical surroundings.  */
    Sevco01044,
    /** **SEVCO:01045**

Primary data collection. A study design process in which the data are recorded and collected during the study for the purpose of the same study. */
    Sevco01045,
    /** **SEVCO:01046**

Real world data collection from monitoring procedures. Real world data collection from data obtained routinely for a purpose of repeated testing. */
    Sevco01046,
    /** **SEVCO:01048**

Real world data collection from testing procedures. Real world data collection from data obtained routinely for a purpose of testing, such as diagnostic testing or screening examination. */
    Sevco01048,
    /** **SEVCO:01049**

Secondary data collection from prior research. A study design process in which the data are collected from data obtained during a different study than the current study. */
    Sevco01049,
    /** **SEVCO:01050**

Real world data collection from personal health records. Real world data collection from data obtained routinely for a purpose of recording data related to personal health in a record controlled by the person, guardian, or caretaker. */
    Sevco01050,
    /** **SEVCO:01051**

Multisite data collection. A study design process in which data are collected from two or more geographic locations. */
    Sevco01051,
    /** **SEVCO:01052**

Includes patient-reported outcome. A study design feature in which one or more outcomes are reported directly from the patient without interpretation by a clinician or researcher. */
    Sevco01052,
    /** **SEVCO:01053**

Includes patient-centered outcome. A study design feature in which one or more measures are outcomes that patients directly care about, i.e. outcomes that are directly related to patients' experience of their life. */
    Sevco01053,
    /** **SEVCO:01054**

Includes disease-oriented outcome. A study design feature in which one or more measures are outcomes that relate to a health or illness condition but are not outcomes which patients directly care about. */
    Sevco01054,
    /** **SEVCO:01060**

Blinding of study participants. A study design process in which study participants are not informed of their intervention assignment. */
    Sevco01060,
    /** **SEVCO:01061**

Blinding of intervention providers. A study design process in which the people administering the intervention are not informed of the intervention assignment. */
    Sevco01061,
    /** **SEVCO:01062**

Blinding of outcome assessors. A study design process in which the people determining the outcome are not informed of the intervention assignment. */
    Sevco01062,
    /** **SEVCO:01063**

Blinding of data analysts. A study design process in which the people managing or processing the data and statistical analysis are not informed of the intervention assignment. */
    Sevco01063,
    /** **SEVCO:01064**

Allocation concealment. A study design process in which all parties influencing study enrollment and allocation to study groups are unaware of the group assignment for the study participant at the time of enrollment and allocation. */
    Sevco01064,
    /** **SEVCO:01085**

Includes process measure. A study design feature in which one or more outcomes are actions or behaviors of a healthcare professional or care team. */
    Sevco01085,
    /** **SEVCO:01086**

Quantitative analysis. A study design process in which data are analyzed with mathematical or statistical methods and formulas. */
    Sevco01086,
    /** **SEVCO:01087**

Qualitative analysis. A study design process in which data are analyzed, without primary reliance on mathematical or statistical techniques, by coding and organizing data to provide interpretation or understanding of experiences or hypotheses. */
    Sevco01087,
    /** **SEVCO:01088**

Comparison Goal. A study design feature in which the study intent is to compare two or more interventions or exposures. */
    Sevco01088,
    /** **SEVCO:01089**

Study Goal. A study design feature specifying the intent of the study. */
    Sevco01089,
    /** **SEVCO:01090**

Comparative Efficacy Goal. A study design feature in which the study intent is to compare two or more interventions with respect to effectiveness in ideal conditions. */
    Sevco01090,
    /** **SEVCO:01091**

Comparative Effectiveness Goal. A study design feature in which the study intent is to compare two or more interventions with respect to benefits and/or harms. */
    Sevco01091,
    /** **SEVCO:01092**

Comparative Safety Goal. A study design feature in which the study intent is to compare two or more interventions with respect to harms. */
    Sevco01092,
    /** **SEVCO:01093**

Equivalence Goal. A study goal with the intent to compare two or more interventions or exposures and determine that any difference in effects is within a prespecified range representing absence of a meaningful difference. */
    Sevco01093,
    /** **SEVCO:01094**

Non-inferiority Goal. A study goal with the intent to compare two or more interventions or exposures and determine that any difference in effects is below a prespecified value representing a threshold between a meaningful difference and absence of a meaningful difference. */
    Sevco01094,
    /** **SEVCO:01095**

Superiority Goal. A study goal with the intent to compare two or more interventions or exposures and detect a difference in effects. */
    Sevco01095,
    /** **SEVCO:01096**

Evaluation Goal. A study goal to assess the efficiency, effectiveness, and impact of a given program, process, person or piece of equipment. */
    Sevco01096,
    /** **SEVCO:01097**

Derivation Goal. A study goal with the intent to generate a predictive algorithm. */
    Sevco01097,
    /** **SEVCO:01098**

Validation Goal. A study goal with the intent to determine the reliability and/or performance of a procedure for a specific predictive, classification, measurement, or communication purpose. */
    Sevco01098,
}
impl ::core::str::FromStr for StudyDesign {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "SEVCO:01001" => Ok(Self::Sevco01001),
            "SEVCO:01002" => Ok(Self::Sevco01002),
            "SEVCO:01003" => Ok(Self::Sevco01003),
            "SEVCO:01004" => Ok(Self::Sevco01004),
            "SEVCO:01005" => Ok(Self::Sevco01005),
            "SEVCO:01006" => Ok(Self::Sevco01006),
            "SEVCO:01007" => Ok(Self::Sevco01007),
            "SEVCO:01008" => Ok(Self::Sevco01008),
            "SEVCO:01009" => Ok(Self::Sevco01009),
            "SEVCO:01010" => Ok(Self::Sevco01010),
            "SEVCO:01011" => Ok(Self::Sevco01011),
            "SEVCO:01012" => Ok(Self::Sevco01012),
            "SEVCO:01013" => Ok(Self::Sevco01013),
            "SEVCO:01014" => Ok(Self::Sevco01014),
            "SEVCO:01015" => Ok(Self::Sevco01015),
            "SEVCO:01016" => Ok(Self::Sevco01016),
            "SEVCO:01017" => Ok(Self::Sevco01017),
            "SEVCO:01018" => Ok(Self::Sevco01018),
            "SEVCO:01019" => Ok(Self::Sevco01019),
            "SEVCO:01020" => Ok(Self::Sevco01020),
            "SEVCO:01021" => Ok(Self::Sevco01021),
            "SEVCO:01022" => Ok(Self::Sevco01022),
            "SEVCO:01023" => Ok(Self::Sevco01023),
            "SEVCO:01024" => Ok(Self::Sevco01024),
            "SEVCO:01025" => Ok(Self::Sevco01025),
            "SEVCO:01026" => Ok(Self::Sevco01026),
            "SEVCO:01027" => Ok(Self::Sevco01027),
            "SEVCO:01028" => Ok(Self::Sevco01028),
            "SEVCO:01029" => Ok(Self::Sevco01029),
            "SEVCO:01030" => Ok(Self::Sevco01030),
            "SEVCO:01031" => Ok(Self::Sevco01031),
            "SEVCO:01032" => Ok(Self::Sevco01032),
            "SEVCO:01033" => Ok(Self::Sevco01033),
            "SEVCO:01034" => Ok(Self::Sevco01034),
            "SEVCO:01035" => Ok(Self::Sevco01035),
            "SEVCO:01036" => Ok(Self::Sevco01036),
            "SEVCO:01037" => Ok(Self::Sevco01037),
            "SEVCO:01038" => Ok(Self::Sevco01038),
            "SEVCO:01039" => Ok(Self::Sevco01039),
            "SEVCO:01040" => Ok(Self::Sevco01040),
            "SEVCO:01041" => Ok(Self::Sevco01041),
            "SEVCO:01042" => Ok(Self::Sevco01042),
            "SEVCO:01043" => Ok(Self::Sevco01043),
            "SEVCO:01044" => Ok(Self::Sevco01044),
            "SEVCO:01045" => Ok(Self::Sevco01045),
            "SEVCO:01046" => Ok(Self::Sevco01046),
            "SEVCO:01048" => Ok(Self::Sevco01048),
            "SEVCO:01049" => Ok(Self::Sevco01049),
            "SEVCO:01050" => Ok(Self::Sevco01050),
            "SEVCO:01051" => Ok(Self::Sevco01051),
            "SEVCO:01052" => Ok(Self::Sevco01052),
            "SEVCO:01053" => Ok(Self::Sevco01053),
            "SEVCO:01054" => Ok(Self::Sevco01054),
            "SEVCO:01060" => Ok(Self::Sevco01060),
            "SEVCO:01061" => Ok(Self::Sevco01061),
            "SEVCO:01062" => Ok(Self::Sevco01062),
            "SEVCO:01063" => Ok(Self::Sevco01063),
            "SEVCO:01064" => Ok(Self::Sevco01064),
            "SEVCO:01085" => Ok(Self::Sevco01085),
            "SEVCO:01086" => Ok(Self::Sevco01086),
            "SEVCO:01087" => Ok(Self::Sevco01087),
            "SEVCO:01088" => Ok(Self::Sevco01088),
            "SEVCO:01089" => Ok(Self::Sevco01089),
            "SEVCO:01090" => Ok(Self::Sevco01090),
            "SEVCO:01091" => Ok(Self::Sevco01091),
            "SEVCO:01092" => Ok(Self::Sevco01092),
            "SEVCO:01093" => Ok(Self::Sevco01093),
            "SEVCO:01094" => Ok(Self::Sevco01094),
            "SEVCO:01095" => Ok(Self::Sevco01095),
            "SEVCO:01096" => Ok(Self::Sevco01096),
            "SEVCO:01097" => Ok(Self::Sevco01097),
            "SEVCO:01098" => Ok(Self::Sevco01098),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StudyDesign {
    fn as_ref(&self) -> &str {
        match self {
            Self::Sevco01001 => "SEVCO:01001",
            Self::Sevco01002 => "SEVCO:01002",
            Self::Sevco01003 => "SEVCO:01003",
            Self::Sevco01004 => "SEVCO:01004",
            Self::Sevco01005 => "SEVCO:01005",
            Self::Sevco01006 => "SEVCO:01006",
            Self::Sevco01007 => "SEVCO:01007",
            Self::Sevco01008 => "SEVCO:01008",
            Self::Sevco01009 => "SEVCO:01009",
            Self::Sevco01010 => "SEVCO:01010",
            Self::Sevco01011 => "SEVCO:01011",
            Self::Sevco01012 => "SEVCO:01012",
            Self::Sevco01013 => "SEVCO:01013",
            Self::Sevco01014 => "SEVCO:01014",
            Self::Sevco01015 => "SEVCO:01015",
            Self::Sevco01016 => "SEVCO:01016",
            Self::Sevco01017 => "SEVCO:01017",
            Self::Sevco01018 => "SEVCO:01018",
            Self::Sevco01019 => "SEVCO:01019",
            Self::Sevco01020 => "SEVCO:01020",
            Self::Sevco01021 => "SEVCO:01021",
            Self::Sevco01022 => "SEVCO:01022",
            Self::Sevco01023 => "SEVCO:01023",
            Self::Sevco01024 => "SEVCO:01024",
            Self::Sevco01025 => "SEVCO:01025",
            Self::Sevco01026 => "SEVCO:01026",
            Self::Sevco01027 => "SEVCO:01027",
            Self::Sevco01028 => "SEVCO:01028",
            Self::Sevco01029 => "SEVCO:01029",
            Self::Sevco01030 => "SEVCO:01030",
            Self::Sevco01031 => "SEVCO:01031",
            Self::Sevco01032 => "SEVCO:01032",
            Self::Sevco01033 => "SEVCO:01033",
            Self::Sevco01034 => "SEVCO:01034",
            Self::Sevco01035 => "SEVCO:01035",
            Self::Sevco01036 => "SEVCO:01036",
            Self::Sevco01037 => "SEVCO:01037",
            Self::Sevco01038 => "SEVCO:01038",
            Self::Sevco01039 => "SEVCO:01039",
            Self::Sevco01040 => "SEVCO:01040",
            Self::Sevco01041 => "SEVCO:01041",
            Self::Sevco01042 => "SEVCO:01042",
            Self::Sevco01043 => "SEVCO:01043",
            Self::Sevco01044 => "SEVCO:01044",
            Self::Sevco01045 => "SEVCO:01045",
            Self::Sevco01046 => "SEVCO:01046",
            Self::Sevco01048 => "SEVCO:01048",
            Self::Sevco01049 => "SEVCO:01049",
            Self::Sevco01050 => "SEVCO:01050",
            Self::Sevco01051 => "SEVCO:01051",
            Self::Sevco01052 => "SEVCO:01052",
            Self::Sevco01053 => "SEVCO:01053",
            Self::Sevco01054 => "SEVCO:01054",
            Self::Sevco01060 => "SEVCO:01060",
            Self::Sevco01061 => "SEVCO:01061",
            Self::Sevco01062 => "SEVCO:01062",
            Self::Sevco01063 => "SEVCO:01063",
            Self::Sevco01064 => "SEVCO:01064",
            Self::Sevco01085 => "SEVCO:01085",
            Self::Sevco01086 => "SEVCO:01086",
            Self::Sevco01087 => "SEVCO:01087",
            Self::Sevco01088 => "SEVCO:01088",
            Self::Sevco01089 => "SEVCO:01089",
            Self::Sevco01090 => "SEVCO:01090",
            Self::Sevco01091 => "SEVCO:01091",
            Self::Sevco01092 => "SEVCO:01092",
            Self::Sevco01093 => "SEVCO:01093",
            Self::Sevco01094 => "SEVCO:01094",
            Self::Sevco01095 => "SEVCO:01095",
            Self::Sevco01096 => "SEVCO:01096",
            Self::Sevco01097 => "SEVCO:01097",
            Self::Sevco01098 => "SEVCO:01098",
        }
    }
}
impl ::std::fmt::Display for StudyDesign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Sevco01001 => "Interventional research",
            Self::Sevco01002 => "Observational research",
            Self::Sevco01003 => "randomized assignment",
            Self::Sevco01004 => "Quasi-Randomized assignment",
            Self::Sevco01005 => "Non-randomized assignment",
            Self::Sevco01006 => "simple randomization",
            Self::Sevco01007 => "stratified randomization",
            Self::Sevco01008 => "block randomization",
            Self::Sevco01009 => "adaptive randomization",
            Self::Sevco01010 => "Comparative study design",
            Self::Sevco01011 => "Parallel cohort design",
            Self::Sevco01012 => "Crossover cohort design",
            Self::Sevco01013 => "Case control design",
            Self::Sevco01014 => "Matching for comparison",
            Self::Sevco01015 => "Cluster as unit of allocation",
            Self::Sevco01016 => "Uncontrolled cohort design",
            Self::Sevco01017 => "Case report",
            Self::Sevco01018 => "Time series design",
            Self::Sevco01019 => "Before and after comparison",
            Self::Sevco01020 => "Family study design",
            Self::Sevco01021 => "Twin study design",
            Self::Sevco01022 => "Population-based design",
            Self::Sevco01023 => "Non-comparative study design",
            Self::Sevco01024 => "Controlled crossover cohort design",
            Self::Sevco01025 => "Single-arm crossover design",
            Self::Sevco01026 => "Real world data collection",
            Self::Sevco01027 => "Cross sectional data collection ",
            Self::Sevco01028 => "Longitudinal data collection",
            Self::Sevco01029 => "Clinical trial",
            Self::Sevco01030 => "Phase 1 trial",
            Self::Sevco01031 => "Exploratory investigational new drug study",
            Self::Sevco01032 => "Phase 1/Phase 2 trial",
            Self::Sevco01033 => "Phase 2 trial",
            Self::Sevco01034 => "Phase 2/Phase 3 trial",
            Self::Sevco01035 => "Phase 3 Trial",
            Self::Sevco01036 => "Post-marketing study",
            Self::Sevco01037 => "Post-Marketing Surveillance study",
            Self::Sevco01038 => "Expanded Access study",
            Self::Sevco01039 => "Real world data collection from healthcare records",
            Self::Sevco01040 => {
                "Real world data collection from healthcare financing records"
            }
            Self::Sevco01041 => "Pragmatic clinical trial",
            Self::Sevco01042 => "Secondary data collection from a registry",
            Self::Sevco01043 => "Multicentric",
            Self::Sevco01044 => "Ecological design",
            Self::Sevco01045 => "Primary data collection",
            Self::Sevco01046 => "Real world data collection from monitoring procedures",
            Self::Sevco01048 => "Real world data collection from testing procedures",
            Self::Sevco01049 => "Secondary data collection from prior research",
            Self::Sevco01050 => "Real world data collection from personal health records",
            Self::Sevco01051 => "Multisite data collection",
            Self::Sevco01052 => "Includes patient-reported outcome",
            Self::Sevco01053 => "Includes patient-centered outcome",
            Self::Sevco01054 => "Includes disease-oriented outcome",
            Self::Sevco01060 => "Blinding of study participants",
            Self::Sevco01061 => "Blinding of intervention providers",
            Self::Sevco01062 => "Blinding of outcome assessors",
            Self::Sevco01063 => "Blinding of data analysts",
            Self::Sevco01064 => "Allocation concealment",
            Self::Sevco01085 => "Includes process measure",
            Self::Sevco01086 => "Quantitative analysis",
            Self::Sevco01087 => "Qualitative analysis",
            Self::Sevco01088 => "Comparison Goal",
            Self::Sevco01089 => "Study Goal",
            Self::Sevco01090 => "Comparative Efficacy Goal",
            Self::Sevco01091 => "Comparative Effectiveness Goal",
            Self::Sevco01092 => "Comparative Safety Goal",
            Self::Sevco01093 => "Equivalence Goal",
            Self::Sevco01094 => "Non-inferiority Goal",
            Self::Sevco01095 => "Superiority Goal",
            Self::Sevco01096 => "Evaluation Goal",
            Self::Sevco01097 => "Derivation Goal",
            Self::Sevco01098 => "Validation Goal",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for StudyDesign {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StudyDesign {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<StudyDesign> for Coding {
    fn from(code: StudyDesign) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/study-design".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<StudyDesign> for CodeableConcept {
    fn from(code: StudyDesign) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubmitDataUpdateType](http://hl7.org/fhir/ValueSet/submit-data-update-type)**. Concepts for how a measure report consumer and receiver coordinate data exchange updates. The choices are snapshot or incremental updates\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubmitDataUpdateType {
    /** **incremental**

Incremental. In contrast to the Snapshot Update, the FHIR Parameters resource used in a Submit Data or the Collect Data scenario contains only the new and updated DEQM and QI Core Profiles since the last transaction. If the Consumer supports incremental updates, the contents of the updated payload updates the previous payload data. */
    Incremental,
    /** **snapshot**

Snapshot. In contrast to the Incremental Update, the FHIR Parameters resource used in a Submit Data or the Collect Data scenario contains all the DEQM and QI Core Profiles for each transaction.  If the Consumer supports snapshot updates, the contents of the updated payload entirely replaces the previous payload */
    Snapshot,
}
impl ::core::str::FromStr for SubmitDataUpdateType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "incremental" => Ok(Self::Incremental),
            "snapshot" => Ok(Self::Snapshot),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubmitDataUpdateType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Incremental => "incremental",
            Self::Snapshot => "snapshot",
        }
    }
}
impl ::std::fmt::Display for SubmitDataUpdateType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Incremental => "Incremental",
            Self::Snapshot => "Snapshot",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubmitDataUpdateType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubmitDataUpdateType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubmitDataUpdateType> for Coding {
    fn from(code: SubmitDataUpdateType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/submit-data-update-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubmitDataUpdateType> for CodeableConcept {
    fn from(code: SubmitDataUpdateType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubscriptionNotificationType](http://hl7.org/fhir/ValueSet/subscription-notification-type)**. The type of notification represented by the status message.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubscriptionNotificationType {
    /** **event-notification**

Event Notification. The status was generated for an event to the subscriber. */
    EventNotification,
    /** **handshake**

Handshake. The status was generated as part of the setup or verification of a communications channel. */
    Handshake,
    /** **heartbeat**

Heartbeat. The status was generated to perform a heartbeat notification to the subscriber. */
    Heartbeat,
    /** **query-event**

Query Event. The status was generated in response to an event query/request. */
    QueryEvent,
    /** **query-status**

Query Status. The status was generated in response to a status query/request. */
    QueryStatus,
}
impl ::core::str::FromStr for SubscriptionNotificationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "event-notification" => Ok(Self::EventNotification),
            "handshake" => Ok(Self::Handshake),
            "heartbeat" => Ok(Self::Heartbeat),
            "query-event" => Ok(Self::QueryEvent),
            "query-status" => Ok(Self::QueryStatus),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionNotificationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::EventNotification => "event-notification",
            Self::Handshake => "handshake",
            Self::Heartbeat => "heartbeat",
            Self::QueryEvent => "query-event",
            Self::QueryStatus => "query-status",
        }
    }
}
impl ::std::fmt::Display for SubscriptionNotificationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::EventNotification => "Event Notification",
            Self::Handshake => "Handshake",
            Self::Heartbeat => "Heartbeat",
            Self::QueryEvent => "Query Event",
            Self::QueryStatus => "Query Status",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubscriptionNotificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionNotificationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionNotificationType> for Coding {
    fn from(code: SubscriptionNotificationType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/subscription-notification-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubscriptionNotificationType> for CodeableConcept {
    fn from(code: SubscriptionNotificationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubscriptionPayloadContent](http://hl7.org/fhir/ValueSet/subscription-payload-content)**. Codes to represent how much resource content to send in the notification payload.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubscriptionPayloadContent {
    /** **empty**

Empty. No resource content is transacted in the notification payload. */
    Empty,
    /** **full-resource**

Full-resource. The entire resource is transacted in the notification payload. */
    FullResource,
    /** **id-only**

Id-only. Only the resource id is transacted in the notification payload. */
    IdOnly,
}
impl ::core::str::FromStr for SubscriptionPayloadContent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "empty" => Ok(Self::Empty),
            "full-resource" => Ok(Self::FullResource),
            "id-only" => Ok(Self::IdOnly),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionPayloadContent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Empty => "empty",
            Self::FullResource => "full-resource",
            Self::IdOnly => "id-only",
        }
    }
}
impl ::std::fmt::Display for SubscriptionPayloadContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Empty => "Empty",
            Self::FullResource => "Full-resource",
            Self::IdOnly => "Id-only",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubscriptionPayloadContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionPayloadContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionPayloadContent> for Coding {
    fn from(code: SubscriptionPayloadContent) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/subscription-payload-content".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubscriptionPayloadContent> for CodeableConcept {
    fn from(code: SubscriptionPayloadContent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubscriptionStatus](http://hl7.org/fhir/subscription-status)**. This codesystem defines a set of codes that can be used to filter Subscription triggers.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SubscriptionStatus {
    /** **active**

Active. The subscription is active. */
    Active,
    /** **entered-in-error**

Entered in Error. This subscription has been flagged as incorrect. */
    EnteredInError,
    /** **error**

Error. The server has an error executing the notification. */
    Error,
    /** **off**

Off. Too many errors have occurred or the subscription has expired. */
    Off,
    /** **requested**

Requested. The client has requested the subscription, and the server has not yet set it up. */
    Requested,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SubscriptionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "error" => Ok(Self::Error),
            "off" => Ok(Self::Off),
            "requested" => Ok(Self::Requested),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SubscriptionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Error => "error",
            Self::Off => "off",
            Self::Requested => "requested",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for SubscriptionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::EnteredInError => "Entered in Error",
            Self::Error => "Error",
            Self::Off => "Off",
            Self::Requested => "Requested",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubscriptionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubscriptionStatus> for Coding {
    fn from(code: SubscriptionStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/subscription-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubscriptionStatus> for CodeableConcept {
    fn from(code: SubscriptionStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceAmountType](http://hl7.org/fhir/ValueSet/substance-amount-type)**. The type of a numeric quantity measurement.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceAmountType {
    /** **Approximately**

Approximately. */
    Approximately,
    /** **Average**

Average. */
    Average,
    /** **LessThan**

Less Than. */
    LessThan,
    /** **MoreThan**

More Than. */
    MoreThan,
}
impl ::core::str::FromStr for SubstanceAmountType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Approximately" => Ok(Self::Approximately),
            "Average" => Ok(Self::Average),
            "LessThan" => Ok(Self::LessThan),
            "MoreThan" => Ok(Self::MoreThan),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceAmountType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Approximately => "Approximately",
            Self::Average => "Average",
            Self::LessThan => "LessThan",
            Self::MoreThan => "MoreThan",
        }
    }
}
impl ::std::fmt::Display for SubstanceAmountType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Approximately => "Approximately",
            Self::Average => "Average",
            Self::LessThan => "Less Than",
            Self::MoreThan => "More Than",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceAmountType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceAmountType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceAmountType> for Coding {
    fn from(code: SubstanceAmountType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-amount-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceAmountType> for CodeableConcept {
    fn from(code: SubstanceAmountType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceForm](http://hl7.org/fhir/ValueSet/substance-form)**. SubstanceForm\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceForm {
    /** **base**

Base of substance. */
    Base,
    /** **salt**

Salt of substance. */
    Salt,
}
impl ::core::str::FromStr for SubstanceForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "base" => Ok(Self::Base),
            "salt" => Ok(Self::Salt),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::Base => "base",
            Self::Salt => "salt",
        }
    }
}
impl ::std::fmt::Display for SubstanceForm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Base => "Base of substance",
            Self::Salt => "Salt of substance",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceForm> for Coding {
    fn from(code: SubstanceForm) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-form".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceForm> for CodeableConcept {
    fn from(code: SubstanceForm) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceGrade](http://hl7.org/fhir/ValueSet/substance-grade)**. SubstanceGrade\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceGrade {
    /** **BP**

British Pharmacopoeia. */
    Bp,
    /** **CompanyStandard**

Company Standard. */
    CompanyStandard,
    /** **JP**

Japanese Pharmacopoeia. */
    Jp,
    /** **Ph.Eur**

European Pharmacopoeia. */
    PhEur,
    /** **USP-NF**

USP/NF United States Pharmacopeia (USP) and the National Formulary (NF). */
    UspNf,
}
impl ::core::str::FromStr for SubstanceGrade {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BP" => Ok(Self::Bp),
            "CompanyStandard" => Ok(Self::CompanyStandard),
            "JP" => Ok(Self::Jp),
            "Ph.Eur" => Ok(Self::PhEur),
            "USP-NF" => Ok(Self::UspNf),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceGrade {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bp => "BP",
            Self::CompanyStandard => "CompanyStandard",
            Self::Jp => "JP",
            Self::PhEur => "Ph.Eur",
            Self::UspNf => "USP-NF",
        }
    }
}
impl ::std::fmt::Display for SubstanceGrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Bp => "British Pharmacopoeia",
            Self::CompanyStandard => "Company Standard",
            Self::Jp => "Japanese Pharmacopoeia",
            Self::PhEur => "European Pharmacopoeia",
            Self::UspNf => {
                "USP/NF United States Pharmacopeia (USP) and the National Formulary (NF)"
            }
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceGrade {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceGrade {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceGrade> for Coding {
    fn from(code: SubstanceGrade) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-grade".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceGrade> for CodeableConcept {
    fn from(code: SubstanceGrade) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceNameAuthority](http://hl7.org/fhir/ValueSet/substance-name-authority)**. SubstanceNameAuthority\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceNameAuthority {
    /** **BAN**

BAN. */
    Ban,
    /** **COSING**

COSING. */
    Cosing,
    /** **FCC**

FCC. */
    Fcc,
    /** **HAB**

HAB. */
    Hab,
    /** **INCI**

INCI. */
    Inci,
    /** **INN**

INN. */
    Inn,
    /** **IUIS**

IUIS. */
    Iuis,
    /** **JAN**

JAN. */
    Jan,
    /** **JECFA**

JECFA. */
    Jecfa,
    /** **MARTINDALE**

MARTINDALE. */
    Martindale,
    /** **PHF**

PHF. */
    Phf,
    /** **Ph.Eur.**

Ph.Eur.. */
    PhEur,
    /** **PhF**

PhF (Pharmacopée française). */
    PhF,
    /** **USAN**

USAN. */
    Usan,
    /** **USP**

USP. */
    Usp,
}
impl ::core::str::FromStr for SubstanceNameAuthority {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BAN" => Ok(Self::Ban),
            "COSING" => Ok(Self::Cosing),
            "FCC" => Ok(Self::Fcc),
            "HAB" => Ok(Self::Hab),
            "INCI" => Ok(Self::Inci),
            "INN" => Ok(Self::Inn),
            "IUIS" => Ok(Self::Iuis),
            "JAN" => Ok(Self::Jan),
            "JECFA" => Ok(Self::Jecfa),
            "MARTINDALE" => Ok(Self::Martindale),
            "PHF" => Ok(Self::Phf),
            "Ph.Eur." => Ok(Self::PhEur),
            "PhF" => Ok(Self::PhF),
            "USAN" => Ok(Self::Usan),
            "USP" => Ok(Self::Usp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceNameAuthority {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ban => "BAN",
            Self::Cosing => "COSING",
            Self::Fcc => "FCC",
            Self::Hab => "HAB",
            Self::Inci => "INCI",
            Self::Inn => "INN",
            Self::Iuis => "IUIS",
            Self::Jan => "JAN",
            Self::Jecfa => "JECFA",
            Self::Martindale => "MARTINDALE",
            Self::Phf => "PHF",
            Self::PhEur => "Ph.Eur.",
            Self::PhF => "PhF",
            Self::Usan => "USAN",
            Self::Usp => "USP",
        }
    }
}
impl ::std::fmt::Display for SubstanceNameAuthority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Ban => "BAN",
            Self::Cosing => "COSING",
            Self::Fcc => "FCC",
            Self::Hab => "HAB",
            Self::Inci => "INCI",
            Self::Inn => "INN",
            Self::Iuis => "IUIS",
            Self::Jan => "JAN",
            Self::Jecfa => "JECFA",
            Self::Martindale => "MARTINDALE",
            Self::Phf => "PHF",
            Self::PhEur => "Ph.Eur.",
            Self::PhF => "PhF (Pharmacopée française)",
            Self::Usan => "USAN",
            Self::Usp => "USP",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceNameAuthority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceNameAuthority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceNameAuthority> for Coding {
    fn from(code: SubstanceNameAuthority) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-name-authority".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceNameAuthority> for CodeableConcept {
    fn from(code: SubstanceNameAuthority) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceNameDomain](http://hl7.org/fhir/ValueSet/substance-name-domain)**. SubstanceNameDomain\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceNameDomain {
    /** **ActiveIngredient**

Active Ingredient. */
    ActiveIngredient,
    /** **FoodColorAdditive**

Food Color Additive. */
    FoodColorAdditive,
}
impl ::core::str::FromStr for SubstanceNameDomain {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActiveIngredient" => Ok(Self::ActiveIngredient),
            "FoodColorAdditive" => Ok(Self::FoodColorAdditive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceNameDomain {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActiveIngredient => "ActiveIngredient",
            Self::FoodColorAdditive => "FoodColorAdditive",
        }
    }
}
impl ::std::fmt::Display for SubstanceNameDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ActiveIngredient => "Active Ingredient",
            Self::FoodColorAdditive => "Food Color Additive",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceNameDomain {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceNameDomain {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceNameDomain> for Coding {
    fn from(code: SubstanceNameDomain) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-name-domain".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceNameDomain> for CodeableConcept {
    fn from(code: SubstanceNameDomain) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceNameType](http://hl7.org/fhir/ValueSet/substance-name-type)**. SubstanceNameType\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceNameType {
    /** **Brand**

brand. */
    Brand,
    /** **Scientific**

scientific. */
    Scientific,
    /** **Systematic**

systematic. */
    Systematic,
}
impl ::core::str::FromStr for SubstanceNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Brand" => Ok(Self::Brand),
            "Scientific" => Ok(Self::Scientific),
            "Systematic" => Ok(Self::Systematic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Brand => "Brand",
            Self::Scientific => "Scientific",
            Self::Systematic => "Systematic",
        }
    }
}
impl ::std::fmt::Display for SubstanceNameType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Brand => "brand",
            Self::Scientific => "scientific",
            Self::Systematic => "systematic",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceNameType> for Coding {
    fn from(code: SubstanceNameType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-name-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceNameType> for CodeableConcept {
    fn from(code: SubstanceNameType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceOpticalActivity](http://hl7.org/fhir/ValueSet/substance-optical-activity)**. The optical rotation type of a substance.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceOpticalActivity {
    /** **+**

dextrorotary. */
    Plus,
    /** **-**

levorotary. */
    Minus,
}
impl ::core::str::FromStr for SubstanceOpticalActivity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "+" => Ok(Self::Plus),
            "-" => Ok(Self::Minus),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceOpticalActivity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Plus => "+",
            Self::Minus => "-",
        }
    }
}
impl ::std::fmt::Display for SubstanceOpticalActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Plus => "dextrorotary",
            Self::Minus => "levorotary",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceOpticalActivity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceOpticalActivity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceOpticalActivity> for Coding {
    fn from(code: SubstanceOpticalActivity) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-optical-activity".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceOpticalActivity> for CodeableConcept {
    fn from(code: SubstanceOpticalActivity) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceRelationshipType](http://hl7.org/fhir/ValueSet/substance-relationship-type)**. The relationship between two substance types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceRelationshipType {
    /** **ActiveMoiety**

Active moiety. */
    ActiveMoiety,
    /** **Impurity**

Impurity of. */
    Impurity,
    /** **Polymorph**

Polymorph of. */
    Polymorph,
    /** **Salt**

Salt to parent. */
    Salt,
    /** **StartingMaterial**

Starting material for. */
    StartingMaterial,
}
impl ::core::str::FromStr for SubstanceRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActiveMoiety" => Ok(Self::ActiveMoiety),
            "Impurity" => Ok(Self::Impurity),
            "Polymorph" => Ok(Self::Polymorph),
            "Salt" => Ok(Self::Salt),
            "StartingMaterial" => Ok(Self::StartingMaterial),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActiveMoiety => "ActiveMoiety",
            Self::Impurity => "Impurity",
            Self::Polymorph => "Polymorph",
            Self::Salt => "Salt",
            Self::StartingMaterial => "StartingMaterial",
        }
    }
}
impl ::std::fmt::Display for SubstanceRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ActiveMoiety => "Active moiety",
            Self::Impurity => "Impurity of",
            Self::Polymorph => "Polymorph of",
            Self::Salt => "Salt to parent",
            Self::StartingMaterial => "Starting material for",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceRelationshipType> for Coding {
    fn from(code: SubstanceRelationshipType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/substance-relationship-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceRelationshipType> for CodeableConcept {
    fn from(code: SubstanceRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceRepresentationFormat](http://hl7.org/fhir/ValueSet/substance-representation-format)**. SubstanceRepresentationFormat\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceRepresentationFormat {
    /** **CDX**

CDX. */
    Cdx,
    /** **InChI**

InChI. */
    InChI,
    /** **MOLFILE**

MOLFILE. */
    Molfile,
    /** **PDB**

PDB. */
    Pdb,
    /** **SDF**

SDF. */
    Sdf,
    /** **SMILES**

SMILES. */
    Smiles,
    /** **mmCIF**

mmCIF. */
    MmCIF,
}
impl ::core::str::FromStr for SubstanceRepresentationFormat {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CDX" => Ok(Self::Cdx),
            "InChI" => Ok(Self::InChI),
            "MOLFILE" => Ok(Self::Molfile),
            "PDB" => Ok(Self::Pdb),
            "SDF" => Ok(Self::Sdf),
            "SMILES" => Ok(Self::Smiles),
            "mmCIF" => Ok(Self::MmCIF),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceRepresentationFormat {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cdx => "CDX",
            Self::InChI => "InChI",
            Self::Molfile => "MOLFILE",
            Self::Pdb => "PDB",
            Self::Sdf => "SDF",
            Self::Smiles => "SMILES",
            Self::MmCIF => "mmCIF",
        }
    }
}
impl ::std::fmt::Display for SubstanceRepresentationFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Cdx => "CDX",
            Self::InChI => "InChI",
            Self::Molfile => "MOLFILE",
            Self::Pdb => "PDB",
            Self::Sdf => "SDF",
            Self::Smiles => "SMILES",
            Self::MmCIF => "mmCIF",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceRepresentationFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceRepresentationFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceRepresentationFormat> for Coding {
    fn from(code: SubstanceRepresentationFormat) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/substance-representation-format".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceRepresentationFormat> for CodeableConcept {
    fn from(code: SubstanceRepresentationFormat) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceRepresentationType](http://hl7.org/fhir/ValueSet/substance-representation-type)**. SubstanceRepresentationType\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceRepresentationType {
    /** **Brand**

brand. */
    Brand,
    /** **Scientific**

scientific. */
    Scientific,
    /** **Systematic**

systematic. */
    Systematic,
}
impl ::core::str::FromStr for SubstanceRepresentationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Brand" => Ok(Self::Brand),
            "Scientific" => Ok(Self::Scientific),
            "Systematic" => Ok(Self::Systematic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceRepresentationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Brand => "Brand",
            Self::Scientific => "Scientific",
            Self::Systematic => "Systematic",
        }
    }
}
impl ::std::fmt::Display for SubstanceRepresentationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Brand => "brand",
            Self::Scientific => "scientific",
            Self::Systematic => "systematic",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceRepresentationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceRepresentationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceRepresentationType> for Coding {
    fn from(code: SubstanceRepresentationType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/substance-representation-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceRepresentationType> for CodeableConcept {
    fn from(code: SubstanceRepresentationType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceSourceMaterialGenus](http://hl7.org/fhir/ValueSet/substance-source-material-genus)**. SubstanceSourceMaterialGenus\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialGenus {
    /** **Ginkgo**

Ginkgo. */
    Ginkgo,
    /** **InfluenzavirusA**

Influenza A virus. */
    InfluenzavirusA,
    /** **Mycobacterium**

Mycobacterium. */
    Mycobacterium,
}
impl ::core::str::FromStr for SubstanceSourceMaterialGenus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Ginkgo" => Ok(Self::Ginkgo),
            "InfluenzavirusA" => Ok(Self::InfluenzavirusA),
            "Mycobacterium" => Ok(Self::Mycobacterium),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialGenus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ginkgo => "Ginkgo",
            Self::InfluenzavirusA => "InfluenzavirusA",
            Self::Mycobacterium => "Mycobacterium",
        }
    }
}
impl ::std::fmt::Display for SubstanceSourceMaterialGenus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Ginkgo => "Ginkgo",
            Self::InfluenzavirusA => "Influenza A virus",
            Self::Mycobacterium => "Mycobacterium",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialGenus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialGenus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceSourceMaterialGenus> for Coding {
    fn from(code: SubstanceSourceMaterialGenus) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/substance-source-material-genus".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceSourceMaterialGenus> for CodeableConcept {
    fn from(code: SubstanceSourceMaterialGenus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceSourceMaterialPart](http://hl7.org/fhir/ValueSet/substance-source-material-part)**. SubstanceSourceMaterialPart\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialPart {
    /** **Animal**

animal. */
    Animal,
    /** **Mineral**

mineral. */
    Mineral,
    /** **Plant**

plant. */
    Plant,
}
impl ::core::str::FromStr for SubstanceSourceMaterialPart {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Animal" => Ok(Self::Animal),
            "Mineral" => Ok(Self::Mineral),
            "Plant" => Ok(Self::Plant),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialPart {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "Animal",
            Self::Mineral => "Mineral",
            Self::Plant => "Plant",
        }
    }
}
impl ::std::fmt::Display for SubstanceSourceMaterialPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Animal => "animal",
            Self::Mineral => "mineral",
            Self::Plant => "plant",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceSourceMaterialPart> for Coding {
    fn from(code: SubstanceSourceMaterialPart) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/substance-source-material-part".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceSourceMaterialPart> for CodeableConcept {
    fn from(code: SubstanceSourceMaterialPart) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceSourceMaterialSpecies](http://hl7.org/fhir/ValueSet/substance-source-material-species)**. SubstanceSourceMaterialSpecies\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialSpecies {
    /** **GinkgoBiloba**

Ginkgo biloba. */
    GinkgoBiloba,
    /** **OleaEuropaea**

Olea europaea. */
    OleaEuropaea,
}
impl ::core::str::FromStr for SubstanceSourceMaterialSpecies {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "GinkgoBiloba" => Ok(Self::GinkgoBiloba),
            "OleaEuropaea" => Ok(Self::OleaEuropaea),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialSpecies {
    fn as_ref(&self) -> &str {
        match self {
            Self::GinkgoBiloba => "GinkgoBiloba",
            Self::OleaEuropaea => "OleaEuropaea",
        }
    }
}
impl ::std::fmt::Display for SubstanceSourceMaterialSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::GinkgoBiloba => "Ginkgo biloba",
            Self::OleaEuropaea => "Olea europaea",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialSpecies {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialSpecies {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceSourceMaterialSpecies> for Coding {
    fn from(code: SubstanceSourceMaterialSpecies) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/substance-source-material-species"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceSourceMaterialSpecies> for CodeableConcept {
    fn from(code: SubstanceSourceMaterialSpecies) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceSourceMaterialType](http://hl7.org/fhir/ValueSet/substance-source-material-type)**. SubstanceSourceMaterialType\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialType {
    /** **Animal**

animal. */
    Animal,
    /** **Mineral**

mineral. */
    Mineral,
    /** **Plant**

plant. */
    Plant,
}
impl ::core::str::FromStr for SubstanceSourceMaterialType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Animal" => Ok(Self::Animal),
            "Mineral" => Ok(Self::Mineral),
            "Plant" => Ok(Self::Plant),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "Animal",
            Self::Mineral => "Mineral",
            Self::Plant => "Plant",
        }
    }
}
impl ::std::fmt::Display for SubstanceSourceMaterialType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Animal => "animal",
            Self::Mineral => "mineral",
            Self::Plant => "plant",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceSourceMaterialType> for Coding {
    fn from(code: SubstanceSourceMaterialType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/substance-source-material-type".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceSourceMaterialType> for CodeableConcept {
    fn from(code: SubstanceSourceMaterialType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceStereochemistry](http://hl7.org/fhir/ValueSet/substance-stereochemistry)**. The stereochemistry type of a substance.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceStereochemistry {
    /** **ConstitutionalIsomer**

constitutional isomer. */
    ConstitutionalIsomer,
    /** **Enantiomer**

enantiomer. */
    Enantiomer,
    /** **Stereoisomer**

stereoisomer. */
    Stereoisomer,
}
impl ::core::str::FromStr for SubstanceStereochemistry {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ConstitutionalIsomer" => Ok(Self::ConstitutionalIsomer),
            "Enantiomer" => Ok(Self::Enantiomer),
            "Stereoisomer" => Ok(Self::Stereoisomer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceStereochemistry {
    fn as_ref(&self) -> &str {
        match self {
            Self::ConstitutionalIsomer => "ConstitutionalIsomer",
            Self::Enantiomer => "Enantiomer",
            Self::Stereoisomer => "Stereoisomer",
        }
    }
}
impl ::std::fmt::Display for SubstanceStereochemistry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ConstitutionalIsomer => "constitutional isomer",
            Self::Enantiomer => "enantiomer",
            Self::Stereoisomer => "stereoisomer",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceStereochemistry {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceStereochemistry {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceStereochemistry> for Coding {
    fn from(code: SubstanceStereochemistry) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-stereochemistry".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceStereochemistry> for CodeableConcept {
    fn from(code: SubstanceStereochemistry) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceStructureTechnique](http://hl7.org/fhir/ValueSet/substance-structure-technique)**. SubstanceStructureTechnique\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceStructureTechnique {
    /** **HPLC**

HPLC. */
    Hplc,
    /** **LigandBindingAssay**

Ligand binding assay. */
    LigandBindingAssay,
    /** **NMR**

NMR. */
    Nmr,
    /** **PeptideMapping**

Peptide mapping. */
    PeptideMapping,
    /** **X-Ray**

X-ray. */
    XRay,
}
impl ::core::str::FromStr for SubstanceStructureTechnique {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "HPLC" => Ok(Self::Hplc),
            "LigandBindingAssay" => Ok(Self::LigandBindingAssay),
            "NMR" => Ok(Self::Nmr),
            "PeptideMapping" => Ok(Self::PeptideMapping),
            "X-Ray" => Ok(Self::XRay),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceStructureTechnique {
    fn as_ref(&self) -> &str {
        match self {
            Self::Hplc => "HPLC",
            Self::LigandBindingAssay => "LigandBindingAssay",
            Self::Nmr => "NMR",
            Self::PeptideMapping => "PeptideMapping",
            Self::XRay => "X-Ray",
        }
    }
}
impl ::std::fmt::Display for SubstanceStructureTechnique {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Hplc => "HPLC",
            Self::LigandBindingAssay => "Ligand binding assay",
            Self::Nmr => "NMR",
            Self::PeptideMapping => "Peptide mapping",
            Self::XRay => "X-ray",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceStructureTechnique {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceStructureTechnique {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceStructureTechnique> for Coding {
    fn from(code: SubstanceStructureTechnique) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/substance-structure-technique".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceStructureTechnique> for CodeableConcept {
    fn from(code: SubstanceStructureTechnique) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceWeightMethod](http://hl7.org/fhir/ValueSet/substance-weight-method)**. SubstanceWeightMethod\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceWeightMethod {
    /** **Calculated**

calculated. */
    Calculated,
    /** **End-groupAnalysis**

End-group analysis. */
    EndGroupAnalysis,
    /** **End-groupTitration**

End-group titration. */
    EndGroupTitration,
    /** **GelPermeationCentrifugation**

gel permeation centrifugation. */
    GelPermeationCentrifugation,
    /** **LighScattering**

light scattering. */
    LighScattering,
    /** **SDS-PAGE**

SDS-PAGE (sodium dodecyl sulfate-polyacrylamide gel electrophoresis). */
    SdsPage,
    /** **Size-ExclusionChromatography**

Size-exclusion chromatography. */
    SizeExclusionChromatography,
    /** **Viscosity**

viscosity. */
    Viscosity,
}
impl ::core::str::FromStr for SubstanceWeightMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Calculated" => Ok(Self::Calculated),
            "End-groupAnalysis" => Ok(Self::EndGroupAnalysis),
            "End-groupTitration" => Ok(Self::EndGroupTitration),
            "GelPermeationCentrifugation" => Ok(Self::GelPermeationCentrifugation),
            "LighScattering" => Ok(Self::LighScattering),
            "SDS-PAGE" => Ok(Self::SdsPage),
            "Size-ExclusionChromatography" => Ok(Self::SizeExclusionChromatography),
            "Viscosity" => Ok(Self::Viscosity),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceWeightMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calculated => "Calculated",
            Self::EndGroupAnalysis => "End-groupAnalysis",
            Self::EndGroupTitration => "End-groupTitration",
            Self::GelPermeationCentrifugation => "GelPermeationCentrifugation",
            Self::LighScattering => "LighScattering",
            Self::SdsPage => "SDS-PAGE",
            Self::SizeExclusionChromatography => "Size-ExclusionChromatography",
            Self::Viscosity => "Viscosity",
        }
    }
}
impl ::std::fmt::Display for SubstanceWeightMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Calculated => "calculated",
            Self::EndGroupAnalysis => "End-group analysis",
            Self::EndGroupTitration => "End-group titration",
            Self::GelPermeationCentrifugation => "gel permeation centrifugation",
            Self::LighScattering => "light scattering",
            Self::SdsPage => {
                "SDS-PAGE (sodium dodecyl sulfate-polyacrylamide gel electrophoresis)"
            }
            Self::SizeExclusionChromatography => "Size-exclusion chromatography",
            Self::Viscosity => "viscosity",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceWeightMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceWeightMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceWeightMethod> for Coding {
    fn from(code: SubstanceWeightMethod) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-weight-method".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceWeightMethod> for CodeableConcept {
    fn from(code: SubstanceWeightMethod) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SubstanceWeightType](http://hl7.org/fhir/ValueSet/substance-weight-type)**. SubstanceWeightType\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceWeightType {
    /** **Average**

number average. */
    Average,
    /** **Exact**

exact. */
    Exact,
    /** **WeightAverage**

weight average. */
    WeightAverage,
}
impl ::core::str::FromStr for SubstanceWeightType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Average" => Ok(Self::Average),
            "Exact" => Ok(Self::Exact),
            "WeightAverage" => Ok(Self::WeightAverage),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceWeightType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Average => "Average",
            Self::Exact => "Exact",
            Self::WeightAverage => "WeightAverage",
        }
    }
}
impl ::std::fmt::Display for SubstanceWeightType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Average => "number average",
            Self::Exact => "exact",
            Self::WeightAverage => "weight average",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SubstanceWeightType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceWeightType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SubstanceWeightType> for Coding {
    fn from(code: SubstanceWeightType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/substance-weight-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SubstanceWeightType> for CodeableConcept {
    fn from(code: SubstanceWeightType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SupplyDeliveryStatus](http://hl7.org/fhir/ValueSet/supplydelivery-status)**. Status of the supply delivery.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SupplyDeliveryStatus {
    /** **abandoned**

Abandoned. Delivery was not completed. */
    Abandoned,
    /** **completed**

Delivered. Supply has been delivered ("completed"). */
    Completed,
    /** **entered-in-error**

Entered In Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "abandoned" rather than "entered-in-error".). */
    EnteredInError,
    /** **in-progress**

In Progress. Supply has been requested, but not delivered. */
    InProgress,
}
impl ::core::str::FromStr for SupplyDeliveryStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abandoned" => Ok(Self::Abandoned),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyDeliveryStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abandoned => "abandoned",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
        }
    }
}
impl ::std::fmt::Display for SupplyDeliveryStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Abandoned => "Abandoned",
            Self::Completed => "Delivered",
            Self::EnteredInError => "Entered In Error",
            Self::InProgress => "In Progress",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SupplyDeliveryStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyDeliveryStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyDeliveryStatus> for Coding {
    fn from(code: SupplyDeliveryStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/supplydelivery-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SupplyDeliveryStatus> for CodeableConcept {
    fn from(code: SupplyDeliveryStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SupplyDeliverySupplyItemType](http://hl7.org/fhir/ValueSet/supplydelivery-supplyitemtype)**. Status of the supply delivery.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SupplyDeliverySupplyItemType {
    /** **biologicallyderivedproduct**

Biologically Derived Product. Supply is a kind of biologically derived product. */
    Biologicallyderivedproduct,
    /** **device**

Device. What is supplied (or requested) is a device. */
    Device,
    /** **medication**

Medication. Supply is a kind of medication. */
    Medication,
}
impl ::core::str::FromStr for SupplyDeliverySupplyItemType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "biologicallyderivedproduct" => Ok(Self::Biologicallyderivedproduct),
            "device" => Ok(Self::Device),
            "medication" => Ok(Self::Medication),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyDeliverySupplyItemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Biologicallyderivedproduct => "biologicallyderivedproduct",
            Self::Device => "device",
            Self::Medication => "medication",
        }
    }
}
impl ::std::fmt::Display for SupplyDeliverySupplyItemType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Biologicallyderivedproduct => "Biologically Derived Product",
            Self::Device => "Device",
            Self::Medication => "Medication",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SupplyDeliverySupplyItemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyDeliverySupplyItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyDeliverySupplyItemType> for Coding {
    fn from(code: SupplyDeliverySupplyItemType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/supplydelivery-supplyitemtype".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SupplyDeliverySupplyItemType> for CodeableConcept {
    fn from(code: SupplyDeliverySupplyItemType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[SupplyRequestStatus](http://hl7.org/fhir/ValueSet/supplyrequest-status)**. Status of the supply request.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SupplyRequestStatus {
    /** **active**

Active. The request is ready to be acted upon. */
    Active,
    /** **cancelled**

Cancelled. The authorization/request to act has been terminated prior to the full completion of the intended actions.  No further activity should occur. */
    Cancelled,
    /** **completed**

Completed. Activity against the request has been sufficiently completed to the satisfaction of the requester. */
    Completed,
    /** **draft**

Draft. The request has been created but is not yet complete or ready for action. */
    Draft,
    /** **entered-in-error**

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** **suspended**

Suspended. The authorization/request to act has been temporarily withdrawn but is expected to resume in the future. */
    Suspended,
    /** **unknown**

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for SupplyRequestStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "suspended" => Ok(Self::Suspended),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyRequestStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Suspended => "suspended",
            Self::Unknown => "unknown",
        }
    }
}
impl ::std::fmt::Display for SupplyRequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "Active",
            Self::Cancelled => "Cancelled",
            Self::Completed => "Completed",
            Self::Draft => "Draft",
            Self::EnteredInError => "Entered in Error",
            Self::Suspended => "Suspended",
            Self::Unknown => "Unknown",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for SupplyRequestStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyRequestStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<SupplyRequestStatus> for Coding {
    fn from(code: SupplyRequestStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/supplyrequest-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<SupplyRequestStatus> for CodeableConcept {
    fn from(code: SupplyRequestStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TargetSpecies](http://hl7.org/fhir/ValueSet/target-species)**. A species for which a medicinal product is intended.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TargetSpecies {
    /** **100000108874**

Dove. */
    N100000108874,
    /** **100000108875**

Quail. */
    N100000108875,
    /** **100000108876**

Snipe. */
    N100000108876,
    /** **100000108877**

Sparrow. */
    N100000108877,
    /** **100000108878**

Starling. */
    N100000108878,
    /** **100000108879**

Swan. */
    N100000108879,
    /** **100000108880**

Turkey hen. */
    N100000108880,
    /** **100000108881**

Turkey cock. */
    N100000108881,
    /** **100000108882**

Turkeys. */
    N100000108882,
    /** **100000108883**

Turkey for reproduction. */
    N100000108883,
    /** **100000108884**

Poult. */
    N100000108884,
    /** **100000108885**

Turtle dove. */
    N100000108885,
    /** **100000108886**

Bison. */
    N100000108886,
    /** **100000108887**

Buffalo. */
    N100000108887,
    /** **100000108888**

Cows. */
    N100000108888,
    /** **100000108889**

Cow for reproduction. */
    N100000108889,
    /** **100000108890**

Bull for reproduction. */
    N100000108890,
    /** **100000108891**

Ox. */
    N100000108891,
    /** **100000108892**

Bullock. */
    N100000108892,
    /** **100000108893**

Cattle. */
    N100000108893,
    /** **100000108894**

Beef cattle. */
    N100000108894,
    /** **100000108895**

Dairy cattle. */
    N100000108895,
    /** **100000108896**

Dry cow. */
    N100000108896,
    /** **100000108897**

Bull. */
    N100000108897,
    /** **100000108898**

Lactating cow. */
    N100000108898,
    /** **100000108899**

All other food producing species. */
    N100000108899,
    /** **100000108900**

All non-food producing species. */
    N100000108900,
    /** **100000108901**

All species  . */
    N100000108901,
    /** **100000108902**

Carnivores. */
    N100000108902,
    /** **100000108903**

Domestic animals. */
    N100000108903,
    /** **100000108904**

Fur animals. */
    N100000108904,
    /** **100000108905**

Game animals. */
    N100000108905,
    /** **100000108906**

Laboratory animals. */
    N100000108906,
    /** **100000108907**

Major species. */
    N100000108907,
    /** **100000108908**

Minor species. */
    N100000108908,
    /** **100000108909**

Ruminant. */
    N100000108909,
    /** **100000108910**

Ruminant and porcine. */
    N100000108910,
    /** **100000108911**

Small animals. */
    N100000108911,
    /** **100000108912**

Crocodile. */
    N100000108912,
    /** **100000108913**

Frog. */
    N100000108913,
    /** **100000108914**

Iguana. */
    N100000108914,
    /** **100000108915**

Lizard. */
    N100000108915,
    /** **100000108916**

Amphibians. */
    N100000108916,
    /** **100000108917**

Reptiles. */
    N100000108917,
    /** **100000108918**

Reptiles for production. */
    N100000108918,
    /** **100000108919**

Snake. */
    N100000108919,
    /** **100000108920**

Tortoise. */
    N100000108920,
    /** **100000108921**

Turtle. */
    N100000108921,
    /** **100000108922**

Honey bees. */
    N100000108922,
    /** **100000108923**

Crustacean. */
    N100000108923,
    /** **100000108924**

Spider. */
    N100000108924,
    /** **100000108925**

Indian hen. */
    N100000108925,
    /** **100000108926**

African Goshawk. */
    N100000108926,
    /** **100000108927**

Black Kite. */
    N100000108927,
    /** **100000108928**

Budgerigar. */
    N100000108928,
    /** **100000108929**

Bustard. */
    N100000108929,
    /** **100000108930**

Buzzard. */
    N100000108930,
    /** **100000108931**

Hen. */
    N100000108931,
    /** **100000108932**

Layer hen. */
    N100000108932,
    /** **100000108933**

Cock. */
    N100000108933,
    /** **100000108934**

Broiler. */
    N100000108934,
    /** **100000108935**

Chickens. */
    N100000108935,
    /** **100000108936**

Chicken embryonated eggs. */
    N100000108936,
    /** **100000108937**

Chicken for reproduction. */
    N100000108937,
    /** **100000108938**

Replacement chick. */
    N100000108938,
    /** **100000108939**

Chick. */
    N100000108939,
    /** **100000108940**

Pullet. */
    N100000108940,
    /** **100000108941**

Cockatiel. */
    N100000108941,
    /** **100000108942**

Cockatoo. */
    N100000108942,
    /** **100000108943**

Common canary. */
    N100000108943,
    /** **100000108944**

Crow. */
    N100000108944,
    /** **100000108945**

Duck. */
    N100000108945,
    /** **100000108946**

Duck broiler. */
    N100000108946,
    /** **100000108947**

Duckling. */
    N100000108947,
    /** **100000108948**

Eagle. */
    N100000108948,
    /** **100000108949**

Emu. */
    N100000108949,
    /** **100000108950**

Goose. */
    N100000108950,
    /** **100000108951**

Guinea fowl. */
    N100000108951,
    /** **100000108952**

Kestrel. */
    N100000108952,
    /** **100000108953**

Kite. */
    N100000108953,
    /** **100000108954**

Macaw. */
    N100000108954,
    /** **100000108955**

Ostrich. */
    N100000108955,
    /** **100000108956**

Birds. */
    N100000108956,
    /** **100000108957**

Fowls. */
    N100000108957,
    /** **100000108958**

Finch. */
    N100000108958,
    /** **100000108959**

Galliformes. */
    N100000108959,
    /** **100000108960**

Game birds. */
    N100000108960,
    /** **100000108961**

Pekin duck. */
    N100000108961,
    /** **100000108962**

Ornamental birds. */
    N100000108962,
    /** **100000108963**

Poultry. */
    N100000108963,
    /** **100000108964**

Owl. */
    N100000108964,
    /** **100000108965**

Parakeet. */
    N100000108965,
    /** **100000108966**

Parrot. */
    N100000108966,
    /** **100000108967**

Partridge. */
    N100000108967,
    /** **100000108968**

Peregrine Falcon. */
    N100000108968,
    /** **100000108969**

Pheasants. */
    N100000108969,
    /** **100000108970**

Carrier pigeon. */
    N100000108970,
    /** **100000108971**

Newborn calves. */
    N100000108971,
    /** **100000108972**

Pregnant cow. */
    N100000108972,
    /** **100000108973**

Pregnant heifer. */
    N100000108973,
    /** **100000108974**

Pre-ruminant cattle. */
    N100000108974,
    /** **100000108975**

Ruminant cattle. */
    N100000108975,
    /** **100000108976**

Wild cattle. */
    N100000108976,
    /** **100000108977**

Calf. */
    N100000108977,
    /** **100000108978**

Heifers. */
    N100000108978,
    /** **100000108979**

Other Bovids. */
    N100000108979,
    /** **100000108980**

Alpaca. */
    N100000108980,
    /** **100000108981**

Camel. */
    N100000108981,
    /** **100000108982**

Llama. */
    N100000108982,
    /** **100000108983**

Other Camelids. */
    N100000108983,
    /** **100000108984**

Bitch. */
    N100000108984,
    /** **100000108985**

Bitch for reproduction. */
    N100000108985,
    /** **100000108986**

Adult male dog. */
    N100000108986,
    /** **100000108987**

Adult male dog for reproduction. */
    N100000108987,
    /** **100000108988**

Dogs. */
    N100000108988,
    /** **100000108989**

Lactating bitch. */
    N100000108989,
    /** **100000108990**

Large dog. */
    N100000108990,
    /** **100000108991**

Medium dog. */
    N100000108991,
    /** **100000108992**

Pregnant bitch. */
    N100000108992,
    /** **100000108993**

Small dog. */
    N100000108993,
    /** **100000108994**

Very large dog. */
    N100000108994,
    /** **100000108995**

Very small dog. */
    N100000108995,
    /** **100000108996**

Puppy. */
    N100000108996,
    /** **100000108997**

Foxes. */
    N100000108997,
    /** **100000108998**

Jackal. */
    N100000108998,
    /** **100000108999**

Other Canids. */
    N100000108999,
    /** **100000109000**

Raccoon dogs. */
    N100000109000,
    /** **100000109001**

Wolf. */
    N100000109001,
    /** **100000109002**

Chamois. */
    N100000109002,
    /** **100000109003**

Other Caprines. */
    N100000109003,
    /** **100000109004**

Adult female goat. */
    N100000109004,
    /** **100000109005**

Adult male goat. */
    N100000109005,
    /** **100000109006**

Dry adult female goat. */
    N100000109006,
    /** **100000109007**

Goats. */
    N100000109007,
    /** **100000109008**

Lactating adult female goat. */
    N100000109008,
    /** **100000109009**

Pregnant adult female goat. */
    N100000109009,
    /** **100000109010**

Pre-ruminant goat. */
    N100000109010,
    /** **100000109011**

Ruminant goat. */
    N100000109011,
    /** **100000109012**

Wild goat. */
    N100000109012,
    /** **100000109013**

Kid. */
    N100000109013,
    /** **100000109014**

Other Ovids. */
    N100000109014,
    /** **100000109015**

Ewe. */
    N100000109015,
    /** **100000109016**

Ram. */
    N100000109016,
    /** **100000109017**

Dry ewe. */
    N100000109017,
    /** **100000109018**

Lactating ewe. */
    N100000109018,
    /** **100000109019**

Pregnant ewe. */
    N100000109019,
    /** **100000109020**

Pre-ruminant sheep. */
    N100000109020,
    /** **100000109021**

Ruminant sheep. */
    N100000109021,
    /** **100000109022**

Sheep. */
    N100000109022,
    /** **100000109023**

Sheep for meat production. */
    N100000109023,
    /** **100000109024**

Dairy sheep. */
    N100000109024,
    /** **100000109025**

Wild sheep. */
    N100000109025,
    /** **100000109026**

Lamb. */
    N100000109026,
    /** **100000109027**

Elk. */
    N100000109027,
    /** **100000109028**

Fallow deer. */
    N100000109028,
    /** **100000109029**

Moose. */
    N100000109029,
    /** **100000109030**

Antelope. */
    N100000109030,
    /** **100000109031**

Cervid. */
    N100000109031,
    /** **100000109032**

Deer. */
    N100000109032,
    /** **100000109033**

Other Deer. */
    N100000109033,
    /** **100000109034**

Red deer. */
    N100000109034,
    /** **100000109035**

Reindeer. */
    N100000109035,
    /** **100000109036**

Roe deer. */
    N100000109036,
    /** **100000109037**

Donkey. */
    N100000109037,
    /** **100000109038**

Mare. */
    N100000109038,
    /** **100000109039**

Gelding. */
    N100000109039,
    /** **100000109040**

Horses. */
    N100000109040,
    /** **100000109041**

Stallion. */
    N100000109041,
    /** **100000109042**

Pony. */
    N100000109042,
    /** **100000109043**

Pregnant mare. */
    N100000109043,
    /** **100000109044**

Non food-producing horse. */
    N100000109044,
    /** **100000109045**

Suckling colt. */
    N100000109045,
    /** **100000109046**

Colt. */
    N100000109046,
    /** **100000109047**

Mule. */
    N100000109047,
    /** **100000109048**

Equid. */
    N100000109048,
    /** **100000109049**

Female equid. */
    N100000109049,
    /** **100000109050**

Other Equids. */
    N100000109050,
    /** **100000109051**

Zebra. */
    N100000109051,
    /** **100000109052**

Bobcat. */
    N100000109052,
    /** **100000109053**

Adult female cat. */
    N100000109053,
    /** **100000109054**

Adult female cat for reproduction. */
    N100000109054,
    /** **100000109055**

Adult male cat. */
    N100000109055,
    /** **100000109056**

Cats. */
    N100000109056,
    /** **100000109057**

Lactating cat. */
    N100000109057,
    /** **100000109058**

Large cat. */
    N100000109058,
    /** **100000109059**

Medium cat. */
    N100000109059,
    /** **100000109060**

Pregnant cat. */
    N100000109060,
    /** **100000109061**

Small cat. */
    N100000109061,
    /** **100000109062**

Kitten. */
    N100000109062,
    /** **100000109063**

Cougar. */
    N100000109063,
    /** **100000109064**

Jaguar. */
    N100000109064,
    /** **100000109065**

Leopard. */
    N100000109065,
    /** **100000109066**

Lion. */
    N100000109066,
    /** **100000109067**

Lynx. */
    N100000109067,
    /** **100000109068**

Other Felids. */
    N100000109068,
    /** **100000109069**

Tiger. */
    N100000109069,
    /** **100000109070**

Tsushima wild cat. */
    N100000109070,
    /** **100000109071**

Other Leporids. */
    N100000109071,
    /** **100000109072**

Hare. */
    N100000109072,
    /** **100000109073**

Female rabbit for reproduction. */
    N100000109073,
}
impl ::core::str::FromStr for TargetSpecies {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000108874" => Ok(Self::N100000108874),
            "100000108875" => Ok(Self::N100000108875),
            "100000108876" => Ok(Self::N100000108876),
            "100000108877" => Ok(Self::N100000108877),
            "100000108878" => Ok(Self::N100000108878),
            "100000108879" => Ok(Self::N100000108879),
            "100000108880" => Ok(Self::N100000108880),
            "100000108881" => Ok(Self::N100000108881),
            "100000108882" => Ok(Self::N100000108882),
            "100000108883" => Ok(Self::N100000108883),
            "100000108884" => Ok(Self::N100000108884),
            "100000108885" => Ok(Self::N100000108885),
            "100000108886" => Ok(Self::N100000108886),
            "100000108887" => Ok(Self::N100000108887),
            "100000108888" => Ok(Self::N100000108888),
            "100000108889" => Ok(Self::N100000108889),
            "100000108890" => Ok(Self::N100000108890),
            "100000108891" => Ok(Self::N100000108891),
            "100000108892" => Ok(Self::N100000108892),
            "100000108893" => Ok(Self::N100000108893),
            "100000108894" => Ok(Self::N100000108894),
            "100000108895" => Ok(Self::N100000108895),
            "100000108896" => Ok(Self::N100000108896),
            "100000108897" => Ok(Self::N100000108897),
            "100000108898" => Ok(Self::N100000108898),
            "100000108899" => Ok(Self::N100000108899),
            "100000108900" => Ok(Self::N100000108900),
            "100000108901" => Ok(Self::N100000108901),
            "100000108902" => Ok(Self::N100000108902),
            "100000108903" => Ok(Self::N100000108903),
            "100000108904" => Ok(Self::N100000108904),
            "100000108905" => Ok(Self::N100000108905),
            "100000108906" => Ok(Self::N100000108906),
            "100000108907" => Ok(Self::N100000108907),
            "100000108908" => Ok(Self::N100000108908),
            "100000108909" => Ok(Self::N100000108909),
            "100000108910" => Ok(Self::N100000108910),
            "100000108911" => Ok(Self::N100000108911),
            "100000108912" => Ok(Self::N100000108912),
            "100000108913" => Ok(Self::N100000108913),
            "100000108914" => Ok(Self::N100000108914),
            "100000108915" => Ok(Self::N100000108915),
            "100000108916" => Ok(Self::N100000108916),
            "100000108917" => Ok(Self::N100000108917),
            "100000108918" => Ok(Self::N100000108918),
            "100000108919" => Ok(Self::N100000108919),
            "100000108920" => Ok(Self::N100000108920),
            "100000108921" => Ok(Self::N100000108921),
            "100000108922" => Ok(Self::N100000108922),
            "100000108923" => Ok(Self::N100000108923),
            "100000108924" => Ok(Self::N100000108924),
            "100000108925" => Ok(Self::N100000108925),
            "100000108926" => Ok(Self::N100000108926),
            "100000108927" => Ok(Self::N100000108927),
            "100000108928" => Ok(Self::N100000108928),
            "100000108929" => Ok(Self::N100000108929),
            "100000108930" => Ok(Self::N100000108930),
            "100000108931" => Ok(Self::N100000108931),
            "100000108932" => Ok(Self::N100000108932),
            "100000108933" => Ok(Self::N100000108933),
            "100000108934" => Ok(Self::N100000108934),
            "100000108935" => Ok(Self::N100000108935),
            "100000108936" => Ok(Self::N100000108936),
            "100000108937" => Ok(Self::N100000108937),
            "100000108938" => Ok(Self::N100000108938),
            "100000108939" => Ok(Self::N100000108939),
            "100000108940" => Ok(Self::N100000108940),
            "100000108941" => Ok(Self::N100000108941),
            "100000108942" => Ok(Self::N100000108942),
            "100000108943" => Ok(Self::N100000108943),
            "100000108944" => Ok(Self::N100000108944),
            "100000108945" => Ok(Self::N100000108945),
            "100000108946" => Ok(Self::N100000108946),
            "100000108947" => Ok(Self::N100000108947),
            "100000108948" => Ok(Self::N100000108948),
            "100000108949" => Ok(Self::N100000108949),
            "100000108950" => Ok(Self::N100000108950),
            "100000108951" => Ok(Self::N100000108951),
            "100000108952" => Ok(Self::N100000108952),
            "100000108953" => Ok(Self::N100000108953),
            "100000108954" => Ok(Self::N100000108954),
            "100000108955" => Ok(Self::N100000108955),
            "100000108956" => Ok(Self::N100000108956),
            "100000108957" => Ok(Self::N100000108957),
            "100000108958" => Ok(Self::N100000108958),
            "100000108959" => Ok(Self::N100000108959),
            "100000108960" => Ok(Self::N100000108960),
            "100000108961" => Ok(Self::N100000108961),
            "100000108962" => Ok(Self::N100000108962),
            "100000108963" => Ok(Self::N100000108963),
            "100000108964" => Ok(Self::N100000108964),
            "100000108965" => Ok(Self::N100000108965),
            "100000108966" => Ok(Self::N100000108966),
            "100000108967" => Ok(Self::N100000108967),
            "100000108968" => Ok(Self::N100000108968),
            "100000108969" => Ok(Self::N100000108969),
            "100000108970" => Ok(Self::N100000108970),
            "100000108971" => Ok(Self::N100000108971),
            "100000108972" => Ok(Self::N100000108972),
            "100000108973" => Ok(Self::N100000108973),
            "100000108974" => Ok(Self::N100000108974),
            "100000108975" => Ok(Self::N100000108975),
            "100000108976" => Ok(Self::N100000108976),
            "100000108977" => Ok(Self::N100000108977),
            "100000108978" => Ok(Self::N100000108978),
            "100000108979" => Ok(Self::N100000108979),
            "100000108980" => Ok(Self::N100000108980),
            "100000108981" => Ok(Self::N100000108981),
            "100000108982" => Ok(Self::N100000108982),
            "100000108983" => Ok(Self::N100000108983),
            "100000108984" => Ok(Self::N100000108984),
            "100000108985" => Ok(Self::N100000108985),
            "100000108986" => Ok(Self::N100000108986),
            "100000108987" => Ok(Self::N100000108987),
            "100000108988" => Ok(Self::N100000108988),
            "100000108989" => Ok(Self::N100000108989),
            "100000108990" => Ok(Self::N100000108990),
            "100000108991" => Ok(Self::N100000108991),
            "100000108992" => Ok(Self::N100000108992),
            "100000108993" => Ok(Self::N100000108993),
            "100000108994" => Ok(Self::N100000108994),
            "100000108995" => Ok(Self::N100000108995),
            "100000108996" => Ok(Self::N100000108996),
            "100000108997" => Ok(Self::N100000108997),
            "100000108998" => Ok(Self::N100000108998),
            "100000108999" => Ok(Self::N100000108999),
            "100000109000" => Ok(Self::N100000109000),
            "100000109001" => Ok(Self::N100000109001),
            "100000109002" => Ok(Self::N100000109002),
            "100000109003" => Ok(Self::N100000109003),
            "100000109004" => Ok(Self::N100000109004),
            "100000109005" => Ok(Self::N100000109005),
            "100000109006" => Ok(Self::N100000109006),
            "100000109007" => Ok(Self::N100000109007),
            "100000109008" => Ok(Self::N100000109008),
            "100000109009" => Ok(Self::N100000109009),
            "100000109010" => Ok(Self::N100000109010),
            "100000109011" => Ok(Self::N100000109011),
            "100000109012" => Ok(Self::N100000109012),
            "100000109013" => Ok(Self::N100000109013),
            "100000109014" => Ok(Self::N100000109014),
            "100000109015" => Ok(Self::N100000109015),
            "100000109016" => Ok(Self::N100000109016),
            "100000109017" => Ok(Self::N100000109017),
            "100000109018" => Ok(Self::N100000109018),
            "100000109019" => Ok(Self::N100000109019),
            "100000109020" => Ok(Self::N100000109020),
            "100000109021" => Ok(Self::N100000109021),
            "100000109022" => Ok(Self::N100000109022),
            "100000109023" => Ok(Self::N100000109023),
            "100000109024" => Ok(Self::N100000109024),
            "100000109025" => Ok(Self::N100000109025),
            "100000109026" => Ok(Self::N100000109026),
            "100000109027" => Ok(Self::N100000109027),
            "100000109028" => Ok(Self::N100000109028),
            "100000109029" => Ok(Self::N100000109029),
            "100000109030" => Ok(Self::N100000109030),
            "100000109031" => Ok(Self::N100000109031),
            "100000109032" => Ok(Self::N100000109032),
            "100000109033" => Ok(Self::N100000109033),
            "100000109034" => Ok(Self::N100000109034),
            "100000109035" => Ok(Self::N100000109035),
            "100000109036" => Ok(Self::N100000109036),
            "100000109037" => Ok(Self::N100000109037),
            "100000109038" => Ok(Self::N100000109038),
            "100000109039" => Ok(Self::N100000109039),
            "100000109040" => Ok(Self::N100000109040),
            "100000109041" => Ok(Self::N100000109041),
            "100000109042" => Ok(Self::N100000109042),
            "100000109043" => Ok(Self::N100000109043),
            "100000109044" => Ok(Self::N100000109044),
            "100000109045" => Ok(Self::N100000109045),
            "100000109046" => Ok(Self::N100000109046),
            "100000109047" => Ok(Self::N100000109047),
            "100000109048" => Ok(Self::N100000109048),
            "100000109049" => Ok(Self::N100000109049),
            "100000109050" => Ok(Self::N100000109050),
            "100000109051" => Ok(Self::N100000109051),
            "100000109052" => Ok(Self::N100000109052),
            "100000109053" => Ok(Self::N100000109053),
            "100000109054" => Ok(Self::N100000109054),
            "100000109055" => Ok(Self::N100000109055),
            "100000109056" => Ok(Self::N100000109056),
            "100000109057" => Ok(Self::N100000109057),
            "100000109058" => Ok(Self::N100000109058),
            "100000109059" => Ok(Self::N100000109059),
            "100000109060" => Ok(Self::N100000109060),
            "100000109061" => Ok(Self::N100000109061),
            "100000109062" => Ok(Self::N100000109062),
            "100000109063" => Ok(Self::N100000109063),
            "100000109064" => Ok(Self::N100000109064),
            "100000109065" => Ok(Self::N100000109065),
            "100000109066" => Ok(Self::N100000109066),
            "100000109067" => Ok(Self::N100000109067),
            "100000109068" => Ok(Self::N100000109068),
            "100000109069" => Ok(Self::N100000109069),
            "100000109070" => Ok(Self::N100000109070),
            "100000109071" => Ok(Self::N100000109071),
            "100000109072" => Ok(Self::N100000109072),
            "100000109073" => Ok(Self::N100000109073),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TargetSpecies {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000108874 => "100000108874",
            Self::N100000108875 => "100000108875",
            Self::N100000108876 => "100000108876",
            Self::N100000108877 => "100000108877",
            Self::N100000108878 => "100000108878",
            Self::N100000108879 => "100000108879",
            Self::N100000108880 => "100000108880",
            Self::N100000108881 => "100000108881",
            Self::N100000108882 => "100000108882",
            Self::N100000108883 => "100000108883",
            Self::N100000108884 => "100000108884",
            Self::N100000108885 => "100000108885",
            Self::N100000108886 => "100000108886",
            Self::N100000108887 => "100000108887",
            Self::N100000108888 => "100000108888",
            Self::N100000108889 => "100000108889",
            Self::N100000108890 => "100000108890",
            Self::N100000108891 => "100000108891",
            Self::N100000108892 => "100000108892",
            Self::N100000108893 => "100000108893",
            Self::N100000108894 => "100000108894",
            Self::N100000108895 => "100000108895",
            Self::N100000108896 => "100000108896",
            Self::N100000108897 => "100000108897",
            Self::N100000108898 => "100000108898",
            Self::N100000108899 => "100000108899",
            Self::N100000108900 => "100000108900",
            Self::N100000108901 => "100000108901",
            Self::N100000108902 => "100000108902",
            Self::N100000108903 => "100000108903",
            Self::N100000108904 => "100000108904",
            Self::N100000108905 => "100000108905",
            Self::N100000108906 => "100000108906",
            Self::N100000108907 => "100000108907",
            Self::N100000108908 => "100000108908",
            Self::N100000108909 => "100000108909",
            Self::N100000108910 => "100000108910",
            Self::N100000108911 => "100000108911",
            Self::N100000108912 => "100000108912",
            Self::N100000108913 => "100000108913",
            Self::N100000108914 => "100000108914",
            Self::N100000108915 => "100000108915",
            Self::N100000108916 => "100000108916",
            Self::N100000108917 => "100000108917",
            Self::N100000108918 => "100000108918",
            Self::N100000108919 => "100000108919",
            Self::N100000108920 => "100000108920",
            Self::N100000108921 => "100000108921",
            Self::N100000108922 => "100000108922",
            Self::N100000108923 => "100000108923",
            Self::N100000108924 => "100000108924",
            Self::N100000108925 => "100000108925",
            Self::N100000108926 => "100000108926",
            Self::N100000108927 => "100000108927",
            Self::N100000108928 => "100000108928",
            Self::N100000108929 => "100000108929",
            Self::N100000108930 => "100000108930",
            Self::N100000108931 => "100000108931",
            Self::N100000108932 => "100000108932",
            Self::N100000108933 => "100000108933",
            Self::N100000108934 => "100000108934",
            Self::N100000108935 => "100000108935",
            Self::N100000108936 => "100000108936",
            Self::N100000108937 => "100000108937",
            Self::N100000108938 => "100000108938",
            Self::N100000108939 => "100000108939",
            Self::N100000108940 => "100000108940",
            Self::N100000108941 => "100000108941",
            Self::N100000108942 => "100000108942",
            Self::N100000108943 => "100000108943",
            Self::N100000108944 => "100000108944",
            Self::N100000108945 => "100000108945",
            Self::N100000108946 => "100000108946",
            Self::N100000108947 => "100000108947",
            Self::N100000108948 => "100000108948",
            Self::N100000108949 => "100000108949",
            Self::N100000108950 => "100000108950",
            Self::N100000108951 => "100000108951",
            Self::N100000108952 => "100000108952",
            Self::N100000108953 => "100000108953",
            Self::N100000108954 => "100000108954",
            Self::N100000108955 => "100000108955",
            Self::N100000108956 => "100000108956",
            Self::N100000108957 => "100000108957",
            Self::N100000108958 => "100000108958",
            Self::N100000108959 => "100000108959",
            Self::N100000108960 => "100000108960",
            Self::N100000108961 => "100000108961",
            Self::N100000108962 => "100000108962",
            Self::N100000108963 => "100000108963",
            Self::N100000108964 => "100000108964",
            Self::N100000108965 => "100000108965",
            Self::N100000108966 => "100000108966",
            Self::N100000108967 => "100000108967",
            Self::N100000108968 => "100000108968",
            Self::N100000108969 => "100000108969",
            Self::N100000108970 => "100000108970",
            Self::N100000108971 => "100000108971",
            Self::N100000108972 => "100000108972",
            Self::N100000108973 => "100000108973",
            Self::N100000108974 => "100000108974",
            Self::N100000108975 => "100000108975",
            Self::N100000108976 => "100000108976",
            Self::N100000108977 => "100000108977",
            Self::N100000108978 => "100000108978",
            Self::N100000108979 => "100000108979",
            Self::N100000108980 => "100000108980",
            Self::N100000108981 => "100000108981",
            Self::N100000108982 => "100000108982",
            Self::N100000108983 => "100000108983",
            Self::N100000108984 => "100000108984",
            Self::N100000108985 => "100000108985",
            Self::N100000108986 => "100000108986",
            Self::N100000108987 => "100000108987",
            Self::N100000108988 => "100000108988",
            Self::N100000108989 => "100000108989",
            Self::N100000108990 => "100000108990",
            Self::N100000108991 => "100000108991",
            Self::N100000108992 => "100000108992",
            Self::N100000108993 => "100000108993",
            Self::N100000108994 => "100000108994",
            Self::N100000108995 => "100000108995",
            Self::N100000108996 => "100000108996",
            Self::N100000108997 => "100000108997",
            Self::N100000108998 => "100000108998",
            Self::N100000108999 => "100000108999",
            Self::N100000109000 => "100000109000",
            Self::N100000109001 => "100000109001",
            Self::N100000109002 => "100000109002",
            Self::N100000109003 => "100000109003",
            Self::N100000109004 => "100000109004",
            Self::N100000109005 => "100000109005",
            Self::N100000109006 => "100000109006",
            Self::N100000109007 => "100000109007",
            Self::N100000109008 => "100000109008",
            Self::N100000109009 => "100000109009",
            Self::N100000109010 => "100000109010",
            Self::N100000109011 => "100000109011",
            Self::N100000109012 => "100000109012",
            Self::N100000109013 => "100000109013",
            Self::N100000109014 => "100000109014",
            Self::N100000109015 => "100000109015",
            Self::N100000109016 => "100000109016",
            Self::N100000109017 => "100000109017",
            Self::N100000109018 => "100000109018",
            Self::N100000109019 => "100000109019",
            Self::N100000109020 => "100000109020",
            Self::N100000109021 => "100000109021",
            Self::N100000109022 => "100000109022",
            Self::N100000109023 => "100000109023",
            Self::N100000109024 => "100000109024",
            Self::N100000109025 => "100000109025",
            Self::N100000109026 => "100000109026",
            Self::N100000109027 => "100000109027",
            Self::N100000109028 => "100000109028",
            Self::N100000109029 => "100000109029",
            Self::N100000109030 => "100000109030",
            Self::N100000109031 => "100000109031",
            Self::N100000109032 => "100000109032",
            Self::N100000109033 => "100000109033",
            Self::N100000109034 => "100000109034",
            Self::N100000109035 => "100000109035",
            Self::N100000109036 => "100000109036",
            Self::N100000109037 => "100000109037",
            Self::N100000109038 => "100000109038",
            Self::N100000109039 => "100000109039",
            Self::N100000109040 => "100000109040",
            Self::N100000109041 => "100000109041",
            Self::N100000109042 => "100000109042",
            Self::N100000109043 => "100000109043",
            Self::N100000109044 => "100000109044",
            Self::N100000109045 => "100000109045",
            Self::N100000109046 => "100000109046",
            Self::N100000109047 => "100000109047",
            Self::N100000109048 => "100000109048",
            Self::N100000109049 => "100000109049",
            Self::N100000109050 => "100000109050",
            Self::N100000109051 => "100000109051",
            Self::N100000109052 => "100000109052",
            Self::N100000109053 => "100000109053",
            Self::N100000109054 => "100000109054",
            Self::N100000109055 => "100000109055",
            Self::N100000109056 => "100000109056",
            Self::N100000109057 => "100000109057",
            Self::N100000109058 => "100000109058",
            Self::N100000109059 => "100000109059",
            Self::N100000109060 => "100000109060",
            Self::N100000109061 => "100000109061",
            Self::N100000109062 => "100000109062",
            Self::N100000109063 => "100000109063",
            Self::N100000109064 => "100000109064",
            Self::N100000109065 => "100000109065",
            Self::N100000109066 => "100000109066",
            Self::N100000109067 => "100000109067",
            Self::N100000109068 => "100000109068",
            Self::N100000109069 => "100000109069",
            Self::N100000109070 => "100000109070",
            Self::N100000109071 => "100000109071",
            Self::N100000109072 => "100000109072",
            Self::N100000109073 => "100000109073",
        }
    }
}
impl ::std::fmt::Display for TargetSpecies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N100000108874 => "Dove",
            Self::N100000108875 => "Quail",
            Self::N100000108876 => "Snipe",
            Self::N100000108877 => "Sparrow",
            Self::N100000108878 => "Starling",
            Self::N100000108879 => "Swan",
            Self::N100000108880 => "Turkey hen",
            Self::N100000108881 => "Turkey cock",
            Self::N100000108882 => "Turkeys",
            Self::N100000108883 => "Turkey for reproduction",
            Self::N100000108884 => "Poult",
            Self::N100000108885 => "Turtle dove",
            Self::N100000108886 => "Bison",
            Self::N100000108887 => "Buffalo",
            Self::N100000108888 => "Cows",
            Self::N100000108889 => "Cow for reproduction",
            Self::N100000108890 => "Bull for reproduction",
            Self::N100000108891 => "Ox",
            Self::N100000108892 => "Bullock",
            Self::N100000108893 => "Cattle",
            Self::N100000108894 => "Beef cattle",
            Self::N100000108895 => "Dairy cattle",
            Self::N100000108896 => "Dry cow",
            Self::N100000108897 => "Bull",
            Self::N100000108898 => "Lactating cow",
            Self::N100000108899 => "All other food producing species",
            Self::N100000108900 => "All non-food producing species",
            Self::N100000108901 => "All species \u{a0}",
            Self::N100000108902 => "Carnivores",
            Self::N100000108903 => "Domestic animals",
            Self::N100000108904 => "Fur animals",
            Self::N100000108905 => "Game animals",
            Self::N100000108906 => "Laboratory animals",
            Self::N100000108907 => "Major species",
            Self::N100000108908 => "Minor species",
            Self::N100000108909 => "Ruminant",
            Self::N100000108910 => "Ruminant and porcine",
            Self::N100000108911 => "Small animals",
            Self::N100000108912 => "Crocodile",
            Self::N100000108913 => "Frog",
            Self::N100000108914 => "Iguana",
            Self::N100000108915 => "Lizard",
            Self::N100000108916 => "Amphibians",
            Self::N100000108917 => "Reptiles",
            Self::N100000108918 => "Reptiles for production",
            Self::N100000108919 => "Snake",
            Self::N100000108920 => "Tortoise",
            Self::N100000108921 => "Turtle",
            Self::N100000108922 => "Honey bees",
            Self::N100000108923 => "Crustacean",
            Self::N100000108924 => "Spider",
            Self::N100000108925 => "Indian hen",
            Self::N100000108926 => "African Goshawk",
            Self::N100000108927 => "Black Kite",
            Self::N100000108928 => "Budgerigar",
            Self::N100000108929 => "Bustard",
            Self::N100000108930 => "Buzzard",
            Self::N100000108931 => "Hen",
            Self::N100000108932 => "Layer hen",
            Self::N100000108933 => "Cock",
            Self::N100000108934 => "Broiler",
            Self::N100000108935 => "Chickens",
            Self::N100000108936 => "Chicken embryonated eggs",
            Self::N100000108937 => "Chicken for reproduction",
            Self::N100000108938 => "Replacement chick",
            Self::N100000108939 => "Chick",
            Self::N100000108940 => "Pullet",
            Self::N100000108941 => "Cockatiel",
            Self::N100000108942 => "Cockatoo",
            Self::N100000108943 => "Common canary",
            Self::N100000108944 => "Crow",
            Self::N100000108945 => "Duck",
            Self::N100000108946 => "Duck broiler",
            Self::N100000108947 => "Duckling",
            Self::N100000108948 => "Eagle",
            Self::N100000108949 => "Emu",
            Self::N100000108950 => "Goose",
            Self::N100000108951 => "Guinea fowl",
            Self::N100000108952 => "Kestrel",
            Self::N100000108953 => "Kite",
            Self::N100000108954 => "Macaw",
            Self::N100000108955 => "Ostrich",
            Self::N100000108956 => "Birds",
            Self::N100000108957 => "Fowls",
            Self::N100000108958 => "Finch",
            Self::N100000108959 => "Galliformes",
            Self::N100000108960 => "Game birds",
            Self::N100000108961 => "Pekin duck",
            Self::N100000108962 => "Ornamental birds",
            Self::N100000108963 => "Poultry",
            Self::N100000108964 => "Owl",
            Self::N100000108965 => "Parakeet",
            Self::N100000108966 => "Parrot",
            Self::N100000108967 => "Partridge",
            Self::N100000108968 => "Peregrine Falcon",
            Self::N100000108969 => "Pheasants",
            Self::N100000108970 => "Carrier pigeon",
            Self::N100000108971 => "Newborn calves",
            Self::N100000108972 => "Pregnant cow",
            Self::N100000108973 => "Pregnant heifer",
            Self::N100000108974 => "Pre-ruminant cattle",
            Self::N100000108975 => "Ruminant cattle",
            Self::N100000108976 => "Wild cattle",
            Self::N100000108977 => "Calf",
            Self::N100000108978 => "Heifers",
            Self::N100000108979 => "Other Bovids",
            Self::N100000108980 => "Alpaca",
            Self::N100000108981 => "Camel",
            Self::N100000108982 => "Llama",
            Self::N100000108983 => "Other Camelids",
            Self::N100000108984 => "Bitch",
            Self::N100000108985 => "Bitch for reproduction",
            Self::N100000108986 => "Adult male dog",
            Self::N100000108987 => "Adult male dog for reproduction",
            Self::N100000108988 => "Dogs",
            Self::N100000108989 => "Lactating bitch",
            Self::N100000108990 => "Large dog",
            Self::N100000108991 => "Medium dog",
            Self::N100000108992 => "Pregnant bitch",
            Self::N100000108993 => "Small dog",
            Self::N100000108994 => "Very large dog",
            Self::N100000108995 => "Very small dog",
            Self::N100000108996 => "Puppy",
            Self::N100000108997 => "Foxes",
            Self::N100000108998 => "Jackal",
            Self::N100000108999 => "Other Canids",
            Self::N100000109000 => "Raccoon dogs",
            Self::N100000109001 => "Wolf",
            Self::N100000109002 => "Chamois",
            Self::N100000109003 => "Other Caprines",
            Self::N100000109004 => "Adult female goat",
            Self::N100000109005 => "Adult male goat",
            Self::N100000109006 => "Dry adult female goat",
            Self::N100000109007 => "Goats",
            Self::N100000109008 => "Lactating adult female goat",
            Self::N100000109009 => "Pregnant adult female goat",
            Self::N100000109010 => "Pre-ruminant goat",
            Self::N100000109011 => "Ruminant goat",
            Self::N100000109012 => "Wild goat",
            Self::N100000109013 => "Kid",
            Self::N100000109014 => "Other Ovids",
            Self::N100000109015 => "Ewe",
            Self::N100000109016 => "Ram",
            Self::N100000109017 => "Dry ewe",
            Self::N100000109018 => "Lactating ewe",
            Self::N100000109019 => "Pregnant ewe",
            Self::N100000109020 => "Pre-ruminant sheep",
            Self::N100000109021 => "Ruminant sheep",
            Self::N100000109022 => "Sheep",
            Self::N100000109023 => "Sheep for meat production",
            Self::N100000109024 => "Dairy sheep",
            Self::N100000109025 => "Wild sheep",
            Self::N100000109026 => "Lamb",
            Self::N100000109027 => "Elk",
            Self::N100000109028 => "Fallow deer",
            Self::N100000109029 => "Moose",
            Self::N100000109030 => "Antelope",
            Self::N100000109031 => "Cervid",
            Self::N100000109032 => "Deer",
            Self::N100000109033 => "Other Deer",
            Self::N100000109034 => "Red deer",
            Self::N100000109035 => "Reindeer",
            Self::N100000109036 => "Roe deer",
            Self::N100000109037 => "Donkey",
            Self::N100000109038 => "Mare",
            Self::N100000109039 => "Gelding",
            Self::N100000109040 => "Horses",
            Self::N100000109041 => "Stallion",
            Self::N100000109042 => "Pony",
            Self::N100000109043 => "Pregnant mare",
            Self::N100000109044 => "Non food-producing horse",
            Self::N100000109045 => "Suckling colt",
            Self::N100000109046 => "Colt",
            Self::N100000109047 => "Mule",
            Self::N100000109048 => "Equid",
            Self::N100000109049 => "Female equid",
            Self::N100000109050 => "Other Equids",
            Self::N100000109051 => "Zebra",
            Self::N100000109052 => "Bobcat",
            Self::N100000109053 => "Adult female cat",
            Self::N100000109054 => "Adult female cat for reproduction",
            Self::N100000109055 => "Adult male cat",
            Self::N100000109056 => "Cats",
            Self::N100000109057 => "Lactating cat",
            Self::N100000109058 => "Large cat",
            Self::N100000109059 => "Medium cat",
            Self::N100000109060 => "Pregnant cat",
            Self::N100000109061 => "Small cat",
            Self::N100000109062 => "Kitten",
            Self::N100000109063 => "Cougar",
            Self::N100000109064 => "Jaguar",
            Self::N100000109065 => "Leopard",
            Self::N100000109066 => "Lion",
            Self::N100000109067 => "Lynx",
            Self::N100000109068 => "Other Felids",
            Self::N100000109069 => "Tiger",
            Self::N100000109070 => "Tsushima wild cat",
            Self::N100000109071 => "Other Leporids",
            Self::N100000109072 => "Hare",
            Self::N100000109073 => "Female rabbit for reproduction",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TargetSpecies {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TargetSpecies {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TargetSpecies> for Coding {
    fn from(code: TargetSpecies) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/target-species".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TargetSpecies> for CodeableConcept {
    fn from(code: TargetSpecies) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TaskCode](http://hl7.org/fhir/ValueSet/task-code.html)**. Codes indicating the type of action that is expected to be performed\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TaskCode {
    /** **abort**

Mark the focal resource as no longer active. Abort, cancel or withdraw the focal resource, as appropriate for the type of resource. */
    Abort,
    /** **approve**

Activate/approve the focal resource. Take what actions are needed to transition the focus resource from 'draft' to 'active' or 'in-progress', as appropriate for the resource type.  This may involve additing additional content, approval, validation, etc. */
    Approve,
    /** **change**

Change the focal resource. Update the focal resource of the owning system to reflect the content specified as the Task.focus */
    Change,
    /** **fulfill**

Fulfill the focal request. Act to perform the actions described in the focus request.  This might result in a 'more assertive' request (order for a plan or proposal, filler order for a placer order), but is intend to eventually result in events.  The degree of fulfillment requested might be limited by Task.restriction. */
    Fulfill,
    /** **instantiate**

Instantiate the focal definition. Act to perform the actions defined in the focus definition resource (ActivityDefinition, PlanDefinition, Questionnaire, etc.)  For PlanDefinition or ActivityDefinition, this might result in a 'more assertive' request (order for a plan or proposal, filler order for a placer order), but is intend to eventually result in events.  For Questionnaire, this would result in a QuestionnaireResponse - and possibly resources constructed using data extracted from the response.  The degree of fulfillment requested might be limited by Task.restriction. */
    Instantiate,
    /** **replace**

Replace the focal resource with the input resource. Replace the focal resource with the specified input resource */
    Replace,
    /** **resume**

Re-activate the focal resource. Transition the focal resource from 'suspended' to 'active' or 'in-progress' as appropriate for the resource type. */
    Resume,
    /** **suspend**

Suspend the focal resource. Transition the focal resource from 'active' or 'in-progress' to 'suspended' */
    Suspend,
}
impl ::core::str::FromStr for TaskCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abort" => Ok(Self::Abort),
            "approve" => Ok(Self::Approve),
            "change" => Ok(Self::Change),
            "fulfill" => Ok(Self::Fulfill),
            "instantiate" => Ok(Self::Instantiate),
            "replace" => Ok(Self::Replace),
            "resume" => Ok(Self::Resume),
            "suspend" => Ok(Self::Suspend),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TaskCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abort => "abort",
            Self::Approve => "approve",
            Self::Change => "change",
            Self::Fulfill => "fulfill",
            Self::Instantiate => "instantiate",
            Self::Replace => "replace",
            Self::Resume => "resume",
            Self::Suspend => "suspend",
        }
    }
}
impl ::std::fmt::Display for TaskCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Abort => "Mark the focal resource as no longer active",
            Self::Approve => "Activate/approve the focal resource",
            Self::Change => "Change the focal resource",
            Self::Fulfill => "Fulfill the focal request",
            Self::Instantiate => "Instantiate the focal definition",
            Self::Replace => "Replace the focal resource with the input resource",
            Self::Resume => "Re-activate the focal resource",
            Self::Suspend => "Suspend the focal resource",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TaskCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TaskCode> for Coding {
    fn from(code: TaskCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/task-code.html".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TaskCode> for CodeableConcept {
    fn from(code: TaskCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TaskIntent](http://hl7.org/fhir/task-intent)**. Distinguishes whether the task is a proposal, plan or full order.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TaskIntent {
    /** **unknown**

Unknown. The intent is not known.  When dealing with Task, it's not always known (or relevant) how the task was initiated - i.e. whether it was proposed, planned, ordered or just done spontaneously. */
    Unknown,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TaskIntent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "unknown" => Ok(Self::Unknown),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TaskIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for TaskIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Unknown => "Unknown",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TaskIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TaskIntent> for Coding {
    fn from(code: TaskIntent) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/task-intent".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TaskIntent> for CodeableConcept {
    fn from(code: TaskIntent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TaskStatus](http://hl7.org/fhir/ValueSet/task-status)**. The current status of the task.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TaskStatus {
    /** **accepted**

Accepted. The potential performer has agreed to execute the task but has not yet started work. */
    Accepted,
    /** **cancelled**

Cancelled. The task was not completed. */
    Cancelled,
    /** **completed**

Completed. The task has been completed. */
    Completed,
    /** **draft**

Draft. The task is not yet ready to be acted upon. */
    Draft,
    /** **entered-in-error**

Entered in Error. The task should never have existed and is retained only because of the possibility it may have used. */
    EnteredInError,
    /** **failed**

Failed. The task was attempted but could not be completed due to some error. */
    Failed,
    /** **in-progress**

In Progress. The task has been started but is not yet complete. */
    InProgress,
    /** **on-hold**

On Hold. The task has been started but work has been paused. */
    OnHold,
    /** **ready**

Ready. The task is ready to be performed, but no action has yet been taken.  Used in place of requested/received/accepted/rejected when request assignment and acceptance is a given. */
    Ready,
    /** **received**

Received. A potential performer has claimed ownership of the task and is evaluating whether to perform it. */
    Received,
    /** **rejected**

Rejected. The potential performer who claimed ownership of the task has decided not to execute it prior to performing any action. */
    Rejected,
    /** **requested**

Requested. The task is ready to be acted upon and action is sought. */
    Requested,
}
impl ::core::str::FromStr for TaskStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "failed" => Ok(Self::Failed),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "ready" => Ok(Self::Ready),
            "received" => Ok(Self::Received),
            "rejected" => Ok(Self::Rejected),
            "requested" => Ok(Self::Requested),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TaskStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Failed => "failed",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::Ready => "ready",
            Self::Received => "received",
            Self::Rejected => "rejected",
            Self::Requested => "requested",
        }
    }
}
impl ::std::fmt::Display for TaskStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Accepted => "Accepted",
            Self::Cancelled => "Cancelled",
            Self::Completed => "Completed",
            Self::Draft => "Draft",
            Self::EnteredInError => "Entered in Error",
            Self::Failed => "Failed",
            Self::InProgress => "In Progress",
            Self::OnHold => "On Hold",
            Self::Ready => "Ready",
            Self::Received => "Received",
            Self::Rejected => "Rejected",
            Self::Requested => "Requested",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TaskStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TaskStatus> for Coding {
    fn from(code: TaskStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/task-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TaskStatus> for CodeableConcept {
    fn from(code: TaskStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TaskStatusReason](http://hl7.org/fhir/ValueSet/task-status-reason)**. The current status reason of the task.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TaskStatusReason {
    /** **environmental-issue**

Environmental-issue. Something in the environment is preventing task completion. */
    EnvironmentalIssue,
    /** **equipment-issue**

Equipment-issue. A piece of equipment necessary for completion of the task is malfunctioning. */
    EquipmentIssue,
    /** **misidentified**

Misidentified. Something related to the task was misidentified. */
    Misidentified,
    /** **missing**

Missing. An item nessary for task completion is missing. */
    Missing,
    /** **personnel-issue**

Personnel-issue. Key personnel necessary for task completion are not present. */
    PersonnelIssue,
}
impl ::core::str::FromStr for TaskStatusReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "environmental-issue" => Ok(Self::EnvironmentalIssue),
            "equipment-issue" => Ok(Self::EquipmentIssue),
            "misidentified" => Ok(Self::Misidentified),
            "missing" => Ok(Self::Missing),
            "personnel-issue" => Ok(Self::PersonnelIssue),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TaskStatusReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::EnvironmentalIssue => "environmental-issue",
            Self::EquipmentIssue => "equipment-issue",
            Self::Misidentified => "misidentified",
            Self::Missing => "missing",
            Self::PersonnelIssue => "personnel-issue",
        }
    }
}
impl ::std::fmt::Display for TaskStatusReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::EnvironmentalIssue => "Environmental-issue",
            Self::EquipmentIssue => "Equipment-issue",
            Self::Misidentified => "Misidentified",
            Self::Missing => "Missing",
            Self::PersonnelIssue => "Personnel-issue",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TaskStatusReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskStatusReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TaskStatusReason> for Coding {
    fn from(code: TaskStatusReason) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/task-status-reason".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TaskStatusReason> for CodeableConcept {
    fn from(code: TaskStatusReason) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TemplateStatusCodeLifeCycle](urn:oid:2.16.840.1.113883.3.1937.98.11.8)**. Life cycle of the Status Code of a Template Design (Version)\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TemplateStatusCodeLifeCycle {
    /** **active**

active. Design has been deemed fit for the intended purpose and is published by the governance group. */
    Active,
    /** **cancelled**

Cancelled. A drafted design is determined to be erroneous or not fit for intended purpose and is discontinued before ever being published in an active state. */
    Cancelled,
    /** **draft**

Draft. Design is under development (nascent). */
    Draft,
    /** **pending**

Under pre-publication review. Design is completed and is being reviewed. */
    Pending,
    /** **rejected**

Rejected. A previously drafted design is determined to be erroneous or not fit for intended purpose and is discontinued before ever being published for consideration in a pending state. */
    Rejected,
    /** **retired**

retired. A previously active design is discontinued from use. It should no longer be used for future designs, but for historical purposes may be used to process data previously recorded using this design. A newer design may or may not exist. The design is published in the retired state. */
    Retired,
    /** **review**

In Review. Design is active, but is under review. The review may result in a change to the design. The change may necessitate a new version to be created. This in turn may result in the prior version of the template to be retired. Alternatively, the review may result in a change to the design that does not require a new version to be created, or it may result in no change to the design at all. */
    Review,
    /** **terminated**

Terminated. A design is determined to be erroneous or not fit for the intended purpose and should no longer be used, even for historical purposes. No new designs can be developed for this template. The associated template no longer needs to be published, but if published, is shown in the terminated state. */
    Terminated,
}
impl ::core::str::FromStr for TemplateStatusCodeLifeCycle {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "pending" => Ok(Self::Pending),
            "rejected" => Ok(Self::Rejected),
            "retired" => Ok(Self::Retired),
            "review" => Ok(Self::Review),
            "terminated" => Ok(Self::Terminated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TemplateStatusCodeLifeCycle {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::Pending => "pending",
            Self::Rejected => "rejected",
            Self::Retired => "retired",
            Self::Review => "review",
            Self::Terminated => "terminated",
        }
    }
}
impl ::std::fmt::Display for TemplateStatusCodeLifeCycle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Active => "active",
            Self::Cancelled => "Cancelled",
            Self::Draft => "Draft",
            Self::Pending => "Under pre-publication review",
            Self::Rejected => "Rejected",
            Self::Retired => "retired",
            Self::Review => "In Review",
            Self::Terminated => "Terminated",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TemplateStatusCodeLifeCycle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TemplateStatusCodeLifeCycle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TemplateStatusCodeLifeCycle> for Coding {
    fn from(code: TemplateStatusCodeLifeCycle) -> Self {
        Coding::builder()
            .system("urn:oid:2.16.840.1.113883.3.1937.98.11.8".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TemplateStatusCodeLifeCycle> for CodeableConcept {
    fn from(code: TemplateStatusCodeLifeCycle) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TestReportActionResult](http://hl7.org/fhir/ValueSet/report-action-result-codes)**. The results of executing an action.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestReportActionResult {
    /** **error**

Error. The action encountered a fatal error and the engine was unable to process. */
    Error,
    /** **fail**

Fail. The action failed. */
    Fail,
    /** **pass**

Pass. The action was successful. */
    Pass,
    /** **skip**

Skip. The action was skipped. */
    Skip,
    /** **warning**

Warning. The action passed but with warnings. */
    Warning,
}
impl ::core::str::FromStr for TestReportActionResult {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "fail" => Ok(Self::Fail),
            "pass" => Ok(Self::Pass),
            "skip" => Ok(Self::Skip),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportActionResult {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Fail => "fail",
            Self::Pass => "pass",
            Self::Skip => "skip",
            Self::Warning => "warning",
        }
    }
}
impl ::std::fmt::Display for TestReportActionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Error => "Error",
            Self::Fail => "Fail",
            Self::Pass => "Pass",
            Self::Skip => "Skip",
            Self::Warning => "Warning",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TestReportActionResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportActionResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportActionResult> for Coding {
    fn from(code: TestReportActionResult) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/report-action-result-codes".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TestReportActionResult> for CodeableConcept {
    fn from(code: TestReportActionResult) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TestReportParticipantType](http://hl7.org/fhir/ValueSet/report-participant-type)**. The type of participant.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestReportParticipantType {
    /** **client**

Client. A FHIR Client. */
    Client,
    /** **server**

Server. A FHIR Server. */
    Server,
    /** **test-engine**

Test Engine. The test execution engine. */
    TestEngine,
}
impl ::core::str::FromStr for TestReportParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client" => Ok(Self::Client),
            "server" => Ok(Self::Server),
            "test-engine" => Ok(Self::TestEngine),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Client => "client",
            Self::Server => "server",
            Self::TestEngine => "test-engine",
        }
    }
}
impl ::std::fmt::Display for TestReportParticipantType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Client => "Client",
            Self::Server => "Server",
            Self::TestEngine => "Test Engine",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TestReportParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportParticipantType> for Coding {
    fn from(code: TestReportParticipantType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/report-participant-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TestReportParticipantType> for CodeableConcept {
    fn from(code: TestReportParticipantType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TestReportResult](http://hl7.org/fhir/ValueSet/report-result-codes)**. The reported execution result.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestReportResult {
    /** **fail**

Fail. One or more test operations failed one or more asserts. */
    Fail,
    /** **pass**

Pass. All test operations successfully passed all asserts. */
    Pass,
    /** **pending**

Pending. One or more test operations is pending execution completion. */
    Pending,
}
impl ::core::str::FromStr for TestReportResult {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fail" => Ok(Self::Fail),
            "pass" => Ok(Self::Pass),
            "pending" => Ok(Self::Pending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportResult {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fail => "fail",
            Self::Pass => "pass",
            Self::Pending => "pending",
        }
    }
}
impl ::std::fmt::Display for TestReportResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Fail => "Fail",
            Self::Pass => "Pass",
            Self::Pending => "Pending",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TestReportResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportResult> for Coding {
    fn from(code: TestReportResult) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/report-result-codes".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TestReportResult> for CodeableConcept {
    fn from(code: TestReportResult) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TestReportStatus](http://hl7.org/fhir/ValueSet/report-status-codes)**. The current status of the test report.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestReportStatus {
    /** **completed**

Completed. All test operations have completed. */
    Completed,
    /** **entered-in-error**

Entered In Error. This test report was entered or created in error. */
    EnteredInError,
    /** **in-progress**

In Progress. A test operations is currently executing. */
    InProgress,
    /** **stopped**

Stopped. The test script execution was manually stopped. */
    Stopped,
    /** **waiting**

Waiting. A test operation is waiting for an external client request. */
    Waiting,
}
impl ::core::str::FromStr for TestReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "stopped" => Ok(Self::Stopped),
            "waiting" => Ok(Self::Waiting),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Stopped => "stopped",
            Self::Waiting => "waiting",
        }
    }
}
impl ::std::fmt::Display for TestReportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Completed => "Completed",
            Self::EnteredInError => "Entered In Error",
            Self::InProgress => "In Progress",
            Self::Stopped => "Stopped",
            Self::Waiting => "Waiting",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TestReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestReportStatus> for Coding {
    fn from(code: TestReportStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/report-status-codes".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TestReportStatus> for CodeableConcept {
    fn from(code: TestReportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TestScriptRequestMethodCode](http://hl7.org/fhir/ValueSet/http-operations)**. The allowable request method or HTTP operation codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestScriptRequestMethodCode {
    /** **delete**

DELETE. HTTP DELETE operation. */
    Delete,
    /** **get**

GET. HTTP GET operation. */
    Get,
    /** **head**

HEAD. HTTP HEAD operation. */
    Head,
    /** **options**

OPTIONS. HTTP OPTIONS operation. */
    Options,
    /** **patch**

PATCH. HTTP PATCH operation. */
    Patch,
    /** **post**

POST. HTTP POST operation. */
    Post,
    /** **put**

PUT. HTTP PUT operation. */
    Put,
}
impl ::core::str::FromStr for TestScriptRequestMethodCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "delete" => Ok(Self::Delete),
            "get" => Ok(Self::Get),
            "head" => Ok(Self::Head),
            "options" => Ok(Self::Options),
            "patch" => Ok(Self::Patch),
            "post" => Ok(Self::Post),
            "put" => Ok(Self::Put),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestScriptRequestMethodCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Delete => "delete",
            Self::Get => "get",
            Self::Head => "head",
            Self::Options => "options",
            Self::Patch => "patch",
            Self::Post => "post",
            Self::Put => "put",
        }
    }
}
impl ::std::fmt::Display for TestScriptRequestMethodCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Delete => "DELETE",
            Self::Get => "GET",
            Self::Head => "HEAD",
            Self::Options => "OPTIONS",
            Self::Patch => "PATCH",
            Self::Post => "POST",
            Self::Put => "PUT",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TestScriptRequestMethodCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptRequestMethodCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptRequestMethodCode> for Coding {
    fn from(code: TestScriptRequestMethodCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/http-operations".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TestScriptRequestMethodCode> for CodeableConcept {
    fn from(code: TestScriptRequestMethodCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TestScriptScopeConformanceType](http://hl7.org/fhir/ValueSet/testscript-scope-conformance-codes)**. The expectation of whether the test must pass for the system to be considered conformant with the artifact.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestScriptScopeConformanceType {
    /** **optional**

Optional. All tests are expected to pass but non-pass statuses may be allowed. */
    Optional,
    /** **required**

Required. All tests are expected to pass. Warning statuses are permitted. This is the default value. */
    Required,
    /** **strict**

Strict. All tests are expected to pass. Warnings are treated as a failure. */
    Strict,
}
impl ::core::str::FromStr for TestScriptScopeConformanceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "optional" => Ok(Self::Optional),
            "required" => Ok(Self::Required),
            "strict" => Ok(Self::Strict),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestScriptScopeConformanceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Optional => "optional",
            Self::Required => "required",
            Self::Strict => "strict",
        }
    }
}
impl ::std::fmt::Display for TestScriptScopeConformanceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Optional => "Optional",
            Self::Required => "Required",
            Self::Strict => "Strict",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TestScriptScopeConformanceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptScopeConformanceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptScopeConformanceType> for Coding {
    fn from(code: TestScriptScopeConformanceType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/testscript-scope-conformance-codes"
                    .to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TestScriptScopeConformanceType> for CodeableConcept {
    fn from(code: TestScriptScopeConformanceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TestScriptScopePhaseType](http://hl7.org/fhir/ValueSet/testscript-scope-phase-codes)**. The phase of testing for this artifact.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestScriptScopePhaseType {
    /** **integration**

Integration. The internal system to system phase. */
    Integration,
    /** **production**

Production. The live system to system phase (Note, this may involve pii/phi data). */
    Production,
    /** **unit**

Unit. The development or implementation phase. */
    Unit,
}
impl ::core::str::FromStr for TestScriptScopePhaseType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "integration" => Ok(Self::Integration),
            "production" => Ok(Self::Production),
            "unit" => Ok(Self::Unit),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestScriptScopePhaseType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Integration => "integration",
            Self::Production => "production",
            Self::Unit => "unit",
        }
    }
}
impl ::std::fmt::Display for TestScriptScopePhaseType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Integration => "Integration",
            Self::Production => "Production",
            Self::Unit => "Unit",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TestScriptScopePhaseType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptScopePhaseType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TestScriptScopePhaseType> for Coding {
    fn from(code: TestScriptScopePhaseType) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/testscript-scope-phase-codes".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TestScriptScopePhaseType> for CodeableConcept {
    fn from(code: TestScriptScopePhaseType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TherapyRelationshipType](http://hl7.org/fhir/ValueSet/therapy-relationship-type)**. Classification of relationship between a therapy and a contraindication or an indication.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TherapyRelationshipType {
    /** **contraindicated-except-with**

Contraindicated unless the other therapy is given. Contraindicated unless the other therapy is given */
    ContraindicatedExceptWith,
    /** **contraindicated-only-with**

Only contraindicated if the other therapy is given. Only contraindicated if the other therapy is given */
    ContraindicatedOnlyWith,
    /** **indicated-except-with**

Indicated except when the other therapy is given. Indicated except when the other therapy is given */
    IndicatedExceptWith,
    /** **indicated-only-after**

Indicated only if the other therapy is planned to be given afterwards (prep). Indicated only if the other therapy is planned to be given afterwards (prep) */
    IndicatedOnlyAfter,
    /** **indicated-only-before**

Indicated only if the other therapy was given before (follow-up). Indicated only if the other therapy was given before (follow-up) */
    IndicatedOnlyBefore,
    /** **indicated-only-with**

Indicated only when the other therapy is given (co-occurrent). Indicated only when the other therapy is given (co-occurrent) */
    IndicatedOnlyWith,
    /** **replace-other-therapy**

Indicated to replace the other therapy. Indicated to replace the other therapy */
    ReplaceOtherTherapy,
    /** **replace-other-therapy-contraindicated**

Indicated to replace the other contraindicated therapy. Indicated to replace the other contraindicated therapy. */
    ReplaceOtherTherapyContraindicated,
    /** **replace-other-therapy-not-effective**

Indicated to replace the other therapy not effective on patient. Indicated to replace the other therapy not effective on patient */
    ReplaceOtherTherapyNotEffective,
    /** **replace-other-therapy-not-tolerated**

Indicated to replace the other therapy not well tolerated by patient. Indicated to replace the other therapy not well tolerated by patient */
    ReplaceOtherTherapyNotTolerated,
}
impl ::core::str::FromStr for TherapyRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contraindicated-except-with" => Ok(Self::ContraindicatedExceptWith),
            "contraindicated-only-with" => Ok(Self::ContraindicatedOnlyWith),
            "indicated-except-with" => Ok(Self::IndicatedExceptWith),
            "indicated-only-after" => Ok(Self::IndicatedOnlyAfter),
            "indicated-only-before" => Ok(Self::IndicatedOnlyBefore),
            "indicated-only-with" => Ok(Self::IndicatedOnlyWith),
            "replace-other-therapy" => Ok(Self::ReplaceOtherTherapy),
            "replace-other-therapy-contraindicated" => {
                Ok(Self::ReplaceOtherTherapyContraindicated)
            }
            "replace-other-therapy-not-effective" => {
                Ok(Self::ReplaceOtherTherapyNotEffective)
            }
            "replace-other-therapy-not-tolerated" => {
                Ok(Self::ReplaceOtherTherapyNotTolerated)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TherapyRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ContraindicatedExceptWith => "contraindicated-except-with",
            Self::ContraindicatedOnlyWith => "contraindicated-only-with",
            Self::IndicatedExceptWith => "indicated-except-with",
            Self::IndicatedOnlyAfter => "indicated-only-after",
            Self::IndicatedOnlyBefore => "indicated-only-before",
            Self::IndicatedOnlyWith => "indicated-only-with",
            Self::ReplaceOtherTherapy => "replace-other-therapy",
            Self::ReplaceOtherTherapyContraindicated => {
                "replace-other-therapy-contraindicated"
            }
            Self::ReplaceOtherTherapyNotEffective => {
                "replace-other-therapy-not-effective"
            }
            Self::ReplaceOtherTherapyNotTolerated => {
                "replace-other-therapy-not-tolerated"
            }
        }
    }
}
impl ::std::fmt::Display for TherapyRelationshipType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ContraindicatedExceptWith => {
                "Contraindicated unless the other therapy is given"
            }
            Self::ContraindicatedOnlyWith => {
                "Only contraindicated if the other therapy is given"
            }
            Self::IndicatedExceptWith => {
                "Indicated except when the other therapy is given"
            }
            Self::IndicatedOnlyAfter => {
                "Indicated only if the other therapy is planned to be given afterwards (prep)"
            }
            Self::IndicatedOnlyBefore => {
                "Indicated only if the other therapy was given before (follow-up)"
            }
            Self::IndicatedOnlyWith => {
                "Indicated only when the other therapy is given (co-occurrent)"
            }
            Self::ReplaceOtherTherapy => "Indicated to replace the other therapy",
            Self::ReplaceOtherTherapyContraindicated => {
                "Indicated to replace the other contraindicated therapy"
            }
            Self::ReplaceOtherTherapyNotEffective => {
                "Indicated to replace the other therapy not effective on patient"
            }
            Self::ReplaceOtherTherapyNotTolerated => {
                "Indicated to replace the other therapy not well tolerated by patient"
            }
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TherapyRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TherapyRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TherapyRelationshipType> for Coding {
    fn from(code: TherapyRelationshipType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/therapy-relationship-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TherapyRelationshipType> for CodeableConcept {
    fn from(code: TherapyRelationshipType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TimingAbbreviation](http://terminology.hl7.org/CodeSystem/timing-abbreviation)**. Code for a known / defined timing pattern.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TimingAbbreviation {
    /** **C**

Continuous (frequency). Service is provided continuously between start time and stop time. */
    C,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TimingAbbreviation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "C" => Ok(Self::C),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TimingAbbreviation {
    fn as_ref(&self) -> &str {
        match self {
            Self::C => "C",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for TimingAbbreviation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::C => "Continuous (frequency)",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TimingAbbreviation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TimingAbbreviation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TimingAbbreviation> for Coding {
    fn from(code: TimingAbbreviation) -> Self {
        Coding::builder()
            .system(
                "http://terminology.hl7.org/CodeSystem/timing-abbreviation".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TimingAbbreviation> for CodeableConcept {
    fn from(code: TimingAbbreviation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TitleType](http://hl7.org/fhir/ValueSet/title-type)**. Used to express the reason and specific aspect for the variant title, such as language and specific language.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TitleType {
    /** **acronym**

Acronym. Abbreviation used as title */
    Acronym,
    /** **autotranslated**

Different language derived from autotranslation. Machine translated form of title in a different language, language element codes the language into which it was translated by machine. */
    Autotranslated,
    /** **duplicate-uid**

Different text for the same object with a different identifier. An alternative form of the title in two or more entries, e.g. in multiple medline entries */
    DuplicateUid,
    /** **earlier-title**

Different text in an earlier version. Alternative form of title in an earlier version such as epub ahead of print. */
    EarlierTitle,
    /** **human-use**

Human use. Human-friendly title */
    HumanUse,
    /** **language**

Different language. Additional form of title in a different language. */
    Language,
    /** **machine-use**

Machine use. Machine-friendly title */
    MachineUse,
    /** **official**

Official title. The official or authoritative title. */
    Official,
    /** **plain-language**

Plain language title. Title using language common to lay public discourse. */
    PlainLanguage,
    /** **primary**

Primary title. Main title for common use. The primary title used for representation if multiple titles exist. */
    Primary,
    /** **scientific**

Scientific title. Title using scientific terminology. */
    Scientific,
    /** **short-title**

Short title. Brief title (e.g. 'running title' or title used in page headers) */
    ShortTitle,
    /** **subtitle**

Subtitle. Subtitle or secondary title. */
    Subtitle,
}
impl ::core::str::FromStr for TitleType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acronym" => Ok(Self::Acronym),
            "autotranslated" => Ok(Self::Autotranslated),
            "duplicate-uid" => Ok(Self::DuplicateUid),
            "earlier-title" => Ok(Self::EarlierTitle),
            "human-use" => Ok(Self::HumanUse),
            "language" => Ok(Self::Language),
            "machine-use" => Ok(Self::MachineUse),
            "official" => Ok(Self::Official),
            "plain-language" => Ok(Self::PlainLanguage),
            "primary" => Ok(Self::Primary),
            "scientific" => Ok(Self::Scientific),
            "short-title" => Ok(Self::ShortTitle),
            "subtitle" => Ok(Self::Subtitle),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TitleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acronym => "acronym",
            Self::Autotranslated => "autotranslated",
            Self::DuplicateUid => "duplicate-uid",
            Self::EarlierTitle => "earlier-title",
            Self::HumanUse => "human-use",
            Self::Language => "language",
            Self::MachineUse => "machine-use",
            Self::Official => "official",
            Self::PlainLanguage => "plain-language",
            Self::Primary => "primary",
            Self::Scientific => "scientific",
            Self::ShortTitle => "short-title",
            Self::Subtitle => "subtitle",
        }
    }
}
impl ::std::fmt::Display for TitleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Acronym => "Acronym",
            Self::Autotranslated => "Different language derived from autotranslation",
            Self::DuplicateUid => {
                "Different text for the same object with a different identifier"
            }
            Self::EarlierTitle => "Different text in an earlier version",
            Self::HumanUse => "Human use",
            Self::Language => "Different language",
            Self::MachineUse => "Machine use",
            Self::Official => "Official title",
            Self::PlainLanguage => "Plain language title",
            Self::Primary => "Primary title",
            Self::Scientific => "Scientific title",
            Self::ShortTitle => "Short title",
            Self::Subtitle => "Subtitle",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TitleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TitleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TitleType> for Coding {
    fn from(code: TitleType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/title-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TitleType> for CodeableConcept {
    fn from(code: TitleType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TransportCode](http://hl7.org/fhir/ValueSet/transport-code.html)**. Codes indicating the type of action that is expected to be performed\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TransportCode {
    /** **abort**

Mark the focal resource as no longer active. Abort, cancel or withdraw the focal resource, as appropriate for the type of resource. */
    Abort,
    /** **approve**

Activate/approve the focal resource. Take what actions are needed to transition the focus resource from 'draft' to 'active' or 'in-progress', as appropriate for the resource type.  This may involve additing additional content, approval, validation, etc. */
    Approve,
    /** **change**

Change the focal resource. Update the focal resource of the owning system to reflect the content specified as the Task.focus */
    Change,
    /** **fulfill**

Fulfill the focal request. Act to perform the actions described in the focus request.  This might result in a 'more assertive' request (order for a plan or proposal, filler order for a placer order), but is intend to eventually result in events.  The degree of fulfillment requested might be limited by Task.restriction. */
    Fulfill,
    /** **instantiate**

Instantiate the focal definition. Act to perform the actions defined in the focus definition resource (ActivityDefinition, PlanDefinition, Questionnaire, etc.)  For PlanDefinition or ActivityDefinition, this might result in a 'more assertive' request (order for a plan or proposal, filler order for a placer order), but is intend to eventually result in events.  For Questionnaire, this would result in a QuestionnaireResponse - and possibly resources constructed using data extracted from the response.  The degree of fulfillment requested might be limited by Task.restriction. */
    Instantiate,
    /** **replace**

Replace the focal resource with the input resource. Replace the focal resource with the specified input resource */
    Replace,
    /** **resume**

Re-activate the focal resource. Transition the focal resource from 'suspended' to 'active' or 'in-progress' as appropriate for the resource type. */
    Resume,
    /** **suspend**

Suspend the focal resource. Transition the focal resource from 'active' or 'in-progress' to 'suspended' */
    Suspend,
}
impl ::core::str::FromStr for TransportCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abort" => Ok(Self::Abort),
            "approve" => Ok(Self::Approve),
            "change" => Ok(Self::Change),
            "fulfill" => Ok(Self::Fulfill),
            "instantiate" => Ok(Self::Instantiate),
            "replace" => Ok(Self::Replace),
            "resume" => Ok(Self::Resume),
            "suspend" => Ok(Self::Suspend),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TransportCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abort => "abort",
            Self::Approve => "approve",
            Self::Change => "change",
            Self::Fulfill => "fulfill",
            Self::Instantiate => "instantiate",
            Self::Replace => "replace",
            Self::Resume => "resume",
            Self::Suspend => "suspend",
        }
    }
}
impl ::std::fmt::Display for TransportCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Abort => "Mark the focal resource as no longer active",
            Self::Approve => "Activate/approve the focal resource",
            Self::Change => "Change the focal resource",
            Self::Fulfill => "Fulfill the focal request",
            Self::Instantiate => "Instantiate the focal definition",
            Self::Replace => "Replace the focal resource with the input resource",
            Self::Resume => "Re-activate the focal resource",
            Self::Suspend => "Suspend the focal resource",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TransportCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TransportCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TransportCode> for Coding {
    fn from(code: TransportCode) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/transport-code.html".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TransportCode> for CodeableConcept {
    fn from(code: TransportCode) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TransportIntent](http://hl7.org/fhir/transport-intent)**. Distinguishes whether the transport is a proposal, plan or full order.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TransportIntent {
    /** **unknown**

Unknown. The intent is not known.  When dealing with Transport, it's not always known (or relevant) how the transport was initiated - i.e. whether it was proposed, planned, ordered or just done spontaneously. */
    Unknown,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TransportIntent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "unknown" => Ok(Self::Unknown),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TransportIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl ::std::fmt::Display for TransportIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Unknown => "Unknown",
            Self::_Custom(s) => s.as_str(),
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TransportIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TransportIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TransportIntent> for Coding {
    fn from(code: TransportIntent) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/transport-intent".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TransportIntent> for CodeableConcept {
    fn from(code: TransportIntent) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TransportStatus](http://hl7.org/fhir/ValueSet/transport-status)**. Status of transport.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TransportStatus {
    /** **abandoned**

Abandoned. Transport was started but not completed. */
    Abandoned,
    /** **cancelled**

Cancelled. Transport was cancelled before started. */
    Cancelled,
    /** **completed**

Completed. Transport has been completed. */
    Completed,
    /** **entered-in-error**

Entered In Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "abandoned" rather than "entered-in-error".). */
    EnteredInError,
    /** **in-progress**

In Progress. Transport has started but not completed. */
    InProgress,
    /** **planned**

Planned. Planned transport that is not yet requested. */
    Planned,
}
impl ::core::str::FromStr for TransportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abandoned" => Ok(Self::Abandoned),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "planned" => Ok(Self::Planned),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TransportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abandoned => "abandoned",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Planned => "planned",
        }
    }
}
impl ::std::fmt::Display for TransportStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Abandoned => "Abandoned",
            Self::Cancelled => "Cancelled",
            Self::Completed => "Completed",
            Self::EnteredInError => "Entered In Error",
            Self::InProgress => "In Progress",
            Self::Planned => "Planned",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TransportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TransportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TransportStatus> for Coding {
    fn from(code: TransportStatus) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/transport-status".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TransportStatus> for CodeableConcept {
    fn from(code: TransportStatus) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TriggerType](http://hl7.org/fhir/ValueSet/trigger-type)**. The type of trigger.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TriggerType {
    /** **data-access-ended**

Data Access Ended. The trigger occurs whenever access to data of a particular type is completed. */
    DataAccessEnded,
    /** **data-accessed**

Data Accessed. The trigger occurs whenever data of a particular type is accessed. */
    DataAccessed,
    /** **data-added**

Data Added. The trigger occurs whenever data of a particular type is added. */
    DataAdded,
    /** **data-changed**

Data Changed. The trigger occurs whenever data of a particular type is changed in any way, either added, modified, or removed. */
    DataChanged,
    /** **data-modified**

Data Updated. The trigger occurs whenever data of a particular type is modified. */
    DataModified,
    /** **data-removed**

Data Removed. The trigger occurs whenever data of a particular type is removed. */
    DataRemoved,
    /** **named-event**

Named Event. The trigger occurs in response to a specific named event, and no other information about the trigger is specified. Named events are completely pre-coordinated, and the formal semantics of the trigger are not provided. */
    NamedEvent,
    /** **periodic**

Periodic. The trigger occurs at a specific time or periodically as described by a timing or schedule. A periodic event cannot have any data elements, but may have a name assigned as a shorthand for the event. */
    Periodic,
}
impl ::core::str::FromStr for TriggerType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-access-ended" => Ok(Self::DataAccessEnded),
            "data-accessed" => Ok(Self::DataAccessed),
            "data-added" => Ok(Self::DataAdded),
            "data-changed" => Ok(Self::DataChanged),
            "data-modified" => Ok(Self::DataModified),
            "data-removed" => Ok(Self::DataRemoved),
            "named-event" => Ok(Self::NamedEvent),
            "periodic" => Ok(Self::Periodic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TriggerType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataAccessEnded => "data-access-ended",
            Self::DataAccessed => "data-accessed",
            Self::DataAdded => "data-added",
            Self::DataChanged => "data-changed",
            Self::DataModified => "data-modified",
            Self::DataRemoved => "data-removed",
            Self::NamedEvent => "named-event",
            Self::Periodic => "periodic",
        }
    }
}
impl ::std::fmt::Display for TriggerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::DataAccessEnded => "Data Access Ended",
            Self::DataAccessed => "Data Accessed",
            Self::DataAdded => "Data Added",
            Self::DataChanged => "Data Changed",
            Self::DataModified => "Data Updated",
            Self::DataRemoved => "Data Removed",
            Self::NamedEvent => "Named Event",
            Self::Periodic => "Periodic",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TriggerType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TriggerType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TriggerType> for Coding {
    fn from(code: TriggerType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/trigger-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TriggerType> for CodeableConcept {
    fn from(code: TriggerType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TriggeredBytype](http://hl7.org/fhir/ValueSet/observation-triggeredbytype)**. Codes providing the triggeredBy type of observation.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TriggeredBytype {
    /** **re-run**

Re-run (per policy). Performance of the same test but with different parameters/settings/solution. */
    ReRun,
    /** **reflex**

Reflex. Performance of one or more other tests depending on the results of the initial test.  This may include collection of additional specimen. While a new ServiceRequest is not required to perform the additional test, where it is still needed (e.g., requesting another laboratory to perform the reflex test), the Observation.basedOn would reference the new ServiceRequest that requested the additional test to be performed as well as the original ServiceRequest to reflect the one that provided the authorization. */
    Reflex,
    /** **repeat**

Repeat (per policy). Performance of the same test again with the same parameters/settings/solution. */
    Repeat,
}
impl ::core::str::FromStr for TriggeredBytype {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "re-run" => Ok(Self::ReRun),
            "reflex" => Ok(Self::Reflex),
            "repeat" => Ok(Self::Repeat),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TriggeredBytype {
    fn as_ref(&self) -> &str {
        match self {
            Self::ReRun => "re-run",
            Self::Reflex => "reflex",
            Self::Repeat => "repeat",
        }
    }
}
impl ::std::fmt::Display for TriggeredBytype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::ReRun => "Re-run (per policy)",
            Self::Reflex => "Reflex",
            Self::Repeat => "Repeat (per policy)",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TriggeredBytype {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TriggeredBytype {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TriggeredBytype> for Coding {
    fn from(code: TriggeredBytype) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/observation-triggeredbytype".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TriggeredBytype> for CodeableConcept {
    fn from(code: TriggeredBytype) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[TypeDerivationRule](http://hl7.org/fhir/ValueSet/type-derivation-rule)**. How a type relates to its baseDefinition.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TypeDerivationRule {
    /** **constraint**

Constraint. This definition adds additional rules to an existing concrete type. */
    Constraint,
    /** **specialization**

Specialization. This definition defines a new type that adds additional elements and optionally additional rules to the base type. */
    Specialization,
}
impl ::core::str::FromStr for TypeDerivationRule {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "constraint" => Ok(Self::Constraint),
            "specialization" => Ok(Self::Specialization),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TypeDerivationRule {
    fn as_ref(&self) -> &str {
        match self {
            Self::Constraint => "constraint",
            Self::Specialization => "specialization",
        }
    }
}
impl ::std::fmt::Display for TypeDerivationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Constraint => "Constraint",
            Self::Specialization => "Specialization",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for TypeDerivationRule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TypeDerivationRule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<TypeDerivationRule> for Coding {
    fn from(code: TypeDerivationRule) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/type-derivation-rule".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<TypeDerivationRule> for CodeableConcept {
    fn from(code: TypeDerivationRule) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[UndesirablEffectFrequency](http://hl7.org/fhir/ValueSet/undesirable-effect-frequency)**. A categorisation for a frequency of occurence of an undesirable effect.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum UndesirablEffectFrequency {
    /** **Common**

Common. */
    Common,
    /** **Rare**

Rare. */
    Rare,
    /** **Uncommon**

Uncommon. */
    Uncommon,
}
impl ::core::str::FromStr for UndesirablEffectFrequency {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Common" => Ok(Self::Common),
            "Rare" => Ok(Self::Rare),
            "Uncommon" => Ok(Self::Uncommon),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UndesirablEffectFrequency {
    fn as_ref(&self) -> &str {
        match self {
            Self::Common => "Common",
            Self::Rare => "Rare",
            Self::Uncommon => "Uncommon",
        }
    }
}
impl ::std::fmt::Display for UndesirablEffectFrequency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Common => "Common",
            Self::Rare => "Rare",
            Self::Uncommon => "Uncommon",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for UndesirablEffectFrequency {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UndesirablEffectFrequency {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UndesirablEffectFrequency> for Coding {
    fn from(code: UndesirablEffectFrequency) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/undesirable-effect-frequency".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<UndesirablEffectFrequency> for CodeableConcept {
    fn from(code: UndesirablEffectFrequency) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[UnitOfPresentation](http://hl7.org/fhir/ValueSet/unit-of-presentation)**. The presentation type in which an administrable medicinal product is given to a patient.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum UnitOfPresentation {
    /** **200000002108**

Barrel. */
    N200000002108,
    /** **200000002109**

Blister. */
    N200000002109,
    /** **200000002110**

Block. */
    N200000002110,
    /** **200000002111**

Bottle. */
    N200000002111,
    /** **200000002112**

Cachet. */
    N200000002112,
    /** **200000002113**

Capsule. */
    N200000002113,
    /** **200000002114**

Cartridge. */
    N200000002114,
    /** **200000002115**

Collar. */
    N200000002115,
    /** **200000002116**

Container. */
    N200000002116,
    /** **200000002117**

Cup. */
    N200000002117,
    /** **200000002118**

Cylinder. */
    N200000002118,
    /** **200000002119**

Dart. */
    N200000002119,
    /** **200000002120**

Dressing. */
    N200000002120,
    /** **200000002121**

Drop. */
    N200000002121,
    /** **200000002122**

Film. */
    N200000002122,
    /** **200000002123**

Chewing gum. */
    N200000002123,
    /** **200000002124**

Implant. */
    N200000002124,
    /** **200000002125**

Inhaler. */
    N200000002125,
    /** **200000002126**

Insert. */
    N200000002126,
    /** **200000002127**

Jar. */
    N200000002127,
    /** **200000002128**

Lozenge. */
    N200000002128,
    /** **200000002129**

Lyophilisate. */
    N200000002129,
    /** **200000002130**

Matrix. */
    N200000002130,
    /** **200000002131**

Pad. */
    N200000002131,
    /** **200000002132**

Paper. */
    N200000002132,
    /** **200000002133**

Pastille. */
    N200000002133,
    /** **200000002134**

Patch. */
    N200000002134,
    /** **200000002135**

Pen. */
    N200000002135,
    /** **200000002136**

Pendant. */
    N200000002136,
    /** **200000002137**

Pessary. */
    N200000002137,
    /** **200000002138**

Pillule. */
    N200000002138,
    /** **200000002139**

Pipette. */
    N200000002139,
    /** **200000002140**

Plaster. */
    N200000002140,
    /** **200000002141**

Plug. */
    N200000002141,
    /** **200000002142**

Pouch. */
    N200000002142,
    /** **200000002143**

Sachet. */
    N200000002143,
    /** **200000002144**

Sponge. */
    N200000002144,
    /** **200000002145**

Spoonful. */
    N200000002145,
    /** **200000002146**

Stick. */
    N200000002146,
    /** **200000002147**

Straw. */
    N200000002147,
    /** **200000002148**

Strip. */
    N200000002148,
    /** **200000002149**

Suppository. */
    N200000002149,
    /** **200000002150**

Syringe. */
    N200000002150,
    /** **200000002151**

System. */
    N200000002151,
    /** **200000002152**

Tablet. */
    N200000002152,
    /** **200000002153**

Tag. */
    N200000002153,
    /** **200000002154**

Tampon. */
    N200000002154,
    /** **200000002155**

Thread. */
    N200000002155,
    /** **200000002156**

Tube. */
    N200000002156,
    /** **200000002157**

Vessel. */
    N200000002157,
    /** **200000002158**

Vial. */
    N200000002158,
    /** **200000002159**

Puff. */
    N200000002159,
    /** **200000002163**

Actuation. */
    N200000002163,
    /** **200000002164**

Ampoule. */
    N200000002164,
    /** **200000002165**

Applicator. */
    N200000002165,
    /** **200000002166**

Bag. */
    N200000002166,
}
impl ::core::str::FromStr for UnitOfPresentation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "200000002108" => Ok(Self::N200000002108),
            "200000002109" => Ok(Self::N200000002109),
            "200000002110" => Ok(Self::N200000002110),
            "200000002111" => Ok(Self::N200000002111),
            "200000002112" => Ok(Self::N200000002112),
            "200000002113" => Ok(Self::N200000002113),
            "200000002114" => Ok(Self::N200000002114),
            "200000002115" => Ok(Self::N200000002115),
            "200000002116" => Ok(Self::N200000002116),
            "200000002117" => Ok(Self::N200000002117),
            "200000002118" => Ok(Self::N200000002118),
            "200000002119" => Ok(Self::N200000002119),
            "200000002120" => Ok(Self::N200000002120),
            "200000002121" => Ok(Self::N200000002121),
            "200000002122" => Ok(Self::N200000002122),
            "200000002123" => Ok(Self::N200000002123),
            "200000002124" => Ok(Self::N200000002124),
            "200000002125" => Ok(Self::N200000002125),
            "200000002126" => Ok(Self::N200000002126),
            "200000002127" => Ok(Self::N200000002127),
            "200000002128" => Ok(Self::N200000002128),
            "200000002129" => Ok(Self::N200000002129),
            "200000002130" => Ok(Self::N200000002130),
            "200000002131" => Ok(Self::N200000002131),
            "200000002132" => Ok(Self::N200000002132),
            "200000002133" => Ok(Self::N200000002133),
            "200000002134" => Ok(Self::N200000002134),
            "200000002135" => Ok(Self::N200000002135),
            "200000002136" => Ok(Self::N200000002136),
            "200000002137" => Ok(Self::N200000002137),
            "200000002138" => Ok(Self::N200000002138),
            "200000002139" => Ok(Self::N200000002139),
            "200000002140" => Ok(Self::N200000002140),
            "200000002141" => Ok(Self::N200000002141),
            "200000002142" => Ok(Self::N200000002142),
            "200000002143" => Ok(Self::N200000002143),
            "200000002144" => Ok(Self::N200000002144),
            "200000002145" => Ok(Self::N200000002145),
            "200000002146" => Ok(Self::N200000002146),
            "200000002147" => Ok(Self::N200000002147),
            "200000002148" => Ok(Self::N200000002148),
            "200000002149" => Ok(Self::N200000002149),
            "200000002150" => Ok(Self::N200000002150),
            "200000002151" => Ok(Self::N200000002151),
            "200000002152" => Ok(Self::N200000002152),
            "200000002153" => Ok(Self::N200000002153),
            "200000002154" => Ok(Self::N200000002154),
            "200000002155" => Ok(Self::N200000002155),
            "200000002156" => Ok(Self::N200000002156),
            "200000002157" => Ok(Self::N200000002157),
            "200000002158" => Ok(Self::N200000002158),
            "200000002159" => Ok(Self::N200000002159),
            "200000002163" => Ok(Self::N200000002163),
            "200000002164" => Ok(Self::N200000002164),
            "200000002165" => Ok(Self::N200000002165),
            "200000002166" => Ok(Self::N200000002166),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UnitOfPresentation {
    fn as_ref(&self) -> &str {
        match self {
            Self::N200000002108 => "200000002108",
            Self::N200000002109 => "200000002109",
            Self::N200000002110 => "200000002110",
            Self::N200000002111 => "200000002111",
            Self::N200000002112 => "200000002112",
            Self::N200000002113 => "200000002113",
            Self::N200000002114 => "200000002114",
            Self::N200000002115 => "200000002115",
            Self::N200000002116 => "200000002116",
            Self::N200000002117 => "200000002117",
            Self::N200000002118 => "200000002118",
            Self::N200000002119 => "200000002119",
            Self::N200000002120 => "200000002120",
            Self::N200000002121 => "200000002121",
            Self::N200000002122 => "200000002122",
            Self::N200000002123 => "200000002123",
            Self::N200000002124 => "200000002124",
            Self::N200000002125 => "200000002125",
            Self::N200000002126 => "200000002126",
            Self::N200000002127 => "200000002127",
            Self::N200000002128 => "200000002128",
            Self::N200000002129 => "200000002129",
            Self::N200000002130 => "200000002130",
            Self::N200000002131 => "200000002131",
            Self::N200000002132 => "200000002132",
            Self::N200000002133 => "200000002133",
            Self::N200000002134 => "200000002134",
            Self::N200000002135 => "200000002135",
            Self::N200000002136 => "200000002136",
            Self::N200000002137 => "200000002137",
            Self::N200000002138 => "200000002138",
            Self::N200000002139 => "200000002139",
            Self::N200000002140 => "200000002140",
            Self::N200000002141 => "200000002141",
            Self::N200000002142 => "200000002142",
            Self::N200000002143 => "200000002143",
            Self::N200000002144 => "200000002144",
            Self::N200000002145 => "200000002145",
            Self::N200000002146 => "200000002146",
            Self::N200000002147 => "200000002147",
            Self::N200000002148 => "200000002148",
            Self::N200000002149 => "200000002149",
            Self::N200000002150 => "200000002150",
            Self::N200000002151 => "200000002151",
            Self::N200000002152 => "200000002152",
            Self::N200000002153 => "200000002153",
            Self::N200000002154 => "200000002154",
            Self::N200000002155 => "200000002155",
            Self::N200000002156 => "200000002156",
            Self::N200000002157 => "200000002157",
            Self::N200000002158 => "200000002158",
            Self::N200000002159 => "200000002159",
            Self::N200000002163 => "200000002163",
            Self::N200000002164 => "200000002164",
            Self::N200000002165 => "200000002165",
            Self::N200000002166 => "200000002166",
        }
    }
}
impl ::std::fmt::Display for UnitOfPresentation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::N200000002108 => "Barrel",
            Self::N200000002109 => "Blister",
            Self::N200000002110 => "Block",
            Self::N200000002111 => "Bottle",
            Self::N200000002112 => "Cachet",
            Self::N200000002113 => "Capsule",
            Self::N200000002114 => "Cartridge",
            Self::N200000002115 => "Collar",
            Self::N200000002116 => "Container",
            Self::N200000002117 => "Cup",
            Self::N200000002118 => "Cylinder",
            Self::N200000002119 => "Dart",
            Self::N200000002120 => "Dressing",
            Self::N200000002121 => "Drop",
            Self::N200000002122 => "Film",
            Self::N200000002123 => "Chewing gum",
            Self::N200000002124 => "Implant",
            Self::N200000002125 => "Inhaler",
            Self::N200000002126 => "Insert",
            Self::N200000002127 => "Jar",
            Self::N200000002128 => "Lozenge",
            Self::N200000002129 => "Lyophilisate",
            Self::N200000002130 => "Matrix",
            Self::N200000002131 => "Pad",
            Self::N200000002132 => "Paper",
            Self::N200000002133 => "Pastille",
            Self::N200000002134 => "Patch",
            Self::N200000002135 => "Pen",
            Self::N200000002136 => "Pendant",
            Self::N200000002137 => "Pessary",
            Self::N200000002138 => "Pillule",
            Self::N200000002139 => "Pipette",
            Self::N200000002140 => "Plaster",
            Self::N200000002141 => "Plug",
            Self::N200000002142 => "Pouch",
            Self::N200000002143 => "Sachet",
            Self::N200000002144 => "Sponge",
            Self::N200000002145 => "Spoonful",
            Self::N200000002146 => "Stick",
            Self::N200000002147 => "Straw",
            Self::N200000002148 => "Strip",
            Self::N200000002149 => "Suppository",
            Self::N200000002150 => "Syringe",
            Self::N200000002151 => "System",
            Self::N200000002152 => "Tablet",
            Self::N200000002153 => "Tag",
            Self::N200000002154 => "Tampon",
            Self::N200000002155 => "Thread",
            Self::N200000002156 => "Tube",
            Self::N200000002157 => "Vessel",
            Self::N200000002158 => "Vial",
            Self::N200000002159 => "Puff",
            Self::N200000002163 => "Actuation",
            Self::N200000002164 => "Ampoule",
            Self::N200000002165 => "Applicator",
            Self::N200000002166 => "Bag",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for UnitOfPresentation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UnitOfPresentation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UnitOfPresentation> for Coding {
    fn from(code: UnitOfPresentation) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/unit-of-presentation".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<UnitOfPresentation> for CodeableConcept {
    fn from(code: UnitOfPresentation) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[UsageContextAgreementScope](http://hl7.org/fhir/ValueSet/usage-context-agreement-scope)**. This codesystem defines codes describing the type of agreement represented by an artifact, for example for use in CanonicalResource.usageContext.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum UsageContextAgreementScope {
    /** **community**

Community. Sets contractual or business expectations for systems participating in a particular exchange community. */
    Community,
    /** **domain**

Domain. Defines use-case-specific requirements for a specific business or health domain.  May vary in jurisdictional scope from international to small region and in business scope from broad to narrow. */
    Domain,
    /** **knowledge**

Knowledge. Defines use-case-specific information or guidance that is relevant to a specific business or health domain but is not mandated for particular use. */
    Knowledge,
    /** **realm-base**

Realm Base. Defines use-case independent foundational expectations for exchange within a particular country or jurisdiction.  Should be accompanied by a jurisdiction.  Commonly used as a 'base' for more restrictive artifacts. */
    RealmBase,
    /** **system-design**

System Design. Documents the specific capabilities of a single system as 'available' for purchase or use.  May have some variability reflecting options that can be configured. */
    SystemDesign,
    /** **system-implementation**

System Implementation. Documents the specific points of a single production system or endpoint.  This may be time-specific - i.e. reflecting the system 'as it is now' or 'as it was at some point in the past'. */
    SystemImplementation,
}
impl ::core::str::FromStr for UsageContextAgreementScope {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "community" => Ok(Self::Community),
            "domain" => Ok(Self::Domain),
            "knowledge" => Ok(Self::Knowledge),
            "realm-base" => Ok(Self::RealmBase),
            "system-design" => Ok(Self::SystemDesign),
            "system-implementation" => Ok(Self::SystemImplementation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UsageContextAgreementScope {
    fn as_ref(&self) -> &str {
        match self {
            Self::Community => "community",
            Self::Domain => "domain",
            Self::Knowledge => "knowledge",
            Self::RealmBase => "realm-base",
            Self::SystemDesign => "system-design",
            Self::SystemImplementation => "system-implementation",
        }
    }
}
impl ::std::fmt::Display for UsageContextAgreementScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Community => "Community",
            Self::Domain => "Domain",
            Self::Knowledge => "Knowledge",
            Self::RealmBase => "Realm Base",
            Self::SystemDesign => "System Design",
            Self::SystemImplementation => "System Implementation",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for UsageContextAgreementScope {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UsageContextAgreementScope {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<UsageContextAgreementScope> for Coding {
    fn from(code: UsageContextAgreementScope) -> Self {
        Coding::builder()
            .system(
                "http://hl7.org/fhir/ValueSet/usage-context-agreement-scope".to_owned(),
            )
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<UsageContextAgreementScope> for CodeableConcept {
    fn from(code: UsageContextAgreementScope) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[Use](http://hl7.org/fhir/ValueSet/claim-use)**. The purpose of the Claim: predetermination, preauthorization, claim.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum Use {
    /** **claim**

Claim. The treatment is complete and this represents a Claim for the services. */
    Claim,
    /** **preauthorization**

Preauthorization. The treatment is proposed and this represents a Pre-authorization for the services. */
    Preauthorization,
    /** **predetermination**

Predetermination. The treatment is proposed and this represents a Pre-determination for the services. */
    Predetermination,
}
impl ::core::str::FromStr for Use {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "claim" => Ok(Self::Claim),
            "preauthorization" => Ok(Self::Preauthorization),
            "predetermination" => Ok(Self::Predetermination),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Use {
    fn as_ref(&self) -> &str {
        match self {
            Self::Claim => "claim",
            Self::Preauthorization => "preauthorization",
            Self::Predetermination => "predetermination",
        }
    }
}
impl ::std::fmt::Display for Use {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Claim => "Claim",
            Self::Preauthorization => "Preauthorization",
            Self::Predetermination => "Predetermination",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for Use {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Use {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<Use> for Coding {
    fn from(code: Use) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/claim-use".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<Use> for CodeableConcept {
    fn from(code: Use) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[VersionAlgorithm](http://hl7.org/fhir/ValueSet/version-algorithm)**. Indicates the mechanism used to compare versions to determine which is more current.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum VersionAlgorithm {
    /** **alpha**

Alphabetical. Simple alphabetic sort on a case-insensitive and accent-insensitive basis.  (Sorting of different cases or accented versions of a character is indeterminate) */
    Alpha,
    /** **date**

Date. Versions are expressed as an ISO date/time syntax (including syntaxes with only portions of a date) */
    Date,
    /** **integer**

Integer. Versions are integers and ordered numerically */
    Integer,
    /** **natural**

Natural. Sorted according to the algorithm defined here: [naturalordersort.org](http://www.naturalordersort.org/) */
    Natural,
    /** **semver**

SemVer. Uses the semantic versioning scheme as defined in [semver.org](http://semver.org). */
    Semver,
}
impl ::core::str::FromStr for VersionAlgorithm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alpha" => Ok(Self::Alpha),
            "date" => Ok(Self::Date),
            "integer" => Ok(Self::Integer),
            "natural" => Ok(Self::Natural),
            "semver" => Ok(Self::Semver),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VersionAlgorithm {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alpha => "alpha",
            Self::Date => "date",
            Self::Integer => "integer",
            Self::Natural => "natural",
            Self::Semver => "semver",
        }
    }
}
impl ::std::fmt::Display for VersionAlgorithm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Alpha => "Alphabetical",
            Self::Date => "Date",
            Self::Integer => "Integer",
            Self::Natural => "Natural",
            Self::Semver => "SemVer",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for VersionAlgorithm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VersionAlgorithm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<VersionAlgorithm> for Coding {
    fn from(code: VersionAlgorithm) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/version-algorithm".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<VersionAlgorithm> for CodeableConcept {
    fn from(code: VersionAlgorithm) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[VirtualServiceType](http://hl7.org/fhir/ValueSet/virtual-service-type)**. Example codes for possible virtual service connection types.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum VirtualServiceType {
    /** **ms-teams**

Microsoft Teams. Microsoft Teams web conferencing meeting */
    MsTeams,
    /** **whatsapp**

WhatsApp conference call. A conference call using the WhatsApp conference call service */
    Whatsapp,
    /** **zoom**

Zoom web conferencing. the amount is the base price used for calculating the total price before applying surcharges, discount or taxes. */
    Zoom,
}
impl ::core::str::FromStr for VirtualServiceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ms-teams" => Ok(Self::MsTeams),
            "whatsapp" => Ok(Self::Whatsapp),
            "zoom" => Ok(Self::Zoom),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VirtualServiceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MsTeams => "ms-teams",
            Self::Whatsapp => "whatsapp",
            Self::Zoom => "zoom",
        }
    }
}
impl ::std::fmt::Display for VirtualServiceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::MsTeams => "Microsoft Teams",
            Self::Whatsapp => "WhatsApp conference call",
            Self::Zoom => "Zoom web conferencing",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for VirtualServiceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VirtualServiceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<VirtualServiceType> for Coding {
    fn from(code: VirtualServiceType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/virtual-service-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<VirtualServiceType> for CodeableConcept {
    fn from(code: VirtualServiceType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[VisionBase](http://hl7.org/fhir/ValueSet/vision-base-codes)**. A coded concept listing the base codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum VisionBase {
    /** **down**

Down. bottom. */
    Down,
    /** **in**

In. inner edge. */
    In,
    /** **out**

Out. outer edge. */
    Out,
    /** **up**

Up. top. */
    Up,
}
impl ::core::str::FromStr for VisionBase {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "down" => Ok(Self::Down),
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            "up" => Ok(Self::Up),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VisionBase {
    fn as_ref(&self) -> &str {
        match self {
            Self::Down => "down",
            Self::In => "in",
            Self::Out => "out",
            Self::Up => "up",
        }
    }
}
impl ::std::fmt::Display for VisionBase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Down => "Down",
            Self::In => "In",
            Self::Out => "Out",
            Self::Up => "Up",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for VisionBase {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VisionBase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<VisionBase> for Coding {
    fn from(code: VisionBase) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/vision-base-codes".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<VisionBase> for CodeableConcept {
    fn from(code: VisionBase) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[VisionEyes](http://hl7.org/fhir/ValueSet/vision-eye-codes)**. A coded concept listing the eye codes.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum VisionEyes {
    /** **left**

Left Eye. Left Eye. */
    Left,
    /** **right**

Right Eye. Right Eye. */
    Right,
}
impl ::core::str::FromStr for VisionEyes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VisionEyes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Left => "left",
            Self::Right => "right",
        }
    }
}
impl ::std::fmt::Display for VisionEyes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::Left => "Left Eye",
            Self::Right => "Right Eye",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for VisionEyes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VisionEyes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<VisionEyes> for Coding {
    fn from(code: VisionEyes) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/vision-eye-codes".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<VisionEyes> for CodeableConcept {
    fn from(code: VisionEyes) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[WarningType](http://hl7.org/fhir/ValueSet/warning-type)**. Classification of warning type.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum WarningType {
    /** **P313**

Get medical advice/attention.. Get medical advice/attention. */
    P313,
    /** **P314**

Get medical advice/attention if you feel unwell.. Get medical advice/attention if you feel unwell. */
    P314,
    /** **P315**

Get immediate medical advice/attention.. Get immediate medical advice/attention. */
    P315,
    /** **P320**

Specific treatment is urgent (see ... on this label).. Specific treatment is urgent (see ... on this label). */
    P320,
    /** **P321**

Specific treatment (see ... on this label).. Specific treatment (see ... on this label). */
    P321,
    /** **P322**

Specific measures (see ... on this label).. Specific measures (see ... on this label). */
    P322,
    /** **P330**

Rinse mouth.. Rinse mouth. */
    P330,
    /** **P331**

Do NOT induce vomiting.. Do NOT induce vomiting. */
    P331,
    /** **P361**

Remove/Take off immediately all contaminated clothing.. Remove/Take off immediately all contaminated clothing. */
    P361,
    /** **P363**

Wash contaminated clothing before reuse... Wash contaminated clothing before reuse. */
    P363,
}
impl ::core::str::FromStr for WarningType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "P313" => Ok(Self::P313),
            "P314" => Ok(Self::P314),
            "P315" => Ok(Self::P315),
            "P320" => Ok(Self::P320),
            "P321" => Ok(Self::P321),
            "P322" => Ok(Self::P322),
            "P330" => Ok(Self::P330),
            "P331" => Ok(Self::P331),
            "P361" => Ok(Self::P361),
            "P363" => Ok(Self::P363),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for WarningType {
    fn as_ref(&self) -> &str {
        match self {
            Self::P313 => "P313",
            Self::P314 => "P314",
            Self::P315 => "P315",
            Self::P320 => "P320",
            Self::P321 => "P321",
            Self::P322 => "P322",
            Self::P330 => "P330",
            Self::P331 => "P331",
            Self::P361 => "P361",
            Self::P363 => "P363",
        }
    }
}
impl ::std::fmt::Display for WarningType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::P313 => "Get medical advice/attention.",
            Self::P314 => "Get medical advice/attention if you feel unwell.",
            Self::P315 => "Get immediate medical advice/attention.",
            Self::P320 => "Specific treatment is urgent (see ... on this label).",
            Self::P321 => "Specific treatment (see ... on this label).",
            Self::P322 => "Specific measures (see ... on this label).",
            Self::P330 => "Rinse mouth.",
            Self::P331 => "Do NOT induce vomiting.",
            Self::P361 => "Remove/Take off immediately all contaminated clothing.",
            Self::P363 => "Wash contaminated clothing before reuse..",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for WarningType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for WarningType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<WarningType> for Coding {
    fn from(code: WarningType) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/warning-type".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<WarningType> for CodeableConcept {
    fn from(code: WarningType) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
#[doc = "**[WeekOfMonth](http://hl7.org/fhir/ValueSet/week-of-month)**. The set of weeks with in a month.\n\nFHIR version: 5.0.0."]
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum WeekOfMonth {
    /** **first**

First. First week of the month. */
    First,
    /** **fourth**

Fourth. Fourth week of the month. */
    Fourth,
    /** **last**

Last. Last week of the month. */
    Last,
    /** **second**

Second. Second week of the month. */
    Second,
    /** **third**

Third. Third week of the month. */
    Third,
}
impl ::core::str::FromStr for WeekOfMonth {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "first" => Ok(Self::First),
            "fourth" => Ok(Self::Fourth),
            "last" => Ok(Self::Last),
            "second" => Ok(Self::Second),
            "third" => Ok(Self::Third),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for WeekOfMonth {
    fn as_ref(&self) -> &str {
        match self {
            Self::First => "first",
            Self::Fourth => "fourth",
            Self::Last => "last",
            Self::Second => "second",
            Self::Third => "third",
        }
    }
}
impl ::std::fmt::Display for WeekOfMonth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let s = match self {
            Self::First => "First",
            Self::Fourth => "Fourth",
            Self::Last => "Last",
            Self::Second => "Second",
            Self::Third => "Third",
        };
        write!(f, "{s}")
    }
}
impl<'de> Deserialize<'de> for WeekOfMonth {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for WeekOfMonth {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
impl From<WeekOfMonth> for Coding {
    fn from(code: WeekOfMonth) -> Self {
        Coding::builder()
            .system("http://hl7.org/fhir/ValueSet/week-of-month".to_owned())
            .code(code.as_ref().to_owned())
            .display(format!("{code}"))
            .build()
    }
}
impl From<WeekOfMonth> for CodeableConcept {
    fn from(code: WeekOfMonth) -> Self {
        let text = format!("{code}");
        let coding = Coding::from(code);
        CodeableConcept::builder().coding(vec![Some(coding)]).text(text).build()
    }
}
