//! Generated code! Take a look at the generator-crate for changing this file!
#![allow(clippy::too_many_lines)]
use serde::{Serialize, Deserialize};
/**FHIR Code `AbstractType`. A list of the base types defined by this version of the FHIR specification - types that are defined, but for which only specializations actually are created.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AbstractType {
    /** # Any

Any. A place holder that means any kind of resource */
    Any,
    /** # Type

Type. A place holder that means any kind of data type */
    Type,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AbstractType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Any" => Ok(Self::Any),
            "Type" => Ok(Self::Type),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AbstractType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Any => "Any",
            Self::Type => "Type",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for AbstractType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AbstractType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AccountStatus`. Indicates whether the account is available to be used.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AccountStatus {
    /** # active

Active. This account is active and may be used. */
    Active,
    /** # entered-in-error

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** # inactive

Inactive. This account is inactive and should not be used to track financial information. */
    Inactive,
    /** # on-hold

On Hold. This account is on hold. */
    OnHold,
    /** # unknown

Unknown. The account status is unknown. */
    Unknown,
}
impl ::core::str::FromStr for AccountStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "on-hold" => Ok(Self::OnHold),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AccountStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::OnHold => "on-hold",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for AccountStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AccountStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionCardinalityBehavior`. Defines behavior for an action or a group for how many times that item may be repeated.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionCardinalityBehavior {
    /** # multiple

Multiple. The action may be selected multiple times. */
    Multiple,
    /** # single

Single. The action may only be selected one time. */
    Single,
}
impl ::core::str::FromStr for ActionCardinalityBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "multiple" => Ok(Self::Multiple),
            "single" => Ok(Self::Single),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionCardinalityBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::Multiple => "multiple",
            Self::Single => "single",
        }
    }
}
impl<'de> Deserialize<'de> for ActionCardinalityBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionCardinalityBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionCode`. Provides examples of actions to be performed.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionCode {
    /** # collect-information

Collect information. The action indicates that information should be collected from a participant in the process. */
    CollectInformation,
    /** # order-service

Order a service. The action indicates that a particular service should be provided. */
    OrderService,
    /** # prescribe-medication

Prescribe a medication. The action indicates that a particular medication should be prescribed to the patient. */
    PrescribeMedication,
    /** # propose-diagnosis

Propose a diagnosis. The action indicates that a particular diagnosis should be proposed. */
    ProposeDiagnosis,
    /** # recommend-immunization

Recommend an immunization. The action indicates that a particular immunization should be performed. */
    RecommendImmunization,
    /** # record-detected-issue

Record a detected issue. The action indicates that a particular detected issue should be recorded. */
    RecordDetectedIssue,
    /** # record-inference

Record an inference. The action indicates that a particular inference should be recorded. */
    RecordInference,
    /** # report-flag

Report a flag. The action indicates that a particular flag should be reported. */
    ReportFlag,
    /** # send-message

Send a message. The action indicates that a particular message should be sent to a participant in the process. */
    SendMessage,
}
impl ::core::str::FromStr for ActionCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "collect-information" => Ok(Self::CollectInformation),
            "order-service" => Ok(Self::OrderService),
            "prescribe-medication" => Ok(Self::PrescribeMedication),
            "propose-diagnosis" => Ok(Self::ProposeDiagnosis),
            "recommend-immunization" => Ok(Self::RecommendImmunization),
            "record-detected-issue" => Ok(Self::RecordDetectedIssue),
            "record-inference" => Ok(Self::RecordInference),
            "report-flag" => Ok(Self::ReportFlag),
            "send-message" => Ok(Self::SendMessage),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::CollectInformation => "collect-information",
            Self::OrderService => "order-service",
            Self::PrescribeMedication => "prescribe-medication",
            Self::ProposeDiagnosis => "propose-diagnosis",
            Self::RecommendImmunization => "recommend-immunization",
            Self::RecordDetectedIssue => "record-detected-issue",
            Self::RecordInference => "record-inference",
            Self::ReportFlag => "report-flag",
            Self::SendMessage => "send-message",
        }
    }
}
impl<'de> Deserialize<'de> for ActionCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionConditionKind`. Defines the kinds of conditions that can appear on actions.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionConditionKind {
    /** # applicability

Applicability. The condition describes whether or not a given action is applicable. */
    Applicability,
    /** # start

Start. The condition is a starting condition for the action. */
    Start,
    /** # stop

Stop. The condition is a stop, or exit condition for the action. */
    Stop,
}
impl ::core::str::FromStr for ActionConditionKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "applicability" => Ok(Self::Applicability),
            "start" => Ok(Self::Start),
            "stop" => Ok(Self::Stop),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionConditionKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Applicability => "applicability",
            Self::Start => "start",
            Self::Stop => "stop",
        }
    }
}
impl<'de> Deserialize<'de> for ActionConditionKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionConditionKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionGroupingBehavior`. Defines organization behavior of a group.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionGroupingBehavior {
    /** # logical-group

Logical Group. A group with this behavior logically groups its sub-elements, and may be shown as a visual group to the end user, but it is not required to do so. */
    LogicalGroup,
    /** # sentence-group

Sentence Group. A group of related alternative actions is a sentence group if the target referenced by the action is the same in all the actions and each action simply constitutes a different variation on how to specify the details for the target. For example, two actions that could be in a SentenceGroup are "aspirin, 500 mg, 2 times per day" and "aspirin, 300 mg, 3 times per day". In both cases, aspirin is the target referenced by the action, and the two actions represent different options for how aspirin might be ordered for the patient. Note that a SentenceGroup would almost always have an associated selection behavior of "AtMostOne", unless it's a required action, in which case, it would be "ExactlyOne". */
    SentenceGroup,
    /** # visual-group

Visual Group. Any group marked with this behavior should be displayed as a visual group to the end user. */
    VisualGroup,
}
impl ::core::str::FromStr for ActionGroupingBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "logical-group" => Ok(Self::LogicalGroup),
            "sentence-group" => Ok(Self::SentenceGroup),
            "visual-group" => Ok(Self::VisualGroup),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionGroupingBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::LogicalGroup => "logical-group",
            Self::SentenceGroup => "sentence-group",
            Self::VisualGroup => "visual-group",
        }
    }
}
impl<'de> Deserialize<'de> for ActionGroupingBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionGroupingBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionParticipantType`. The type of participant for the action.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionParticipantType {
    /** # device

Device. The participant is a system or device used in the care of the patient. */
    Device,
    /** # patient

Patient. The participant is the patient under evaluation. */
    Patient,
    /** # practitioner

Practitioner. The participant is a practitioner involved in the patient's care. */
    Practitioner,
    /** # related-person

Related Person. The participant is a person related to the patient. */
    RelatedPerson,
}
impl ::core::str::FromStr for ActionParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "device" => Ok(Self::Device),
            "patient" => Ok(Self::Patient),
            "practitioner" => Ok(Self::Practitioner),
            "related-person" => Ok(Self::RelatedPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "device",
            Self::Patient => "patient",
            Self::Practitioner => "practitioner",
            Self::RelatedPerson => "related-person",
        }
    }
}
impl<'de> Deserialize<'de> for ActionParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionPrecheckBehavior`. Defines selection frequency behavior for an action or group.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionPrecheckBehavior {
    /** # no

No. An action with this behavior is one of the less frequent actions included by the end user, for the particular context in which the action occurs. The system displaying the actions to the end user would typically not "pre-check" such an action. */
    No,
    /** # yes

Yes. An action with this behavior is one of the most frequent action that is, or should be, included by an end user, for the particular context in which the action occurs. The system displaying the action to the end user should consider "pre-checking" such an action as a convenience for the user. */
    Yes,
}
impl ::core::str::FromStr for ActionPrecheckBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "no" => Ok(Self::No),
            "yes" => Ok(Self::Yes),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionPrecheckBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::No => "no",
            Self::Yes => "yes",
        }
    }
}
impl<'de> Deserialize<'de> for ActionPrecheckBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionPrecheckBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionReasonCode`. Provides examples of reasons for actions to be performed.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionReasonCode {
    /** # care-gap

Care gap detected. The action should be performed to address a detected care gap. */
    CareGap,
    /** # drug-drug-interaction

Drug-drug interaction. The action should be performed to address a detected potential drug-drug interaction. */
    DrugDrugInteraction,
    /** # off-pathway

Off pathway. The action should be performed because the patient was determined to be off pathway. */
    OffPathway,
    /** # quality-measure

Quality measure. The action should be performed to bring the patient's care in line with a quality measure. */
    QualityMeasure,
    /** # risk-assessment

Risk assessment. The action should be performed based on a particular risk assessment. */
    RiskAssessment,
}
impl ::core::str::FromStr for ActionReasonCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "care-gap" => Ok(Self::CareGap),
            "drug-drug-interaction" => Ok(Self::DrugDrugInteraction),
            "off-pathway" => Ok(Self::OffPathway),
            "quality-measure" => Ok(Self::QualityMeasure),
            "risk-assessment" => Ok(Self::RiskAssessment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionReasonCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::CareGap => "care-gap",
            Self::DrugDrugInteraction => "drug-drug-interaction",
            Self::OffPathway => "off-pathway",
            Self::QualityMeasure => "quality-measure",
            Self::RiskAssessment => "risk-assessment",
        }
    }
}
impl<'de> Deserialize<'de> for ActionReasonCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionReasonCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionRelationshipType`. Defines the types of relationships between actions.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionRelationshipType {
    /** # after

After. The action must be performed after the related action. */
    After,
    /** # after-end

After End. The action must be performed after the end of the related action. */
    AfterEnd,
    /** # after-start

After Start. The action must be performed after the start of the related action. */
    AfterStart,
    /** # before

Before. The action must be performed before the related action. */
    Before,
    /** # before-end

Before End. The action must be performed before the end of the related action. */
    BeforeEnd,
    /** # before-start

Before Start. The action must be performed before the start of the related action. */
    BeforeStart,
    /** # concurrent

Concurrent. The action must be performed concurrent with the related action. */
    Concurrent,
    /** # concurrent-with-end

Concurrent With End. The action must be performed concurrent with the end of the related action. */
    ConcurrentWithEnd,
    /** # concurrent-with-start

Concurrent With Start. The action must be performed concurrent with the start of the related action. */
    ConcurrentWithStart,
}
impl ::core::str::FromStr for ActionRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "after" => Ok(Self::After),
            "after-end" => Ok(Self::AfterEnd),
            "after-start" => Ok(Self::AfterStart),
            "before" => Ok(Self::Before),
            "before-end" => Ok(Self::BeforeEnd),
            "before-start" => Ok(Self::BeforeStart),
            "concurrent" => Ok(Self::Concurrent),
            "concurrent-with-end" => Ok(Self::ConcurrentWithEnd),
            "concurrent-with-start" => Ok(Self::ConcurrentWithStart),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::After => "after",
            Self::AfterEnd => "after-end",
            Self::AfterStart => "after-start",
            Self::Before => "before",
            Self::BeforeEnd => "before-end",
            Self::BeforeStart => "before-start",
            Self::Concurrent => "concurrent",
            Self::ConcurrentWithEnd => "concurrent-with-end",
            Self::ConcurrentWithStart => "concurrent-with-start",
        }
    }
}
impl<'de> Deserialize<'de> for ActionRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionRequiredBehavior`. Defines expectations around whether an action or action group is required.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionRequiredBehavior {
    /** # could

Could. An action with this behavior may be included in the set of actions processed by the end user. */
    Could,
    /** # must

Must. An action with this behavior must be included in the actions processed by the end user; the end user SHALL NOT choose not to include this action. */
    Must,
    /** # must-unless-documented

Must Unless Documented. An action with this behavior must be included in the set of actions processed by the end user, unless the end user provides documentation as to why the action was not included. */
    MustUnlessDocumented,
}
impl ::core::str::FromStr for ActionRequiredBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "could" => Ok(Self::Could),
            "must" => Ok(Self::Must),
            "must-unless-documented" => Ok(Self::MustUnlessDocumented),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionRequiredBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::Could => "could",
            Self::Must => "must",
            Self::MustUnlessDocumented => "must-unless-documented",
        }
    }
}
impl<'de> Deserialize<'de> for ActionRequiredBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionRequiredBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionSelectionBehavior`. Defines selection behavior of a group.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionSelectionBehavior {
    /** # all

All. All the actions in the group must be selected as a single unit. */
    All,
    /** # all-or-none

All Or None. All the actions in the group are meant to be chosen as a single unit: either all must be selected by the end user, or none may be selected. */
    AllOrNone,
    /** # any

Any. Any number of the actions in the group may be chosen, from zero to all. */
    Any,
    /** # at-most-one

At Most One. The end user may choose zero or at most one of the actions in the group. */
    AtMostOne,
    /** # exactly-one

Exactly One. The end user must choose one and only one of the selectable actions in the group. The user SHALL NOT choose none of the actions in the group. */
    ExactlyOne,
    /** # one-or-more

One Or More. The end user must choose a minimum of one, and as many additional as desired. */
    OneOrMore,
}
impl ::core::str::FromStr for ActionSelectionBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "all-or-none" => Ok(Self::AllOrNone),
            "any" => Ok(Self::Any),
            "at-most-one" => Ok(Self::AtMostOne),
            "exactly-one" => Ok(Self::ExactlyOne),
            "one-or-more" => Ok(Self::OneOrMore),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionSelectionBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::All => "all",
            Self::AllOrNone => "all-or-none",
            Self::Any => "any",
            Self::AtMostOne => "at-most-one",
            Self::ExactlyOne => "exactly-one",
            Self::OneOrMore => "one-or-more",
        }
    }
}
impl<'de> Deserialize<'de> for ActionSelectionBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionSelectionBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ActionType`. The type of action to be performed.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ActionType {
    /** # create

Create. The action is to create a new resource. */
    Create,
    /** # fire-event

Fire Event. The action is to fire a specific event. */
    FireEvent,
    /** # remove

Remove. The action is to remove an existing resource. */
    Remove,
    /** # update

Update. The action is to update an existing resource. */
    Update,
}
impl ::core::str::FromStr for ActionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "create" => Ok(Self::Create),
            "fire-event" => Ok(Self::FireEvent),
            "remove" => Ok(Self::Remove),
            "update" => Ok(Self::Update),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ActionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Create => "create",
            Self::FireEvent => "fire-event",
            Self::Remove => "remove",
            Self::Update => "update",
        }
    }
}
impl<'de> Deserialize<'de> for ActionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ActionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdditionalMonitoring`. Extra monitoring defined for a Medicinal Product.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdditionalMonitoring {
    /** # BlackTriangleMonitoring

Requirement for Black Triangle Monitoring. Requirement for Black Triangle Monitoring */
    BlackTriangleMonitoring,
}
impl ::core::str::FromStr for AdditionalMonitoring {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BlackTriangleMonitoring" => Ok(Self::BlackTriangleMonitoring),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdditionalMonitoring {
    fn as_ref(&self) -> &str {
        match self {
            Self::BlackTriangleMonitoring => "BlackTriangleMonitoring",
        }
    }
}
impl<'de> Deserialize<'de> for AdditionalMonitoring {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdditionalMonitoring {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AddressType`. The type of an address (physical / postal).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AddressType {
    /** # both

Postal & Physical. An address that is both physical and postal. */
    Both,
    /** # physical

Physical. A physical address that can be visited. */
    Physical,
    /** # postal

Postal. Mailing addresses - PO Boxes and care-of addresses. */
    Postal,
}
impl ::core::str::FromStr for AddressType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "both" => Ok(Self::Both),
            "physical" => Ok(Self::Physical),
            "postal" => Ok(Self::Postal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AddressType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Both => "both",
            Self::Physical => "physical",
            Self::Postal => "postal",
        }
    }
}
impl<'de> Deserialize<'de> for AddressType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AddressType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AddressUse`. The use of an address.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AddressUse {
    /** # billing

Billing. An address to be used to send bills, invoices, receipts etc. */
    Billing,
    /** # home

Home. A communication address at a home. */
    Home,
    /** # old

Old / Incorrect. This address is no longer in use (or was never correct but retained for records). */
    Old,
    /** # temp

Temporary. A temporary address. The period can provide more detailed information. */
    Temp,
    /** # work

Work. An office address. First choice for business related contacts during business hours. */
    Work,
}
impl ::core::str::FromStr for AddressUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "billing" => Ok(Self::Billing),
            "home" => Ok(Self::Home),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "work" => Ok(Self::Work),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AddressUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Billing => "billing",
            Self::Home => "home",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Work => "work",
        }
    }
}
impl<'de> Deserialize<'de> for AddressUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AddressUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdjudicationCodes`. This value set includes a smattering of Adjudication codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AdjudicationCodes {
    /** # benefit

Benefit Amount. Amount payable under the coverage */
    Benefit,
    /** # copay

CoPay. Patient Co-Payment */
    Copay,
    /** # deductible

Deductible. Amount deducted from the eligible amount prior to adjudication. */
    Deductible,
    /** # eligible

Eligible Amount. Amount of the change which is considered for adjudication. */
    Eligible,
    /** # eligpercent

Eligible %. Eligible Percentage. */
    Eligpercent,
    /** # submitted

Submitted Amount. The total submitted amount for the claim or group or line item. */
    Submitted,
    /** # tax

Tax. The amount of tax. */
    Tax,
    /** # unallocdeduct

Unallocated Deductible. The amount of deductible which could not allocated to other line items. */
    Unallocdeduct,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AdjudicationCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "benefit" => Ok(Self::Benefit),
            "copay" => Ok(Self::Copay),
            "deductible" => Ok(Self::Deductible),
            "eligible" => Ok(Self::Eligible),
            "eligpercent" => Ok(Self::Eligpercent),
            "submitted" => Ok(Self::Submitted),
            "tax" => Ok(Self::Tax),
            "unallocdeduct" => Ok(Self::Unallocdeduct),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AdjudicationCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Benefit => "benefit",
            Self::Copay => "copay",
            Self::Deductible => "deductible",
            Self::Eligible => "eligible",
            Self::Eligpercent => "eligpercent",
            Self::Submitted => "submitted",
            Self::Tax => "tax",
            Self::Unallocdeduct => "unallocdeduct",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for AdjudicationCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdjudicationCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdjudicationReasonCodes`. This value set includes smattering of Adjudication Reason codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AdjudicationReasonCodes {
    /** # ar001

Not covered. Not covered */
    Ar001,
    /** # ar002

Plan Limit Reached. Plan Limit Reached */
    Ar002,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AdjudicationReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ar001" => Ok(Self::Ar001),
            "ar002" => Ok(Self::Ar002),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AdjudicationReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ar001 => "ar001",
            Self::Ar002 => "ar002",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for AdjudicationReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdjudicationReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdministrableDoseForm`. Dose form for a medication, in the form suitable for administering to the patient, after mixing, where necessary.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdministrableDoseForm {
    /** # 100000073362

Oral suspension. */
    N100000073362,
    /** # 100000073363

Oral gel. */
    N100000073363,
    /** # 100000073364

Powder for oral solution. */
    N100000073364,
    /** # 100000073365

Granules for oral solution. */
    N100000073365,
    /** # 100000073367

Lyophilisate for suspension. */
    N100000073367,
    /** # 100000073368

Powder for syrup. */
    N100000073368,
    /** # 100000073369

Soluble tablet. */
    N100000073369,
    /** # 100000073370

Herbal tea. */
    N100000073370,
    /** # 100000073371

Instant herbal tea. */
    N100000073371,
    /** # 100000073372

Granules. */
    N100000073372,
    /** # 100000073373

Gastro-resistant granules. */
    N100000073373,
    /** # 100000073374

Modified-release granules. */
    N100000073374,
    /** # 100000073375

Capsule, hard. */
    N100000073375,
    /** # 100000073376

Gastro-resistant capsule, hard. */
    N100000073376,
    /** # 100000073377

Chewable capsule, soft. */
    N100000073377,
    /** # 100000073378

Prolonged-release capsule, soft. */
    N100000073378,
    /** # 100000073379

Modified-release capsule, soft. */
    N100000073379,
    /** # 100000073380

Coated tablet. */
    N100000073380,
    /** # 100000073642

Oral drops, solution. */
    N100000073642,
    /** # 100000073643

Oral drops, suspension. */
    N100000073643,
    /** # 100000073644

Oral drops, emulsion. */
    N100000073644,
    /** # 100000073645

Oral liquid. */
    N100000073645,
    /** # 100000073646

Oral solution. */
    N100000073646,
    /** # 100000073647

Oral emulsion. */
    N100000073647,
    /** # 100000073648

Oral paste. */
    N100000073648,
    /** # 100000073649

Powder for oral suspension. */
    N100000073649,
    /** # 100000073650

Granules for oral suspension. */
    N100000073650,
    /** # 100000073652

Syrup. */
    N100000073652,
    /** # 100000073653

Granules for syrup. */
    N100000073653,
    /** # 100000073654

Dispersible tablet. */
    N100000073654,
    /** # 100000073655

Oral powder. */
    N100000073655,
    /** # 100000073656

Effervescent powder. */
    N100000073656,
    /** # 100000073657

Effervescent granules. */
    N100000073657,
    /** # 100000073658

Prolonged-release granules. */
    N100000073658,
    /** # 100000073659

Cachet. */
    N100000073659,
    /** # 100000073660

Capsule, soft. */
    N100000073660,
    /** # 100000073661

Gastro-resistant capsule, soft. */
    N100000073661,
    /** # 100000073662

Prolonged-release capsule, hard. */
    N100000073662,
    /** # 100000073663

Modified-release capsule, hard. */
    N100000073663,
    /** # 100000073664

Tablet. */
    N100000073664,
    /** # 100000073665

Film-coated tablet. */
    N100000073665,
    /** # 100000073666

Orodispersible tablet. */
    N100000073666,
    /** # 100000073667

Gastro-resistant tablet. */
    N100000073667,
    /** # 100000073668

Modified-release tablet. */
    N100000073668,
    /** # 100000073669

Medicated chewing-gum. */
    N100000073669,
    /** # 100000073670

Pillules. */
    N100000073670,
    /** # 100000073671

Pulsatile-release intraruminal device. */
    N100000073671,
    /** # 100000073672

Premix for medicated feeding stuff. */
    N100000073672,
    /** # 100000073673

Gargle. */
    N100000073673,
    /** # 100000073674

Gargle, powder for solution. */
    N100000073674,
    /** # 100000073675

Oromucosal suspension. */
    N100000073675,
    /** # 100000073676

Oromucosal spray. */
    N100000073676,
    /** # 100000073677

Mouthwash. */
    N100000073677,
    /** # 100000073678

Gingival solution. */
    N100000073678,
    /** # 100000073679

Oromucosal paste. */
    N100000073679,
    /** # 100000073680

Gingival gel. */
    N100000073680,
    /** # 100000073681

Effervescent tablet. */
    N100000073681,
    /** # 100000073682

Oral lyophilisate. */
    N100000073682,
    /** # 100000073683

Prolonged-release tablet. */
    N100000073683,
    /** # 100000073684

Chewable tablet. */
    N100000073684,
    /** # 100000073685

Oral gum. */
    N100000073685,
    /** # 100000073686

Continuous-release intraruminal device. */
    N100000073686,
    /** # 100000073687

Lick block. */
    N100000073687,
    /** # 100000073688

Medicated pellets. */
    N100000073688,
    /** # 100000073689

Concentrate for gargle. */
    N100000073689,
    /** # 100000073690

Gargle, tablet for solution. */
    N100000073690,
    /** # 100000073691

Oromucosal solution. */
    N100000073691,
    /** # 100000073692

Oromucosal drops. */
    N100000073692,
    /** # 100000073693

Sublingual spray. */
    N100000073693,
    /** # 100000073694

Mouthwash, tablet for solution. */
    N100000073694,
    /** # 100000073695

Oromucosal gel. */
    N100000073695,
    /** # 100000073696

Oromucosal cream. */
    N100000073696,
    /** # 100000073697

Gingival paste. */
    N100000073697,
    /** # 100000073698

Sublingual tablet. */
    N100000073698,
    /** # 100000073699

Buccal tablet. */
    N100000073699,
    /** # 100000073700

Compressed lozenge. */
    N100000073700,
    /** # 100000073701

Oromucosal capsule. */
    N100000073701,
    /** # 100000073702

Muco-adhesive buccal tablet. */
    N100000073702,
    /** # 100000073703

Lozenge. */
    N100000073703,
    /** # 100000073704

Pastille. */
    N100000073704,
    /** # 100000073705

Dental gel. */
    N100000073705,
    /** # 100000073706

Dental insert. */
    N100000073706,
    /** # 100000073707

Dental powder. */
    N100000073707,
    /** # 100000073708

Dental suspension. */
    N100000073708,
    /** # 100000073709

Toothpaste. */
    N100000073709,
    /** # 100000073710

Periodontal gel. */
    N100000073710,
    /** # 100000073711

Bath additive. */
    N100000073711,
    /** # 100000073712

Cream. */
    N100000073712,
    /** # 100000073713

Ointment. */
    N100000073713,
    /** # 100000073714

Medicated plaster. */
    N100000073714,
    /** # 100000073715

Shampoo. */
    N100000073715,
    /** # 100000073716

Cutaneous spray, suspension. */
    N100000073716,
    /** # 100000073717

Cutaneous liquid. */
    N100000073717,
    /** # 100000073718

Concentrate for cutaneous solution. */
    N100000073718,
    /** # 100000073719

Cutaneous emulsion. */
    N100000073719,
    /** # 100000073720

Cutaneous patch. */
    N100000073720,
    /** # 100000073721

Periodontal powder. */
    N100000073721,
    /** # 100000073722

Dental stick. */
    N100000073722,
    /** # 100000073723

Dental solution. */
    N100000073723,
    /** # 100000073724

Dental emulsion. */
    N100000073724,
    /** # 100000073725

Periodontal insert. */
    N100000073725,
    /** # 100000073726

Gel. */
    N100000073726,
    /** # 100000073727

Cutaneous paste. */
    N100000073727,
    /** # 100000073728

Cutaneous foam. */
    N100000073728,
    /** # 100000073729

Cutaneous spray, solution. */
    N100000073729,
    /** # 100000073730

Cutaneous spray, powder. */
    N100000073730,
    /** # 100000073731

Cutaneous solution. */
    N100000073731,
    /** # 100000073732

Cutaneous suspension. */
    N100000073732,
    /** # 100000073733

Cutaneous powder. */
    N100000073733,
    /** # 100000073734

Solution for iontophoresis. */
    N100000073734,
    /** # 100000073735

Collodion. */
    N100000073735,
    /** # 100000073736

Poultice. */
    N100000073736,
    /** # 100000073737

Cutaneous sponge. */
    N100000073737,
    /** # 100000073738

Collar. */
    N100000073738,
    /** # 100000073739

Ear tag. */
    N100000073739,
    /** # 100000073740

Dip suspension. */
    N100000073740,
    /** # 100000073741

Transdermal patch. */
    N100000073741,
    /** # 100000073742

Medicated nail lacquer. */
    N100000073742,
    /** # 100000073743

Cutaneous stick. */
    N100000073743,
    /** # 100000073744

Impregnated dressing. */
    N100000073744,
    /** # 100000073745

Medicated pendant. */
    N100000073745,
    /** # 100000073746

Dip solution. */
    N100000073746,
    /** # 100000073747

Dip emulsion. */
    N100000073747,
    /** # 100000073748

Concentrate for dip suspension. */
    N100000073748,
    /** # 100000073749

Powder for dip solution. */
    N100000073749,
    /** # 100000073750

Powder for suspension for fish treatment. */
    N100000073750,
    /** # 100000073751

Pour-on suspension. */
    N100000073751,
    /** # 100000073752

Spot-on solution. */
    N100000073752,
    /** # 100000073753

Spot-on emulsion. */
    N100000073753,
    /** # 100000073754

Teat dip suspension. */
    N100000073754,
    /** # 100000073755

Teat spray solution. */
    N100000073755,
    /** # 100000073756

Solution for skin-prick test. */
    N100000073756,
    /** # 100000073757

Plaster for provocation test. */
    N100000073757,
    /** # 100000073758

Eye gel. */
    N100000073758,
    /** # 100000073759

Eye drops, solution. */
    N100000073759,
    /** # 100000073760

Eye drops, suspension. */
    N100000073760,
    /** # 100000073761

Concentrate for dip solution. */
    N100000073761,
    /** # 100000073762

Concentrate for dip emulsion. */
    N100000073762,
    /** # 100000073763

Concentrate for solution for fish treatment. */
    N100000073763,
    /** # 100000073764

Pour-on solution. */
    N100000073764,
    /** # 100000073765

Pour-on emulsion. */
    N100000073765,
    /** # 100000073766

Spot-on suspension. */
    N100000073766,
    /** # 100000073767

Teat dip solution. */
    N100000073767,
    /** # 100000073768

Teat dip emulsion. */
    N100000073768,
    /** # 100000073769

Transdermal system. */
    N100000073769,
    /** # 100000073770

Solution for skin-scratch test. */
    N100000073770,
    /** # 100000073771

Eye cream. */
    N100000073771,
    /** # 100000073772

Eye ointment. */
    N100000073772,
    /** # 100000073773

Eye drops, emulsion. */
    N100000073773,
    /** # 100000073775

Eye drops, solvent for reconstitution. */
    N100000073775,
    /** # 100000073776

Eye lotion. */
    N100000073776,
    /** # 100000073777

Ophthalmic insert. */
    N100000073777,
    /** # 100000073778

Ear cream. */
    N100000073778,
    /** # 100000073779

Ear ointment. */
    N100000073779,
    /** # 100000073780

Ear drops, suspension. */
    N100000073780,
    /** # 100000073782

Eye drops, prolonged-release. */
    N100000073782,
    /** # 100000073783

Eye lotion, solvent for reconstitution. */
    N100000073783,
    /** # 100000073784

Ophthalmic strip. */
    N100000073784,
    /** # 100000073785

Ear gel. */
    N100000073785,
    /** # 100000073786

Ear drops, solution. */
    N100000073786,
    /** # 100000073787

Ear drops, emulsion. */
    N100000073787,
    /** # 100000073788

Ear powder. */
    N100000073788,
    /** # 100000073789

Ear spray, suspension. */
    N100000073789,
    /** # 100000073790

Ear wash, solution. */
    N100000073790,
    /** # 100000073791

Ear tampon. */
    N100000073791,
    /** # 100000073792

Nasal cream. */
    N100000073792,
    /** # 100000073793

Nasal gel. */
    N100000073793,
    /** # 100000073794

Nasal drops, solution. */
    N100000073794,
    /** # 100000073795

Nasal drops, emulsion. */
    N100000073795,
    /** # 100000073796

Nasal spray, solution. */
    N100000073796,
    /** # 100000073797

Nasal spray, emulsion. */
    N100000073797,
    /** # 100000073798

Nasal stick. */
    N100000073798,
    /** # 100000073799

Vaginal gel. */
    N100000073799,
    /** # 100000073800

Vaginal foam. */
    N100000073800,
    /** # 100000073802

Ear spray, solution. */
    N100000073802,
    /** # 100000073803

Ear spray, emulsion. */
    N100000073803,
    /** # 100000073804

Ear wash, emulsion. */
    N100000073804,
    /** # 100000073805

Ear stick. */
    N100000073805,
    /** # 100000073806

Nasal ointment. */
    N100000073806,
    /** # 100000073807

Nasal drops, suspension. */
    N100000073807,
    /** # 100000073808

Nasal powder. */
    N100000073808,
    /** # 100000073809

Nasal spray, suspension. */
    N100000073809,
    /** # 100000073810

Nasal wash. */
    N100000073810,
    /** # 100000073811

Vaginal cream. */
    N100000073811,
    /** # 100000073812

Vaginal ointment. */
    N100000073812,
    /** # 100000073813

Vaginal solution. */
    N100000073813,
    /** # 100000073814

Vaginal emulsion. */
    N100000073814,
    /** # 100000073815

Pessary. */
    N100000073815,
    /** # 100000073816

Vaginal capsule, soft. */
    N100000073816,
    /** # 100000073817

Effervescent vaginal tablet. */
    N100000073817,
    /** # 100000073818

Vaginal delivery system. */
    N100000073818,
    /** # 100000073819

Rectal cream. */
    N100000073819,
    /** # 100000073820

Rectal foam. */
    N100000073820,
    /** # 100000073821

Vaginal suspension. */
    N100000073821,
    /** # 100000073822

Tablet for vaginal solution. */
    N100000073822,
    /** # 100000073823

Vaginal capsule, hard. */
    N100000073823,
    /** # 100000073824

Vaginal tablet. */
    N100000073824,
    /** # 100000073825

Medicated vaginal tampon. */
    N100000073825,
    /** # 100000073826

Vaginal sponge. */
    N100000073826,
    /** # 100000073827

Rectal gel. */
    N100000073827,
    /** # 100000073863

Solution for injection. */
    N100000073863,
}
impl ::core::str::FromStr for AdministrableDoseForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073362" => Ok(Self::N100000073362),
            "100000073363" => Ok(Self::N100000073363),
            "100000073364" => Ok(Self::N100000073364),
            "100000073365" => Ok(Self::N100000073365),
            "100000073367" => Ok(Self::N100000073367),
            "100000073368" => Ok(Self::N100000073368),
            "100000073369" => Ok(Self::N100000073369),
            "100000073370" => Ok(Self::N100000073370),
            "100000073371" => Ok(Self::N100000073371),
            "100000073372" => Ok(Self::N100000073372),
            "100000073373" => Ok(Self::N100000073373),
            "100000073374" => Ok(Self::N100000073374),
            "100000073375" => Ok(Self::N100000073375),
            "100000073376" => Ok(Self::N100000073376),
            "100000073377" => Ok(Self::N100000073377),
            "100000073378" => Ok(Self::N100000073378),
            "100000073379" => Ok(Self::N100000073379),
            "100000073380" => Ok(Self::N100000073380),
            "100000073642" => Ok(Self::N100000073642),
            "100000073643" => Ok(Self::N100000073643),
            "100000073644" => Ok(Self::N100000073644),
            "100000073645" => Ok(Self::N100000073645),
            "100000073646" => Ok(Self::N100000073646),
            "100000073647" => Ok(Self::N100000073647),
            "100000073648" => Ok(Self::N100000073648),
            "100000073649" => Ok(Self::N100000073649),
            "100000073650" => Ok(Self::N100000073650),
            "100000073652" => Ok(Self::N100000073652),
            "100000073653" => Ok(Self::N100000073653),
            "100000073654" => Ok(Self::N100000073654),
            "100000073655" => Ok(Self::N100000073655),
            "100000073656" => Ok(Self::N100000073656),
            "100000073657" => Ok(Self::N100000073657),
            "100000073658" => Ok(Self::N100000073658),
            "100000073659" => Ok(Self::N100000073659),
            "100000073660" => Ok(Self::N100000073660),
            "100000073661" => Ok(Self::N100000073661),
            "100000073662" => Ok(Self::N100000073662),
            "100000073663" => Ok(Self::N100000073663),
            "100000073664" => Ok(Self::N100000073664),
            "100000073665" => Ok(Self::N100000073665),
            "100000073666" => Ok(Self::N100000073666),
            "100000073667" => Ok(Self::N100000073667),
            "100000073668" => Ok(Self::N100000073668),
            "100000073669" => Ok(Self::N100000073669),
            "100000073670" => Ok(Self::N100000073670),
            "100000073671" => Ok(Self::N100000073671),
            "100000073672" => Ok(Self::N100000073672),
            "100000073673" => Ok(Self::N100000073673),
            "100000073674" => Ok(Self::N100000073674),
            "100000073675" => Ok(Self::N100000073675),
            "100000073676" => Ok(Self::N100000073676),
            "100000073677" => Ok(Self::N100000073677),
            "100000073678" => Ok(Self::N100000073678),
            "100000073679" => Ok(Self::N100000073679),
            "100000073680" => Ok(Self::N100000073680),
            "100000073681" => Ok(Self::N100000073681),
            "100000073682" => Ok(Self::N100000073682),
            "100000073683" => Ok(Self::N100000073683),
            "100000073684" => Ok(Self::N100000073684),
            "100000073685" => Ok(Self::N100000073685),
            "100000073686" => Ok(Self::N100000073686),
            "100000073687" => Ok(Self::N100000073687),
            "100000073688" => Ok(Self::N100000073688),
            "100000073689" => Ok(Self::N100000073689),
            "100000073690" => Ok(Self::N100000073690),
            "100000073691" => Ok(Self::N100000073691),
            "100000073692" => Ok(Self::N100000073692),
            "100000073693" => Ok(Self::N100000073693),
            "100000073694" => Ok(Self::N100000073694),
            "100000073695" => Ok(Self::N100000073695),
            "100000073696" => Ok(Self::N100000073696),
            "100000073697" => Ok(Self::N100000073697),
            "100000073698" => Ok(Self::N100000073698),
            "100000073699" => Ok(Self::N100000073699),
            "100000073700" => Ok(Self::N100000073700),
            "100000073701" => Ok(Self::N100000073701),
            "100000073702" => Ok(Self::N100000073702),
            "100000073703" => Ok(Self::N100000073703),
            "100000073704" => Ok(Self::N100000073704),
            "100000073705" => Ok(Self::N100000073705),
            "100000073706" => Ok(Self::N100000073706),
            "100000073707" => Ok(Self::N100000073707),
            "100000073708" => Ok(Self::N100000073708),
            "100000073709" => Ok(Self::N100000073709),
            "100000073710" => Ok(Self::N100000073710),
            "100000073711" => Ok(Self::N100000073711),
            "100000073712" => Ok(Self::N100000073712),
            "100000073713" => Ok(Self::N100000073713),
            "100000073714" => Ok(Self::N100000073714),
            "100000073715" => Ok(Self::N100000073715),
            "100000073716" => Ok(Self::N100000073716),
            "100000073717" => Ok(Self::N100000073717),
            "100000073718" => Ok(Self::N100000073718),
            "100000073719" => Ok(Self::N100000073719),
            "100000073720" => Ok(Self::N100000073720),
            "100000073721" => Ok(Self::N100000073721),
            "100000073722" => Ok(Self::N100000073722),
            "100000073723" => Ok(Self::N100000073723),
            "100000073724" => Ok(Self::N100000073724),
            "100000073725" => Ok(Self::N100000073725),
            "100000073726" => Ok(Self::N100000073726),
            "100000073727" => Ok(Self::N100000073727),
            "100000073728" => Ok(Self::N100000073728),
            "100000073729" => Ok(Self::N100000073729),
            "100000073730" => Ok(Self::N100000073730),
            "100000073731" => Ok(Self::N100000073731),
            "100000073732" => Ok(Self::N100000073732),
            "100000073733" => Ok(Self::N100000073733),
            "100000073734" => Ok(Self::N100000073734),
            "100000073735" => Ok(Self::N100000073735),
            "100000073736" => Ok(Self::N100000073736),
            "100000073737" => Ok(Self::N100000073737),
            "100000073738" => Ok(Self::N100000073738),
            "100000073739" => Ok(Self::N100000073739),
            "100000073740" => Ok(Self::N100000073740),
            "100000073741" => Ok(Self::N100000073741),
            "100000073742" => Ok(Self::N100000073742),
            "100000073743" => Ok(Self::N100000073743),
            "100000073744" => Ok(Self::N100000073744),
            "100000073745" => Ok(Self::N100000073745),
            "100000073746" => Ok(Self::N100000073746),
            "100000073747" => Ok(Self::N100000073747),
            "100000073748" => Ok(Self::N100000073748),
            "100000073749" => Ok(Self::N100000073749),
            "100000073750" => Ok(Self::N100000073750),
            "100000073751" => Ok(Self::N100000073751),
            "100000073752" => Ok(Self::N100000073752),
            "100000073753" => Ok(Self::N100000073753),
            "100000073754" => Ok(Self::N100000073754),
            "100000073755" => Ok(Self::N100000073755),
            "100000073756" => Ok(Self::N100000073756),
            "100000073757" => Ok(Self::N100000073757),
            "100000073758" => Ok(Self::N100000073758),
            "100000073759" => Ok(Self::N100000073759),
            "100000073760" => Ok(Self::N100000073760),
            "100000073761" => Ok(Self::N100000073761),
            "100000073762" => Ok(Self::N100000073762),
            "100000073763" => Ok(Self::N100000073763),
            "100000073764" => Ok(Self::N100000073764),
            "100000073765" => Ok(Self::N100000073765),
            "100000073766" => Ok(Self::N100000073766),
            "100000073767" => Ok(Self::N100000073767),
            "100000073768" => Ok(Self::N100000073768),
            "100000073769" => Ok(Self::N100000073769),
            "100000073770" => Ok(Self::N100000073770),
            "100000073771" => Ok(Self::N100000073771),
            "100000073772" => Ok(Self::N100000073772),
            "100000073773" => Ok(Self::N100000073773),
            "100000073775" => Ok(Self::N100000073775),
            "100000073776" => Ok(Self::N100000073776),
            "100000073777" => Ok(Self::N100000073777),
            "100000073778" => Ok(Self::N100000073778),
            "100000073779" => Ok(Self::N100000073779),
            "100000073780" => Ok(Self::N100000073780),
            "100000073782" => Ok(Self::N100000073782),
            "100000073783" => Ok(Self::N100000073783),
            "100000073784" => Ok(Self::N100000073784),
            "100000073785" => Ok(Self::N100000073785),
            "100000073786" => Ok(Self::N100000073786),
            "100000073787" => Ok(Self::N100000073787),
            "100000073788" => Ok(Self::N100000073788),
            "100000073789" => Ok(Self::N100000073789),
            "100000073790" => Ok(Self::N100000073790),
            "100000073791" => Ok(Self::N100000073791),
            "100000073792" => Ok(Self::N100000073792),
            "100000073793" => Ok(Self::N100000073793),
            "100000073794" => Ok(Self::N100000073794),
            "100000073795" => Ok(Self::N100000073795),
            "100000073796" => Ok(Self::N100000073796),
            "100000073797" => Ok(Self::N100000073797),
            "100000073798" => Ok(Self::N100000073798),
            "100000073799" => Ok(Self::N100000073799),
            "100000073800" => Ok(Self::N100000073800),
            "100000073802" => Ok(Self::N100000073802),
            "100000073803" => Ok(Self::N100000073803),
            "100000073804" => Ok(Self::N100000073804),
            "100000073805" => Ok(Self::N100000073805),
            "100000073806" => Ok(Self::N100000073806),
            "100000073807" => Ok(Self::N100000073807),
            "100000073808" => Ok(Self::N100000073808),
            "100000073809" => Ok(Self::N100000073809),
            "100000073810" => Ok(Self::N100000073810),
            "100000073811" => Ok(Self::N100000073811),
            "100000073812" => Ok(Self::N100000073812),
            "100000073813" => Ok(Self::N100000073813),
            "100000073814" => Ok(Self::N100000073814),
            "100000073815" => Ok(Self::N100000073815),
            "100000073816" => Ok(Self::N100000073816),
            "100000073817" => Ok(Self::N100000073817),
            "100000073818" => Ok(Self::N100000073818),
            "100000073819" => Ok(Self::N100000073819),
            "100000073820" => Ok(Self::N100000073820),
            "100000073821" => Ok(Self::N100000073821),
            "100000073822" => Ok(Self::N100000073822),
            "100000073823" => Ok(Self::N100000073823),
            "100000073824" => Ok(Self::N100000073824),
            "100000073825" => Ok(Self::N100000073825),
            "100000073826" => Ok(Self::N100000073826),
            "100000073827" => Ok(Self::N100000073827),
            "100000073863" => Ok(Self::N100000073863),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdministrableDoseForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073362 => "100000073362",
            Self::N100000073363 => "100000073363",
            Self::N100000073364 => "100000073364",
            Self::N100000073365 => "100000073365",
            Self::N100000073367 => "100000073367",
            Self::N100000073368 => "100000073368",
            Self::N100000073369 => "100000073369",
            Self::N100000073370 => "100000073370",
            Self::N100000073371 => "100000073371",
            Self::N100000073372 => "100000073372",
            Self::N100000073373 => "100000073373",
            Self::N100000073374 => "100000073374",
            Self::N100000073375 => "100000073375",
            Self::N100000073376 => "100000073376",
            Self::N100000073377 => "100000073377",
            Self::N100000073378 => "100000073378",
            Self::N100000073379 => "100000073379",
            Self::N100000073380 => "100000073380",
            Self::N100000073642 => "100000073642",
            Self::N100000073643 => "100000073643",
            Self::N100000073644 => "100000073644",
            Self::N100000073645 => "100000073645",
            Self::N100000073646 => "100000073646",
            Self::N100000073647 => "100000073647",
            Self::N100000073648 => "100000073648",
            Self::N100000073649 => "100000073649",
            Self::N100000073650 => "100000073650",
            Self::N100000073652 => "100000073652",
            Self::N100000073653 => "100000073653",
            Self::N100000073654 => "100000073654",
            Self::N100000073655 => "100000073655",
            Self::N100000073656 => "100000073656",
            Self::N100000073657 => "100000073657",
            Self::N100000073658 => "100000073658",
            Self::N100000073659 => "100000073659",
            Self::N100000073660 => "100000073660",
            Self::N100000073661 => "100000073661",
            Self::N100000073662 => "100000073662",
            Self::N100000073663 => "100000073663",
            Self::N100000073664 => "100000073664",
            Self::N100000073665 => "100000073665",
            Self::N100000073666 => "100000073666",
            Self::N100000073667 => "100000073667",
            Self::N100000073668 => "100000073668",
            Self::N100000073669 => "100000073669",
            Self::N100000073670 => "100000073670",
            Self::N100000073671 => "100000073671",
            Self::N100000073672 => "100000073672",
            Self::N100000073673 => "100000073673",
            Self::N100000073674 => "100000073674",
            Self::N100000073675 => "100000073675",
            Self::N100000073676 => "100000073676",
            Self::N100000073677 => "100000073677",
            Self::N100000073678 => "100000073678",
            Self::N100000073679 => "100000073679",
            Self::N100000073680 => "100000073680",
            Self::N100000073681 => "100000073681",
            Self::N100000073682 => "100000073682",
            Self::N100000073683 => "100000073683",
            Self::N100000073684 => "100000073684",
            Self::N100000073685 => "100000073685",
            Self::N100000073686 => "100000073686",
            Self::N100000073687 => "100000073687",
            Self::N100000073688 => "100000073688",
            Self::N100000073689 => "100000073689",
            Self::N100000073690 => "100000073690",
            Self::N100000073691 => "100000073691",
            Self::N100000073692 => "100000073692",
            Self::N100000073693 => "100000073693",
            Self::N100000073694 => "100000073694",
            Self::N100000073695 => "100000073695",
            Self::N100000073696 => "100000073696",
            Self::N100000073697 => "100000073697",
            Self::N100000073698 => "100000073698",
            Self::N100000073699 => "100000073699",
            Self::N100000073700 => "100000073700",
            Self::N100000073701 => "100000073701",
            Self::N100000073702 => "100000073702",
            Self::N100000073703 => "100000073703",
            Self::N100000073704 => "100000073704",
            Self::N100000073705 => "100000073705",
            Self::N100000073706 => "100000073706",
            Self::N100000073707 => "100000073707",
            Self::N100000073708 => "100000073708",
            Self::N100000073709 => "100000073709",
            Self::N100000073710 => "100000073710",
            Self::N100000073711 => "100000073711",
            Self::N100000073712 => "100000073712",
            Self::N100000073713 => "100000073713",
            Self::N100000073714 => "100000073714",
            Self::N100000073715 => "100000073715",
            Self::N100000073716 => "100000073716",
            Self::N100000073717 => "100000073717",
            Self::N100000073718 => "100000073718",
            Self::N100000073719 => "100000073719",
            Self::N100000073720 => "100000073720",
            Self::N100000073721 => "100000073721",
            Self::N100000073722 => "100000073722",
            Self::N100000073723 => "100000073723",
            Self::N100000073724 => "100000073724",
            Self::N100000073725 => "100000073725",
            Self::N100000073726 => "100000073726",
            Self::N100000073727 => "100000073727",
            Self::N100000073728 => "100000073728",
            Self::N100000073729 => "100000073729",
            Self::N100000073730 => "100000073730",
            Self::N100000073731 => "100000073731",
            Self::N100000073732 => "100000073732",
            Self::N100000073733 => "100000073733",
            Self::N100000073734 => "100000073734",
            Self::N100000073735 => "100000073735",
            Self::N100000073736 => "100000073736",
            Self::N100000073737 => "100000073737",
            Self::N100000073738 => "100000073738",
            Self::N100000073739 => "100000073739",
            Self::N100000073740 => "100000073740",
            Self::N100000073741 => "100000073741",
            Self::N100000073742 => "100000073742",
            Self::N100000073743 => "100000073743",
            Self::N100000073744 => "100000073744",
            Self::N100000073745 => "100000073745",
            Self::N100000073746 => "100000073746",
            Self::N100000073747 => "100000073747",
            Self::N100000073748 => "100000073748",
            Self::N100000073749 => "100000073749",
            Self::N100000073750 => "100000073750",
            Self::N100000073751 => "100000073751",
            Self::N100000073752 => "100000073752",
            Self::N100000073753 => "100000073753",
            Self::N100000073754 => "100000073754",
            Self::N100000073755 => "100000073755",
            Self::N100000073756 => "100000073756",
            Self::N100000073757 => "100000073757",
            Self::N100000073758 => "100000073758",
            Self::N100000073759 => "100000073759",
            Self::N100000073760 => "100000073760",
            Self::N100000073761 => "100000073761",
            Self::N100000073762 => "100000073762",
            Self::N100000073763 => "100000073763",
            Self::N100000073764 => "100000073764",
            Self::N100000073765 => "100000073765",
            Self::N100000073766 => "100000073766",
            Self::N100000073767 => "100000073767",
            Self::N100000073768 => "100000073768",
            Self::N100000073769 => "100000073769",
            Self::N100000073770 => "100000073770",
            Self::N100000073771 => "100000073771",
            Self::N100000073772 => "100000073772",
            Self::N100000073773 => "100000073773",
            Self::N100000073775 => "100000073775",
            Self::N100000073776 => "100000073776",
            Self::N100000073777 => "100000073777",
            Self::N100000073778 => "100000073778",
            Self::N100000073779 => "100000073779",
            Self::N100000073780 => "100000073780",
            Self::N100000073782 => "100000073782",
            Self::N100000073783 => "100000073783",
            Self::N100000073784 => "100000073784",
            Self::N100000073785 => "100000073785",
            Self::N100000073786 => "100000073786",
            Self::N100000073787 => "100000073787",
            Self::N100000073788 => "100000073788",
            Self::N100000073789 => "100000073789",
            Self::N100000073790 => "100000073790",
            Self::N100000073791 => "100000073791",
            Self::N100000073792 => "100000073792",
            Self::N100000073793 => "100000073793",
            Self::N100000073794 => "100000073794",
            Self::N100000073795 => "100000073795",
            Self::N100000073796 => "100000073796",
            Self::N100000073797 => "100000073797",
            Self::N100000073798 => "100000073798",
            Self::N100000073799 => "100000073799",
            Self::N100000073800 => "100000073800",
            Self::N100000073802 => "100000073802",
            Self::N100000073803 => "100000073803",
            Self::N100000073804 => "100000073804",
            Self::N100000073805 => "100000073805",
            Self::N100000073806 => "100000073806",
            Self::N100000073807 => "100000073807",
            Self::N100000073808 => "100000073808",
            Self::N100000073809 => "100000073809",
            Self::N100000073810 => "100000073810",
            Self::N100000073811 => "100000073811",
            Self::N100000073812 => "100000073812",
            Self::N100000073813 => "100000073813",
            Self::N100000073814 => "100000073814",
            Self::N100000073815 => "100000073815",
            Self::N100000073816 => "100000073816",
            Self::N100000073817 => "100000073817",
            Self::N100000073818 => "100000073818",
            Self::N100000073819 => "100000073819",
            Self::N100000073820 => "100000073820",
            Self::N100000073821 => "100000073821",
            Self::N100000073822 => "100000073822",
            Self::N100000073823 => "100000073823",
            Self::N100000073824 => "100000073824",
            Self::N100000073825 => "100000073825",
            Self::N100000073826 => "100000073826",
            Self::N100000073827 => "100000073827",
            Self::N100000073863 => "100000073863",
        }
    }
}
impl<'de> Deserialize<'de> for AdministrableDoseForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdministrableDoseForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdministrativeGender`. The gender of a person used for administrative purposes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdministrativeGender {
    /** # female

Female. Female. */
    Female,
    /** # male

Male. Male. */
    Male,
    /** # other

Other. Other. */
    Other,
    /** # unknown

Unknown. Unknown. */
    Unknown,
}
impl ::core::str::FromStr for AdministrativeGender {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "female" => Ok(Self::Female),
            "male" => Ok(Self::Male),
            "other" => Ok(Self::Other),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdministrativeGender {
    fn as_ref(&self) -> &str {
        match self {
            Self::Female => "female",
            Self::Male => "male",
            Self::Other => "other",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for AdministrativeGender {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdministrativeGender {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdmitSource`. This codesystem defines a set of codes that can be used to indicate from where the patient came in.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AdmitSource {
    /** # born

Born in hospital. The patient is a newborn and the encounter will track the baby related activities (as opposed to the Mothers encounter - that may be associated using the newborn encounters partof property) */
    Born,
    /** # emd

From accident/emergency department. The patient has been transferred from the emergency department within the hospital. This is typically used in the transition to an inpatient encounter */
    Emd,
    /** # gp

General Practitioner referral. The patient has been admitted due to a referred from a General Practitioner. */
    Gp,
    /** # hosp-trans

Transferred from other hospital. The Patient has been transferred from another hospital for this encounter. */
    HospTrans,
    /** # mp

Medical Practitioner/physician referral. The patient has been admitted due to a referred from a Specialist (as opposed to a General Practitioner). */
    Mp,
    /** # nursing

From nursing home. The patient has been transferred from a nursing home. */
    Nursing,
    /** # other

Other. The patient has been admitted from a source otherwise not specified here. */
    Other,
    /** # outp

From outpatient department. The patient has been transferred from an outpatient department within the hospital. */
    Outp,
    /** # psych

From psychiatric hospital. The patient has been transferred from a psychiatric facility. */
    Psych,
    /** # rehab

From rehabilitation facility. The patient has been transferred from a rehabilitation facility or clinic. */
    Rehab,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AdmitSource {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "born" => Ok(Self::Born),
            "emd" => Ok(Self::Emd),
            "gp" => Ok(Self::Gp),
            "hosp-trans" => Ok(Self::HospTrans),
            "mp" => Ok(Self::Mp),
            "nursing" => Ok(Self::Nursing),
            "other" => Ok(Self::Other),
            "outp" => Ok(Self::Outp),
            "psych" => Ok(Self::Psych),
            "rehab" => Ok(Self::Rehab),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AdmitSource {
    fn as_ref(&self) -> &str {
        match self {
            Self::Born => "born",
            Self::Emd => "emd",
            Self::Gp => "gp",
            Self::HospTrans => "hosp-trans",
            Self::Mp => "mp",
            Self::Nursing => "nursing",
            Self::Other => "other",
            Self::Outp => "outp",
            Self::Psych => "psych",
            Self::Rehab => "rehab",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for AdmitSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdmitSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdverseEventActuality`. Overall nature of the adverse event, e.g. real or potential.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdverseEventActuality {
    /** # actual

Adverse Event. The adverse event actually happened regardless of whether anyone was affected or harmed. */
    Actual,
    /** # potential

Potential Adverse Event. A potential adverse event. */
    Potential,
}
impl ::core::str::FromStr for AdverseEventActuality {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "actual" => Ok(Self::Actual),
            "potential" => Ok(Self::Potential),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventActuality {
    fn as_ref(&self) -> &str {
        match self {
            Self::Actual => "actual",
            Self::Potential => "potential",
        }
    }
}
impl<'de> Deserialize<'de> for AdverseEventActuality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventActuality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdverseEventCategory`. Overall categorization of the event, e.g. product-related or situational.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdverseEventCategory {
    /** # expired-drug

Expired Drug. The adverse event pertains to an expired drug. */
    ExpiredDrug,
    /** # incorrect-prescribing-information

Incorrect Prescribing Information. The adverse event pertains to incorrect perscribing information. */
    IncorrectPrescribingInformation,
    /** # medical-device-use-error

Medical Device Use Error. The adverse event pertains to a medical device use error. */
    MedicalDeviceUseError,
    /** # problem-different-manufacturer

Problem with Different Manufacturer of Same Medicine. The adverse event pertains to a problem with a different manufacturer of the same medication. */
    ProblemDifferentManufacturer,
    /** # product-problem

Product Problem. The adverse event pertains to a product problem. */
    ProductProblem,
    /** # product-quality

Product Quality. The adverse event pertains to product quality. */
    ProductQuality,
    /** # product-use-error

Product Use Error. The adverse event pertains to a product use error. */
    ProductUseError,
    /** # unsafe-physical-environment

Unsafe Physical Environment. The adverse event pertains to an unsafe physical environment. */
    UnsafePhysicalEnvironment,
    /** # wrong-dose

Wrong Dose. The adverse event pertains to a wrong dose. */
    WrongDose,
    /** # wrong-duration

Wrong Duration. The adverse event pertains to a wrong duration. */
    WrongDuration,
    /** # wrong-rate

Wrong Rate. The adverse event pertains to a wrong rate. */
    WrongRate,
    /** # wrong-route-of-administration

Wrong Route of Administration. The adverse event pertains to a wrong route of administration. */
    WrongRouteOfAdministration,
    /** # wrong-technique

Wrong Technique. The adverse event pertains to a wrong technique. */
    WrongTechnique,
    /** # wrong-time

Wrong Time. The adverse event pertains to a wrong time. */
    WrongTime,
}
impl ::core::str::FromStr for AdverseEventCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "expired-drug" => Ok(Self::ExpiredDrug),
            "incorrect-prescribing-information" => {
                Ok(Self::IncorrectPrescribingInformation)
            }
            "medical-device-use-error" => Ok(Self::MedicalDeviceUseError),
            "problem-different-manufacturer" => Ok(Self::ProblemDifferentManufacturer),
            "product-problem" => Ok(Self::ProductProblem),
            "product-quality" => Ok(Self::ProductQuality),
            "product-use-error" => Ok(Self::ProductUseError),
            "unsafe-physical-environment" => Ok(Self::UnsafePhysicalEnvironment),
            "wrong-dose" => Ok(Self::WrongDose),
            "wrong-duration" => Ok(Self::WrongDuration),
            "wrong-rate" => Ok(Self::WrongRate),
            "wrong-route-of-administration" => Ok(Self::WrongRouteOfAdministration),
            "wrong-technique" => Ok(Self::WrongTechnique),
            "wrong-time" => Ok(Self::WrongTime),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::ExpiredDrug => "expired-drug",
            Self::IncorrectPrescribingInformation => "incorrect-prescribing-information",
            Self::MedicalDeviceUseError => "medical-device-use-error",
            Self::ProblemDifferentManufacturer => "problem-different-manufacturer",
            Self::ProductProblem => "product-problem",
            Self::ProductQuality => "product-quality",
            Self::ProductUseError => "product-use-error",
            Self::UnsafePhysicalEnvironment => "unsafe-physical-environment",
            Self::WrongDose => "wrong-dose",
            Self::WrongDuration => "wrong-duration",
            Self::WrongRate => "wrong-rate",
            Self::WrongRouteOfAdministration => "wrong-route-of-administration",
            Self::WrongTechnique => "wrong-technique",
            Self::WrongTime => "wrong-time",
        }
    }
}
impl<'de> Deserialize<'de> for AdverseEventCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdverseEventCausalityAssessment`. Codes for the assessment of whether the entity caused the event.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdverseEventCausalityAssessment {
    /** # Certain

Certain. i) Event or laboratory test abnormality, with plausible time relationship to drug intake; ii) Cannot be explained by disease or other drugs; iii) Response to withdrawal plausible (pharmacologically, pathologically); iv) Event definitive pharmacologically or phenomenologically (i.e. an objective and specific medical disorder or a recognized pharmacological phenomenon); or v) Re-challenge satisfactory, if necessary. */
    Certain,
    /** # Conditional-Classified

Conditional/Classified. i) Event or laboratory test abnormality; ii) More data for proper assessment needed; or iii) Additional data under examination. */
    ConditionalClassified,
    /** # Possible

Possible. i) Event or laboratory test abnormality, with reasonable time relationship to drug intake; ii) Could also be explained by disease or other drugs; or iii) Information on drug withdrawal may be lacking or unclear. */
    Possible,
    /** # Probably-Likely

Probably/Likely. i) Event or laboratory test abnormality, with reasonable time relationship to drug intake; ii) Unlikely to be attributed to disease or other drugs; iii) Response to withdrawal clinically reasonable; or iv) Re-challenge not required. */
    ProbablyLikely,
    /** # Unassessable-Unclassifiable

Unassessable/Unclassifiable. i) Report suggesting an adverse reaction; ii) Cannot be judged because information is insufficient or contradictory; or iii) Data cannot be supplemented or verified. */
    UnassessableUnclassifiable,
    /** # Unlikely

Unlikely. i) Event or laboratory test abnormality, with a time to drug intake that makes a relationship improbable (but not impossible); or ii) Disease or other drugs provide plausible explanations. */
    Unlikely,
}
impl ::core::str::FromStr for AdverseEventCausalityAssessment {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Certain" => Ok(Self::Certain),
            "Conditional-Classified" => Ok(Self::ConditionalClassified),
            "Possible" => Ok(Self::Possible),
            "Probably-Likely" => Ok(Self::ProbablyLikely),
            "Unassessable-Unclassifiable" => Ok(Self::UnassessableUnclassifiable),
            "Unlikely" => Ok(Self::Unlikely),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCausalityAssessment {
    fn as_ref(&self) -> &str {
        match self {
            Self::Certain => "Certain",
            Self::ConditionalClassified => "Conditional-Classified",
            Self::Possible => "Possible",
            Self::ProbablyLikely => "Probably-Likely",
            Self::UnassessableUnclassifiable => "Unassessable-Unclassifiable",
            Self::Unlikely => "Unlikely",
        }
    }
}
impl<'de> Deserialize<'de> for AdverseEventCausalityAssessment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCausalityAssessment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdverseEventCausalityMethod`. TODO.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdverseEventCausalityMethod {
    /** # Bayesian

Bayesian. */
    Bayesian,
    /** # Checklist

Checklist. */
    Checklist,
    /** # ProbabilityScale

Probability Scale. */
    ProbabilityScale,
}
impl ::core::str::FromStr for AdverseEventCausalityMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Bayesian" => Ok(Self::Bayesian),
            "Checklist" => Ok(Self::Checklist),
            "ProbabilityScale" => Ok(Self::ProbabilityScale),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventCausalityMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bayesian => "Bayesian",
            Self::Checklist => "Checklist",
            Self::ProbabilityScale => "ProbabilityScale",
        }
    }
}
impl<'de> Deserialize<'de> for AdverseEventCausalityMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventCausalityMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdverseEventOutcome`. TODO (and should this be required?).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdverseEventOutcome {
    /** # fatal

Fatal. */
    Fatal,
    /** # ongoing

Ongoing. */
    Ongoing,
    /** # recovering

Recovering. */
    Recovering,
    /** # resolved

Resolved. */
    Resolved,
    /** # resolvedWithSequelae

Resolved with Sequelae. */
    ResolvedWithSequelae,
    /** # unknown

Unknown. */
    Unknown,
}
impl ::core::str::FromStr for AdverseEventOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fatal" => Ok(Self::Fatal),
            "ongoing" => Ok(Self::Ongoing),
            "recovering" => Ok(Self::Recovering),
            "resolved" => Ok(Self::Resolved),
            "resolvedWithSequelae" => Ok(Self::ResolvedWithSequelae),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fatal => "fatal",
            Self::Ongoing => "ongoing",
            Self::Recovering => "recovering",
            Self::Resolved => "resolved",
            Self::ResolvedWithSequelae => "resolvedWithSequelae",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for AdverseEventOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdverseEventSeriousness`. Overall seriousness of this event for the patient.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdverseEventSeriousness {
    /** # Non-serious

Non-serious. Non-serious. */
    NonSerious,
    /** # Serious

Serious. Serious. */
    Serious,
    /** # SeriousIsBirthDefect

Is a congenital anomaly/birth defect. Is a congenital anomaly/birth defect. */
    SeriousIsBirthDefect,
    /** # SeriousIsLifeThreatening

Is Life-threatening. Is Life-threatening. */
    SeriousIsLifeThreatening,
    /** # SeriousRequiresPreventImpairment

Requires intervention to prevent permanent impairment. Requires intervention to prevent permanent impairment or damage (i.e., an important medical event that requires medical judgement). */
    SeriousRequiresPreventImpairment,
    /** # SeriousResultsInDeath

Results in death. Results in death. */
    SeriousResultsInDeath,
    /** # SeriousResultsInDisability

Results in persistent or significant disability/incapacity. Results in persistent or significant disability/incapacity. */
    SeriousResultsInDisability,
    /** # SeriousResultsInHospitalization

Requires or prolongs inpatient hospitalization. Requires inpatient hospitalization or causes prolongation of existing hospitalization. */
    SeriousResultsInHospitalization,
}
impl ::core::str::FromStr for AdverseEventSeriousness {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Non-serious" => Ok(Self::NonSerious),
            "Serious" => Ok(Self::Serious),
            "SeriousIsBirthDefect" => Ok(Self::SeriousIsBirthDefect),
            "SeriousIsLifeThreatening" => Ok(Self::SeriousIsLifeThreatening),
            "SeriousRequiresPreventImpairment" => {
                Ok(Self::SeriousRequiresPreventImpairment)
            }
            "SeriousResultsInDeath" => Ok(Self::SeriousResultsInDeath),
            "SeriousResultsInDisability" => Ok(Self::SeriousResultsInDisability),
            "SeriousResultsInHospitalization" => {
                Ok(Self::SeriousResultsInHospitalization)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventSeriousness {
    fn as_ref(&self) -> &str {
        match self {
            Self::NonSerious => "Non-serious",
            Self::Serious => "Serious",
            Self::SeriousIsBirthDefect => "SeriousIsBirthDefect",
            Self::SeriousIsLifeThreatening => "SeriousIsLifeThreatening",
            Self::SeriousRequiresPreventImpairment => "SeriousRequiresPreventImpairment",
            Self::SeriousResultsInDeath => "SeriousResultsInDeath",
            Self::SeriousResultsInDisability => "SeriousResultsInDisability",
            Self::SeriousResultsInHospitalization => "SeriousResultsInHospitalization",
        }
    }
}
impl<'de> Deserialize<'de> for AdverseEventSeriousness {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventSeriousness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AdverseEventSeverity`. The severity of the adverse event itself, in direct relation to the subject.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AdverseEventSeverity {
    /** # mild

Mild. */
    Mild,
    /** # moderate

Moderate. */
    Moderate,
    /** # severe

Severe. */
    Severe,
}
impl ::core::str::FromStr for AdverseEventSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mild" => Ok(Self::Mild),
            "moderate" => Ok(Self::Moderate),
            "severe" => Ok(Self::Severe),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AdverseEventSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mild => "mild",
            Self::Moderate => "moderate",
            Self::Severe => "severe",
        }
    }
}
impl<'de> Deserialize<'de> for AdverseEventSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AdverseEventSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AggregationMode`. How resource references can be aggregated.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AggregationMode {
    /** # bundled

Bundled. The resource the reference points to will be found in the same bundle as the resource that includes the reference. */
    Bundled,
    /** # contained

Contained. The reference is a local reference to a contained resource. */
    Contained,
    /** # referenced

Referenced. The reference to a resource that has to be resolved externally to the resource that includes the reference. */
    Referenced,
}
impl ::core::str::FromStr for AggregationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bundled" => Ok(Self::Bundled),
            "contained" => Ok(Self::Contained),
            "referenced" => Ok(Self::Referenced),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AggregationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bundled => "bundled",
            Self::Contained => "contained",
            Self::Referenced => "referenced",
        }
    }
}
impl<'de> Deserialize<'de> for AggregationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AggregationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AllergyIntoleranceCategory`. Category of an identified substance associated with allergies or intolerances.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceCategory {
    /** # biologic

Biologic. A preparation that is synthesized from living organisms or their products, especially a human or animal protein, such as a hormone or antitoxin, that is used as a diagnostic, preventive, or therapeutic agent. Examples of biologic medications include: vaccines; allergenic extracts, which are used for both diagnosis and treatment (for example, allergy shots); gene therapies; cellular therapies.  There are other biologic products, such as tissues, which are not typically associated with allergies. */
    Biologic,
    /** # environment

Environment. Any substances that are encountered in the environment, including any substance not already classified as food, medication, or biologic. */
    Environment,
    /** # food

Food. Any substance consumed to provide nutritional support for the body. */
    Food,
    /** # medication

Medication. Substances administered to achieve a physiological effect. */
    Medication,
}
impl ::core::str::FromStr for AllergyIntoleranceCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "biologic" => Ok(Self::Biologic),
            "environment" => Ok(Self::Environment),
            "food" => Ok(Self::Food),
            "medication" => Ok(Self::Medication),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Biologic => "biologic",
            Self::Environment => "environment",
            Self::Food => "food",
            Self::Medication => "medication",
        }
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AllergyIntoleranceCertainty`. Statement about the degree of clinical certainty that a specific substance was the cause    of the manifestation in a reaction event.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceCertainty {
    /** # confirmed

Confirmed. There is a very high level of clinical certainty that the reaction was due to the identified      substance, which may include clinical evidence by testing or rechallenge. */
    Confirmed,
    /** # likely

Likely. There is a high level of clinical certainty that the reaction was caused by the identified      substance. */
    Likely,
    /** # unknown

Unknown. The clinical certainty that the reaction was caused by the identified substance is unknown.       It is an explicit assertion that certainty is not known. */
    Unknown,
    /** # unlikely

Unlikely. There is a low level of clinical certainty that the reaction was caused by the identified      substance. */
    Unlikely,
}
impl ::core::str::FromStr for AllergyIntoleranceCertainty {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(Self::Confirmed),
            "likely" => Ok(Self::Likely),
            "unknown" => Ok(Self::Unknown),
            "unlikely" => Ok(Self::Unlikely),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCertainty {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confirmed => "confirmed",
            Self::Likely => "likely",
            Self::Unknown => "unknown",
            Self::Unlikely => "unlikely",
        }
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCertainty {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCertainty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AllergyIntoleranceClinicalStatusCodes`. Preferred value set for AllergyIntolerance Clinical Status.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceClinicalStatusCodes {
    /** # active

Active. The subject is currently experiencing, or is at risk of, a reaction to the identified substance. */
    Active,
    /** # inactive

Inactive. The subject is no longer at risk of a reaction to the identified substance. */
    Inactive,
    /** # resolved

Resolved. A reaction to the identified substance has been clinically reassessed by testing or re-exposure and is considered no longer to be present. Re-exposure could be accidental, unplanned, or outside of any clinical setting. */
    Resolved,
}
impl ::core::str::FromStr for AllergyIntoleranceClinicalStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "resolved" => Ok(Self::Resolved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceClinicalStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Resolved => "resolved",
        }
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceClinicalStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceClinicalStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AllergyIntoleranceCriticality`. Estimate of the potential clinical harm, or seriousness, of a reaction to an identified substance.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceCriticality {
    /** # high

High Risk. Worst case result of a future exposure is assessed to be life-threatening or having high potential for organ system failure. */
    High,
    /** # low

Low Risk. Worst case result of a future exposure is not assessed to be life-threatening or having high potential for organ system failure. */
    Low,
    /** # unable-to-assess

Unable to Assess Risk. Unable to assess the worst case result of a future exposure. */
    UnableToAssess,
}
impl ::core::str::FromStr for AllergyIntoleranceCriticality {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "unable-to-assess" => Ok(Self::UnableToAssess),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceCriticality {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::UnableToAssess => "unable-to-assess",
        }
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceCriticality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceCriticality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AllergyIntoleranceSeverity`. Clinical assessment of the severity of a reaction event as a whole, potentially considering multiple different manifestations.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceSeverity {
    /** # mild

Mild. Causes mild physiological effects. */
    Mild,
    /** # moderate

Moderate. Causes moderate physiological effects. */
    Moderate,
    /** # severe

Severe. Causes severe physiological effects. */
    Severe,
}
impl ::core::str::FromStr for AllergyIntoleranceSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mild" => Ok(Self::Mild),
            "moderate" => Ok(Self::Moderate),
            "severe" => Ok(Self::Severe),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mild => "mild",
            Self::Moderate => "moderate",
            Self::Severe => "severe",
        }
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AllergyIntoleranceType`. Identification of the underlying physiological mechanism for a Reaction Risk.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceType {
    /** # allergy

Allergy. A propensity for hypersensitive reaction(s) to a substance.  These reactions are most typically type I hypersensitivity, plus other "allergy-like" reactions, including pseudoallergy. */
    Allergy,
    /** # intolerance

Intolerance. A propensity for adverse reactions to a substance that is not judged to be allergic or "allergy-like".  These reactions are typically (but not necessarily) non-immune.  They are to some degree idiosyncratic and/or patient-specific (i.e. are not a reaction that is expected to occur with most or all patients given similar circumstances). */
    Intolerance,
}
impl ::core::str::FromStr for AllergyIntoleranceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "allergy" => Ok(Self::Allergy),
            "intolerance" => Ok(Self::Intolerance),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Allergy => "allergy",
            Self::Intolerance => "intolerance",
        }
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AllergyIntoleranceVerificationStatusCodes`. Preferred value set for AllergyIntolerance Verification Status.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AllergyIntoleranceVerificationStatusCodes {
    /** # confirmed

Confirmed. A high level of certainty about the propensity for a reaction to the identified substance, which may include clinical evidence by testing or rechallenge. */
    Confirmed,
    /** # entered-in-error

Entered in Error. The statement was entered in error and is not valid. */
    EnteredInError,
    /** # refuted

Refuted. A propensity for a reaction to the identified substance has been disputed or disproven with a sufficient level of clinical certainty to justify invalidating the assertion. This might or might not include testing or rechallenge. */
    Refuted,
    /** # unconfirmed

Unconfirmed. A low level of certainty about the propensity for a reaction to the identified substance. */
    Unconfirmed,
}
impl ::core::str::FromStr for AllergyIntoleranceVerificationStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(Self::Confirmed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "refuted" => Ok(Self::Refuted),
            "unconfirmed" => Ok(Self::Unconfirmed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AllergyIntoleranceVerificationStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confirmed => "confirmed",
            Self::EnteredInError => "entered-in-error",
            Self::Refuted => "refuted",
            Self::Unconfirmed => "unconfirmed",
        }
    }
}
impl<'de> Deserialize<'de> for AllergyIntoleranceVerificationStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AllergyIntoleranceVerificationStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AnimalSpecies`. This example value set defines a set of codes that can be used to indicate species of animal patients.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AnimalSpecies {
    /** # canislf

Dog. Canis lupus familiaris */
    Canislf,
    /** # ovisa

Sheep. Ovis aries */
    Ovisa,
    /** # serinuscd

Domestic Canary. Serinus canaria domestica */
    Serinuscd,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AnimalSpecies {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "canislf" => Ok(Self::Canislf),
            "ovisa" => Ok(Self::Ovisa),
            "serinuscd" => Ok(Self::Serinuscd),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AnimalSpecies {
    fn as_ref(&self) -> &str {
        match self {
            Self::Canislf => "canislf",
            Self::Ovisa => "ovisa",
            Self::Serinuscd => "serinuscd",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for AnimalSpecies {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AnimalSpecies {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AnimalTissueType`. A tissue type of an animal.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AnimalTissueType {
    /** # 100000072091

All relevant tissues. */
    N100000072091,
    /** # 100000072092

Fat. */
    N100000072092,
    /** # 100000072093

Honey. */
    N100000072093,
    /** # 100000072094

Liver. */
    N100000072094,
    /** # 100000072095

Fresh Milk. */
    N100000072095,
    /** # 100000072096

Muscle and skin in natural proportions. */
    N100000072096,
    /** # 100000072104

Eggs. */
    N100000072104,
    /** # 100000072105

Skin and fat. */
    N100000072105,
    /** # 100000072106

Kidney. */
    N100000072106,
    /** # 100000072107

Meat and offal. */
    N100000072107,
    /** # 100000072108

Muscle. */
    N100000072108,
    /** # 100000072109

Unspecified. */
    N100000072109,
    /** # 100000111053

Adipose tissue. */
    N100000111053,
    /** # 100000111054

Adrenal. */
    N100000111054,
    /** # 100000111055

Blood vessels. */
    N100000111055,
    /** # 100000111056

Bone. */
    N100000111056,
    /** # 100000111057

Bone marrow. */
    N100000111057,
    /** # 100000111058

Brain. */
    N100000111058,
    /** # 100000111059

Connective tissue. */
    N100000111059,
    /** # 100000111060

Cornea. */
    N100000111060,
    /** # 100000111061

Dental pulp. */
    N100000111061,
    /** # 100000111062

Duodenum. */
    N100000111062,
    /** # 100000111063

Dura mater. */
    N100000111063,
    /** # 100000111064

Egg, embryonated. */
    N100000111064,
    /** # 100000111065

Egg. */
    N100000111065,
    /** # 100000111066

Egg white. */
    N100000111066,
    /** # 100000111067

Egg yolk. */
    N100000111067,
    /** # 100000111068

Embryos. */
    N100000111068,
    /** # 100000111069

Enteric plexuses. */
    N100000111069,
    /** # 100000111070

Esophagus. */
    N100000111070,
    /** # 100000111071

Feathers. */
    N100000111071,
    /** # 100000111072

Foetus. */
    N100000111072,
    /** # 100000111073

Fore-stomach (ruminants only). */
    N100000111073,
    /** # 100000111074

Gingival tissue. */
    N100000111074,
    /** # 100000111075

Hair. */
    N100000111075,
    /** # 100000111076

Heart/pericardium. */
    N100000111076,
    /** # 100000111077

Hide. */
    N100000111077,
    /** # 100000111078

Hooves. */
    N100000111078,
    /** # 100000111079

Ileum. */
    N100000111079,
    /** # 100000111080

Jejunum. */
    N100000111080,
    /** # 100000111081

Kidney. */
    N100000111081,
    /** # 100000111082

Lard/lard oil. */
    N100000111082,
    /** # 100000111083

Large intestine. */
    N100000111083,
    /** # 100000111084

Liver. */
    N100000111084,
    /** # 100000111085

Lung. */
    N100000111085,
    /** # 100000111086

Lymph nodes. */
    N100000111086,
    /** # 100000111087

Mammary gland. */
    N100000111087,
    /** # 100000111088

Udder. */
    N100000111088,
    /** # 100000111089

Mammary tumour. */
    N100000111089,
    /** # 100000111090

Meat extract. */
    N100000111090,
    /** # 100000111091

Nasopharyngeal. */
    N100000111091,
    /** # 100000111092

Nictitating membrane. */
    N100000111092,
    /** # 100000111093

Nasal mucosa. */
    N100000111093,
    /** # 100000111094

Ovary. */
    N100000111094,
    /** # 100000111095

Pancreas. */
    N100000111095,
    /** # 100000111096

Peripheral nerves. */
    N100000111096,
    /** # 100000111097

Pituitary gland. */
    N100000111097,
    /** # 100000111098

Placenta. */
    N100000111098,
    /** # 100000111099

Prostate. */
    N100000111099,
    /** # 100000111100

Epididymis. */
    N100000111100,
    /** # 100000111101

Seminal vesicle. */
    N100000111101,
    /** # 100000111102

Rennet, calf. */
    N100000111102,
    /** # 100000111103

Retina. */
    N100000111103,
    /** # 100000111104

Optic nerve. */
    N100000111104,
    /** # 100000111105

Salivary gland. */
    N100000111105,
    /** # 100000111106

Shank. */
    N100000111106,
    /** # 100000111107

Skeletal muscle. */
    N100000111107,
    /** # 100000111108

Skin. */
    N100000111108,
    /** # 100000111109

Spinal ganglia. */
    N100000111109,
    /** # 100000111110

Spinal cord. */
    N100000111110,
    /** # 100000111111

Spleen. */
    N100000111111,
    /** # 100000111112

Stomach. */
    N100000111112,
    /** # 100000111113

Abomasum. */
    N100000111113,
    /** # 100000111114

Submaxillary glands. */
    N100000111114,
    /** # 100000111115

Tallow. */
    N100000111115,
    /** # 100000111116

Tendon. */
    N100000111116,
    /** # 100000111117

Testis. */
    N100000111117,
    /** # 100000111118

Thymus. */
    N100000111118,
    /** # 100000111119

Thyroid gland. */
    N100000111119,
    /** # 100000111120

Tongue. */
    N100000111120,
    /** # 100000111121

Tonsil. */
    N100000111121,
    /** # 100000111122

Trachea. */
    N100000111122,
    /** # 100000111123

Trigeminal ganglia. */
    N100000111123,
    /** # 100000111124

Tripe. */
    N100000111124,
    /** # 100000111125

Uterus (Non-gravid). */
    N100000111125,
    /** # 100000111126

Wool. */
    N100000111126,
    /** # 100000111127

Ascites fluid. */
    N100000111127,
    /** # 100000111128

Bile. */
    N100000111128,
    /** # 100000111129

Blood1. */
    N100000111129,
    /** # 100000111130

Blood, foetal. */
    N100000111130,
    /** # 100000111131

Colostrum. */
    N100000111131,
    /** # 100000111132

Cord blood. */
    N100000111132,
    /** # 100000111133

CSF. */
    N100000111133,
    /** # 100000111134

Faeces. */
    N100000111134,
    /** # 100000111135

Milk. */
    N100000111135,
    /** # 100000111136

Nasal mucus. */
    N100000111136,
    /** # 100000111137

Placenta fluids. */
    N100000111137,
    /** # 100000111138

Plasma. */
    N100000111138,
    /** # 100000111139

Saliva. */
    N100000111139,
    /** # 100000111140

Secretion from bees. */
    N100000111140,
    /** # 100000111141

Semen. */
    N100000111141,
    /** # 100000111142

Serum, calf. */
    N100000111142,
    /** # 100000111143

Serum, donor adult bovine. */
    N100000111143,
    /** # 100000111144

Serum, donor calf. */
    N100000111144,
    /** # 100000111145

Serum, foetal bovine. */
    N100000111145,
    /** # 100000111146

Serum, newborn calf. */
    N100000111146,
    /** # 100000111147

Serum/plasma derivate, adult bovine. */
    N100000111147,
    /** # 100000111148

Serum/plasma, adult bovine. */
    N100000111148,
    /** # 100000111149

Sweat. */
    N100000111149,
    /** # 100000111150

Tears. */
    N100000111150,
    /** # 100000111151

Urine. */
    N100000111151,
    /** # 100000111152

Venom. */
    N100000111152,
    /** # 100000111153

Whey. */
    N100000111153,
    /** # 100000111154

Casein. */
    N100000111154,
    /** # 100000111155

Fermentation products. */
    N100000111155,
    /** # 100000111156

Gelatin. */
    N100000111156,
    /** # 100000111157

Lactose. */
    N100000111157,
    /** # 100000111158

Protein. */
    N100000111158,
    /** # 100000111159

Insulin. */
    N100000111159,
    /** # 100000111160

Collagen. */
    N100000111160,
    /** # 100000111161

Animal Charcoal. */
    N100000111161,
    /** # 100000111162

Peptones. */
    N100000111162,
    /** # 100000111163

Fatty acids. */
    N100000111163,
    /** # 100000111164

Glycerol. */
    N100000111164,
    /** # 100000125717

Not applicable. */
    N100000125717,
    /** # 100000136180

Meat and offal, milk. */
    N100000136180,
    /** # 100000136181

Agar blood. */
    N100000136181,
    /** # 100000136182

Casamino acid. */
    N100000136182,
    /** # 100000136183

Casein, hydrolysate. */
    N100000136183,
    /** # 100000136184

Casein, pancreatic digest. */
    N100000136184,
    /** # 100000136185

Casein, peptides N3. */
    N100000136185,
    /** # 100000136186

Cells. */
    N100000136186,
    /** # 100000136187

Cells, BHK21. */
    N100000136187,
    /** # 100000136188

Cells, CHO. */
    N100000136188,
    /** # 100000136189

Cells, CRFK. */
    N100000136189,
    /** # 100000136190

Cells, embryo SPF. */
    N100000136190,
    /** # 100000136191

Cells, IRC5. */
    N100000136191,
    /** # 100000136192

Cells, kidney. */
    N100000136192,
    /** # 100000136193

Cells, MDCK. */
    N100000136193,
    /** # 100000136194

Cells, red blood. */
    N100000136194,
    /** # 100000136195

Collagen, hydrolysate. */
    N100000136195,
    /** # 100000136196

Cholesterol. */
    N100000136196,
    /** # 100000136197

Egg, SPF embryonated. */
    N100000136197,
    /** # 100000136198

Enzyme. */
    N100000136198,
    /** # 100000136199

Enzyme, pancreatic enzymes. */
    N100000136199,
    /** # 100000136200

Enzyme, pancreatin 6NF. */
    N100000136200,
    /** # 100000136201

Enzyme, pepsin. */
    N100000136201,
    /** # 100000136202

Enzyme, pronase. */
    N100000136202,
    /** # 100000136203

Enzyme, trypsin. */
    N100000136203,
    /** # 100000136204

Heart, digest. */
    N100000136204,
    /** # 100000136205

Heart, extract. */
    N100000136205,
    /** # 100000136206

Intestinal mucosae. */
    N100000136206,
    /** # 100000136207

Lactalbumin hydrolysate. */
    N100000136207,
    /** # 100000136208

Liver, digest. */
    N100000136208,
    /** # 100000136209

Lymphocytes. */
    N100000136209,
    /** # 100000136210

Meat. */
    N100000136210,
    /** # 100000136211

Meat, enzymic hydrolysate. */
    N100000136211,
    /** # 100000136212

Medium, cooked meat. */
    N100000136212,
    /** # 100000136213

Medium, F10-199 medium. */
    N100000136213,
    /** # 100000136214

Medium, FMD culture medium. */
    N100000136214,
    /** # 100000136215

Medium, Glasgow MEM culture. */
    N100000136215,
    /** # 100000136216

Medium, LB Agar Lennox. */
    N100000136216,
    /** # 100000136217

Medium, LB Broth Lennox. */
    N100000136217,
    /** # 100000136218

Medium, modified thioglycolate medium. */
    N100000136218,
    /** # 100000136219

Medium, trypticase soy broth. */
    N100000136219,
    /** # 100000136220

Medium, tryptose phosphate broth. */
    N100000136220,
    /** # 100000136221

Milk, skimmed. */
    N100000136221,
    /** # 100000136222

Pancreas, extract. */
    N100000136222,
    /** # 100000136223

Peptones, casein hydrochloric peptone. */
    N100000136223,
    /** # 100000136224

Peptones, casein tryptic peptone. */
    N100000136224,
    /** # 100000136225

Pituitary extract. */
    N100000136225,
    /** # 100000136226

Rennet. */
    N100000136226,
    /** # 100000136227

Medium, nutrient broth. */
    N100000136227,
    /** # 100000136228

Medium, NZ-Amine. */
    N100000136228,
    /** # 100000136229

Medium, thioglycolate medium. */
    N100000136229,
    /** # 100000136230

Peptones, proteose peptone. */
    N100000136230,
    /** # 100000136231

Serum. */
    N100000136231,
    /** # 100000136232

Serum, albumin. */
    N100000136232,
    /** # 100000136233

Serum, Iron fortified calf. */
    N100000136233,
    /** # 100000136234

Skin, connective tissue and bone. */
    N100000136234,
    /** # 100000136235

Sperm. */
    N100000136235,
    /** # 100000136236

Tryptone. */
    N100000136236,
    /** # 100000136237

Meat, extract desiccated. */
    N100000136237,
    /** # 100000136247

Stomach mucosa. */
    N100000136247,
    /** # 100000136248

Transferin. */
    N100000136248,
    /** # 100000136554

Non-neural. */
    N100000136554,
    /** # 100000136555

Not specified. */
    N100000136555,
    /** # 100000136556

Organ tissue. */
    N100000136556,
    /** # 100000142485

Skin and fat in natural proportions. */
    N100000142485,
}
impl ::core::str::FromStr for AnimalTissueType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000072091" => Ok(Self::N100000072091),
            "100000072092" => Ok(Self::N100000072092),
            "100000072093" => Ok(Self::N100000072093),
            "100000072094" => Ok(Self::N100000072094),
            "100000072095" => Ok(Self::N100000072095),
            "100000072096" => Ok(Self::N100000072096),
            "100000072104" => Ok(Self::N100000072104),
            "100000072105" => Ok(Self::N100000072105),
            "100000072106" => Ok(Self::N100000072106),
            "100000072107" => Ok(Self::N100000072107),
            "100000072108" => Ok(Self::N100000072108),
            "100000072109" => Ok(Self::N100000072109),
            "100000111053" => Ok(Self::N100000111053),
            "100000111054" => Ok(Self::N100000111054),
            "100000111055" => Ok(Self::N100000111055),
            "100000111056" => Ok(Self::N100000111056),
            "100000111057" => Ok(Self::N100000111057),
            "100000111058" => Ok(Self::N100000111058),
            "100000111059" => Ok(Self::N100000111059),
            "100000111060" => Ok(Self::N100000111060),
            "100000111061" => Ok(Self::N100000111061),
            "100000111062" => Ok(Self::N100000111062),
            "100000111063" => Ok(Self::N100000111063),
            "100000111064" => Ok(Self::N100000111064),
            "100000111065" => Ok(Self::N100000111065),
            "100000111066" => Ok(Self::N100000111066),
            "100000111067" => Ok(Self::N100000111067),
            "100000111068" => Ok(Self::N100000111068),
            "100000111069" => Ok(Self::N100000111069),
            "100000111070" => Ok(Self::N100000111070),
            "100000111071" => Ok(Self::N100000111071),
            "100000111072" => Ok(Self::N100000111072),
            "100000111073" => Ok(Self::N100000111073),
            "100000111074" => Ok(Self::N100000111074),
            "100000111075" => Ok(Self::N100000111075),
            "100000111076" => Ok(Self::N100000111076),
            "100000111077" => Ok(Self::N100000111077),
            "100000111078" => Ok(Self::N100000111078),
            "100000111079" => Ok(Self::N100000111079),
            "100000111080" => Ok(Self::N100000111080),
            "100000111081" => Ok(Self::N100000111081),
            "100000111082" => Ok(Self::N100000111082),
            "100000111083" => Ok(Self::N100000111083),
            "100000111084" => Ok(Self::N100000111084),
            "100000111085" => Ok(Self::N100000111085),
            "100000111086" => Ok(Self::N100000111086),
            "100000111087" => Ok(Self::N100000111087),
            "100000111088" => Ok(Self::N100000111088),
            "100000111089" => Ok(Self::N100000111089),
            "100000111090" => Ok(Self::N100000111090),
            "100000111091" => Ok(Self::N100000111091),
            "100000111092" => Ok(Self::N100000111092),
            "100000111093" => Ok(Self::N100000111093),
            "100000111094" => Ok(Self::N100000111094),
            "100000111095" => Ok(Self::N100000111095),
            "100000111096" => Ok(Self::N100000111096),
            "100000111097" => Ok(Self::N100000111097),
            "100000111098" => Ok(Self::N100000111098),
            "100000111099" => Ok(Self::N100000111099),
            "100000111100" => Ok(Self::N100000111100),
            "100000111101" => Ok(Self::N100000111101),
            "100000111102" => Ok(Self::N100000111102),
            "100000111103" => Ok(Self::N100000111103),
            "100000111104" => Ok(Self::N100000111104),
            "100000111105" => Ok(Self::N100000111105),
            "100000111106" => Ok(Self::N100000111106),
            "100000111107" => Ok(Self::N100000111107),
            "100000111108" => Ok(Self::N100000111108),
            "100000111109" => Ok(Self::N100000111109),
            "100000111110" => Ok(Self::N100000111110),
            "100000111111" => Ok(Self::N100000111111),
            "100000111112" => Ok(Self::N100000111112),
            "100000111113" => Ok(Self::N100000111113),
            "100000111114" => Ok(Self::N100000111114),
            "100000111115" => Ok(Self::N100000111115),
            "100000111116" => Ok(Self::N100000111116),
            "100000111117" => Ok(Self::N100000111117),
            "100000111118" => Ok(Self::N100000111118),
            "100000111119" => Ok(Self::N100000111119),
            "100000111120" => Ok(Self::N100000111120),
            "100000111121" => Ok(Self::N100000111121),
            "100000111122" => Ok(Self::N100000111122),
            "100000111123" => Ok(Self::N100000111123),
            "100000111124" => Ok(Self::N100000111124),
            "100000111125" => Ok(Self::N100000111125),
            "100000111126" => Ok(Self::N100000111126),
            "100000111127" => Ok(Self::N100000111127),
            "100000111128" => Ok(Self::N100000111128),
            "100000111129" => Ok(Self::N100000111129),
            "100000111130" => Ok(Self::N100000111130),
            "100000111131" => Ok(Self::N100000111131),
            "100000111132" => Ok(Self::N100000111132),
            "100000111133" => Ok(Self::N100000111133),
            "100000111134" => Ok(Self::N100000111134),
            "100000111135" => Ok(Self::N100000111135),
            "100000111136" => Ok(Self::N100000111136),
            "100000111137" => Ok(Self::N100000111137),
            "100000111138" => Ok(Self::N100000111138),
            "100000111139" => Ok(Self::N100000111139),
            "100000111140" => Ok(Self::N100000111140),
            "100000111141" => Ok(Self::N100000111141),
            "100000111142" => Ok(Self::N100000111142),
            "100000111143" => Ok(Self::N100000111143),
            "100000111144" => Ok(Self::N100000111144),
            "100000111145" => Ok(Self::N100000111145),
            "100000111146" => Ok(Self::N100000111146),
            "100000111147" => Ok(Self::N100000111147),
            "100000111148" => Ok(Self::N100000111148),
            "100000111149" => Ok(Self::N100000111149),
            "100000111150" => Ok(Self::N100000111150),
            "100000111151" => Ok(Self::N100000111151),
            "100000111152" => Ok(Self::N100000111152),
            "100000111153" => Ok(Self::N100000111153),
            "100000111154" => Ok(Self::N100000111154),
            "100000111155" => Ok(Self::N100000111155),
            "100000111156" => Ok(Self::N100000111156),
            "100000111157" => Ok(Self::N100000111157),
            "100000111158" => Ok(Self::N100000111158),
            "100000111159" => Ok(Self::N100000111159),
            "100000111160" => Ok(Self::N100000111160),
            "100000111161" => Ok(Self::N100000111161),
            "100000111162" => Ok(Self::N100000111162),
            "100000111163" => Ok(Self::N100000111163),
            "100000111164" => Ok(Self::N100000111164),
            "100000125717" => Ok(Self::N100000125717),
            "100000136180" => Ok(Self::N100000136180),
            "100000136181" => Ok(Self::N100000136181),
            "100000136182" => Ok(Self::N100000136182),
            "100000136183" => Ok(Self::N100000136183),
            "100000136184" => Ok(Self::N100000136184),
            "100000136185" => Ok(Self::N100000136185),
            "100000136186" => Ok(Self::N100000136186),
            "100000136187" => Ok(Self::N100000136187),
            "100000136188" => Ok(Self::N100000136188),
            "100000136189" => Ok(Self::N100000136189),
            "100000136190" => Ok(Self::N100000136190),
            "100000136191" => Ok(Self::N100000136191),
            "100000136192" => Ok(Self::N100000136192),
            "100000136193" => Ok(Self::N100000136193),
            "100000136194" => Ok(Self::N100000136194),
            "100000136195" => Ok(Self::N100000136195),
            "100000136196" => Ok(Self::N100000136196),
            "100000136197" => Ok(Self::N100000136197),
            "100000136198" => Ok(Self::N100000136198),
            "100000136199" => Ok(Self::N100000136199),
            "100000136200" => Ok(Self::N100000136200),
            "100000136201" => Ok(Self::N100000136201),
            "100000136202" => Ok(Self::N100000136202),
            "100000136203" => Ok(Self::N100000136203),
            "100000136204" => Ok(Self::N100000136204),
            "100000136205" => Ok(Self::N100000136205),
            "100000136206" => Ok(Self::N100000136206),
            "100000136207" => Ok(Self::N100000136207),
            "100000136208" => Ok(Self::N100000136208),
            "100000136209" => Ok(Self::N100000136209),
            "100000136210" => Ok(Self::N100000136210),
            "100000136211" => Ok(Self::N100000136211),
            "100000136212" => Ok(Self::N100000136212),
            "100000136213" => Ok(Self::N100000136213),
            "100000136214" => Ok(Self::N100000136214),
            "100000136215" => Ok(Self::N100000136215),
            "100000136216" => Ok(Self::N100000136216),
            "100000136217" => Ok(Self::N100000136217),
            "100000136218" => Ok(Self::N100000136218),
            "100000136219" => Ok(Self::N100000136219),
            "100000136220" => Ok(Self::N100000136220),
            "100000136221" => Ok(Self::N100000136221),
            "100000136222" => Ok(Self::N100000136222),
            "100000136223" => Ok(Self::N100000136223),
            "100000136224" => Ok(Self::N100000136224),
            "100000136225" => Ok(Self::N100000136225),
            "100000136226" => Ok(Self::N100000136226),
            "100000136227" => Ok(Self::N100000136227),
            "100000136228" => Ok(Self::N100000136228),
            "100000136229" => Ok(Self::N100000136229),
            "100000136230" => Ok(Self::N100000136230),
            "100000136231" => Ok(Self::N100000136231),
            "100000136232" => Ok(Self::N100000136232),
            "100000136233" => Ok(Self::N100000136233),
            "100000136234" => Ok(Self::N100000136234),
            "100000136235" => Ok(Self::N100000136235),
            "100000136236" => Ok(Self::N100000136236),
            "100000136237" => Ok(Self::N100000136237),
            "100000136247" => Ok(Self::N100000136247),
            "100000136248" => Ok(Self::N100000136248),
            "100000136554" => Ok(Self::N100000136554),
            "100000136555" => Ok(Self::N100000136555),
            "100000136556" => Ok(Self::N100000136556),
            "100000142485" => Ok(Self::N100000142485),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AnimalTissueType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000072091 => "100000072091",
            Self::N100000072092 => "100000072092",
            Self::N100000072093 => "100000072093",
            Self::N100000072094 => "100000072094",
            Self::N100000072095 => "100000072095",
            Self::N100000072096 => "100000072096",
            Self::N100000072104 => "100000072104",
            Self::N100000072105 => "100000072105",
            Self::N100000072106 => "100000072106",
            Self::N100000072107 => "100000072107",
            Self::N100000072108 => "100000072108",
            Self::N100000072109 => "100000072109",
            Self::N100000111053 => "100000111053",
            Self::N100000111054 => "100000111054",
            Self::N100000111055 => "100000111055",
            Self::N100000111056 => "100000111056",
            Self::N100000111057 => "100000111057",
            Self::N100000111058 => "100000111058",
            Self::N100000111059 => "100000111059",
            Self::N100000111060 => "100000111060",
            Self::N100000111061 => "100000111061",
            Self::N100000111062 => "100000111062",
            Self::N100000111063 => "100000111063",
            Self::N100000111064 => "100000111064",
            Self::N100000111065 => "100000111065",
            Self::N100000111066 => "100000111066",
            Self::N100000111067 => "100000111067",
            Self::N100000111068 => "100000111068",
            Self::N100000111069 => "100000111069",
            Self::N100000111070 => "100000111070",
            Self::N100000111071 => "100000111071",
            Self::N100000111072 => "100000111072",
            Self::N100000111073 => "100000111073",
            Self::N100000111074 => "100000111074",
            Self::N100000111075 => "100000111075",
            Self::N100000111076 => "100000111076",
            Self::N100000111077 => "100000111077",
            Self::N100000111078 => "100000111078",
            Self::N100000111079 => "100000111079",
            Self::N100000111080 => "100000111080",
            Self::N100000111081 => "100000111081",
            Self::N100000111082 => "100000111082",
            Self::N100000111083 => "100000111083",
            Self::N100000111084 => "100000111084",
            Self::N100000111085 => "100000111085",
            Self::N100000111086 => "100000111086",
            Self::N100000111087 => "100000111087",
            Self::N100000111088 => "100000111088",
            Self::N100000111089 => "100000111089",
            Self::N100000111090 => "100000111090",
            Self::N100000111091 => "100000111091",
            Self::N100000111092 => "100000111092",
            Self::N100000111093 => "100000111093",
            Self::N100000111094 => "100000111094",
            Self::N100000111095 => "100000111095",
            Self::N100000111096 => "100000111096",
            Self::N100000111097 => "100000111097",
            Self::N100000111098 => "100000111098",
            Self::N100000111099 => "100000111099",
            Self::N100000111100 => "100000111100",
            Self::N100000111101 => "100000111101",
            Self::N100000111102 => "100000111102",
            Self::N100000111103 => "100000111103",
            Self::N100000111104 => "100000111104",
            Self::N100000111105 => "100000111105",
            Self::N100000111106 => "100000111106",
            Self::N100000111107 => "100000111107",
            Self::N100000111108 => "100000111108",
            Self::N100000111109 => "100000111109",
            Self::N100000111110 => "100000111110",
            Self::N100000111111 => "100000111111",
            Self::N100000111112 => "100000111112",
            Self::N100000111113 => "100000111113",
            Self::N100000111114 => "100000111114",
            Self::N100000111115 => "100000111115",
            Self::N100000111116 => "100000111116",
            Self::N100000111117 => "100000111117",
            Self::N100000111118 => "100000111118",
            Self::N100000111119 => "100000111119",
            Self::N100000111120 => "100000111120",
            Self::N100000111121 => "100000111121",
            Self::N100000111122 => "100000111122",
            Self::N100000111123 => "100000111123",
            Self::N100000111124 => "100000111124",
            Self::N100000111125 => "100000111125",
            Self::N100000111126 => "100000111126",
            Self::N100000111127 => "100000111127",
            Self::N100000111128 => "100000111128",
            Self::N100000111129 => "100000111129",
            Self::N100000111130 => "100000111130",
            Self::N100000111131 => "100000111131",
            Self::N100000111132 => "100000111132",
            Self::N100000111133 => "100000111133",
            Self::N100000111134 => "100000111134",
            Self::N100000111135 => "100000111135",
            Self::N100000111136 => "100000111136",
            Self::N100000111137 => "100000111137",
            Self::N100000111138 => "100000111138",
            Self::N100000111139 => "100000111139",
            Self::N100000111140 => "100000111140",
            Self::N100000111141 => "100000111141",
            Self::N100000111142 => "100000111142",
            Self::N100000111143 => "100000111143",
            Self::N100000111144 => "100000111144",
            Self::N100000111145 => "100000111145",
            Self::N100000111146 => "100000111146",
            Self::N100000111147 => "100000111147",
            Self::N100000111148 => "100000111148",
            Self::N100000111149 => "100000111149",
            Self::N100000111150 => "100000111150",
            Self::N100000111151 => "100000111151",
            Self::N100000111152 => "100000111152",
            Self::N100000111153 => "100000111153",
            Self::N100000111154 => "100000111154",
            Self::N100000111155 => "100000111155",
            Self::N100000111156 => "100000111156",
            Self::N100000111157 => "100000111157",
            Self::N100000111158 => "100000111158",
            Self::N100000111159 => "100000111159",
            Self::N100000111160 => "100000111160",
            Self::N100000111161 => "100000111161",
            Self::N100000111162 => "100000111162",
            Self::N100000111163 => "100000111163",
            Self::N100000111164 => "100000111164",
            Self::N100000125717 => "100000125717",
            Self::N100000136180 => "100000136180",
            Self::N100000136181 => "100000136181",
            Self::N100000136182 => "100000136182",
            Self::N100000136183 => "100000136183",
            Self::N100000136184 => "100000136184",
            Self::N100000136185 => "100000136185",
            Self::N100000136186 => "100000136186",
            Self::N100000136187 => "100000136187",
            Self::N100000136188 => "100000136188",
            Self::N100000136189 => "100000136189",
            Self::N100000136190 => "100000136190",
            Self::N100000136191 => "100000136191",
            Self::N100000136192 => "100000136192",
            Self::N100000136193 => "100000136193",
            Self::N100000136194 => "100000136194",
            Self::N100000136195 => "100000136195",
            Self::N100000136196 => "100000136196",
            Self::N100000136197 => "100000136197",
            Self::N100000136198 => "100000136198",
            Self::N100000136199 => "100000136199",
            Self::N100000136200 => "100000136200",
            Self::N100000136201 => "100000136201",
            Self::N100000136202 => "100000136202",
            Self::N100000136203 => "100000136203",
            Self::N100000136204 => "100000136204",
            Self::N100000136205 => "100000136205",
            Self::N100000136206 => "100000136206",
            Self::N100000136207 => "100000136207",
            Self::N100000136208 => "100000136208",
            Self::N100000136209 => "100000136209",
            Self::N100000136210 => "100000136210",
            Self::N100000136211 => "100000136211",
            Self::N100000136212 => "100000136212",
            Self::N100000136213 => "100000136213",
            Self::N100000136214 => "100000136214",
            Self::N100000136215 => "100000136215",
            Self::N100000136216 => "100000136216",
            Self::N100000136217 => "100000136217",
            Self::N100000136218 => "100000136218",
            Self::N100000136219 => "100000136219",
            Self::N100000136220 => "100000136220",
            Self::N100000136221 => "100000136221",
            Self::N100000136222 => "100000136222",
            Self::N100000136223 => "100000136223",
            Self::N100000136224 => "100000136224",
            Self::N100000136225 => "100000136225",
            Self::N100000136226 => "100000136226",
            Self::N100000136227 => "100000136227",
            Self::N100000136228 => "100000136228",
            Self::N100000136229 => "100000136229",
            Self::N100000136230 => "100000136230",
            Self::N100000136231 => "100000136231",
            Self::N100000136232 => "100000136232",
            Self::N100000136233 => "100000136233",
            Self::N100000136234 => "100000136234",
            Self::N100000136235 => "100000136235",
            Self::N100000136236 => "100000136236",
            Self::N100000136237 => "100000136237",
            Self::N100000136247 => "100000136247",
            Self::N100000136248 => "100000136248",
            Self::N100000136554 => "100000136554",
            Self::N100000136555 => "100000136555",
            Self::N100000136556 => "100000136556",
            Self::N100000142485 => "100000142485",
        }
    }
}
impl<'de> Deserialize<'de> for AnimalTissueType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AnimalTissueType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AppointmentStatus`. The free/busy status of an appointment.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AppointmentStatus {
    /** # arrived

Arrived. The patient/patients has/have arrived and is/are waiting to be seen. */
    Arrived,
    /** # booked

Booked. All participant(s) have been considered and the appointment is confirmed to go ahead at the date/times specified. */
    Booked,
    /** # cancelled

Cancelled. The appointment has been cancelled. */
    Cancelled,
    /** # checked-in

Checked In. When checked in, all pre-encounter administrative work is complete, and the encounter may begin. (where multiple patients are involved, they are all present). */
    CheckedIn,
    /** # entered-in-error

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** # fulfilled

Fulfilled. The planning stages of the appointment are now complete, the encounter resource will exist and will track further status changes. Note that an encounter may exist before the appointment status is fulfilled for many reasons. */
    Fulfilled,
    /** # noshow

No Show. Some or all of the participant(s) have not/did not appear for the appointment (usually the patient). */
    Noshow,
    /** # pending

Pending. Some or all of the participant(s) have not finalized their acceptance of the appointment request. */
    Pending,
    /** # proposed

Proposed. None of the participant(s) have finalized their acceptance of the appointment request, and the start/end time might not be set yet. */
    Proposed,
    /** # waitlist

Waitlisted. The appointment has been placed on a waitlist, to be scheduled/confirmed in the future when a slot/service is available.
A specific time might or might not be pre-allocated. */
    Waitlist,
}
impl ::core::str::FromStr for AppointmentStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "arrived" => Ok(Self::Arrived),
            "booked" => Ok(Self::Booked),
            "cancelled" => Ok(Self::Cancelled),
            "checked-in" => Ok(Self::CheckedIn),
            "entered-in-error" => Ok(Self::EnteredInError),
            "fulfilled" => Ok(Self::Fulfilled),
            "noshow" => Ok(Self::Noshow),
            "pending" => Ok(Self::Pending),
            "proposed" => Ok(Self::Proposed),
            "waitlist" => Ok(Self::Waitlist),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AppointmentStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Arrived => "arrived",
            Self::Booked => "booked",
            Self::Cancelled => "cancelled",
            Self::CheckedIn => "checked-in",
            Self::EnteredInError => "entered-in-error",
            Self::Fulfilled => "fulfilled",
            Self::Noshow => "noshow",
            Self::Pending => "pending",
            Self::Proposed => "proposed",
            Self::Waitlist => "waitlist",
        }
    }
}
impl<'de> Deserialize<'de> for AppointmentStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AppointmentStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ArticleUrlType`. Code the reason for different URLs, eg abstract and full-text.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArticleUrlType {
    /** # abstract

Abstract. URL to reach the abstract for the article. */
    Abstract,
    /** # abstract-version

Abstract Version. URL to reach a specific version of the abstract for the article. */
    AbstractVersion,
    /** # compressed-file

Compressed file. Compressed archive file (e.g. a zip file) that contains multiple files */
    CompressedFile,
    /** # doi-based

DOI Based. URL derived from DOI. */
    DoiBased,
    /** # full-text

Full-Text. URL to reach the full-text of the article. */
    FullText,
    /** # full-text-version

Full-Text Version. URL to reach a specific version of the full-text of the article. */
    FullTextVersion,
    /** # json

JSON. URL to reach computable content in JSON format. */
    Json,
    /** # json-version

JSON Version. URL to reach a specific version of computable content in JSON format. */
    JsonVersion,
    /** # not-specified

Not Specified. Used when URL type is not specified, commonly when only a single URL is provided. */
    NotSpecified,
    /** # pdf

PDF. URL to reach the full-text of the article in PDF form. */
    Pdf,
    /** # pdf-version

PDF Version. URL to reach a specific version of the full-text of the article in PDF form. */
    PdfVersion,
    /** # supplement

Supplement. Supplement */
    Supplement,
    /** # supplementary-file-directory

Supplementary file directory. Supplementary file directory */
    SupplementaryFileDirectory,
    /** # webpage

Webpage. Used when URL type is a webpage, but other codes do not apply. */
    Webpage,
    /** # xml

XML. URL to reach computable content in XML format. */
    Xml,
    /** # xml-version

XML. URL to reach a specific version of computable content in XML format. */
    XmlVersion,
}
impl ::core::str::FromStr for ArticleUrlType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abstract" => Ok(Self::Abstract),
            "abstract-version" => Ok(Self::AbstractVersion),
            "compressed-file" => Ok(Self::CompressedFile),
            "doi-based" => Ok(Self::DoiBased),
            "full-text" => Ok(Self::FullText),
            "full-text-version" => Ok(Self::FullTextVersion),
            "json" => Ok(Self::Json),
            "json-version" => Ok(Self::JsonVersion),
            "not-specified" => Ok(Self::NotSpecified),
            "pdf" => Ok(Self::Pdf),
            "pdf-version" => Ok(Self::PdfVersion),
            "supplement" => Ok(Self::Supplement),
            "supplementary-file-directory" => Ok(Self::SupplementaryFileDirectory),
            "webpage" => Ok(Self::Webpage),
            "xml" => Ok(Self::Xml),
            "xml-version" => Ok(Self::XmlVersion),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArticleUrlType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abstract => "abstract",
            Self::AbstractVersion => "abstract-version",
            Self::CompressedFile => "compressed-file",
            Self::DoiBased => "doi-based",
            Self::FullText => "full-text",
            Self::FullTextVersion => "full-text-version",
            Self::Json => "json",
            Self::JsonVersion => "json-version",
            Self::NotSpecified => "not-specified",
            Self::Pdf => "pdf",
            Self::PdfVersion => "pdf-version",
            Self::Supplement => "supplement",
            Self::SupplementaryFileDirectory => "supplementary-file-directory",
            Self::Webpage => "webpage",
            Self::Xml => "xml",
            Self::XmlVersion => "xml-version",
        }
    }
}
impl<'de> Deserialize<'de> for ArticleUrlType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArticleUrlType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ArtifactContributionInstanceType`. Artifact Contribution Instance Type

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArtifactContributionInstanceType {
    /** # approved

Approved. Approved */
    Approved,
    /** # edited

Edited. Edited */
    Edited,
    /** # reviewed

Reviewed. Reviewed */
    Reviewed,
}
impl ::core::str::FromStr for ArtifactContributionInstanceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "approved" => Ok(Self::Approved),
            "edited" => Ok(Self::Edited),
            "reviewed" => Ok(Self::Reviewed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactContributionInstanceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Approved => "approved",
            Self::Edited => "edited",
            Self::Reviewed => "reviewed",
        }
    }
}
impl<'de> Deserialize<'de> for ArtifactContributionInstanceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactContributionInstanceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ArtifactContributionType`. Citation contribution.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArtifactContributionType {
    /** # conceptualization

Conceptualization. Conceptualization (see https://jats4r.org/credit-taxonomy). */
    Conceptualization,
    /** # data-curation

Data curation. Data curation (see https://jats4r.org/credit-taxonomy). */
    DataCuration,
    /** # formal-analysis

Formal analysis. Formal analysis (see https://jats4r.org/credit-taxonomy). */
    FormalAnalysis,
    /** # funding-acquisition

Funding acquisition. Funding acquisition (see https://jats4r.org/credit-taxonomy). */
    FundingAcquisition,
    /** # investigation

Investigation. Investigation (see https://jats4r.org/credit-taxonomy). */
    Investigation,
    /** # methodology

Methodology. Methodology (see https://jats4r.org/credit-taxonomy). */
    Methodology,
    /** # project-administration

Project administration. Project administration (see https://jats4r.org/credit-taxonomy). */
    ProjectAdministration,
    /** # resources

Resources. Resources (see https://jats4r.org/credit-taxonomy). */
    Resources,
    /** # software

Software. Software (see https://jats4r.org/credit-taxonomy). */
    Software,
    /** # supervision

Supervision. Supervision (see https://jats4r.org/credit-taxonomy). */
    Supervision,
    /** # validation

Validation. Validation (see https://jats4r.org/credit-taxonomy). */
    Validation,
    /** # visualization

Visualization. Visualization (see https://jats4r.org/credit-taxonomy). */
    Visualization,
    /** # writing-original-draft

Writing - original draft. Writing - original draft (see https://jats4r.org/credit-taxonomy). */
    WritingOriginalDraft,
    /** # writing-review-editing

Writing - review & editing. Writing - review & editing (see https://jats4r.org/credit-taxonomy). */
    WritingReviewEditing,
}
impl ::core::str::FromStr for ArtifactContributionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "conceptualization" => Ok(Self::Conceptualization),
            "data-curation" => Ok(Self::DataCuration),
            "formal-analysis" => Ok(Self::FormalAnalysis),
            "funding-acquisition" => Ok(Self::FundingAcquisition),
            "investigation" => Ok(Self::Investigation),
            "methodology" => Ok(Self::Methodology),
            "project-administration" => Ok(Self::ProjectAdministration),
            "resources" => Ok(Self::Resources),
            "software" => Ok(Self::Software),
            "supervision" => Ok(Self::Supervision),
            "validation" => Ok(Self::Validation),
            "visualization" => Ok(Self::Visualization),
            "writing-original-draft" => Ok(Self::WritingOriginalDraft),
            "writing-review-editing" => Ok(Self::WritingReviewEditing),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactContributionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Conceptualization => "conceptualization",
            Self::DataCuration => "data-curation",
            Self::FormalAnalysis => "formal-analysis",
            Self::FundingAcquisition => "funding-acquisition",
            Self::Investigation => "investigation",
            Self::Methodology => "methodology",
            Self::ProjectAdministration => "project-administration",
            Self::Resources => "resources",
            Self::Software => "software",
            Self::Supervision => "supervision",
            Self::Validation => "validation",
            Self::Visualization => "visualization",
            Self::WritingOriginalDraft => "writing-original-draft",
            Self::WritingReviewEditing => "writing-review-editing",
        }
    }
}
impl<'de> Deserialize<'de> for ArtifactContributionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactContributionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ArtifactRelationshipType`. Artifact Relationship Type

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ArtifactRelationshipType {
    /** # amended-with

Amended with. Amended with */
    AmendedWith,
    /** # amends

Amends. Amends */
    Amends,
    /** # appended-with

Appended with. Appended with */
    AppendedWith,
    /** # appends

Appends. Appends */
    Appends,
    /** # cited-by

Cited by. Cited by */
    CitedBy,
    /** # cites

Cites. Cites */
    Cites,
    /** # comment-in

Comment In. Comment In */
    CommentIn,
    /** # comments-on

Comments On. Comments On */
    CommentsOn,
    /** # composed-of

Composed of. Composed of */
    ComposedOf,
    /** # correction-in

Correction In. Correction In */
    CorrectionIn,
    /** # corrects

Corrects. Corrects */
    Corrects,
    /** # depends-on

Depends on. Depends on */
    DependsOn,
    /** # derived-from

Derived from. Derived from */
    DerivedFrom,
    /** # part-of

Part of. Part of */
    PartOf,
    /** # replaced-with

Replaced with. Replaced with */
    ReplacedWith,
    /** # replaces

Replaces. Replaces */
    Replaces,
    /** # retracted-by

Retracted by. Retracted by */
    RetractedBy,
    /** # retracts

Retracts. Retracts */
    Retracts,
    /** # similar-to

Similar to. Similar to */
    SimilarTo,
    /** # supported-with

Supported with. Supported with */
    SupportedWith,
    /** # supports

Supports. Supports */
    Supports,
    /** # transformed-into

Transformed into. Transformed into */
    TransformedInto,
    /** # transformed-with

Transformed with. Transformed with */
    TransformedWith,
    /** # transforms

Transforms. Transforms */
    Transforms,
}
impl ::core::str::FromStr for ArtifactRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended-with" => Ok(Self::AmendedWith),
            "amends" => Ok(Self::Amends),
            "appended-with" => Ok(Self::AppendedWith),
            "appends" => Ok(Self::Appends),
            "cited-by" => Ok(Self::CitedBy),
            "cites" => Ok(Self::Cites),
            "comment-in" => Ok(Self::CommentIn),
            "comments-on" => Ok(Self::CommentsOn),
            "composed-of" => Ok(Self::ComposedOf),
            "correction-in" => Ok(Self::CorrectionIn),
            "corrects" => Ok(Self::Corrects),
            "depends-on" => Ok(Self::DependsOn),
            "derived-from" => Ok(Self::DerivedFrom),
            "part-of" => Ok(Self::PartOf),
            "replaced-with" => Ok(Self::ReplacedWith),
            "replaces" => Ok(Self::Replaces),
            "retracted-by" => Ok(Self::RetractedBy),
            "retracts" => Ok(Self::Retracts),
            "similar-to" => Ok(Self::SimilarTo),
            "supported-with" => Ok(Self::SupportedWith),
            "supports" => Ok(Self::Supports),
            "transformed-into" => Ok(Self::TransformedInto),
            "transformed-with" => Ok(Self::TransformedWith),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ArtifactRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AmendedWith => "amended-with",
            Self::Amends => "amends",
            Self::AppendedWith => "appended-with",
            Self::Appends => "appends",
            Self::CitedBy => "cited-by",
            Self::Cites => "cites",
            Self::CommentIn => "comment-in",
            Self::CommentsOn => "comments-on",
            Self::ComposedOf => "composed-of",
            Self::CorrectionIn => "correction-in",
            Self::Corrects => "corrects",
            Self::DependsOn => "depends-on",
            Self::DerivedFrom => "derived-from",
            Self::PartOf => "part-of",
            Self::ReplacedWith => "replaced-with",
            Self::Replaces => "replaces",
            Self::RetractedBy => "retracted-by",
            Self::Retracts => "retracts",
            Self::SimilarTo => "similar-to",
            Self::SupportedWith => "supported-with",
            Self::Supports => "supports",
            Self::TransformedInto => "transformed-into",
            Self::TransformedWith => "transformed-with",
            Self::Transforms => "transforms",
        }
    }
}
impl<'de> Deserialize<'de> for ArtifactRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ArtifactRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AssertionDirectionType`. The type of direction to use for assertion.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AssertionDirectionType {
    /** # request

request. The assertion is evaluated on the request. */
    Request,
    /** # response

response. The assertion is evaluated on the response. This is the default value. */
    Response,
}
impl ::core::str::FromStr for AssertionDirectionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "request" => Ok(Self::Request),
            "response" => Ok(Self::Response),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionDirectionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Request => "request",
            Self::Response => "response",
        }
    }
}
impl<'de> Deserialize<'de> for AssertionDirectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionDirectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AssertionOperatorType`. The type of operator to use for assertion.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AssertionOperatorType {
    /** # contains

contains. Compare value string contains a known value. */
    Contains,
    /** # empty

empty. Compare value is empty. */
    Empty,
    /** # equals

equals. Default value. Equals comparison. */
    Equals,
    /** # eval

evaluate. Evaluate the FHIRPath expression as a boolean condition. */
    Eval,
    /** # greaterThan

greaterThan. Compare value to be greater than a known value. */
    GreaterThan,
    /** # in

in. Compare value within a known set of values. */
    In,
    /** # lessThan

lessThan. Compare value to be less than a known value. */
    LessThan,
    /** # notContains

notContains. Compare value string does not contain a known value. */
    NotContains,
    /** # notEmpty

notEmpty. Compare value is not empty. */
    NotEmpty,
    /** # notEquals

notEquals. Not equals comparison. */
    NotEquals,
    /** # notIn

notIn. Compare value not within a known set of values. */
    NotIn,
}
impl ::core::str::FromStr for AssertionOperatorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contains" => Ok(Self::Contains),
            "empty" => Ok(Self::Empty),
            "equals" => Ok(Self::Equals),
            "eval" => Ok(Self::Eval),
            "greaterThan" => Ok(Self::GreaterThan),
            "in" => Ok(Self::In),
            "lessThan" => Ok(Self::LessThan),
            "notContains" => Ok(Self::NotContains),
            "notEmpty" => Ok(Self::NotEmpty),
            "notEquals" => Ok(Self::NotEquals),
            "notIn" => Ok(Self::NotIn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionOperatorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contains => "contains",
            Self::Empty => "empty",
            Self::Equals => "equals",
            Self::Eval => "eval",
            Self::GreaterThan => "greaterThan",
            Self::In => "in",
            Self::LessThan => "lessThan",
            Self::NotContains => "notContains",
            Self::NotEmpty => "notEmpty",
            Self::NotEquals => "notEquals",
            Self::NotIn => "notIn",
        }
    }
}
impl<'de> Deserialize<'de> for AssertionOperatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionOperatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AssertionResponseTypes`. The type of response code to use for assertion.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AssertionResponseTypes {
    /** # bad

bad. Response code is 400. */
    Bad,
    /** # conflict

conflict. Response code is 409. */
    Conflict,
    /** # created

created. Response code is 201. */
    Created,
    /** # forbidden

forbidden. Response code is 403. */
    Forbidden,
    /** # gone

gone. Response code is 410. */
    Gone,
    /** # methodNotAllowed

methodNotAllowed. Response code is 405. */
    MethodNotAllowed,
    /** # noContent

noContent. Response code is 204. */
    NoContent,
    /** # notFound

notFound. Response code is 404. */
    NotFound,
    /** # notModified

notModified. Response code is 304. */
    NotModified,
    /** # okay

okay. Response code is 200. */
    Okay,
    /** # preconditionFailed

preconditionFailed. Response code is 412. */
    PreconditionFailed,
    /** # unprocessable

unprocessable. Response code is 422. */
    Unprocessable,
}
impl ::core::str::FromStr for AssertionResponseTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bad" => Ok(Self::Bad),
            "conflict" => Ok(Self::Conflict),
            "created" => Ok(Self::Created),
            "forbidden" => Ok(Self::Forbidden),
            "gone" => Ok(Self::Gone),
            "methodNotAllowed" => Ok(Self::MethodNotAllowed),
            "noContent" => Ok(Self::NoContent),
            "notFound" => Ok(Self::NotFound),
            "notModified" => Ok(Self::NotModified),
            "okay" => Ok(Self::Okay),
            "preconditionFailed" => Ok(Self::PreconditionFailed),
            "unprocessable" => Ok(Self::Unprocessable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AssertionResponseTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bad => "bad",
            Self::Conflict => "conflict",
            Self::Created => "created",
            Self::Forbidden => "forbidden",
            Self::Gone => "gone",
            Self::MethodNotAllowed => "methodNotAllowed",
            Self::NoContent => "noContent",
            Self::NotFound => "notFound",
            Self::NotModified => "notModified",
            Self::Okay => "okay",
            Self::PreconditionFailed => "preconditionFailed",
            Self::Unprocessable => "unprocessable",
        }
    }
}
impl<'de> Deserialize<'de> for AssertionResponseTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AssertionResponseTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AttributeEstimateType`. A statistic about a statistic, e.g.  Confidence interval or p-value

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AttributeEstimateType {
    /** # 0000037

Standard error of the mean. The standard deviation of the sample-mean's estimate of a population mean. It is calculated by dividing the sample standard deviation (i.e., the sample-based estimate of the standard deviation of the population) by the square root of n , the size (number of observations) of the sample. */
    N0000037,
    /** # 0000419

Cochran's Q statistic. A measure of heterogeneity across study computed by summing the squared deviations of each study's estimate from the overall meta-analytic estimate, weighting each study's contribution in the same manner as in the meta-analysis. */
    N0000419,
    /** # 0000420

I-squared. The percentage of total variation across studies that is due to heterogeneity rather than chance. I2 can be readily calculated from basic results obtained from a typical meta-analysis as i2 = 100%×(q - df)/q, where q is cochran's heterogeneity statistic and df the degrees of freedom. Negative values of i2 are put equal to zero so that i2 lies between 0% and 100%. A value of 0% indicates no observed heterogeneity, and larger values show increasing heterogeneity. Unlike cochran's q, it does not inherently depend upon the number of studies considered. A confidence interval for i² is constructed using either i) the iterative non-central chi-squared distribution method of hedges and piggott (2001); or ii) the test-based method of higgins and thompson (2002). The non-central chi-square method is currently the method of choice (higgins, personal communication, 2006) – it is computed if the 'exact' option is selected. */
    N0000420,
    /** # 0000421

Tau squared. An estimate of the between-study variance in a random-effects meta-analysis. The square root of this number (i.e. Tau) is the estimated standard deviation of underlying effects across studies. */
    N0000421,
    /** # 0000455

Credible interval. An interval of a posterior distribution which is such that the density at any point inside the interval is greater than the density at any point outside and that the area under the curve for that interval is equal to a prespecified probability level. For any probability level there is generally only one such interval, which is also often known as the highest posterior density region. Unlike the usual confidence interval associated with frequentist inference, here the intervals specify the range within which parameters lie with a certain probability. The bayesian counterparts of the confidence interval used in frequentists statistics. */
    N0000455,
    /** # C38013

Range. The difference between the lowest and highest numerical values; the limits or scale of variation. */
    C38013,
    /** # C44185

P-value. The probability of obtaining the results obtained, or more extreme results, if the hypothesis being tested and all other model assumptions are true */
    C44185,
    /** # C48918

Variance. A measure of the variability in a sample or population. It is calculated as the mean squared deviation (MSD) of the individual values from their common mean. In calculating the MSD, the divisor n is commonly used for a population variance and the divisor n-1 for a sample variance. */
    C48918,
    /** # C53245

Interquartile range. The difference between the 3d and 1st quartiles is called the interquartile range and it is used as a measure of variability (dispersion). */
    C53245,
    /** # C53322

Standard deviation. A measure of the range of values in a set of numbers. Standard deviation is a statistic used as a measure of the dispersion or variation in a distribution, equal to the square root of the arithmetic mean of the squares of the deviations from the arithmetic mean. */
    C53322,
    /** # C53324

Confidence interval. A range of values considered compatible with the observed data at the specified confidence level */
    C53324,
}
impl ::core::str::FromStr for AttributeEstimateType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0000037" => Ok(Self::N0000037),
            "0000419" => Ok(Self::N0000419),
            "0000420" => Ok(Self::N0000420),
            "0000421" => Ok(Self::N0000421),
            "0000455" => Ok(Self::N0000455),
            "C38013" => Ok(Self::C38013),
            "C44185" => Ok(Self::C44185),
            "C48918" => Ok(Self::C48918),
            "C53245" => Ok(Self::C53245),
            "C53322" => Ok(Self::C53322),
            "C53324" => Ok(Self::C53324),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AttributeEstimateType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0000037 => "0000037",
            Self::N0000419 => "0000419",
            Self::N0000420 => "0000420",
            Self::N0000421 => "0000421",
            Self::N0000455 => "0000455",
            Self::C38013 => "C38013",
            Self::C44185 => "C44185",
            Self::C48918 => "C48918",
            Self::C53245 => "C53245",
            Self::C53322 => "C53322",
            Self::C53324 => "C53324",
        }
    }
}
impl<'de> Deserialize<'de> for AttributeEstimateType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AttributeEstimateType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AuditEventAction`. Indicator for type of action performed during the event that generated the event.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AuditEventAction {
    /** # C

Create. Create a new database object, such as placing an order. */
    C,
    /** # D

Delete. Delete items, such as a doctor master file record. */
    D,
    /** # E

Execute. Perform a system or application function such as log-on, program execution or use of an object's method, or perform a query/search operation. */
    E,
    /** # R

Read/View/Print. Display or print data, such as a doctor census. */
    R,
    /** # U

Update. Update data, such as revise patient information. */
    U,
}
impl ::core::str::FromStr for AuditEventAction {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "C" => Ok(Self::C),
            "D" => Ok(Self::D),
            "E" => Ok(Self::E),
            "R" => Ok(Self::R),
            "U" => Ok(Self::U),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventAction {
    fn as_ref(&self) -> &str {
        match self {
            Self::C => "C",
            Self::D => "D",
            Self::E => "E",
            Self::R => "R",
            Self::U => "U",
        }
    }
}
impl<'de> Deserialize<'de> for AuditEventAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AuditEventAgentNetworkType`. The type of network access point of this agent in the audit event.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AuditEventAgentNetworkType {
    /** # 1

Machine Name. The machine name, including DNS name. */
    N1,
    /** # 2

IP Address. The assigned Internet Protocol (IP) address. */
    N2,
    /** # 3

Telephone Number. The assigned telephone number. */
    N3,
    /** # 4

Email address. The assigned email address. */
    N4,
    /** # 5

URI. URI (User directory, HTTP-PUT, ftp, etc.). */
    N5,
}
impl ::core::str::FromStr for AuditEventAgentNetworkType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "2" => Ok(Self::N2),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventAgentNetworkType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N2 => "2",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::N5 => "5",
        }
    }
}
impl<'de> Deserialize<'de> for AuditEventAgentNetworkType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventAgentNetworkType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AuditEventEntityRole`. Code representing the role the entity played in the audit event.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AuditEventEntityRole {
    /** # 1

Patient. This object is the patient that is the subject of care related to this event.  It is identifiable by patient ID or equivalent.  The patient may be either human or animal. */
    N1,
    /** # 10

Guarantor. Insurance company, or any other organization who accepts responsibility for paying for the healthcare event. */
    N10,
    /** # 11

Security User Entity. A person or active system object involved in the event with a security role. */
    N11,
    /** # 12

Security User Group. A person or system object involved in the event with the authority to modify security roles of other objects. */
    N12,
    /** # 13

Security Resource. A passive object, such as a role table, that is relevant to the event. */
    N13,
    /** # 14

Security Granularity Definition. (deprecated)  Relevant to certain RBAC security methodologies. */
    N14,
    /** # 15

Practitioner. Any person or organization responsible for providing care.  This encompasses all forms of care, licensed or otherwise, and all sorts of teams and care groups. Note the distinction between practitioner and the doctor that actually provided the care to the patient. */
    N15,
    /** # 16

Data Destination. The source or destination for data transfer, when it does not match some other role. */
    N16,
    /** # 17

Data Repository. A source or destination for data transfer that acts as an archive, database, or similar role. */
    N17,
    /** # 18

Schedule. An object that holds schedule information.  This could be an appointment book, availability information, etc. */
    N18,
    /** # 19

Customer. An organization or person that is the recipient of services.  This could be an organization that is buying services for a patient, or a person that is buying services for an animal. */
    N19,
    /** # 2

Location. This is a location identified as related to the event.  This is usually the location where the event took place.  Note that for shipping, the usual events are arrival at a location or departure from a location. */
    N2,
    /** # 20

Job. An order, task, work item, procedure step, or other description of work to be performed; e.g. a particular instance of an MPPS. */
    N20,
    /** # 21

Job Stream. A list of jobs or a system that provides lists of jobs; e.g. an MWL SCP. */
    N21,
    /** # 22

Table. (Deprecated). */
    N22,
    /** # 23

Routing Criteria. An object that specifies or controls the routing or delivery of items.  For example, a distribution list is the routing criteria for mail.  The items delivered may be documents, jobs, or other objects. */
    N23,
    /** # 24

Query. The contents of a query.  This is used to capture the contents of any kind of query.  For security surveillance purposes knowing the queries being made is very important. */
    N24,
    /** # 3

Report. This object is any kind of persistent document created as a result of the event.  This could be a paper report, film, electronic report, DICOM Study, etc.  Issues related to medical records life cycle management are conveyed elsewhere. */
    N3,
    /** # 4

Domain Resource. A logical object related to a health record event.  This is any healthcare  specific resource (object) not restricted to FHIR defined Resources. */
    N4,
    /** # 5

Master file. This is any configurable file used to control creation of documents.  Examples include the objects maintained by the HL7 Master File transactions, Value Sets, etc. */
    N5,
    /** # 6

User. A human participant not otherwise identified by some other category. */
    N6,
    /** # 7

List. (deprecated). */
    N7,
    /** # 8

Doctor. Typically, a licensed person who is providing or performing care related to the event, generally a physician.   The key distinction between doctor and practitioner is with regards to their role, not the licensing.  The doctor is the human who actually performed the work.  The practitioner is the human or organization that is responsible for the work. */
    N8,
    /** # 9

Subscriber. A person or system that is being notified as part of the event.  This is relevant in situations where automated systems provide notifications to other parties when an event took place. */
    N9,
}
impl ::core::str::FromStr for AuditEventEntityRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "10" => Ok(Self::N10),
            "11" => Ok(Self::N11),
            "12" => Ok(Self::N12),
            "13" => Ok(Self::N13),
            "14" => Ok(Self::N14),
            "15" => Ok(Self::N15),
            "16" => Ok(Self::N16),
            "17" => Ok(Self::N17),
            "18" => Ok(Self::N18),
            "19" => Ok(Self::N19),
            "2" => Ok(Self::N2),
            "20" => Ok(Self::N20),
            "21" => Ok(Self::N21),
            "22" => Ok(Self::N22),
            "23" => Ok(Self::N23),
            "24" => Ok(Self::N24),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            "6" => Ok(Self::N6),
            "7" => Ok(Self::N7),
            "8" => Ok(Self::N8),
            "9" => Ok(Self::N9),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventEntityRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N10 => "10",
            Self::N11 => "11",
            Self::N12 => "12",
            Self::N13 => "13",
            Self::N14 => "14",
            Self::N15 => "15",
            Self::N16 => "16",
            Self::N17 => "17",
            Self::N18 => "18",
            Self::N19 => "19",
            Self::N2 => "2",
            Self::N20 => "20",
            Self::N21 => "21",
            Self::N22 => "22",
            Self::N23 => "23",
            Self::N24 => "24",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::N5 => "5",
            Self::N6 => "6",
            Self::N7 => "7",
            Self::N8 => "8",
            Self::N9 => "9",
        }
    }
}
impl<'de> Deserialize<'de> for AuditEventEntityRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventEntityRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AuditEventEntityType`. Code for the entity type involved in the audit event (derived from ATNA).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AuditEventEntityType {
    /** # 1

Person. Person */
    N1,
    /** # 2

System Object. System Object */
    N2,
    /** # 3

Organization. Organization */
    N3,
    /** # 4

Other. Other */
    N4,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AuditEventEntityType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "2" => Ok(Self::N2),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AuditEventEntityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N2 => "2",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for AuditEventEntityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventEntityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AuditEventID`. Event Types for Audit Events - defined by DICOM with some FHIR specific additions.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AuditEventID {
    /** # rest

RESTful Operation. Audit Event: Execution of a RESTful operation as defined by FHIR. */
    Rest,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AuditEventID {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "rest" => Ok(Self::Rest),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AuditEventID {
    fn as_ref(&self) -> &str {
        match self {
            Self::Rest => "rest",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for AuditEventID {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventID {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AuditEventOutcome`. Indicates whether the event succeeded or failed.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum AuditEventOutcome {
    /** # 0

Success. The operation completed successfully (whether with warnings or not). */
    N0,
    /** # 12

Major failure. An error of such magnitude occurred that the system is no longer available for use (i.e. the system died). */
    N12,
    /** # 4

Minor failure. The action was not successful due to some kind of minor failure (often equivalent to an HTTP 400 response). */
    N4,
    /** # 8

Serious failure. The action was not successful due to some kind of unexpected error (often equivalent to an HTTP 500 response). */
    N8,
}
impl ::core::str::FromStr for AuditEventOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0" => Ok(Self::N0),
            "12" => Ok(Self::N12),
            "4" => Ok(Self::N4),
            "8" => Ok(Self::N8),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for AuditEventOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0 => "0",
            Self::N12 => "12",
            Self::N4 => "4",
            Self::N8 => "8",
        }
    }
}
impl<'de> Deserialize<'de> for AuditEventOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `AuditEventSourceType`. The type of process where the audit event originated from.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AuditEventSourceType {
    /** # 1

User Device. End-user display device, diagnostic device. */
    N1,
    /** # 2

Data Interface. Data acquisition device or instrument. */
    N2,
    /** # 3

Web Server. Web Server process or thread. */
    N3,
    /** # 4

Application Server. Application Server process or thread. */
    N4,
    /** # 5

Database Server. Database Server process or thread. */
    N5,
    /** # 6

Security Server. Security server, e.g. a domain controller. */
    N6,
    /** # 7

Network Device. ISO level 1-3 network component. */
    N7,
    /** # 8

Network Router. ISO level 4-6 operating software. */
    N8,
    /** # 9

Other. Other kind of device (defined by DICOM, but some other code/system can be used). */
    N9,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for AuditEventSourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "2" => Ok(Self::N2),
            "3" => Ok(Self::N3),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            "6" => Ok(Self::N6),
            "7" => Ok(Self::N7),
            "8" => Ok(Self::N8),
            "9" => Ok(Self::N9),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for AuditEventSourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N2 => "2",
            Self::N3 => "3",
            Self::N4 => "4",
            Self::N5 => "5",
            Self::N6 => "6",
            Self::N7 => "7",
            Self::N8 => "8",
            Self::N9 => "9",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for AuditEventSourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for AuditEventSourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BasicResourceTypes`. This value set defines codes for resources not yet supported by (or which will never be supported by) FHIR.  Many of the codes listed here will eventually be turned into official resources.  However, there is no guarantee that any particular resource will be created nor that the scope will be exactly as defined by the codes presented here.  Codes in this set will be deprecated if/when formal resources are defined that encompass these concepts.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BasicResourceTypes {
    /** # account

Account. A financial instrument used to track costs, charges or other amounts. */
    Account,
    /** # adjudicat

Invoice Adjudication. The determination of what will be paid against a particular invoice based on coverage, plan rules, etc. */
    Adjudicat,
    /** # adminact

Administrative Activity. An occurrence of a non-care-related event in the healthcare domain, such as approvals, reviews, etc. */
    Adminact,
    /** # advevent

Adverse Event. An undesired reaction caused by exposure to some agent (e.g. a medication, immunization, food, or environmental agent). */
    Advevent,
    /** # aptmtreq

Appointment Request. A request that a time be scheduled for a type of service for a specified patient, potentially subject to other constraints */
    Aptmtreq,
    /** # consent

Consent. An assertion of permission for an activity or set of activities to occur, possibly subject to particular limitations; e.g. surgical consent, information disclosure consent, etc. */
    Consent,
    /** # diet

Diet. The specification of a set of food and/or other nutritional material to be delivered to a patient. */
    Diet,
    /** # exposure

Exposure. Record of a situation where a subject was exposed to a substance.  Usually of interest to public health. */
    Exposure,
    /** # investigation

Investigation. A formalized inquiry into the circumstances surrounding a particular unplanned event or potential event for the purposes of identifying possible causes and contributing factors for the event */
    Investigation,
    /** # invoice

Invoice. A request for payment for goods and/or services.  Includes the idea of a healthcare insurance claim. */
    Invoice,
    /** # predetermine

Predetermination. An adjudication of what would be paid under an insurance plan for a hypothetical claim for goods or services */
    Predetermine,
    /** # predetreq

Pre-determination Request. A request for a pre-determination of the cost that would be paid under an insurance plan for a hypothetical claim for goods or services */
    Predetreq,
    /** # protocol

Protocol. A set of (possibly conditional) steps to be taken to achieve some aim.  Includes study protocols, treatment protocols, emergency protocols, etc. */
    Protocol,
    /** # referral

Referral. A request that care of a particular type be provided to a patient.  Could involve the transfer of care, a consult, etc. */
    Referral,
    /** # study

Study. An investigation to determine information about a particular therapy or product */
    Study,
    /** # transfer

Transfer. The transition of a patient or set of material from one location to another */
    Transfer,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for BasicResourceTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "account" => Ok(Self::Account),
            "adjudicat" => Ok(Self::Adjudicat),
            "adminact" => Ok(Self::Adminact),
            "advevent" => Ok(Self::Advevent),
            "aptmtreq" => Ok(Self::Aptmtreq),
            "consent" => Ok(Self::Consent),
            "diet" => Ok(Self::Diet),
            "exposure" => Ok(Self::Exposure),
            "investigation" => Ok(Self::Investigation),
            "invoice" => Ok(Self::Invoice),
            "predetermine" => Ok(Self::Predetermine),
            "predetreq" => Ok(Self::Predetreq),
            "protocol" => Ok(Self::Protocol),
            "referral" => Ok(Self::Referral),
            "study" => Ok(Self::Study),
            "transfer" => Ok(Self::Transfer),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for BasicResourceTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Account => "account",
            Self::Adjudicat => "adjudicat",
            Self::Adminact => "adminact",
            Self::Advevent => "advevent",
            Self::Aptmtreq => "aptmtreq",
            Self::Consent => "consent",
            Self::Diet => "diet",
            Self::Exposure => "exposure",
            Self::Investigation => "investigation",
            Self::Invoice => "invoice",
            Self::Predetermine => "predetermine",
            Self::Predetreq => "predetreq",
            Self::Protocol => "protocol",
            Self::Referral => "referral",
            Self::Study => "study",
            Self::Transfer => "transfer",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for BasicResourceTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BasicResourceTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BenefitCategoryCodes`. This value set includes a smattering of Benefit SubCategory codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BenefitCategoryCodes {
    /** # 1

Medical Care. Medical Care. */
    N1,
    /** # 14

Renal Supplies. Renal Supplies excluding Dialysis. */
    N14,
    /** # 2

Surgical. Surgical. */
    N2,
    /** # 23

Diagnostic Dental. Diagnostic Dental. */
    N23,
    /** # 24

Periodontics. Periodontics. */
    N24,
    /** # 25

Restorative. Restorative. */
    N25,
    /** # 26

Endodontics. Endodontics. */
    N26,
    /** # 27

Maxillofacial Prosthetics. Maxillofacial Prosthetics. */
    N27,
    /** # 28

Adjunctive Dental Services. Adjunctive Dental Services. */
    N28,
    /** # 3

Consultation. Consultation. */
    N3,
    /** # 30

Health Benefit Plan Coverage. Health Benefit Plan Coverage. */
    N30,
    /** # 35

Dental Care. Dental Care. */
    N35,
    /** # 36

Dental Crowns. Dental Crowns. */
    N36,
    /** # 37

Dental Accident. Dental Accident. */
    N37,
    /** # 4

Diagnostic XRay. Diagnostic XRay. */
    N4,
    /** # 49

Hospital Room and Board. Hospital Room and Board. */
    N49,
    /** # 5

Diagnostic Lab. Diagnostic Lab. */
    N5,
    /** # 55

Major Medical. Major Medical. */
    N55,
    /** # 56

Medically Related Transportation. Medically Related Transportation. */
    N56,
    /** # 61

In-vitro Fertilization. In-vitro Fertilization. */
    N61,
    /** # 62

MRI Scan. MRI Scan. */
    N62,
    /** # 63

Donor Procedures. Donor Procedures such as organ harvest. */
    N63,
    /** # 69

Maternity. Maternity. */
    N69,
    /** # 76

Renal Dialysis. Renal dialysis. */
    N76,
    /** # F1

Medical Coverage. Medical Coverage. */
    F1,
    /** # F3

Dental Coverage. Dental Coverage. */
    F3,
    /** # F4

Hearing Coverage. Hearing Coverage. */
    F4,
    /** # F6

Vision Coverage. Vision Coverage. */
    F6,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for BenefitCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "14" => Ok(Self::N14),
            "2" => Ok(Self::N2),
            "23" => Ok(Self::N23),
            "24" => Ok(Self::N24),
            "25" => Ok(Self::N25),
            "26" => Ok(Self::N26),
            "27" => Ok(Self::N27),
            "28" => Ok(Self::N28),
            "3" => Ok(Self::N3),
            "30" => Ok(Self::N30),
            "35" => Ok(Self::N35),
            "36" => Ok(Self::N36),
            "37" => Ok(Self::N37),
            "4" => Ok(Self::N4),
            "49" => Ok(Self::N49),
            "5" => Ok(Self::N5),
            "55" => Ok(Self::N55),
            "56" => Ok(Self::N56),
            "61" => Ok(Self::N61),
            "62" => Ok(Self::N62),
            "63" => Ok(Self::N63),
            "69" => Ok(Self::N69),
            "76" => Ok(Self::N76),
            "F1" => Ok(Self::F1),
            "F3" => Ok(Self::F3),
            "F4" => Ok(Self::F4),
            "F6" => Ok(Self::F6),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for BenefitCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N14 => "14",
            Self::N2 => "2",
            Self::N23 => "23",
            Self::N24 => "24",
            Self::N25 => "25",
            Self::N26 => "26",
            Self::N27 => "27",
            Self::N28 => "28",
            Self::N3 => "3",
            Self::N30 => "30",
            Self::N35 => "35",
            Self::N36 => "36",
            Self::N37 => "37",
            Self::N4 => "4",
            Self::N49 => "49",
            Self::N5 => "5",
            Self::N55 => "55",
            Self::N56 => "56",
            Self::N61 => "61",
            Self::N62 => "62",
            Self::N63 => "63",
            Self::N69 => "69",
            Self::N76 => "76",
            Self::F1 => "F1",
            Self::F3 => "F3",
            Self::F4 => "F4",
            Self::F6 => "F6",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for BenefitCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BenefitCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BenefitCostApplicability`. Whether the cost applies to in-network or out-of-network providers.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BenefitCostApplicability {
    /** # in-network

In Network. Provider is contracted with the health insurance company to provide services to plan members for specific pre-negotiated rates */
    InNetwork,
    /** # other

Other. Other applicability */
    Other,
    /** # out-of-network

Out of Network. Provider is  not contracted with the health insurance company to provide services to plan members for specific pre-negotiated rates */
    OutOfNetwork,
}
impl ::core::str::FromStr for BenefitCostApplicability {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "in-network" => Ok(Self::InNetwork),
            "other" => Ok(Self::Other),
            "out-of-network" => Ok(Self::OutOfNetwork),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BenefitCostApplicability {
    fn as_ref(&self) -> &str {
        match self {
            Self::InNetwork => "in-network",
            Self::Other => "other",
            Self::OutOfNetwork => "out-of-network",
        }
    }
}
impl<'de> Deserialize<'de> for BenefitCostApplicability {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BenefitCostApplicability {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BenefitTermCodes`. This value set includes a smattering of Benefit Term codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BenefitTermCodes {
    /** # annual

Annual. Annual, renewing on the anniversary */
    Annual,
    /** # day

Day. Per day */
    Day,
    /** # lifetime

Lifetime. For the total term, lifetime, of the policy or coverage */
    Lifetime,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for BenefitTermCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "annual" => Ok(Self::Annual),
            "day" => Ok(Self::Day),
            "lifetime" => Ok(Self::Lifetime),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for BenefitTermCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Annual => "annual",
            Self::Day => "day",
            Self::Lifetime => "lifetime",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for BenefitTermCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BenefitTermCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BenefitTypeCodes`. This value set includes a smattering of Benefit type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BenefitTypeCodes {
    /** # benefit

Benefit. Maximum benefit allowable. */
    Benefit,
    /** # copay

Copayment per service. Copayment per service */
    Copay,
    /** # copay-maximum

Copayment maximum per service. Copayment maximum per service */
    CopayMaximum,
    /** # copay-percent

Copayment Percent per service. Copayment percentage per service */
    CopayPercent,
    /** # deductible

Deductible. Cost to be incurred before benefits are applied */
    Deductible,
    /** # medical-primarycare

Medical Primary Health Coverage. Medical Primary Health Coverage */
    MedicalPrimarycare,
    /** # pharmacy-dispense

Pharmacy Dispense Coverage. Pharmacy Dispense Coverage */
    PharmacyDispense,
    /** # room

Room. Type of room */
    Room,
    /** # vision-contacts

Vision Contacts Coverage. Contact Lenses */
    VisionContacts,
    /** # vision-exam

Vision Exam. Vision Exam */
    VisionExam,
    /** # vision-glasses

Vision Glasses. Frames and lenses */
    VisionGlasses,
    /** # visit

Visit. Service visit */
    Visit,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for BenefitTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "benefit" => Ok(Self::Benefit),
            "copay" => Ok(Self::Copay),
            "copay-maximum" => Ok(Self::CopayMaximum),
            "copay-percent" => Ok(Self::CopayPercent),
            "deductible" => Ok(Self::Deductible),
            "medical-primarycare" => Ok(Self::MedicalPrimarycare),
            "pharmacy-dispense" => Ok(Self::PharmacyDispense),
            "room" => Ok(Self::Room),
            "vision-contacts" => Ok(Self::VisionContacts),
            "vision-exam" => Ok(Self::VisionExam),
            "vision-glasses" => Ok(Self::VisionGlasses),
            "visit" => Ok(Self::Visit),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for BenefitTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Benefit => "benefit",
            Self::Copay => "copay",
            Self::CopayMaximum => "copay-maximum",
            Self::CopayPercent => "copay-percent",
            Self::Deductible => "deductible",
            Self::MedicalPrimarycare => "medical-primarycare",
            Self::PharmacyDispense => "pharmacy-dispense",
            Self::Room => "room",
            Self::VisionContacts => "vision-contacts",
            Self::VisionExam => "vision-exam",
            Self::VisionGlasses => "vision-glasses",
            Self::Visit => "visit",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for BenefitTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BenefitTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BindingStrength`. Indication of the degree of conformance expectations associated with a binding.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BindingStrength {
    /** # example

Example. Instances are not expected or even encouraged to draw from the specified value set.  The value set merely provides examples of the types of concepts intended to be included. */
    Example,
    /** # extensible

Extensible. To be conformant, the concept in this element SHALL be from the specified value set if any of the codes within the value set can apply to the concept being communicated.  If the value set does not cover the concept (based on human review), alternate codings (or, data type allowing, text) may be included instead. */
    Extensible,
    /** # preferred

Preferred. Instances are encouraged to draw from the specified codes for interoperability purposes but are not required to do so to be considered conformant. */
    Preferred,
    /** # required

Required. To be conformant, the concept in this element SHALL be from the specified value set. */
    Required,
}
impl ::core::str::FromStr for BindingStrength {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "example" => Ok(Self::Example),
            "extensible" => Ok(Self::Extensible),
            "preferred" => Ok(Self::Preferred),
            "required" => Ok(Self::Required),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BindingStrength {
    fn as_ref(&self) -> &str {
        match self {
            Self::Example => "example",
            Self::Extensible => "extensible",
            Self::Preferred => "preferred",
            Self::Required => "required",
        }
    }
}
impl<'de> Deserialize<'de> for BindingStrength {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BindingStrength {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BiologicallyDerivedProductCategory`. Biologically Derived Product Category.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductCategory {
    /** # biologicalAgent

BiologicalAgent. Biological agent of unspecified type. */
    BiologicalAgent,
    /** # cells

Cells. Collection of cells. */
    Cells,
    /** # fluid

Fluid. Body fluid. */
    Fluid,
    /** # organ

Organ. A collection of tissues joined in a structural unit to serve a common function. */
    Organ,
    /** # tissue

Tissue. An ensemble of similar cells and their extracellular matrix from the same origin that together carry out a specific function. */
    Tissue,
}
impl ::core::str::FromStr for BiologicallyDerivedProductCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "biologicalAgent" => Ok(Self::BiologicalAgent),
            "cells" => Ok(Self::Cells),
            "fluid" => Ok(Self::Fluid),
            "organ" => Ok(Self::Organ),
            "tissue" => Ok(Self::Tissue),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::BiologicalAgent => "biologicalAgent",
            Self::Cells => "cells",
            Self::Fluid => "fluid",
            Self::Organ => "organ",
            Self::Tissue => "tissue",
        }
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BiologicallyDerivedProductStatus`. Biologically Derived Product Status.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductStatus {
    /** # available

Available. Product is currently available for use. */
    Available,
    /** # unavailable

Unavailable. Product is not currently available for use. */
    Unavailable,
}
impl ::core::str::FromStr for BiologicallyDerivedProductStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "unavailable" => Ok(Self::Unavailable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::Unavailable => "unavailable",
        }
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BiologicallyDerivedProductStorageScale`. BiologicallyDerived Product Storage Scale.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BiologicallyDerivedProductStorageScale {
    /** # celsius

Celsius. Celsius or centigrade temperature scale. */
    Celsius,
    /** # farenheit

Fahrenheit. Fahrenheit temperature scale. */
    Farenheit,
    /** # kelvin

Kelvin. Kelvin absolute thermodynamic temperature scale. */
    Kelvin,
}
impl ::core::str::FromStr for BiologicallyDerivedProductStorageScale {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "celsius" => Ok(Self::Celsius),
            "farenheit" => Ok(Self::Farenheit),
            "kelvin" => Ok(Self::Kelvin),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BiologicallyDerivedProductStorageScale {
    fn as_ref(&self) -> &str {
        match self {
            Self::Celsius => "celsius",
            Self::Farenheit => "farenheit",
            Self::Kelvin => "kelvin",
        }
    }
}
impl<'de> Deserialize<'de> for BiologicallyDerivedProductStorageScale {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BiologicallyDerivedProductStorageScale {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `BundleType`. Indicates the purpose of a bundle - how it is intended to be used.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum BundleType {
    /** # batch

Batch. The bundle is a set of actions - intended to be processed by a server as a group of independent actions. */
    Batch,
    /** # batch-response

Batch Response. The bundle is a batch response. Note that as a batch, some responses may indicate failure and others success. */
    BatchResponse,
    /** # collection

Collection. The bundle is a set of resources collected into a single package for ease of distribution that imposes no processing obligations or behavioral rules beyond persistence. */
    Collection,
    /** # document

Document. The bundle is a document. The first resource is a Composition. */
    Document,
    /** # history

History List. The bundle is a list of resources from a history interaction on a server. */
    History,
    /** # message

Message. The bundle is a message. The first resource is a MessageHeader. */
    Message,
    /** # searchset

Search Results. The bundle is a list of resources returned as a result of a search/query interaction, operation, or message. */
    Searchset,
    /** # transaction

Transaction. The bundle is a transaction - intended to be processed by a server as an atomic commit. */
    Transaction,
    /** # transaction-response

Transaction Response. The bundle is a transaction response. Because the response is a transaction response, the transaction has succeeded, and all responses are error free. */
    TransactionResponse,
}
impl ::core::str::FromStr for BundleType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "batch" => Ok(Self::Batch),
            "batch-response" => Ok(Self::BatchResponse),
            "collection" => Ok(Self::Collection),
            "document" => Ok(Self::Document),
            "history" => Ok(Self::History),
            "message" => Ok(Self::Message),
            "searchset" => Ok(Self::Searchset),
            "transaction" => Ok(Self::Transaction),
            "transaction-response" => Ok(Self::TransactionResponse),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for BundleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Batch => "batch",
            Self::BatchResponse => "batch-response",
            Self::Collection => "collection",
            Self::Document => "document",
            Self::History => "history",
            Self::Message => "message",
            Self::Searchset => "searchset",
            Self::Transaction => "transaction",
            Self::TransactionResponse => "transaction-response",
        }
    }
}
impl<'de> Deserialize<'de> for BundleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for BundleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CapabilityStatementKind`. How a capability statement is intended to be used.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CapabilityStatementKind {
    /** # capability

Capability. The CapabilityStatement instance represents the capabilities of a system or piece of software, independent of a particular installation. */
    Capability,
    /** # instance

Instance. The CapabilityStatement instance represents the present capabilities of a specific system instance.  This is the kind returned by /metadata for a FHIR server end-point. */
    Instance,
    /** # requirements

Requirements. The CapabilityStatement instance represents a set of requirements for other systems to meet; e.g. as part of an implementation guide or 'request for proposal'. */
    Requirements,
}
impl ::core::str::FromStr for CapabilityStatementKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "capability" => Ok(Self::Capability),
            "instance" => Ok(Self::Instance),
            "requirements" => Ok(Self::Requirements),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CapabilityStatementKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Capability => "capability",
            Self::Instance => "instance",
            Self::Requirements => "requirements",
        }
    }
}
impl<'de> Deserialize<'de> for CapabilityStatementKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CapabilityStatementKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CarePlanActivityStatus`. Codes that reflect the current state of a care plan activity within its overall life cycle.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CarePlanActivityStatus {
    /** # cancelled

Cancelled. The planned care plan activity has been withdrawn. */
    Cancelled,
    /** # completed

Completed. Care plan activity has been completed (more or less) as planned. */
    Completed,
    /** # entered-in-error

Entered in Error. Care plan activity was entered in error and voided. */
    EnteredInError,
    /** # in-progress

In Progress. Care plan activity has been started but is not yet complete. */
    InProgress,
    /** # not-started

Not Started. Care plan activity is planned but no action has yet been taken. */
    NotStarted,
    /** # on-hold

On Hold. Care plan activity was started but has temporarily ceased with an expectation of resumption at a future time. */
    OnHold,
    /** # scheduled

Scheduled. Appointment or other booking has occurred but activity has not yet begun. */
    Scheduled,
    /** # stopped

Stopped. The planned care plan activity has been ended prior to completion after the activity was started. */
    Stopped,
    /** # unknown

Unknown. The current state of the care plan activity is not known.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which one. */
    Unknown,
}
impl ::core::str::FromStr for CarePlanActivityStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "not-started" => Ok(Self::NotStarted),
            "on-hold" => Ok(Self::OnHold),
            "scheduled" => Ok(Self::Scheduled),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CarePlanActivityStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::NotStarted => "not-started",
            Self::OnHold => "on-hold",
            Self::Scheduled => "scheduled",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for CarePlanActivityStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CarePlanActivityStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CareTeamStatus`. Indicates the status of the care team.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CareTeamStatus {
    /** # active

Active. The care team is currently participating in the coordination and delivery of care. */
    Active,
    /** # entered-in-error

Entered in Error. The care team should have never existed. */
    EnteredInError,
    /** # inactive

Inactive. The care team was, but is no longer, participating in the coordination and delivery of care. */
    Inactive,
    /** # proposed

Proposed. The care team has been drafted and proposed, but not yet participating in the coordination and delivery of patient care. */
    Proposed,
    /** # suspended

Suspended. The care team is temporarily on hold or suspended and not participating in the coordination and delivery of care. */
    Suspended,
}
impl ::core::str::FromStr for CareTeamStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "proposed" => Ok(Self::Proposed),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CareTeamStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Proposed => "proposed",
            Self::Suspended => "suspended",
        }
    }
}
impl<'de> Deserialize<'de> for CareTeamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CareTeamStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CatalogEntryRelationType`. The type of relations between entries.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CatalogEntryRelationType {
    /** # is-replaced-by

Replaced By. the related entry represents an item that replaces the current retired item. */
    IsReplacedBy,
    /** # triggers

Triggers. the related entry represents an activity that may be triggered by the current item. */
    Triggers,
}
impl ::core::str::FromStr for CatalogEntryRelationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "is-replaced-by" => Ok(Self::IsReplacedBy),
            "triggers" => Ok(Self::Triggers),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CatalogEntryRelationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::IsReplacedBy => "is-replaced-by",
            Self::Triggers => "triggers",
        }
    }
}
impl<'de> Deserialize<'de> for CatalogEntryRelationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CatalogEntryRelationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CatalogType`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CatalogType {
    /** # device

Device Catalog. Device Catalog. */
    Device,
    /** # medication

Medication Catalog. Medication Catalog. */
    Medication,
    /** # protocol

Protocol List. Protocol List. */
    Protocol,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CatalogType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "device" => Ok(Self::Device),
            "medication" => Ok(Self::Medication),
            "protocol" => Ok(Self::Protocol),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CatalogType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "device",
            Self::Medication => "medication",
            Self::Protocol => "protocol",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for CatalogType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CatalogType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CharacteristicCombination`. Logical grouping of characteristics.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CharacteristicCombination {
    /** # intersection

intersection. Combine characteristics with AND. */
    Intersection,
    /** # union

union. Combine characteristics with OR. */
    Union,
}
impl ::core::str::FromStr for CharacteristicCombination {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "intersection" => Ok(Self::Intersection),
            "union" => Ok(Self::Union),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CharacteristicCombination {
    fn as_ref(&self) -> &str {
        match self {
            Self::Intersection => "intersection",
            Self::Union => "union",
        }
    }
}
impl<'de> Deserialize<'de> for CharacteristicCombination {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CharacteristicCombination {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CharacteristicMethod`. The method used to determine the characteristic(s) of the variable.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CharacteristicMethod {
    /** # Default

Default. Default. */
    Default,
}
impl ::core::str::FromStr for CharacteristicMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Default" => Ok(Self::Default),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CharacteristicMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Default => "Default",
        }
    }
}
impl<'de> Deserialize<'de> for CharacteristicMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CharacteristicMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ChargeItemCode`. Example set of codes that can be used for billing purposes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ChargeItemCode {
    /** # 1100

Unvorhergesehene Inanspruchnahme. From German EBM billing system:
Unvorhergesehene Inanspruchnahme des Vertragsarztes durch einen Patienten;zwischen 19:00 und 22:00 Uhr;an Samstagen, Sonntagen und gesetzlichen Feiertagen, am 24.12. und 31.12. zwischen 07:00 und 19:00 Uhr. */
    N1100,
    /** # 1210

Notfallpauschale. From German EBM billing system:
Notfallpauschale im organisierten Not(-fall)dienst und für nicht an der vertragsärztlichen Versorgung teilnehmende Ärzte, Institute und Krankenhäuser bei Inanspruchnahme;zwischen 07:00 und 19:00 Uhr. */
    N1210,
    /** # 1320

Grundpauschale. From German EBM billing system:
Grundpauschale für Ärzte, Institute und Krankenhäuser, die zur Erbringung von Leistungen innerhalb mindestens eines der Fachgebiete Anästhesiologie, Frauenheilkunde und Geburtshilfe, Haut- und Geschlechtskrankheiten, Mund-, Kiefer- und Gesichtschirurgie und Humangenetik ermächtigt sind. */
    N1320,
}
impl ::core::str::FromStr for ChargeItemCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1100" => Ok(Self::N1100),
            "1210" => Ok(Self::N1210),
            "1320" => Ok(Self::N1320),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ChargeItemCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1100 => "1100",
            Self::N1210 => "1210",
            Self::N1320 => "1320",
        }
    }
}
impl<'de> Deserialize<'de> for ChargeItemCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ChargeItemCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ChargeItemStatus`. Codes identifying the lifecycle stage of a ChargeItem.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ChargeItemStatus {
    /** # aborted

Aborted. The processing of the charge was aborted. */
    Aborted,
    /** # billable

Billable. The charge item is ready for billing. */
    Billable,
    /** # billed

Billed. The charge item has been billed (e.g. a billing engine has generated financial transactions by applying the associated ruled for the charge item to the context of the Encounter, and placed them into Claims/Invoices. */
    Billed,
    /** # entered-in-error

Entered in Error. The charge item has been entered in error and should not be processed for billing. */
    EnteredInError,
    /** # not-billable

Not billable. The charge item has been determined to be not billable (e.g. due to rules associated with the billing code). */
    NotBillable,
    /** # planned

Planned. The charge item has been entered, but the charged service is not  yet complete, so it shall not be billed yet but might be used in the context of pre-authorization. */
    Planned,
    /** # unknown

Unknown. The authoring system does not know which of the status values currently applies for this charge item  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for ChargeItemStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aborted" => Ok(Self::Aborted),
            "billable" => Ok(Self::Billable),
            "billed" => Ok(Self::Billed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "not-billable" => Ok(Self::NotBillable),
            "planned" => Ok(Self::Planned),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ChargeItemStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aborted => "aborted",
            Self::Billable => "billable",
            Self::Billed => "billed",
            Self::EnteredInError => "entered-in-error",
            Self::NotBillable => "not-billable",
            Self::Planned => "planned",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for ChargeItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ChargeItemStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CholCodeLegacyStatus`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CholCodeLegacyStatus {
    /** # chol

*/
    Chol,
    /** # chol-mass

*/
    CholMass,
    /** # chol-mmol

*/
    CholMmol,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CholCodeLegacyStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "chol" => Ok(Self::Chol),
            "chol-mass" => Ok(Self::CholMass),
            "chol-mmol" => Ok(Self::CholMmol),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CholCodeLegacyStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Chol => "chol",
            Self::CholMass => "chol-mass",
            Self::CholMmol => "chol-mmol",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for CholCodeLegacyStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CholCodeLegacyStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CitationArtifactClassifier`. Citation artifact classifier

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitationArtifactClassifier {
    /** # 68059040

Video-Audio Media. Used with articles which include video files or clips, or for articles which are entirely video. */
    N68059040,
    /** # D000076942

Preprint. Scientific manuscript made available prior to PEER REVIEW. */
    D000076942,
    /** # D001877

Book. Non-periodical written or printed works consisting of sheets of pages fastened or bound together within covers. */
    D001877,
    /** # D016420

Comment. Comment */
    D016420,
    /** # D016422

Letter. Letter */
    D016422,
    /** # D016425

Published Erratum. Published Erratum */
    D016425,
    /** # D016428

Journal Article. Journal Article */
    D016428,
    /** # D019991

Database. A structured file of information or a set of logically related data stored and retrieved using computer-based means. */
    D019991,
    /** # D064886

Dataset. Works consisting of organized collections of data, which have been stored permanently in a formalized manner suitable for communication, interpretation, or processing. */
    D064886,
    /** # Electronic

Electronic. the journal is published in electronic format only */
    Electronic,
    /** # Electronic-Print

Electronic-Print. the journal is published first in electronic format followed by print (this value is currently used for just one journal, Nucleic Acids Research) */
    ElectronicPrint,
    /** # Electronic-eCollection

Electronic-eCollection. used for electronic-only journals that publish individual articles first and then later collect them into an "issue" date that is typically called an eCollection. */
    ElectronicECollection,
    /** # Print

Print. the journal is published in print format only */
    Print,
    /** # Print-Electronic

Print Electronic. the journal is published in both print and electronic format */
    PrintElectronic,
    /** # audio

Audio file. The article cited is an audio file. */
    Audio,
    /** # common-share

Common Share. Citation Resource containing value added data that is openly shared */
    CommonShare,
    /** # executable-app

Executable app. Executable app */
    ExecutableApp,
    /** # fhir-resource

FHIR Resource. The article cited is a FHIR resource. */
    FhirResource,
    /** # image

Image file. The article cited is an audio file. */
    Image,
    /** # machine-code

Machine code. The article cited is machine code. */
    MachineCode,
    /** # medline-base

Medline Base. Citation Resource containing only data from Medline */
    MedlineBase,
    /** # project-specific

Project Specific. Citation Resource containing value added data specific to a project */
    ProjectSpecific,
    /** # protocol

Protocol. The article cited is the protocol of an activity and not the results or findings. */
    Protocol,
    /** # webpage

Webpage. Webpage */
    Webpage,
}
impl ::core::str::FromStr for CitationArtifactClassifier {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "68059040" => Ok(Self::N68059040),
            "D000076942" => Ok(Self::D000076942),
            "D001877" => Ok(Self::D001877),
            "D016420" => Ok(Self::D016420),
            "D016422" => Ok(Self::D016422),
            "D016425" => Ok(Self::D016425),
            "D016428" => Ok(Self::D016428),
            "D019991" => Ok(Self::D019991),
            "D064886" => Ok(Self::D064886),
            "Electronic" => Ok(Self::Electronic),
            "Electronic-Print" => Ok(Self::ElectronicPrint),
            "Electronic-eCollection" => Ok(Self::ElectronicECollection),
            "Print" => Ok(Self::Print),
            "Print-Electronic" => Ok(Self::PrintElectronic),
            "audio" => Ok(Self::Audio),
            "common-share" => Ok(Self::CommonShare),
            "executable-app" => Ok(Self::ExecutableApp),
            "fhir-resource" => Ok(Self::FhirResource),
            "image" => Ok(Self::Image),
            "machine-code" => Ok(Self::MachineCode),
            "medline-base" => Ok(Self::MedlineBase),
            "project-specific" => Ok(Self::ProjectSpecific),
            "protocol" => Ok(Self::Protocol),
            "webpage" => Ok(Self::Webpage),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationArtifactClassifier {
    fn as_ref(&self) -> &str {
        match self {
            Self::N68059040 => "68059040",
            Self::D000076942 => "D000076942",
            Self::D001877 => "D001877",
            Self::D016420 => "D016420",
            Self::D016422 => "D016422",
            Self::D016425 => "D016425",
            Self::D016428 => "D016428",
            Self::D019991 => "D019991",
            Self::D064886 => "D064886",
            Self::Electronic => "Electronic",
            Self::ElectronicPrint => "Electronic-Print",
            Self::ElectronicECollection => "Electronic-eCollection",
            Self::Print => "Print",
            Self::PrintElectronic => "Print-Electronic",
            Self::Audio => "audio",
            Self::CommonShare => "common-share",
            Self::ExecutableApp => "executable-app",
            Self::FhirResource => "fhir-resource",
            Self::Image => "image",
            Self::MachineCode => "machine-code",
            Self::MedlineBase => "medline-base",
            Self::ProjectSpecific => "project-specific",
            Self::Protocol => "protocol",
            Self::Webpage => "webpage",
        }
    }
}
impl<'de> Deserialize<'de> for CitationArtifactClassifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationArtifactClassifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CitationClassificationType`. Citation classification type

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitationClassificationType {
    /** # citation-source

Citation Source. Citation repository where this citation was created or copied from */
    CitationSource,
    /** # fevir-platform-use

FEvIR Platform Use. Used for Citation sharing on the Fast Evidence Interoperability Resources (FEvIR) Platform */
    FevirPlatformUse,
    /** # medline-owner

MEDLINE Citation Owner. The party responsible for creating and validating the MEDLINE citation */
    MedlineOwner,
}
impl ::core::str::FromStr for CitationClassificationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "citation-source" => Ok(Self::CitationSource),
            "fevir-platform-use" => Ok(Self::FevirPlatformUse),
            "medline-owner" => Ok(Self::MedlineOwner),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationClassificationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::CitationSource => "citation-source",
            Self::FevirPlatformUse => "fevir-platform-use",
            Self::MedlineOwner => "medline-owner",
        }
    }
}
impl<'de> Deserialize<'de> for CitationClassificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationClassificationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CitationStatusType`. Citation status type

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitationStatusType {
    /** # medline-completed

Medline Citation Status of Completed. Medline Citation Status of Completed */
    MedlineCompleted,
    /** # medline-in-data-review

Medline Citation Status of In-Data-Review. Medline Citation Status of In-Data-Review */
    MedlineInDataReview,
    /** # medline-in-process

Medline Citation Status of In-Process. Medline Citation Status of In-Process */
    MedlineInProcess,
    /** # medline-medline

Medline Citation Status of MEDLINE. Medline Citation Status of MEDLINE */
    MedlineMedline,
    /** # medline-oldmedline

Medline Citation Status of OLDMEDLINE. Medline Citation Status of OLDMEDLINE */
    MedlineOldmedline,
    /** # medline-publisher

Medline Citation Status of Publisher. Medline Citation Status of Publisher */
    MedlinePublisher,
    /** # medline-pubmed-not-medline

Medline Citation Status of PubMed-not-MEDLINE. Medline Citation Status of PubMed-not-MEDLINE */
    MedlinePubmedNotMedline,
    /** # pubmed-publication-status-aheadofprint

PubMed PublicationStatus of aheadofprint. electronically published, but followed by print */
    PubmedPublicationStatusAheadofprint,
    /** # pubmed-publication-status-epublish

PubMed PublicationStatus of epublish. electronically published only, never published in print */
    PubmedPublicationStatusEpublish,
    /** # pubmed-publication-status-ppublish

PubMed PublicationStatus of ppublish. published in print */
    PubmedPublicationStatusPpublish,
    /** # pubmed-pubstatus-accepted

PubMed Pubstatus of Accepted. PubMed Pubstatus of Accepted */
    PubmedPubstatusAccepted,
    /** # pubmed-pubstatus-aheadofprint

PubMed Pubstatus of aheadofprint. PubMed Pubstatus of aheadofprint */
    PubmedPubstatusAheadofprint,
    /** # pubmed-pubstatus-ecollection

PubMed Pubstatus of Ecollection. PubMed Pubstatus of Ecollection */
    PubmedPubstatusEcollection,
    /** # pubmed-pubstatus-entrez

PubMed Pubstatus of Entrez. PubMed Pubstatus of Entrez */
    PubmedPubstatusEntrez,
    /** # pubmed-pubstatus-epublish

PubMed Pubstatus of Epublish. PubMed Pubstatus of Epublish */
    PubmedPubstatusEpublish,
    /** # pubmed-pubstatus-medline

PubMed Pubstatus of Medline. PubMed Pubstatus of Medline */
    PubmedPubstatusMedline,
    /** # pubmed-pubstatus-medliner

PubMed Pubstatus of Medliner. PubMed Pubstatus of Medliner */
    PubmedPubstatusMedliner,
    /** # pubmed-pubstatus-pmc

PubMed Pubstatus of PMC. PubMed Pubstatus of PMC */
    PubmedPubstatusPmc,
    /** # pubmed-pubstatus-pmc-release

PubMed Pubstatus of PMC release. PubMed Pubstatus of PMC release */
    PubmedPubstatusPmcRelease,
    /** # pubmed-pubstatus-pmcr

PubMed Pubstatus of PMCr. PubMed Pubstatus of PMCr */
    PubmedPubstatusPmcr,
    /** # pubmed-pubstatus-ppublish

PubMed Pubstatus of Ppublish. PubMed Pubstatus of Ppublish */
    PubmedPubstatusPpublish,
    /** # pubmed-pubstatus-premedline

PubMed Pubstatus of Premedline. PubMed Pubstatus of Premedline */
    PubmedPubstatusPremedline,
    /** # pubmed-pubstatus-pubmed

PubMed Pubstatus of PubMed. PubMed Pubstatus of PubMed */
    PubmedPubstatusPubmed,
    /** # pubmed-pubstatus-pubmedr

PubMed Pubstatus of PubMedr. PubMed Pubstatus of PubMedr */
    PubmedPubstatusPubmedr,
    /** # pubmed-pubstatus-received

PubMed Pubstatus of Received. PubMed Pubstatus of Received */
    PubmedPubstatusReceived,
    /** # pubmed-pubstatus-retracted

PubMed Pubstatus of Retracted. PubMed Pubstatus of Retracted */
    PubmedPubstatusRetracted,
    /** # pubmed-pubstatus-revised

PubMed Pubstatus of Revised. PubMed Pubstatus of Revised */
    PubmedPubstatusRevised,
}
impl ::core::str::FromStr for CitationStatusType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "medline-completed" => Ok(Self::MedlineCompleted),
            "medline-in-data-review" => Ok(Self::MedlineInDataReview),
            "medline-in-process" => Ok(Self::MedlineInProcess),
            "medline-medline" => Ok(Self::MedlineMedline),
            "medline-oldmedline" => Ok(Self::MedlineOldmedline),
            "medline-publisher" => Ok(Self::MedlinePublisher),
            "medline-pubmed-not-medline" => Ok(Self::MedlinePubmedNotMedline),
            "pubmed-publication-status-aheadofprint" => {
                Ok(Self::PubmedPublicationStatusAheadofprint)
            }
            "pubmed-publication-status-epublish" => {
                Ok(Self::PubmedPublicationStatusEpublish)
            }
            "pubmed-publication-status-ppublish" => {
                Ok(Self::PubmedPublicationStatusPpublish)
            }
            "pubmed-pubstatus-accepted" => Ok(Self::PubmedPubstatusAccepted),
            "pubmed-pubstatus-aheadofprint" => Ok(Self::PubmedPubstatusAheadofprint),
            "pubmed-pubstatus-ecollection" => Ok(Self::PubmedPubstatusEcollection),
            "pubmed-pubstatus-entrez" => Ok(Self::PubmedPubstatusEntrez),
            "pubmed-pubstatus-epublish" => Ok(Self::PubmedPubstatusEpublish),
            "pubmed-pubstatus-medline" => Ok(Self::PubmedPubstatusMedline),
            "pubmed-pubstatus-medliner" => Ok(Self::PubmedPubstatusMedliner),
            "pubmed-pubstatus-pmc" => Ok(Self::PubmedPubstatusPmc),
            "pubmed-pubstatus-pmc-release" => Ok(Self::PubmedPubstatusPmcRelease),
            "pubmed-pubstatus-pmcr" => Ok(Self::PubmedPubstatusPmcr),
            "pubmed-pubstatus-ppublish" => Ok(Self::PubmedPubstatusPpublish),
            "pubmed-pubstatus-premedline" => Ok(Self::PubmedPubstatusPremedline),
            "pubmed-pubstatus-pubmed" => Ok(Self::PubmedPubstatusPubmed),
            "pubmed-pubstatus-pubmedr" => Ok(Self::PubmedPubstatusPubmedr),
            "pubmed-pubstatus-received" => Ok(Self::PubmedPubstatusReceived),
            "pubmed-pubstatus-retracted" => Ok(Self::PubmedPubstatusRetracted),
            "pubmed-pubstatus-revised" => Ok(Self::PubmedPubstatusRevised),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationStatusType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MedlineCompleted => "medline-completed",
            Self::MedlineInDataReview => "medline-in-data-review",
            Self::MedlineInProcess => "medline-in-process",
            Self::MedlineMedline => "medline-medline",
            Self::MedlineOldmedline => "medline-oldmedline",
            Self::MedlinePublisher => "medline-publisher",
            Self::MedlinePubmedNotMedline => "medline-pubmed-not-medline",
            Self::PubmedPublicationStatusAheadofprint => {
                "pubmed-publication-status-aheadofprint"
            }
            Self::PubmedPublicationStatusEpublish => "pubmed-publication-status-epublish",
            Self::PubmedPublicationStatusPpublish => "pubmed-publication-status-ppublish",
            Self::PubmedPubstatusAccepted => "pubmed-pubstatus-accepted",
            Self::PubmedPubstatusAheadofprint => "pubmed-pubstatus-aheadofprint",
            Self::PubmedPubstatusEcollection => "pubmed-pubstatus-ecollection",
            Self::PubmedPubstatusEntrez => "pubmed-pubstatus-entrez",
            Self::PubmedPubstatusEpublish => "pubmed-pubstatus-epublish",
            Self::PubmedPubstatusMedline => "pubmed-pubstatus-medline",
            Self::PubmedPubstatusMedliner => "pubmed-pubstatus-medliner",
            Self::PubmedPubstatusPmc => "pubmed-pubstatus-pmc",
            Self::PubmedPubstatusPmcRelease => "pubmed-pubstatus-pmc-release",
            Self::PubmedPubstatusPmcr => "pubmed-pubstatus-pmcr",
            Self::PubmedPubstatusPpublish => "pubmed-pubstatus-ppublish",
            Self::PubmedPubstatusPremedline => "pubmed-pubstatus-premedline",
            Self::PubmedPubstatusPubmed => "pubmed-pubstatus-pubmed",
            Self::PubmedPubstatusPubmedr => "pubmed-pubstatus-pubmedr",
            Self::PubmedPubstatusReceived => "pubmed-pubstatus-received",
            Self::PubmedPubstatusRetracted => "pubmed-pubstatus-retracted",
            Self::PubmedPubstatusRevised => "pubmed-pubstatus-revised",
        }
    }
}
impl<'de> Deserialize<'de> for CitationStatusType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationStatusType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CitationSummaryStyle`. The format for display of the citation.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitationSummaryStyle {
    /** # acs

American Chemical Society. Chemistry. */
    Acs,
    /** # ama11

American Medical Association 11th edition. Medicine. */
    Ama11,
    /** # apa6

American Psychological Association 6th edition. APA 6th edition used by Education, Psychology and Sciences. */
    Apa6,
    /** # apa7

American Psychological Association 7th edition. APA 7th edition (October 2019) used by Education, Psychology and Sciences. */
    Apa7,
    /** # asa6

American Sociological Association 6th edition. Sociology. */
    Asa6,
    /** # chicago-a-17

Chicago Style Version 17 Author Date. Used by Business, History and the Fine Arts. */
    ChicagoA17,
    /** # chicago-b-17

Chicago Style Version 17 Full note. Used by Business, History and the Fine Arts. */
    ChicagoB17,
    /** # cochrane

Cochrane Style. Used by Cochrane reviews, example: Huang, M, Tang T, Pang, P, Li, M, Ma R, Lu, J, et al. Treating COVID-19 with Chloroquine. J Mol Cell Biol 2020; 12(4):322–5. */
    Cochrane,
    /** # comppub

Computable Publishing. Citation style to report human-readable and/or machine-readable access paths, example: Alper BS, Dehnbostel J, Shahin K. 14-day mortality remdesivir vs placebo meta-analysis (ACTT-1, Wang et al, WHO SOLIDARITY).  Fast Evidence Interoperability Resources (FEvIR) Platform, entry 55, version 4. Created 2020 Dec 17. Revised 2020 Dec 21. Accessed 2021 Mar 13. Computable resource at: https://fevir.net/resources/Evidence/55. */
    Comppub,
    /** # elsevier-harvard

Elsevier-Harvard Style. Biology ecology. */
    ElsevierHarvard,
    /** # ieee

Institute of Electrical and Electronics Engineers. IT, Engineering. */
    Ieee,
    /** # mla8

Modern Language Association 8th edition. MLA 8th edition used by the Humanities. */
    Mla8,
    /** # nature

Nature Referencing style. Biology. */
    Nature,
    /** # vancouver

Vancouver style. Citation style used by International Committee of Medical Journal Editors and maintained by US National Library of Medicine. */
    Vancouver,
}
impl ::core::str::FromStr for CitationSummaryStyle {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acs" => Ok(Self::Acs),
            "ama11" => Ok(Self::Ama11),
            "apa6" => Ok(Self::Apa6),
            "apa7" => Ok(Self::Apa7),
            "asa6" => Ok(Self::Asa6),
            "chicago-a-17" => Ok(Self::ChicagoA17),
            "chicago-b-17" => Ok(Self::ChicagoB17),
            "cochrane" => Ok(Self::Cochrane),
            "comppub" => Ok(Self::Comppub),
            "elsevier-harvard" => Ok(Self::ElsevierHarvard),
            "ieee" => Ok(Self::Ieee),
            "mla8" => Ok(Self::Mla8),
            "nature" => Ok(Self::Nature),
            "vancouver" => Ok(Self::Vancouver),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitationSummaryStyle {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acs => "acs",
            Self::Ama11 => "ama11",
            Self::Apa6 => "apa6",
            Self::Apa7 => "apa7",
            Self::Asa6 => "asa6",
            Self::ChicagoA17 => "chicago-a-17",
            Self::ChicagoB17 => "chicago-b-17",
            Self::Cochrane => "cochrane",
            Self::Comppub => "comppub",
            Self::ElsevierHarvard => "elsevier-harvard",
            Self::Ieee => "ieee",
            Self::Mla8 => "mla8",
            Self::Nature => "nature",
            Self::Vancouver => "vancouver",
        }
    }
}
impl<'de> Deserialize<'de> for CitationSummaryStyle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitationSummaryStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CitedArtifactAbstractType`. Used to express the reason and specific aspect for the variant abstract, such as language and specific language

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedArtifactAbstractType {
    /** # autotranslated

Different language derived from autotranslation. Machine translated form of abstract in a different language, language element codes the language into which it was translated by machine */
    Autotranslated,
    /** # different-publisher

Different publisher for abstract. Abstract produced by a different publisher than the cited artifact */
    DifferentPublisher,
    /** # duplicate-pmid

Different text in additional Medline entry. Alternative form of abstract in two or more Medline entries */
    DuplicatePmid,
    /** # earlier-abstract

Different text in an earlier version. Alternative form of abstract in an earlier version such as epub ahead of print */
    EarlierAbstract,
    /** # language

Different language. Additional form of abstract in a different language */
    Language,
    /** # long-abstract

Long abstract. Long version of the abstract, for use when abstracts are provided in different sizes or lengths */
    LongAbstract,
    /** # plain-language

Plain language. Additional form of abstract written for the general public */
    PlainLanguage,
    /** # primary-human-use

Primary human use. Human-friendly main or official abstract */
    PrimaryHumanUse,
    /** # primary-machine-use

Primary machine use. Machine-friendly main or official abstract */
    PrimaryMachineUse,
    /** # short-abstract

Short abstract. Brief abstract, for use when abstracts are provided in different sizes or lengths */
    ShortAbstract,
    /** # truncated

Truncated. Truncated abstract */
    Truncated,
}
impl ::core::str::FromStr for CitedArtifactAbstractType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "autotranslated" => Ok(Self::Autotranslated),
            "different-publisher" => Ok(Self::DifferentPublisher),
            "duplicate-pmid" => Ok(Self::DuplicatePmid),
            "earlier-abstract" => Ok(Self::EarlierAbstract),
            "language" => Ok(Self::Language),
            "long-abstract" => Ok(Self::LongAbstract),
            "plain-language" => Ok(Self::PlainLanguage),
            "primary-human-use" => Ok(Self::PrimaryHumanUse),
            "primary-machine-use" => Ok(Self::PrimaryMachineUse),
            "short-abstract" => Ok(Self::ShortAbstract),
            "truncated" => Ok(Self::Truncated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactAbstractType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Autotranslated => "autotranslated",
            Self::DifferentPublisher => "different-publisher",
            Self::DuplicatePmid => "duplicate-pmid",
            Self::EarlierAbstract => "earlier-abstract",
            Self::Language => "language",
            Self::LongAbstract => "long-abstract",
            Self::PlainLanguage => "plain-language",
            Self::PrimaryHumanUse => "primary-human-use",
            Self::PrimaryMachineUse => "primary-machine-use",
            Self::ShortAbstract => "short-abstract",
            Self::Truncated => "truncated",
        }
    }
}
impl<'de> Deserialize<'de> for CitedArtifactAbstractType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactAbstractType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CitedArtifactClassificationType`. Cited Artifact Classification Type

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedArtifactClassificationType {
    /** # chemical

Chemical. Chemical */
    Chemical,
    /** # citation-subset

Citation subset. Citation subset */
    CitationSubset,
    /** # coverage

Coverage. The spatial or temporal topic of the resource, spatial applicability of the resource, or jurisdiction under which the resource is relevant */
    Coverage,
    /** # keyword

Keyword. Keyword */
    Keyword,
    /** # knowledge-artifact-type

Knowledge Artifact Type. Knowledge Artifact Type */
    KnowledgeArtifactType,
    /** # mesh-heading

MeSH heading. MeSH heading */
    MeshHeading,
    /** # publication-type

Publication type. Publication type */
    PublicationType,
    /** # publishing-model

Publishing Model. Used for PubModel attribute in Medline */
    PublishingModel,
    /** # supplemental-mesh-disease

Supplemental MeSH for Disease. Supplemental MeSH for Disease */
    SupplementalMeshDisease,
    /** # supplemental-mesh-organism

Supplemental MeSH for Organism. Supplemental MeSH for Organism */
    SupplementalMeshOrganism,
    /** # supplemental-mesh-protocol

Supplemental MeSH for Protocol. Supplemental MeSH for Protocol */
    SupplementalMeshProtocol,
}
impl ::core::str::FromStr for CitedArtifactClassificationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "chemical" => Ok(Self::Chemical),
            "citation-subset" => Ok(Self::CitationSubset),
            "coverage" => Ok(Self::Coverage),
            "keyword" => Ok(Self::Keyword),
            "knowledge-artifact-type" => Ok(Self::KnowledgeArtifactType),
            "mesh-heading" => Ok(Self::MeshHeading),
            "publication-type" => Ok(Self::PublicationType),
            "publishing-model" => Ok(Self::PublishingModel),
            "supplemental-mesh-disease" => Ok(Self::SupplementalMeshDisease),
            "supplemental-mesh-organism" => Ok(Self::SupplementalMeshOrganism),
            "supplemental-mesh-protocol" => Ok(Self::SupplementalMeshProtocol),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactClassificationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Chemical => "chemical",
            Self::CitationSubset => "citation-subset",
            Self::Coverage => "coverage",
            Self::Keyword => "keyword",
            Self::KnowledgeArtifactType => "knowledge-artifact-type",
            Self::MeshHeading => "mesh-heading",
            Self::PublicationType => "publication-type",
            Self::PublishingModel => "publishing-model",
            Self::SupplementalMeshDisease => "supplemental-mesh-disease",
            Self::SupplementalMeshOrganism => "supplemental-mesh-organism",
            Self::SupplementalMeshProtocol => "supplemental-mesh-protocol",
        }
    }
}
impl<'de> Deserialize<'de> for CitedArtifactClassificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactClassificationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CitedArtifactPartType`. To describe the reason for the variant citation, such as version number or subpart specification.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedArtifactPartType {
    /** # article-set

Part of an article set. Used to distinguish an individual article within an article set where the article set is a base citation. */
    ArticleSet,
    /** # figures

figures. Denotes specific figure or figures of an article or artifact. */
    Figures,
    /** # lines

lines. Denotes specific line or lines of an article or artifact. */
    Lines,
    /** # pages

pages. Denotes specific page or pages of an article or artifact. */
    Pages,
    /** # paragraphs

paragraphs. Denotes specific paragraph or paragraphs of an article or artifact. */
    Paragraphs,
    /** # sections

sections. Denotes specific section or sections of an article or artifact. */
    Sections,
    /** # supplement

Supplement or Appendix. Used to denote a supplementary file, appendix, or additional part that is not a subpart of the primary article. */
    Supplement,
    /** # supplement-subpart

Supplement or Appendix Subpart. Used to denote a subpart within a supplementary file or appendix. */
    SupplementSubpart,
    /** # tables

tables. Denotes specific table or tables of an article or artifact. */
    Tables,
}
impl ::core::str::FromStr for CitedArtifactPartType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "article-set" => Ok(Self::ArticleSet),
            "figures" => Ok(Self::Figures),
            "lines" => Ok(Self::Lines),
            "pages" => Ok(Self::Pages),
            "paragraphs" => Ok(Self::Paragraphs),
            "sections" => Ok(Self::Sections),
            "supplement" => Ok(Self::Supplement),
            "supplement-subpart" => Ok(Self::SupplementSubpart),
            "tables" => Ok(Self::Tables),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactPartType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ArticleSet => "article-set",
            Self::Figures => "figures",
            Self::Lines => "lines",
            Self::Pages => "pages",
            Self::Paragraphs => "paragraphs",
            Self::Sections => "sections",
            Self::Supplement => "supplement",
            Self::SupplementSubpart => "supplement-subpart",
            Self::Tables => "tables",
        }
    }
}
impl<'de> Deserialize<'de> for CitedArtifactPartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactPartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CitedArtifactStatusType`. Cited Artifact Status Type

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedArtifactStatusType {
    /** # accepted

Accepted. The content that was not published yet has been approved for publication by the publisher and/or editor. */
    Accepted,
    /** # active

Active. The content is considered complete for its current state by the content creator. */
    Active,
    /** # approved

Approved. The content has been approved for a state transition, with the focus of approval described in the text associated with this coding. */
    Approved,
    /** # archived

Archived. The content is retired or considered no longer current but still available as part of the public record. */
    Archived,
    /** # created

Created. The content was originally constructed or composed. */
    Created,
    /** # draft

Draft. The content is considered unfinished or incomplete and not representative of the current state desired by the content creator. */
    Draft,
    /** # post-review-pre-published

Post review pre published. The content is in a state between the review(s) being completed and being published. */
    PostReviewPrePublished,
    /** # pre-review

Pre review. The content is awaiting assignment and delivery to reviewer(s). */
    PreReview,
    /** # published-early-form

Published early form. The content is published but future changes to the published version are expected. */
    PublishedEarlyForm,
    /** # published-final-form

Published final form. The content is published and further changes to the content are not expected. */
    PublishedFinalForm,
    /** # rejected

Rejected. The content that was not published has been removed from consideration for publishing by a publisher or editor. */
    Rejected,
    /** # retracted

Retracted. The content that was published is removed from publication and should no longer be considered part of the public record. */
    Retracted,
    /** # submitted

Submitted. The content was sent to the publisher for consideration of publication. */
    Submitted,
    /** # under-review

Under review. The content is in a state of being reviewed. */
    UnderReview,
    /** # withdrawn

Withdrawn. The content that was not published has been removed from consideration for publishing by the submitter. */
    Withdrawn,
}
impl ::core::str::FromStr for CitedArtifactStatusType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "active" => Ok(Self::Active),
            "approved" => Ok(Self::Approved),
            "archived" => Ok(Self::Archived),
            "created" => Ok(Self::Created),
            "draft" => Ok(Self::Draft),
            "post-review-pre-published" => Ok(Self::PostReviewPrePublished),
            "pre-review" => Ok(Self::PreReview),
            "published-early-form" => Ok(Self::PublishedEarlyForm),
            "published-final-form" => Ok(Self::PublishedFinalForm),
            "rejected" => Ok(Self::Rejected),
            "retracted" => Ok(Self::Retracted),
            "submitted" => Ok(Self::Submitted),
            "under-review" => Ok(Self::UnderReview),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedArtifactStatusType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Active => "active",
            Self::Approved => "approved",
            Self::Archived => "archived",
            Self::Created => "created",
            Self::Draft => "draft",
            Self::PostReviewPrePublished => "post-review-pre-published",
            Self::PreReview => "pre-review",
            Self::PublishedEarlyForm => "published-early-form",
            Self::PublishedFinalForm => "published-final-form",
            Self::Rejected => "rejected",
            Self::Retracted => "retracted",
            Self::Submitted => "submitted",
            Self::UnderReview => "under-review",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl<'de> Deserialize<'de> for CitedArtifactStatusType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedArtifactStatusType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CitedMedium`. NLM codes Internet or Print.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CitedMedium {
    /** # internet

Internet. Online publication in a periodic release. Used to match NLM JournalIssue CitedMedium code for online version. */
    Internet,
    /** # internet-without-issue

Internet without issue. Online publication without any periodic release. Used for article specific publication date which could be the same as or different from journal issue publication date. */
    InternetWithoutIssue,
    /** # offline-digital-storage

Offline Digital Storage. Publication in a physical device for electronic data storage, organized in issues for periodic release. */
    OfflineDigitalStorage,
    /** # offline-digital-storage-without-issue

Offline Digital Storage without issue. Publication in a physical device for electronic data storage, without any periodic release. */
    OfflineDigitalStorageWithoutIssue,
    /** # print

Print. Print publication in a periodic release. Used to match NLM JournalIssue CitedMedium code for print version. */
    Print,
    /** # print-without-issue

Print without issue. Print publication without any periodic release. */
    PrintWithoutIssue,
}
impl ::core::str::FromStr for CitedMedium {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "internet" => Ok(Self::Internet),
            "internet-without-issue" => Ok(Self::InternetWithoutIssue),
            "offline-digital-storage" => Ok(Self::OfflineDigitalStorage),
            "offline-digital-storage-without-issue" => {
                Ok(Self::OfflineDigitalStorageWithoutIssue)
            }
            "print" => Ok(Self::Print),
            "print-without-issue" => Ok(Self::PrintWithoutIssue),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CitedMedium {
    fn as_ref(&self) -> &str {
        match self {
            Self::Internet => "internet",
            Self::InternetWithoutIssue => "internet-without-issue",
            Self::OfflineDigitalStorage => "offline-digital-storage",
            Self::OfflineDigitalStorageWithoutIssue => {
                "offline-digital-storage-without-issue"
            }
            Self::Print => "print",
            Self::PrintWithoutIssue => "print-without-issue",
        }
    }
}
impl<'de> Deserialize<'de> for CitedMedium {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CitedMedium {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ClaimCareTeamRoleCodes`. This value set includes sample Claim Care Team Role codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClaimCareTeamRoleCodes {
    /** # assist

Assisting Provider. Assisting care provider. */
    Assist,
    /** # other

Other. Other role on the care team. */
    Other,
    /** # primary

Primary provider. The primary care provider. */
    Primary,
    /** # supervisor

Supervising Provider. Supervising care provider. */
    Supervisor,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ClaimCareTeamRoleCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assist" => Ok(Self::Assist),
            "other" => Ok(Self::Other),
            "primary" => Ok(Self::Primary),
            "supervisor" => Ok(Self::Supervisor),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ClaimCareTeamRoleCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assist => "assist",
            Self::Other => "other",
            Self::Primary => "primary",
            Self::Supervisor => "supervisor",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ClaimCareTeamRoleCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimCareTeamRoleCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ClaimInformationCategoryCodes`. This value set includes sample Information Category codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClaimInformationCategoryCodes {
    /** # attachment

Attachment. Materials attached such as images, documents and resources. */
    Attachment,
    /** # discharge

Discharge. Discharge status and discharge to locations. */
    Discharge,
    /** # employmentimpacted

EmploymentImpacted. An indication that the patient was unable to work, the period if known otherwise a Yes/No (boolean). */
    Employmentimpacted,
    /** # exception

Exception. Insurance policy exceptions. */
    Exception,
    /** # externalcause

External Caause. The external cause of an illness or injury. */
    Externalcause,
    /** # hospitalized

Hospitalized. An indication that the patient was hospitalized, the period if known otherwise a Yes/No (boolean). */
    Hospitalized,
    /** # info

Information. Codes conveying additional situation and condition information. */
    Info,
    /** # material

Materials Forwarded. Materials being forwarded, e.g. Models, molds, images, documents. */
    Material,
    /** # missingtooth

Missing Tooth. Teeth which are missing for any reason, for example: prior extraction, never developed. */
    Missingtooth,
    /** # onset

Onset. Period, start or end dates of aspects of the Condition. */
    Onset,
    /** # other

Other. Other information identified by the type.system. */
    Other,
    /** # patientreasonforvisit

Patient Reason for Visit. The reason for the patient visit. */
    Patientreasonforvisit,
    /** # prosthesis

Prosthesis. The type of prosthesis and date of supply if a previously supplied prosthesis. */
    Prosthesis,
    /** # related

Related Services. Nature and date of the related event e.g. Last exam, service, X-ray etc. */
    Related,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ClaimInformationCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "attachment" => Ok(Self::Attachment),
            "discharge" => Ok(Self::Discharge),
            "employmentimpacted" => Ok(Self::Employmentimpacted),
            "exception" => Ok(Self::Exception),
            "externalcause" => Ok(Self::Externalcause),
            "hospitalized" => Ok(Self::Hospitalized),
            "info" => Ok(Self::Info),
            "material" => Ok(Self::Material),
            "missingtooth" => Ok(Self::Missingtooth),
            "onset" => Ok(Self::Onset),
            "other" => Ok(Self::Other),
            "patientreasonforvisit" => Ok(Self::Patientreasonforvisit),
            "prosthesis" => Ok(Self::Prosthesis),
            "related" => Ok(Self::Related),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ClaimInformationCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attachment => "attachment",
            Self::Discharge => "discharge",
            Self::Employmentimpacted => "employmentimpacted",
            Self::Exception => "exception",
            Self::Externalcause => "externalcause",
            Self::Hospitalized => "hospitalized",
            Self::Info => "info",
            Self::Material => "material",
            Self::Missingtooth => "missingtooth",
            Self::Onset => "onset",
            Self::Other => "other",
            Self::Patientreasonforvisit => "patientreasonforvisit",
            Self::Prosthesis => "prosthesis",
            Self::Related => "related",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ClaimInformationCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimInformationCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ClaimTypeCodes`. This value set includes Claim Type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClaimTypeCodes {
    /** # institutional

Institutional. Hospital, clinic and typically inpatient claims. */
    Institutional,
    /** # oral

Oral. Dental, Denture and Hygiene claims. */
    Oral,
    /** # pharmacy

Pharmacy. Pharmacy claims for goods and services. */
    Pharmacy,
    /** # professional

Professional. Typically, outpatient claims from Physician, Psychological, Chiropractor, Physiotherapy, Speech Pathology, rehabilitative, consulting. */
    Professional,
    /** # vision

Vision. Vision claims for professional services and products such as glasses and contact lenses. */
    Vision,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ClaimTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "institutional" => Ok(Self::Institutional),
            "oral" => Ok(Self::Oral),
            "pharmacy" => Ok(Self::Pharmacy),
            "professional" => Ok(Self::Professional),
            "vision" => Ok(Self::Vision),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ClaimTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Institutional => "institutional",
            Self::Oral => "oral",
            Self::Pharmacy => "pharmacy",
            Self::Professional => "professional",
            Self::Vision => "vision",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ClaimTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClaimTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ClinicalUseDefinitionCategory`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ClinicalUseDefinitionCategory {
    /** # DriveAndMachines

Effects on Ability to Drive and Use Machines. */
    DriveAndMachines,
    /** # Overdose

Overdose. */
    Overdose,
    /** # Pregnancy

Pregnancy and Lactation. */
    Pregnancy,
}
impl ::core::str::FromStr for ClinicalUseDefinitionCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "DriveAndMachines" => Ok(Self::DriveAndMachines),
            "Overdose" => Ok(Self::Overdose),
            "Pregnancy" => Ok(Self::Pregnancy),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClinicalUseDefinitionCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::DriveAndMachines => "DriveAndMachines",
            Self::Overdose => "Overdose",
            Self::Pregnancy => "Pregnancy",
        }
    }
}
impl<'de> Deserialize<'de> for ClinicalUseDefinitionCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClinicalUseDefinitionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ClinicalUseDefinitionType`. Overall defining type of this clinical use definition.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ClinicalUseDefinitionType {
    /** # contraindication

Contraindication. A reason for not giving the medication. */
    Contraindication,
    /** # indication

Indication. A reason for giving the medication. */
    Indication,
    /** # interaction

Interaction. Interactions between the medication and other substances. */
    Interaction,
    /** # undesirable-effect

Undesirable Effect. Side effects or adverse effects associated with the medication. */
    UndesirableEffect,
    /** # warning

Warning. A general warning or issue that is not specifically one of the other types. */
    Warning,
}
impl ::core::str::FromStr for ClinicalUseDefinitionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contraindication" => Ok(Self::Contraindication),
            "indication" => Ok(Self::Indication),
            "interaction" => Ok(Self::Interaction),
            "undesirable-effect" => Ok(Self::UndesirableEffect),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ClinicalUseDefinitionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contraindication => "contraindication",
            Self::Indication => "indication",
            Self::Interaction => "interaction",
            Self::UndesirableEffect => "undesirable-effect",
            Self::Warning => "warning",
        }
    }
}
impl<'de> Deserialize<'de> for ClinicalUseDefinitionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ClinicalUseDefinitionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CodeSearchSupport`. The degree to which the server supports the code search parameter on ValueSet, if it is supported.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CodeSearchSupport {
    /** # all

Implicit Codes. The search for code on ValueSet only includes all codes based on the expansion of the value set. */
    All,
    /** # explicit

Explicit Codes. The search for code on ValueSet only includes codes explicitly detailed on includes or expansions. */
    Explicit,
}
impl ::core::str::FromStr for CodeSearchSupport {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "explicit" => Ok(Self::Explicit),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSearchSupport {
    fn as_ref(&self) -> &str {
        match self {
            Self::All => "all",
            Self::Explicit => "explicit",
        }
    }
}
impl<'de> Deserialize<'de> for CodeSearchSupport {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSearchSupport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CodeSystemContentMode`. The extent of the content of the code system (the concepts and codes it defines) are represented in a code system resource.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CodeSystemContentMode {
    /** # complete

Complete. All the concepts defined by the code system are included in the code system resource. */
    Complete,
    /** # example

Example. A few representative concepts are included in the code system resource. There is no useful intent in the subset choice and there's no process to make it workable: it's not intended to be workable. */
    Example,
    /** # fragment

Fragment. A subset of the code system concepts are included in the code system resource. This is a curated subset released for a specific purpose under the governance of the code system steward, and that the intent, bounds and consequences of the fragmentation are clearly defined in the fragment or the code system documentation. Fragments are also known as partitions. */
    Fragment,
    /** # not-present

Not Present. None of the concepts defined by the code system are included in the code system resource. */
    NotPresent,
    /** # supplement

Supplement. The resource doesn't define any new concepts; it just provides additional designations and properties to another code system. */
    Supplement,
}
impl ::core::str::FromStr for CodeSystemContentMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "example" => Ok(Self::Example),
            "fragment" => Ok(Self::Fragment),
            "not-present" => Ok(Self::NotPresent),
            "supplement" => Ok(Self::Supplement),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSystemContentMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Example => "example",
            Self::Fragment => "fragment",
            Self::NotPresent => "not-present",
            Self::Supplement => "supplement",
        }
    }
}
impl<'de> Deserialize<'de> for CodeSystemContentMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSystemContentMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CodeSystemHierarchyMeaning`. The meaning of the hierarchy of concepts in a code system.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CodeSystemHierarchyMeaning {
    /** # classified-with

Classified With. Child concepts in the hierarchy may have only one parent, and there is a presumption that the code system is a "closed world" meaning all things must be in the hierarchy. This results in concepts such as "not otherwise classified.". */
    ClassifiedWith,
    /** # grouped-by

Grouped By. No particular relationship between the concepts can be assumed, except what can be determined by inspection of the definitions of the elements (possible reasons to use this: importing from a source where this is not defined, or where various parts of the hierarchy have different meanings). */
    GroupedBy,
    /** # is-a

Is-A. A hierarchy where the child concepts have an IS-A relationship with the parents - that is, all the properties of the parent are also true for its child concepts. Not that is-a is a property of the concepts, so additional subsumption relationships may be defined using properties or the [subsumes](extension-codesystem-subsumes.html) extension. */
    IsA,
    /** # part-of

Part Of. Child elements list the individual parts of a composite whole (e.g. body site). */
    PartOf,
}
impl ::core::str::FromStr for CodeSystemHierarchyMeaning {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "classified-with" => Ok(Self::ClassifiedWith),
            "grouped-by" => Ok(Self::GroupedBy),
            "is-a" => Ok(Self::IsA),
            "part-of" => Ok(Self::PartOf),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CodeSystemHierarchyMeaning {
    fn as_ref(&self) -> &str {
        match self {
            Self::ClassifiedWith => "classified-with",
            Self::GroupedBy => "grouped-by",
            Self::IsA => "is-a",
            Self::PartOf => "part-of",
        }
    }
}
impl<'de> Deserialize<'de> for CodeSystemHierarchyMeaning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CodeSystemHierarchyMeaning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CombinedDoseForm`. Dose forms for a product as a whole, considering all individual parts, but before any mixing

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CombinedDoseForm {
    /** # 100000073366

Powder and solvent for oral solution. */
    N100000073366,
    /** # 100000073651

Powder and solvent for oral suspension. */
    N100000073651,
    /** # 100000073774

Eye drops, powder and solvent for solution. */
    N100000073774,
    /** # 100000073781

Eye drops, powder and solvent for suspension. */
    N100000073781,
    /** # 100000073801

Ear drops, powder and solvent for suspension. */
    N100000073801,
    /** # 100000073860

Powder and solvent for solution for infusion. */
    N100000073860,
    /** # 100000073868

Powder and solvent for solution for injection. */
    N100000073868,
    /** # 100000073869

Powder and solvent for suspension for injection. */
    N100000073869,
    /** # 100000073884

Powder and solvent for implantation paste. */
    N100000073884,
    /** # 100000073891

Endotracheopulmonary instillation, powder and solvent for solution. */
    N100000073891,
    /** # 100000073892

Powder and solvent for endocervical gel. */
    N100000073892,
    /** # 100000073941

Powder and solvent for sealant. */
    N100000073941,
    /** # 100000073972

Concentrate and solvent for concentrate for solution for infusion. */
    N100000073972,
    /** # 100000073973

Concentrate and solvent for cutaneous use. */
    N100000073973,
    /** # 100000073974

Concentrate and solvent for injection. */
    N100000073974,
    /** # 100000073975

Concentrate and solvent for solution for infusion. */
    N100000073975,
    /** # 100000073987

Concentrate and diluent for solution for infusion. */
    N100000073987,
    /** # 100000073988

Concentrate and solvent for cutaneous solution. */
    N100000073988,
    /** # 100000073989

Concentrate and solvent for solution for injection. */
    N100000073989,
    /** # 100000073990

Concentrate and solvent for suspension for injection. */
    N100000073990,
    /** # 100000073999

Granules and solvent for suspension for injection. */
    N100000073999,
    /** # 100000074015

Powder and solvent for concentrate for solution for infusion. */
    N100000074015,
    /** # 100000074016

Powder and solvent for cutaneous solution. */
    N100000074016,
    /** # 100000074017

Powder and solvent for gingival gel. */
    N100000074017,
    /** # 100000074018

Powder and solvent for prolonged-release suspension for injection. */
    N100000074018,
    /** # 100000074030

Powder and solvent for endosinusial solution. */
    N100000074030,
    /** # 100000074031

Powder and solvent for intraocular instillation solution. */
    N100000074031,
    /** # 100000074032

Powder and suspension for suspension for injection. */
    N100000074032,
    /** # 100000074048

Suspension and effervescent granules for oral suspension. */
    N100000074048,
    /** # 100000074051

Tablet and solvent for rectal suspension. */
    N100000074051,
    /** # 100000074053

Powder and solvent for dental gel. */
    N100000074053,
    /** # 100000074056

Gas and solvent for dispersion for injection/infusion. */
    N100000074056,
    /** # 100000074057

Powder and solvent for solution for injection/infusion. */
    N100000074057,
    /** # 100000074061

Suspension and solution for spray. */
    N100000074061,
    /** # 100000074064

Tablet and powder for oral solution. */
    N100000074064,
    /** # 100000075580

Emulsion and suspension for emulsion for injection. */
    N100000075580,
    /** # 100000075584

Powder and solvent for dispersion for injection. */
    N100000075584,
    /** # 100000075587

Powder for mouth wash. */
    N100000075587,
    /** # 100000116137

Lyophilisate and solvent for solution for injection. */
    N100000116137,
    /** # 100000116141

Fibrin sealant-powder and solvent for fibrin sealant. */
    N100000116141,
    /** # 100000116155

Granules and solvent for oral suspension. */
    N100000116155,
    /** # 100000116160

Lyophilisate and solvent for suspension for injection. */
    N100000116160,
    /** # 100000116172

Powder and gel for gel. */
    N100000116172,
    /** # 100000116173

Powder and solution for solution for injection. */
    N100000116173,
    /** # 100000116174

Powder and solvent for epilesional solution. */
    N100000116174,
    /** # 100000116175

Powder and solvent for intravesical solution. */
    N100000116175,
    /** # 100000116176

Powder and solvent for intravesical suspension. */
    N100000116176,
    /** # 100000116177

Powder and solvent for nebuliser solution. */
    N100000116177,
    /** # 100000116179

Powder, dispersion and solvent for concentrate for dispersion for infusion. */
    N100000116179,
    /** # 100000125746

Powder and solvent for emulsion for injection. */
    N100000125746,
    /** # 100000125747

Nasal drops, powder and solvent for solution. */
    N100000125747,
    /** # 100000125777

Suspension and solvent for suspension for injection. */
    N100000125777,
    /** # 100000136318

Concentrate and solvent for solution for injection/infusion. */
    N100000136318,
    /** # 100000136325

Powder and solvent for solution for injection/skin-prick test. */
    N100000136325,
    /** # 100000136558

Lyophilisate and solvent for suspension for nasal administration. */
    N100000136558,
    /** # 100000136560

Powder and solvent for solution for sealant. */
    N100000136560,
    /** # 100000136907

Solution for dispersion for injection/infusion. */
    N100000136907,
    /** # 100000143502

Powder and solution for dental cement. */
    N100000143502,
    /** # 100000143546

Endotracheopulmonary instillation, powder and solvent for suspension. */
    N100000143546,
    /** # 100000143552

Powder, solvent and matrix for implantation matrix. */
    N100000143552,
    /** # 100000156068

Nasal drops, lyophilisate and solvent for suspension. */
    N100000156068,
    /** # 100000157796

Lyophilisate and suspension for suspension for injection. */
    N100000157796,
    /** # 100000164467

Powder for concentrate and solution for solution for infusion. */
    N100000164467,
    /** # 100000169997

Powder and solution for bee-hive solution. */
    N100000169997,
    /** # 100000170588

Suspension and solvent for oral spray. */
    N100000170588,
    /** # 100000171127

Lyophilisate and solvent for oral suspension. */
    N100000171127,
    /** # 100000171193

Concentrate and solvent for concentrate for oral spray, suspension. */
    N100000171193,
    /** # 100000171238

Lyophilisate and solvent for oculonasal suspension. */
    N100000171238,
    /** # 100000171935

Emulsion and lyophilisate for suspension for injection. */
    N100000171935,
    /** # 100000174065

Powder and solvent for syrup. */
    N100000174065,
    /** # 200000002161

Nasal spray, lyophilisate and solvent for suspension. */
    N200000002161,
    /** # 200000002287

Powder and solution for bee-hive dispersion. */
    N200000002287,
    /** # 200000004201

Solution and dispersion for nebuliser dispersion. */
    N200000004201,
    /** # 200000004819

Effervescent powder and powder for oral suspension. */
    N200000004819,
    /** # 200000004820

Lyophilisate and solvent for emulsion for injection. */
    N200000004820,
    /** # 200000005547

Powder and solution for suspension for injection. */
    N200000005547,
    /** # 200000010382

Lyophilisate and solvent for suspension for nasal spray or injection. */
    N200000010382,
}
impl ::core::str::FromStr for CombinedDoseForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073366" => Ok(Self::N100000073366),
            "100000073651" => Ok(Self::N100000073651),
            "100000073774" => Ok(Self::N100000073774),
            "100000073781" => Ok(Self::N100000073781),
            "100000073801" => Ok(Self::N100000073801),
            "100000073860" => Ok(Self::N100000073860),
            "100000073868" => Ok(Self::N100000073868),
            "100000073869" => Ok(Self::N100000073869),
            "100000073884" => Ok(Self::N100000073884),
            "100000073891" => Ok(Self::N100000073891),
            "100000073892" => Ok(Self::N100000073892),
            "100000073941" => Ok(Self::N100000073941),
            "100000073972" => Ok(Self::N100000073972),
            "100000073973" => Ok(Self::N100000073973),
            "100000073974" => Ok(Self::N100000073974),
            "100000073975" => Ok(Self::N100000073975),
            "100000073987" => Ok(Self::N100000073987),
            "100000073988" => Ok(Self::N100000073988),
            "100000073989" => Ok(Self::N100000073989),
            "100000073990" => Ok(Self::N100000073990),
            "100000073999" => Ok(Self::N100000073999),
            "100000074015" => Ok(Self::N100000074015),
            "100000074016" => Ok(Self::N100000074016),
            "100000074017" => Ok(Self::N100000074017),
            "100000074018" => Ok(Self::N100000074018),
            "100000074030" => Ok(Self::N100000074030),
            "100000074031" => Ok(Self::N100000074031),
            "100000074032" => Ok(Self::N100000074032),
            "100000074048" => Ok(Self::N100000074048),
            "100000074051" => Ok(Self::N100000074051),
            "100000074053" => Ok(Self::N100000074053),
            "100000074056" => Ok(Self::N100000074056),
            "100000074057" => Ok(Self::N100000074057),
            "100000074061" => Ok(Self::N100000074061),
            "100000074064" => Ok(Self::N100000074064),
            "100000075580" => Ok(Self::N100000075580),
            "100000075584" => Ok(Self::N100000075584),
            "100000075587" => Ok(Self::N100000075587),
            "100000116137" => Ok(Self::N100000116137),
            "100000116141" => Ok(Self::N100000116141),
            "100000116155" => Ok(Self::N100000116155),
            "100000116160" => Ok(Self::N100000116160),
            "100000116172" => Ok(Self::N100000116172),
            "100000116173" => Ok(Self::N100000116173),
            "100000116174" => Ok(Self::N100000116174),
            "100000116175" => Ok(Self::N100000116175),
            "100000116176" => Ok(Self::N100000116176),
            "100000116177" => Ok(Self::N100000116177),
            "100000116179" => Ok(Self::N100000116179),
            "100000125746" => Ok(Self::N100000125746),
            "100000125747" => Ok(Self::N100000125747),
            "100000125777" => Ok(Self::N100000125777),
            "100000136318" => Ok(Self::N100000136318),
            "100000136325" => Ok(Self::N100000136325),
            "100000136558" => Ok(Self::N100000136558),
            "100000136560" => Ok(Self::N100000136560),
            "100000136907" => Ok(Self::N100000136907),
            "100000143502" => Ok(Self::N100000143502),
            "100000143546" => Ok(Self::N100000143546),
            "100000143552" => Ok(Self::N100000143552),
            "100000156068" => Ok(Self::N100000156068),
            "100000157796" => Ok(Self::N100000157796),
            "100000164467" => Ok(Self::N100000164467),
            "100000169997" => Ok(Self::N100000169997),
            "100000170588" => Ok(Self::N100000170588),
            "100000171127" => Ok(Self::N100000171127),
            "100000171193" => Ok(Self::N100000171193),
            "100000171238" => Ok(Self::N100000171238),
            "100000171935" => Ok(Self::N100000171935),
            "100000174065" => Ok(Self::N100000174065),
            "200000002161" => Ok(Self::N200000002161),
            "200000002287" => Ok(Self::N200000002287),
            "200000004201" => Ok(Self::N200000004201),
            "200000004819" => Ok(Self::N200000004819),
            "200000004820" => Ok(Self::N200000004820),
            "200000005547" => Ok(Self::N200000005547),
            "200000010382" => Ok(Self::N200000010382),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CombinedDoseForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073366 => "100000073366",
            Self::N100000073651 => "100000073651",
            Self::N100000073774 => "100000073774",
            Self::N100000073781 => "100000073781",
            Self::N100000073801 => "100000073801",
            Self::N100000073860 => "100000073860",
            Self::N100000073868 => "100000073868",
            Self::N100000073869 => "100000073869",
            Self::N100000073884 => "100000073884",
            Self::N100000073891 => "100000073891",
            Self::N100000073892 => "100000073892",
            Self::N100000073941 => "100000073941",
            Self::N100000073972 => "100000073972",
            Self::N100000073973 => "100000073973",
            Self::N100000073974 => "100000073974",
            Self::N100000073975 => "100000073975",
            Self::N100000073987 => "100000073987",
            Self::N100000073988 => "100000073988",
            Self::N100000073989 => "100000073989",
            Self::N100000073990 => "100000073990",
            Self::N100000073999 => "100000073999",
            Self::N100000074015 => "100000074015",
            Self::N100000074016 => "100000074016",
            Self::N100000074017 => "100000074017",
            Self::N100000074018 => "100000074018",
            Self::N100000074030 => "100000074030",
            Self::N100000074031 => "100000074031",
            Self::N100000074032 => "100000074032",
            Self::N100000074048 => "100000074048",
            Self::N100000074051 => "100000074051",
            Self::N100000074053 => "100000074053",
            Self::N100000074056 => "100000074056",
            Self::N100000074057 => "100000074057",
            Self::N100000074061 => "100000074061",
            Self::N100000074064 => "100000074064",
            Self::N100000075580 => "100000075580",
            Self::N100000075584 => "100000075584",
            Self::N100000075587 => "100000075587",
            Self::N100000116137 => "100000116137",
            Self::N100000116141 => "100000116141",
            Self::N100000116155 => "100000116155",
            Self::N100000116160 => "100000116160",
            Self::N100000116172 => "100000116172",
            Self::N100000116173 => "100000116173",
            Self::N100000116174 => "100000116174",
            Self::N100000116175 => "100000116175",
            Self::N100000116176 => "100000116176",
            Self::N100000116177 => "100000116177",
            Self::N100000116179 => "100000116179",
            Self::N100000125746 => "100000125746",
            Self::N100000125747 => "100000125747",
            Self::N100000125777 => "100000125777",
            Self::N100000136318 => "100000136318",
            Self::N100000136325 => "100000136325",
            Self::N100000136558 => "100000136558",
            Self::N100000136560 => "100000136560",
            Self::N100000136907 => "100000136907",
            Self::N100000143502 => "100000143502",
            Self::N100000143546 => "100000143546",
            Self::N100000143552 => "100000143552",
            Self::N100000156068 => "100000156068",
            Self::N100000157796 => "100000157796",
            Self::N100000164467 => "100000164467",
            Self::N100000169997 => "100000169997",
            Self::N100000170588 => "100000170588",
            Self::N100000171127 => "100000171127",
            Self::N100000171193 => "100000171193",
            Self::N100000171238 => "100000171238",
            Self::N100000171935 => "100000171935",
            Self::N100000174065 => "100000174065",
            Self::N200000002161 => "200000002161",
            Self::N200000002287 => "200000002287",
            Self::N200000004201 => "200000004201",
            Self::N200000004819 => "200000004819",
            Self::N200000004820 => "200000004820",
            Self::N200000005547 => "200000005547",
            Self::N200000010382 => "200000010382",
        }
    }
}
impl<'de> Deserialize<'de> for CombinedDoseForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CombinedDoseForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CommonTags`. Common Tag Codes defined by FHIR project

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CommonTags {
    /** # actionable

Actionable. This request is intended to be acted upon, not merely stored */
    Actionable,
}
impl ::core::str::FromStr for CommonTags {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "actionable" => Ok(Self::Actionable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommonTags {
    fn as_ref(&self) -> &str {
        match self {
            Self::Actionable => "actionable",
        }
    }
}
impl<'de> Deserialize<'de> for CommonTags {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommonTags {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CommunicationCategory`. Codes for general categories of communications such as alerts, instructions, etc.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CommunicationCategory {
    /** # alert

Alert. The communication conveys an alert. */
    Alert,
    /** # instruction

Instruction. The communication conveys an instruction. */
    Instruction,
    /** # notification

Notification. The communication conveys a notification. */
    Notification,
    /** # reminder

Reminder. The communication conveys a reminder. */
    Reminder,
}
impl ::core::str::FromStr for CommunicationCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alert" => Ok(Self::Alert),
            "instruction" => Ok(Self::Instruction),
            "notification" => Ok(Self::Notification),
            "reminder" => Ok(Self::Reminder),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommunicationCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alert => "alert",
            Self::Instruction => "instruction",
            Self::Notification => "notification",
            Self::Reminder => "reminder",
        }
    }
}
impl<'de> Deserialize<'de> for CommunicationCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommunicationCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CommunicationNotDoneReason`. Codes for the reason why a communication did not happen.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CommunicationNotDoneReason {
    /** # family-objection

Family Objection. The communication was not done due to a family objection. */
    FamilyObjection,
    /** # invalid-phone-number

Invalid Phone Number. The communication was not done due to an invalid phone number. */
    InvalidPhoneNumber,
    /** # patient-objection

Patient Objection. The communication was not done due to a patient objection. */
    PatientObjection,
    /** # recipient-unavailable

Recipient Unavailable. The communication was not done due to the recipient being unavailable. */
    RecipientUnavailable,
    /** # system-error

System Error. The communication was not done due to a system error. */
    SystemError,
    /** # unknown

Unknown. The communication was not done due to an unknown reason. */
    Unknown,
}
impl ::core::str::FromStr for CommunicationNotDoneReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "family-objection" => Ok(Self::FamilyObjection),
            "invalid-phone-number" => Ok(Self::InvalidPhoneNumber),
            "patient-objection" => Ok(Self::PatientObjection),
            "recipient-unavailable" => Ok(Self::RecipientUnavailable),
            "system-error" => Ok(Self::SystemError),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommunicationNotDoneReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::FamilyObjection => "family-objection",
            Self::InvalidPhoneNumber => "invalid-phone-number",
            Self::PatientObjection => "patient-objection",
            Self::RecipientUnavailable => "recipient-unavailable",
            Self::SystemError => "system-error",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for CommunicationNotDoneReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommunicationNotDoneReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CommunicationTopic`. Codes describing the purpose or content of the communication.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CommunicationTopic {
    /** # appointment-reminder

Appointment Reminder. The purpose or content of the communication is an appointment reminder. */
    AppointmentReminder,
    /** # phone-consult

Phone Consult. The purpose or content of the communication is a phone consult. */
    PhoneConsult,
    /** # prescription-refill-request

Prescription Refill Request. The purpose or content of the communication is a prescription refill request. */
    PrescriptionRefillRequest,
    /** # progress-update

Progress Update. The purpose or content of the communication is a progress update. */
    ProgressUpdate,
    /** # report-labs

Report Labs. The purpose or content of the communication is to report labs. */
    ReportLabs,
    /** # summary-report

Summary Report. The purpose or content of the communication is a summary report. */
    SummaryReport,
}
impl ::core::str::FromStr for CommunicationTopic {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "appointment-reminder" => Ok(Self::AppointmentReminder),
            "phone-consult" => Ok(Self::PhoneConsult),
            "prescription-refill-request" => Ok(Self::PrescriptionRefillRequest),
            "progress-update" => Ok(Self::ProgressUpdate),
            "report-labs" => Ok(Self::ReportLabs),
            "summary-report" => Ok(Self::SummaryReport),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CommunicationTopic {
    fn as_ref(&self) -> &str {
        match self {
            Self::AppointmentReminder => "appointment-reminder",
            Self::PhoneConsult => "phone-consult",
            Self::PrescriptionRefillRequest => "prescription-refill-request",
            Self::ProgressUpdate => "progress-update",
            Self::ReportLabs => "report-labs",
            Self::SummaryReport => "summary-report",
        }
    }
}
impl<'de> Deserialize<'de> for CommunicationTopic {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CommunicationTopic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CompartmentType`. Which type a compartment definition describes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CompartmentType {
    /** # Device

Device. The compartment definition is for the device compartment. */
    Device,
    /** # Encounter

Encounter. The compartment definition is for the encounter compartment. */
    Encounter,
    /** # Patient

Patient. The compartment definition is for the patient compartment. */
    Patient,
    /** # Practitioner

Practitioner. The compartment definition is for the practitioner compartment. */
    Practitioner,
    /** # RelatedPerson

RelatedPerson. The compartment definition is for the related-person compartment. */
    RelatedPerson,
}
impl ::core::str::FromStr for CompartmentType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Device" => Ok(Self::Device),
            "Encounter" => Ok(Self::Encounter),
            "Patient" => Ok(Self::Patient),
            "Practitioner" => Ok(Self::Practitioner),
            "RelatedPerson" => Ok(Self::RelatedPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompartmentType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "Device",
            Self::Encounter => "Encounter",
            Self::Patient => "Patient",
            Self::Practitioner => "Practitioner",
            Self::RelatedPerson => "RelatedPerson",
        }
    }
}
impl<'de> Deserialize<'de> for CompartmentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompartmentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CompositeMeasureScoring`. The composite scoring method of the measure.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CompositeMeasureScoring {
    /** # all-or-nothing

All-or-nothing. All-or-nothing scoring includes an individual in the numerator of the composite measure if they are in the numerators of all of the component measures in which they are in the denominator. */
    AllOrNothing,
    /** # linear

Linear. Linear scoring gives an individual a score based on the number of numerators in which they appear. */
    Linear,
    /** # opportunity

Opportunity. Opportunity scoring combines the scores from component measures by combining the numerators and denominators for each component. */
    Opportunity,
    /** # weighted

Weighted. Weighted scoring gives an individual a score based on a weighted factor for each component numerator in which they appear. */
    Weighted,
}
impl ::core::str::FromStr for CompositeMeasureScoring {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all-or-nothing" => Ok(Self::AllOrNothing),
            "linear" => Ok(Self::Linear),
            "opportunity" => Ok(Self::Opportunity),
            "weighted" => Ok(Self::Weighted),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositeMeasureScoring {
    fn as_ref(&self) -> &str {
        match self {
            Self::AllOrNothing => "all-or-nothing",
            Self::Linear => "linear",
            Self::Opportunity => "opportunity",
            Self::Weighted => "weighted",
        }
    }
}
impl<'de> Deserialize<'de> for CompositeMeasureScoring {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositeMeasureScoring {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CompositionAttestationMode`. The way in which a person authenticated a composition.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CompositionAttestationMode {
    /** # legal

Legal. The person authenticated the content and accepted legal responsibility for its content. */
    Legal,
    /** # official

Official. The organization authenticated the content as consistent with their policies and procedures. */
    Official,
    /** # personal

Personal. The person authenticated the content in their personal capacity. */
    Personal,
    /** # professional

Professional. The person authenticated the content in their professional capacity. */
    Professional,
}
impl ::core::str::FromStr for CompositionAttestationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "legal" => Ok(Self::Legal),
            "official" => Ok(Self::Official),
            "personal" => Ok(Self::Personal),
            "professional" => Ok(Self::Professional),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositionAttestationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Legal => "legal",
            Self::Official => "official",
            Self::Personal => "personal",
            Self::Professional => "professional",
        }
    }
}
impl<'de> Deserialize<'de> for CompositionAttestationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositionAttestationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CompositionStatus`. The workflow/clinical status of the composition.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CompositionStatus {
    /** # amended

Amended. The composition content or the referenced resources have been modified (edited or added to) subsequent to being released as "final" and the composition is complete and verified by an authorized person. */
    Amended,
    /** # entered-in-error

Entered in Error. The composition or document was originally created/issued in error, and this is an amendment that marks that the entire series should not be considered as valid. */
    EnteredInError,
    /** # final

Final. This version of the composition is complete and verified by an appropriate person and no further work is planned. Any subsequent updates would be on a new version of the composition. */
    Final,
    /** # preliminary

Preliminary. This is a preliminary composition or document (also known as initial or interim). The content may be incomplete or unverified. */
    Preliminary,
}
impl ::core::str::FromStr for CompositionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "preliminary" => Ok(Self::Preliminary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CompositionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Preliminary => "preliminary",
        }
    }
}
impl<'de> Deserialize<'de> for CompositionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CompositionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConceptMapEquivalence`. The degree of equivalence between concepts.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConceptMapEquivalence {
    /** # disjoint

Disjoint. This is an explicit assertion that there is no mapping between the source and target concept. */
    Disjoint,
    /** # equal

Equal. The definitions of the concepts are exactly the same (i.e. only grammatical differences) and structural implications of meaning are identical or irrelevant (i.e. intentionally identical). */
    Equal,
    /** # equivalent

Equivalent. The definitions of the concepts mean the same thing (including when structural implications of meaning are considered) (i.e. extensionally identical). */
    Equivalent,
    /** # inexact

Inexact. The target mapping overlaps with the source concept, but both source and target cover additional meaning, or the definitions are imprecise and it is uncertain whether they have the same boundaries to their meaning. The sense in which the mapping is inexact SHALL be described in the comments in this case, and applications should be careful when attempting to use these mappings operationally. */
    Inexact,
    /** # narrower

Narrower. The target mapping is narrower in meaning than the source concept. The sense in which the mapping is narrower SHALL be described in the comments in this case, and applications should be careful when attempting to use these mappings operationally. */
    Narrower,
    /** # relatedto

Related To. The concepts are related to each other, and have at least some overlap in meaning, but the exact relationship is not known. */
    Relatedto,
    /** # specializes

Specializes. The target mapping specializes the meaning of the source concept (e.g. the target is-a source). */
    Specializes,
    /** # subsumes

Subsumes. The target mapping subsumes the meaning of the source concept (e.g. the source is-a target). */
    Subsumes,
    /** # unmatched

Unmatched. There is no match for this concept in the target code system. */
    Unmatched,
    /** # wider

Wider. The target mapping is wider in meaning than the source concept. */
    Wider,
}
impl ::core::str::FromStr for ConceptMapEquivalence {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "disjoint" => Ok(Self::Disjoint),
            "equal" => Ok(Self::Equal),
            "equivalent" => Ok(Self::Equivalent),
            "inexact" => Ok(Self::Inexact),
            "narrower" => Ok(Self::Narrower),
            "relatedto" => Ok(Self::Relatedto),
            "specializes" => Ok(Self::Specializes),
            "subsumes" => Ok(Self::Subsumes),
            "unmatched" => Ok(Self::Unmatched),
            "wider" => Ok(Self::Wider),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapEquivalence {
    fn as_ref(&self) -> &str {
        match self {
            Self::Disjoint => "disjoint",
            Self::Equal => "equal",
            Self::Equivalent => "equivalent",
            Self::Inexact => "inexact",
            Self::Narrower => "narrower",
            Self::Relatedto => "relatedto",
            Self::Specializes => "specializes",
            Self::Subsumes => "subsumes",
            Self::Unmatched => "unmatched",
            Self::Wider => "wider",
        }
    }
}
impl<'de> Deserialize<'de> for ConceptMapEquivalence {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapEquivalence {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConceptMapGroupUnmappedMode`. Defines which action to take if there is no match in the group.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConceptMapGroupUnmappedMode {
    /** # fixed

Fixed Code. Use the code explicitly provided in the group.unmapped. */
    Fixed,
    /** # other-map

Other Map. Use the map identified by the canonical URL in the url element. */
    OtherMap,
    /** # provided

Provided Code. Use the code as provided in the $translate request. */
    Provided,
}
impl ::core::str::FromStr for ConceptMapGroupUnmappedMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fixed" => Ok(Self::Fixed),
            "other-map" => Ok(Self::OtherMap),
            "provided" => Ok(Self::Provided),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConceptMapGroupUnmappedMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fixed => "fixed",
            Self::OtherMap => "other-map",
            Self::Provided => "provided",
        }
    }
}
impl<'de> Deserialize<'de> for ConceptMapGroupUnmappedMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptMapGroupUnmappedMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConceptSubsumptionOutcome`. Codes indicating the results of a subsumption check between codes

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConceptSubsumptionOutcome {
    /** # equivalent

Equivalent. The two concepts are equivalent (have the same properties). */
    Equivalent,
    /** # not-subsumed

Not-Subsumed. Coding/code "A" and Coding/code "B" are disjoint (e.g. each has propeties that the other doesn't have). */
    NotSubsumed,
    /** # subsumed-by

Subsumed-By. Coding/code "A" is subsumed by Coding/code "B" (e.g. A has all the properties B has, and some of it's own). */
    SubsumedBy,
    /** # subsumes

Subsumes. Coding/code "A" subsumes Coding/code "B" (e.g. B has all the properties A has, and some of it's own). */
    Subsumes,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConceptSubsumptionOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "equivalent" => Ok(Self::Equivalent),
            "not-subsumed" => Ok(Self::NotSubsumed),
            "subsumed-by" => Ok(Self::SubsumedBy),
            "subsumes" => Ok(Self::Subsumes),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConceptSubsumptionOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equivalent => "equivalent",
            Self::NotSubsumed => "not-subsumed",
            Self::SubsumedBy => "subsumed-by",
            Self::Subsumes => "subsumes",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ConceptSubsumptionOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConceptSubsumptionOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConditionCategoryCodes`. Example value set for Condition Categories.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConditionCategoryCodes {
    /** # encounter-diagnosis

Encounter Diagnosis. A point in time diagnosis (e.g. from a physician or nurse) in context of an encounter. */
    EncounterDiagnosis,
    /** # problem-list-item

Problem List Item. An item on a problem list that can be managed over time and can be expressed by a practitioner (e.g. physician, nurse), patient, or related person. */
    ProblemListItem,
}
impl ::core::str::FromStr for ConditionCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "encounter-diagnosis" => Ok(Self::EncounterDiagnosis),
            "problem-list-item" => Ok(Self::ProblemListItem),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::EncounterDiagnosis => "encounter-diagnosis",
            Self::ProblemListItem => "problem-list-item",
        }
    }
}
impl<'de> Deserialize<'de> for ConditionCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConditionClinicalStatusCodes`. Preferred value set for Condition Clinical Status.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConditionClinicalStatusCodes {
    /** # active

Active. The subject is currently experiencing the symptoms of the condition or there is evidence of the condition. */
    Active,
    /** # inactive

Inactive. The subject is no longer experiencing the symptoms of the condition or there is no longer evidence of the condition. */
    Inactive,
    /** # recurrence

Recurrence. The subject is experiencing a re-occurence or repeating of a previously resolved condition, e.g. urinary tract infection, pancreatitis, cholangitis, conjunctivitis. */
    Recurrence,
    /** # relapse

Relapse. The subject is experiencing a return of a condition, or signs and symptoms after a period of improvement or remission, e.g. relapse of cancer, multiple sclerosis, rheumatoid arthritis, systemic lupus erythematosus, bipolar disorder, [psychotic relapse of] schizophrenia, etc. */
    Relapse,
    /** # remission

Remission. The subject is no longer experiencing the symptoms of the condition, but there is a risk of the symptoms returning. */
    Remission,
    /** # resolved

Resolved. The subject is no longer experiencing the symptoms of the condition and there is a negligible perceived risk of the symptoms returning. */
    Resolved,
}
impl ::core::str::FromStr for ConditionClinicalStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "recurrence" => Ok(Self::Recurrence),
            "relapse" => Ok(Self::Relapse),
            "remission" => Ok(Self::Remission),
            "resolved" => Ok(Self::Resolved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionClinicalStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Recurrence => "recurrence",
            Self::Relapse => "relapse",
            Self::Remission => "remission",
            Self::Resolved => "resolved",
        }
    }
}
impl<'de> Deserialize<'de> for ConditionClinicalStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionClinicalStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConditionVerificationStatus`. The verification status to support or decline the clinical status of the condition or diagnosis.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConditionVerificationStatus {
    /** # confirmed

Confirmed. There is sufficient diagnostic and/or clinical evidence to treat this as a confirmed condition. */
    Confirmed,
    /** # differential

Differential. One of a set of potential (and typically mutually exclusive) diagnoses asserted to further guide the diagnostic process and preliminary treatment. */
    Differential,
    /** # entered-in-error

Entered in Error. The statement was entered in error and is not valid. */
    EnteredInError,
    /** # provisional

Provisional. This is a tentative diagnosis - still a candidate that is under consideration. */
    Provisional,
    /** # refuted

Refuted. This condition has been ruled out by diagnostic and clinical evidence. */
    Refuted,
    /** # unconfirmed

Unconfirmed. There is not sufficient diagnostic and/or clinical evidence to treat this as a confirmed condition. */
    Unconfirmed,
}
impl ::core::str::FromStr for ConditionVerificationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confirmed" => Ok(Self::Confirmed),
            "differential" => Ok(Self::Differential),
            "entered-in-error" => Ok(Self::EnteredInError),
            "provisional" => Ok(Self::Provisional),
            "refuted" => Ok(Self::Refuted),
            "unconfirmed" => Ok(Self::Unconfirmed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionVerificationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confirmed => "confirmed",
            Self::Differential => "differential",
            Self::EnteredInError => "entered-in-error",
            Self::Provisional => "provisional",
            Self::Refuted => "refuted",
            Self::Unconfirmed => "unconfirmed",
        }
    }
}
impl<'de> Deserialize<'de> for ConditionVerificationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionVerificationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConditionalDeleteStatus`. A code that indicates how the server supports conditional delete.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConditionalDeleteStatus {
    /** # multiple

Multiple Deletes Supported. Conditional deletes are supported, and multiple resources can be deleted in a single interaction. */
    Multiple,
    /** # not-supported

Not Supported. No support for conditional deletes. */
    NotSupported,
    /** # single

Single Deletes Supported. Conditional deletes are supported, but only single resources at a time. */
    Single,
}
impl ::core::str::FromStr for ConditionalDeleteStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "multiple" => Ok(Self::Multiple),
            "not-supported" => Ok(Self::NotSupported),
            "single" => Ok(Self::Single),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionalDeleteStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Multiple => "multiple",
            Self::NotSupported => "not-supported",
            Self::Single => "single",
        }
    }
}
impl<'de> Deserialize<'de> for ConditionalDeleteStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionalDeleteStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConditionalReadStatus`. A code that indicates how the server supports conditional read.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConditionalReadStatus {
    /** # full-support

Full Support. Conditional reads are supported, with both If-Modified-Since and If-None-Match HTTP Headers. */
    FullSupport,
    /** # modified-since

If-Modified-Since. Conditional reads are supported, but only with the If-Modified-Since HTTP Header. */
    ModifiedSince,
    /** # not-match

If-None-Match. Conditional reads are supported, but only with the If-None-Match HTTP Header. */
    NotMatch,
    /** # not-supported

Not Supported. No support for conditional reads. */
    NotSupported,
}
impl ::core::str::FromStr for ConditionalReadStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "full-support" => Ok(Self::FullSupport),
            "modified-since" => Ok(Self::ModifiedSince),
            "not-match" => Ok(Self::NotMatch),
            "not-supported" => Ok(Self::NotSupported),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConditionalReadStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::FullSupport => "full-support",
            Self::ModifiedSince => "modified-since",
            Self::NotMatch => "not-match",
            Self::NotSupported => "not-supported",
        }
    }
}
impl<'de> Deserialize<'de> for ConditionalReadStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConditionalReadStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConsentActionCodes`. This value set includes example Consent Action codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConsentActionCodes {
    /** # access

Access. Retrieval without permitting collection, use or disclosure. e.g., no screen-scraping for collection, use or disclosure (view-only access) */
    Access,
    /** # collect

Collect. Gather retrieved information for storage */
    Collect,
    /** # correct

Access and Correct. Allow retrieval of a patient's information for the purpose of update or rectify */
    Correct,
    /** # disclose

Disclose. Transfer retrieved information */
    Disclose,
    /** # use

Use. Utilize the retrieved information */
    Use,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConsentActionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "access" => Ok(Self::Access),
            "collect" => Ok(Self::Collect),
            "correct" => Ok(Self::Correct),
            "disclose" => Ok(Self::Disclose),
            "use" => Ok(Self::Use),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConsentActionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Access => "access",
            Self::Collect => "collect",
            Self::Correct => "correct",
            Self::Disclose => "disclose",
            Self::Use => "use",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ConsentActionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentActionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConsentCategoryCodes`. FHIR Specific Example codes for Consent Category

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConsentCategoryCodes {
    /** # acd

Advance Directive. Any instructions, written or given verbally by a patient to a health care provider in anticipation of potential need for medical treatment. [2005 Honor My Wishes] */
    Acd,
    /** # dnr

Do Not Resuscitate. A legal document, signed by both the patient and their provider, stating a desire not to have CPR initiated in case of a cardiac event. Note: This form was replaced in 2003 with the Physician Orders for Life-Sustaining Treatment [POLST]. */
    Dnr,
    /** # emrgonly

Emergency Only. Opt-in to disclosure of health information for emergency only consent directive. Comment: This general consent directive specifically limits disclosure of health information for purpose of emergency treatment. Additional parameters may further limit the disclosure to specific users, roles, duration, types of information, and impose uses obligations. [ActConsentDirective (2.16.840.1.113883.1.11.20425)] */
    Emrgonly,
    /** # hcd

Health Care Directive. Patient's document telling patient's health care provider what the patient wants or does not want if the patient is diagnosed as being terminally ill and in a persistent vegetative state or in a permanently unconscious condition.[2005 Honor My Wishes] */
    Hcd,
    /** # npp

Notice of Privacy Practices. Acknowledgement of custodian notice of privacy practices. Usage Notes: This type of consent directive acknowledges a custodian's notice of privacy practices including its permitted collection, access, use and disclosure of health information to users and for purposes of use specified. [ActConsentDirective (2.16.840.1.113883.1.11.20425)] */
    Npp,
    /** # polst

POLST. The Physician Order for Life-Sustaining Treatment form records a person's health care wishes for end of life emergency treatment and translates them into an order by the physician. It must be reviewed and signed by both the patient and the physician, Advanced Registered Nurse Practitioner or Physician Assistant. [2005 Honor My Wishes] Comment: Opt-in Consent Directive with restrictions. */
    Polst,
    /** # research

Research Information Access. Consent to have healthcare information in an electronic health record accessed for research purposes. [VALUE SET: ActConsentType (2.16.840.1.113883.1.11.19897)] */
    Research,
    /** # rsdid

De-identified Information Access. Consent to have de-identified healthcare information in an electronic health record that is accessed for research purposes, but without consent to re-identify the information under any circumstance. [VALUE SET: ActConsentType (2.16.840.1.113883.1.11.19897) */
    Rsdid,
    /** # rsreid

Re-identifiable Information Access. Consent to have de-identified healthcare information in an electronic health record that is accessed for research purposes re-identified under specific circumstances outlined in the consent. [VALUE SET: ActConsentType (2.16.840.1.113883.1.11.19897)] */
    Rsreid,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConsentCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acd" => Ok(Self::Acd),
            "dnr" => Ok(Self::Dnr),
            "emrgonly" => Ok(Self::Emrgonly),
            "hcd" => Ok(Self::Hcd),
            "npp" => Ok(Self::Npp),
            "polst" => Ok(Self::Polst),
            "research" => Ok(Self::Research),
            "rsdid" => Ok(Self::Rsdid),
            "rsreid" => Ok(Self::Rsreid),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConsentCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acd => "acd",
            Self::Dnr => "dnr",
            Self::Emrgonly => "emrgonly",
            Self::Hcd => "hcd",
            Self::Npp => "npp",
            Self::Polst => "polst",
            Self::Research => "research",
            Self::Rsdid => "rsdid",
            Self::Rsreid => "rsreid",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ConsentCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConsentDataMeaning`. How a resource reference is interpreted when testing consent restrictions.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConsentDataMeaning {
    /** # authoredby

AuthoredBy. The consent applies to instances of resources that are authored by. */
    Authoredby,
    /** # dependents

Dependents. The consent applies directly to the instance of the resource and instances that refer to it. */
    Dependents,
    /** # instance

Instance. The consent applies directly to the instance of the resource. */
    Instance,
    /** # related

Related. The consent applies directly to the instance of the resource and instances it refers to. */
    Related,
}
impl ::core::str::FromStr for ConsentDataMeaning {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "authoredby" => Ok(Self::Authoredby),
            "dependents" => Ok(Self::Dependents),
            "instance" => Ok(Self::Instance),
            "related" => Ok(Self::Related),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentDataMeaning {
    fn as_ref(&self) -> &str {
        match self {
            Self::Authoredby => "authoredby",
            Self::Dependents => "dependents",
            Self::Instance => "instance",
            Self::Related => "related",
        }
    }
}
impl<'de> Deserialize<'de> for ConsentDataMeaning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentDataMeaning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConsentProvisionType`. How a rule statement is applied, such as adding additional consent or removing consent.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConsentProvisionType {
    /** # deny

Opt Out. Consent is denied for actions meeting these rules. */
    Deny,
    /** # permit

Opt In. Consent is provided for actions meeting these rules. */
    Permit,
}
impl ::core::str::FromStr for ConsentProvisionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deny" => Ok(Self::Deny),
            "permit" => Ok(Self::Permit),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentProvisionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deny => "deny",
            Self::Permit => "permit",
        }
    }
}
impl<'de> Deserialize<'de> for ConsentProvisionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentProvisionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConsentScopeCodes`. This value set includes the current scopes for the Consent resources.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConsentScopeCodes {
    /** # adr

Advanced Care Directive. Actions to be taken if they are no longer able to make decisions for themselves */
    Adr,
    /** # patient-privacy

Privacy Consent. Agreement to collect, access, use or disclose (share) information */
    PatientPrivacy,
    /** # research

Research. Consent to participate in research protocol and information sharing required */
    Research,
    /** # treatment

Treatment. Consent to undergo a specific treatment */
    Treatment,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ConsentScopeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "adr" => Ok(Self::Adr),
            "patient-privacy" => Ok(Self::PatientPrivacy),
            "research" => Ok(Self::Research),
            "treatment" => Ok(Self::Treatment),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ConsentScopeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adr => "adr",
            Self::PatientPrivacy => "patient-privacy",
            Self::Research => "research",
            Self::Treatment => "treatment",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ConsentScopeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentScopeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConsentState`. Indicates the state of the consent.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConsentState {
    /** # active

Active. The consent is to be followed and enforced. */
    Active,
    /** # draft

Pending. The consent is in development or awaiting use but is not yet intended to be acted upon. */
    Draft,
    /** # entered-in-error

Entered in Error. The consent was created wrongly (e.g. wrong patient) and should be ignored. */
    EnteredInError,
    /** # inactive

Inactive. The consent is terminated or replaced. */
    Inactive,
    /** # proposed

Proposed. The consent has been proposed but not yet agreed to by all parties. The negotiation stage. */
    Proposed,
    /** # rejected

Rejected. The consent has been rejected by one or more of the parties. */
    Rejected,
}
impl ::core::str::FromStr for ConsentState {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            "proposed" => Ok(Self::Proposed),
            "rejected" => Ok(Self::Rejected),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConsentState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
            Self::Proposed => "proposed",
            Self::Rejected => "rejected",
        }
    }
}
impl<'de> Deserialize<'de> for ConsentState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConsentState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ConstraintSeverity`. SHALL applications comply with this constraint?

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ConstraintSeverity {
    /** # error

Error. If the constraint is violated, the resource is not conformant. */
    Error,
    /** # warning

Warning. If the constraint is violated, the resource is conformant, but it is not necessarily following best practice. */
    Warning,
}
impl ::core::str::FromStr for ConstraintSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ConstraintSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Warning => "warning",
        }
    }
}
impl<'de> Deserialize<'de> for ConstraintSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ConstraintSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContactEntityType`. This example value set defines a set of codes that can be used to indicate the purpose for which you would contact a contact party.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContactEntityType {
    /** # ADMIN

Administrative. Contact details for administrative enquiries. */
    Admin,
    /** # BILL

Billing. Contact details for information regarding to billing/general finance enquiries. */
    Bill,
    /** # HR

Human Resource. Contact details for issues related to Human Resources, such as staff matters, OH&S etc. */
    Hr,
    /** # PATINF

Patient. Generic information contact for patients. */
    Patinf,
    /** # PAYOR

Payor. Contact details for dealing with issues related to insurance claims/adjudication/payment. */
    Payor,
    /** # PRESS

Press. Dedicated contact point for matters relating to press enquiries. */
    Press,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContactEntityType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ADMIN" => Ok(Self::Admin),
            "BILL" => Ok(Self::Bill),
            "HR" => Ok(Self::Hr),
            "PATINF" => Ok(Self::Patinf),
            "PAYOR" => Ok(Self::Payor),
            "PRESS" => Ok(Self::Press),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContactEntityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Admin => "ADMIN",
            Self::Bill => "BILL",
            Self::Hr => "HR",
            Self::Patinf => "PATINF",
            Self::Payor => "PAYOR",
            Self::Press => "PRESS",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContactEntityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactEntityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContactPointSystem`. Telecommunications form for contact point.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContactPointSystem {
    /** # email

Email. The value is an email address. */
    Email,
    /** # fax

Fax. The value is a fax machine. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required. */
    Fax,
    /** # other

Other. A contact that is not a phone, fax, page or email address and is not expressible as a URL.  E.g. Internal mail address.  This SHOULD NOT be used for contacts that are expressible as a URL (e.g. Skype, Twitter, Facebook, etc.)  Extensions may be used to distinguish "other" contact types. */
    Other,
    /** # pager

Pager. The value is a pager number. These may be local pager numbers that are only usable on a particular pager system. */
    Pager,
    /** # phone

Phone. The value is a telephone number used for voice calls. Use of full international numbers starting with + is recommended to enable automatic dialing support but not required. */
    Phone,
    /** # sms

SMS. A contact that can be used for sending an sms message (e.g. mobile phones, some landlines). */
    Sms,
    /** # url

URL. A contact that is not a phone, fax, pager or email address and is expressed as a URL.  This is intended for various institutional or personal contacts including web sites, blogs, Skype, Twitter, Facebook, etc. Do not use for email addresses. */
    Url,
}
impl ::core::str::FromStr for ContactPointSystem {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "email" => Ok(Self::Email),
            "fax" => Ok(Self::Fax),
            "other" => Ok(Self::Other),
            "pager" => Ok(Self::Pager),
            "phone" => Ok(Self::Phone),
            "sms" => Ok(Self::Sms),
            "url" => Ok(Self::Url),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContactPointSystem {
    fn as_ref(&self) -> &str {
        match self {
            Self::Email => "email",
            Self::Fax => "fax",
            Self::Other => "other",
            Self::Pager => "pager",
            Self::Phone => "phone",
            Self::Sms => "sms",
            Self::Url => "url",
        }
    }
}
impl<'de> Deserialize<'de> for ContactPointSystem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactPointSystem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContactPointUse`. Use of contact point.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContactPointUse {
    /** # home

Home. A communication contact point at a home; attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call. Typically used with urgent cases, or if no other contacts are available. */
    Home,
    /** # mobile

Mobile. A telecommunication device that moves and stays with its owner. May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business. */
    Mobile,
    /** # old

Old. This contact point is no longer in use (or was never correct, but retained for records). */
    Old,
    /** # temp

Temp. A temporary contact point. The period can provide more detailed information. */
    Temp,
    /** # work

Work. An office contact point. First choice for business related contacts during business hours. */
    Work,
}
impl ::core::str::FromStr for ContactPointUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "home" => Ok(Self::Home),
            "mobile" => Ok(Self::Mobile),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "work" => Ok(Self::Work),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContactPointUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Home => "home",
            Self::Mobile => "mobile",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Work => "work",
        }
    }
}
impl<'de> Deserialize<'de> for ContactPointUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContactPointUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContainerCap`. Color of the container cap.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContainerCap {
    /** # black

black cap. black cap. */
    Black,
    /** # brown

brown cap. brown cap. */
    Brown,
    /** # dark-yellow

dark yellow cap. dark yellow cap. */
    DarkYellow,
    /** # green

green cap. green cap. */
    Green,
    /** # grey

grey cap. grey cap. */
    Grey,
    /** # lavender

lavender cap. lavender cap. */
    Lavender,
    /** # light-blue

light blue cap. light blue cap. */
    LightBlue,
    /** # light-green

light green cap. light green cap. */
    LightGreen,
    /** # pink

pink cap. pink cap. */
    Pink,
    /** # red

red cap. red cap. */
    Red,
    /** # white

white cap. white cap. */
    White,
    /** # yellow

yellow cap. yellow cap. */
    Yellow,
}
impl ::core::str::FromStr for ContainerCap {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "black" => Ok(Self::Black),
            "brown" => Ok(Self::Brown),
            "dark-yellow" => Ok(Self::DarkYellow),
            "green" => Ok(Self::Green),
            "grey" => Ok(Self::Grey),
            "lavender" => Ok(Self::Lavender),
            "light-blue" => Ok(Self::LightBlue),
            "light-green" => Ok(Self::LightGreen),
            "pink" => Ok(Self::Pink),
            "red" => Ok(Self::Red),
            "white" => Ok(Self::White),
            "yellow" => Ok(Self::Yellow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContainerCap {
    fn as_ref(&self) -> &str {
        match self {
            Self::Black => "black",
            Self::Brown => "brown",
            Self::DarkYellow => "dark-yellow",
            Self::Green => "green",
            Self::Grey => "grey",
            Self::Lavender => "lavender",
            Self::LightBlue => "light-blue",
            Self::LightGreen => "light-green",
            Self::Pink => "pink",
            Self::Red => "red",
            Self::White => "white",
            Self::Yellow => "yellow",
        }
    }
}
impl<'de> Deserialize<'de> for ContainerCap {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContainerCap {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractActionCodes`. This value set includes sample Contract Action codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractActionCodes {
    /** # action-a

Action A. Definition for Action A */
    ActionA,
    /** # action-b

Action B. Definition for Action B */
    ActionB,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractActionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "action-a" => Ok(Self::ActionA),
            "action-b" => Ok(Self::ActionB),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractActionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActionA => "action-a",
            Self::ActionB => "action-b",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractActionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractActionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractActionStatus`. This CodeSystem contains FHIR-defined contract action status types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractActionStatus {
    /** # complete

Complete. To be completed */
    Complete,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractActionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractActionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractActionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractActionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractActorRoleCodes`. This value set includes sample Contract Actor Role codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractActorRoleCodes {
    /** # patient

Patient. A receiver, human or animal, of health care related goods and services. */
    Patient,
    /** # practitioner

Practitioner. Someone who provides health care related services to people or animals including both clinical and support services. */
    Practitioner,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractActorRoleCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "patient" => Ok(Self::Patient),
            "practitioner" => Ok(Self::Practitioner),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractActorRoleCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Patient => "patient",
            Self::Practitioner => "practitioner",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractActorRoleCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractActorRoleCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractAssetAvailability`. This CodeSystem contains FHIR-defined contract asset availability types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetAvailability {
    /** # lease

Lease. To be completed */
    Lease,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetAvailability {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "lease" => Ok(Self::Lease),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetAvailability {
    fn as_ref(&self) -> &str {
        match self {
            Self::Lease => "lease",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractAssetAvailability {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetAvailability {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractAssetContext`. This CodeSystem contains FHIR-defined contract asset context types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetContext {
    /** # custodian

Custodian. To be completed */
    Custodian,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetContext {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "custodian" => Ok(Self::Custodian),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetContext {
    fn as_ref(&self) -> &str {
        match self {
            Self::Custodian => "custodian",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractAssetContext {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetContext {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractAssetScope`. This CodeSystem contains FHIR-defined contract asset scope types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetScope {
    /** # thing

Thing. To be completed */
    Thing,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetScope {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "thing" => Ok(Self::Thing),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetScope {
    fn as_ref(&self) -> &str {
        match self {
            Self::Thing => "thing",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractAssetScope {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetScope {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractAssetSubtype`. This CodeSystem contains FHIR-defined contract asset type sub-types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetSubtype {
    /** # participation

Participation. To be completed */
    Participation,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetSubtype {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "participation" => Ok(Self::Participation),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetSubtype {
    fn as_ref(&self) -> &str {
        match self {
            Self::Participation => "participation",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractAssetSubtype {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetSubtype {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractAssetType`. This CodeSystem contains FHIR-defined contract asset type types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractAssetType {
    /** # participation

Participation. To be completed */
    Participation,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractAssetType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "participation" => Ok(Self::Participation),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractAssetType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Participation => "participation",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractAssetType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractAssetType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractContentDerivative`. This is an example set of Content Derivative type codes, which represent the minimal content derived from the basal information source at a specific stage in its lifecycle, which is sufficient to manage that source information, for example, in a repository, registry, processes and workflows, for making access control decisions, and providing query responses.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractContentDerivative {
    /** # registration

Content Registration. Content derivative that conveys sufficient information needed to register the source basal content from which it is derived.  This derivative content may be used to register the basal content as it changes status in its lifecycle.  For example, content registration may occur when the basal content is created, updated, inactive, or deleted. */
    Registration,
    /** # retrieval

Content Retrieval. A content derivative that conveys sufficient information to locate and retrieve the content. */
    Retrieval,
    /** # shareable

Shareable Content. A Content Derivative that conveys sufficient information to determine the authorized entities with which the content may be shared. */
    Shareable,
    /** # statement

Content Statement. Content derivative that has less than full fidelity to the basal information source from which it was 'transcribed'. It provides recipients with the full content representation they may require for compliance purposes, and typically include a reference to or an attached unstructured representation for recipients needing an exact copy of the legal agreement. */
    Statement,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractContentDerivative {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "registration" => Ok(Self::Registration),
            "retrieval" => Ok(Self::Retrieval),
            "shareable" => Ok(Self::Shareable),
            "statement" => Ok(Self::Statement),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractContentDerivative {
    fn as_ref(&self) -> &str {
        match self {
            Self::Registration => "registration",
            Self::Retrieval => "retrieval",
            Self::Shareable => "shareable",
            Self::Statement => "statement",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractContentDerivative {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractContentDerivative {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractDecisionMode`. This CodeSystem contains FHIR-defined contract decision mode types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractDecisionMode {
    /** # policy

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractDecisionMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractDecisionMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractDecisionMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractDecisionMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractDefinitionSubtype`. This CodeSystem contains FHIR-defined contract definition subtypes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractDefinitionSubtype {
    /** # temp

Temporary Value. To be completed */
    Temp,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractDefinitionSubtype {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "temp" => Ok(Self::Temp),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractDefinitionSubtype {
    fn as_ref(&self) -> &str {
        match self {
            Self::Temp => "temp",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractDefinitionSubtype {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractDefinitionSubtype {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractDefinitionType`. This CodeSystem contains FHIR-defined contract definition types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractDefinitionType {
    /** # temp

Temporary Value. To be completed */
    Temp,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractDefinitionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "temp" => Ok(Self::Temp),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractDefinitionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Temp => "temp",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractDefinitionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractDefinitionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractExpirationType`. This CodeSystem contains FHIR-defined contract Expiration types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractExpirationType {
    /** # breach

Breach. To be completed */
    Breach,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractExpirationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "breach" => Ok(Self::Breach),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractExpirationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Breach => "breach",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractExpirationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractExpirationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractLegalState`. This CodeSystem contains FHIR-defined contract status types. Each definition includes usage notes explaining the precedence order in contract lifecycle - i.e., while only some stages are required, the order in which they may occur is deterministic; and a map to comparable FHIR and v.3 status codes. It follows guidance about use of status codes in FHIR at http://build.fhir.org/sc.html.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractLegalState {
    /** # amended

Amended. Contract is augmented with additional information to correct errors in a predecessor or to updated values in a predecessor. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: revised; replaced. */
    Amended,
    /** # appended

Appended. Contract is augmented with additional information that was missing from a predecessor Contract. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: updated, replaced. */
    Appended,
    /** # cancelled

Cancelled. Contract is terminated due to failure of the Grantor and/or the Grantee to fulfil one or more contract provisions. Usage: Abnormal contract termination. Precedence Order = 10. Comparable FHIR and v.3 status codes: stopped; failed; aborted. */
    Cancelled,
    /** # disputed

Disputed. Contract is pended to rectify failure of the Grantor or the Grantee to fulfil contract provision(s). E.g., Grantee complaint about Grantor's failure to comply with contract provisions. Usage: Contract pended. Precedence Order = 7. Comparable FHIR and v.3 status codes: on hold; pended; suspended. */
    Disputed,
    /** # entered-in-error

Entered in Error. Contract was created in error. No Precedence Order.  Status may be applied to a Contract with any status. */
    EnteredInError,
    /** # executable

Executable. Contract execution pending; may be executed when either the Grantor or the Grantee accepts the contract provisions by signing. I.e., where either the Grantor or the Grantee has signed, but not both. E.g., when an insurance applicant signs the insurers application, which references the policy. Usage: Optional first step of contract execution activity.  May be skipped and contracting activity moves directly to executed state. Precedence Order = 3. Comparable FHIR and v.3 status codes: draft; preliminary; planned; intended; active. */
    Executable,
    /** # executed

Executed. Contract is activated for period stipulated when both the Grantor and Grantee have signed it. Usage: Required state for normal completion of contracting activity.  Precedence Order = 6. Comparable FHIR and v.3 status codes: accepted; completed. */
    Executed,
    /** # negotiable

Negotiable. Contract execution is suspended while either or both the Grantor and Grantee propose and consider new or revised contract provisions. I.e., where the party which has not signed proposes changes to the terms.  E .g., a life insurer declines to agree to the signed application because the life insurer has evidence that the applicant, who asserted to being younger or a non-smoker to get a lower premium rate - but offers instead to agree to a higher premium based on the applicants actual age or smoking status. Usage: Optional contract activity between executable and executed state. Precedence Order = 4. Comparable FHIR and v.3 status codes: in progress; review; held. */
    Negotiable,
    /** # offered

Offered. Contract is a proposal by either the Grantor or the Grantee. Aka - A Contract hard copy or electronic 'template', 'form' or 'application'. E.g., health insurance application; consent directive form. Usage: Beginning of contract negotiation, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 2. Comparable FHIR and v.3 status codes: requested; new. */
    Offered,
    /** # policy

Policy. Contract template is available as the basis for an application or offer by the Grantor or Grantee. E.g., health insurance policy; consent directive policy.  Usage: Required initial contract activity, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 1. Comparable FHIR and v.3 status codes: proposed; intended. */
    Policy,
    /** # rejected

Rejected.  Execution of the Contract is not completed because either or both the Grantor and Grantee decline to accept some or all of the contract provisions. Usage: Optional contract activity between executable and abnormal termination. Precedence Order = 5. Comparable FHIR and v.3 status codes:  stopped; cancelled. */
    Rejected,
    /** # renewed

Renewed. Beginning of a successor Contract at the termination of predecessor Contract lifecycle. Usage: Follows termination of a preceding Contract that has reached its expiry date. Precedence Order = 13. Comparable FHIR and v.3 status codes: superseded. */
    Renewed,
    /** # resolved

Resolved. Contract is reactivated after being pended because of faulty execution. *E.g., competency of the signer(s), or where the policy is substantially different from and did not accompany the application/form so that the applicant could not compare them. Aka - ''reactivated''. Usage: Optional stage where a pended contract is reactivated. Precedence Order = 8. Comparable FHIR and v.3 status codes: reactivated. */
    Resolved,
    /** # revoked

Revoked. A Contract that is rescinded.  May be required prior to replacing with an updated Contract. Comparable FHIR and v.3 status codes: nullified. */
    Revoked,
    /** # terminated

Terminated. Contract reaches its expiry date. It might or might not be renewed or renegotiated. Usage: Normal end of contract period. Precedence Order = 12. Comparable FHIR and v.3 status codes: Obsoleted. */
    Terminated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractLegalState {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "disputed" => Ok(Self::Disputed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "executable" => Ok(Self::Executable),
            "executed" => Ok(Self::Executed),
            "negotiable" => Ok(Self::Negotiable),
            "offered" => Ok(Self::Offered),
            "policy" => Ok(Self::Policy),
            "rejected" => Ok(Self::Rejected),
            "renewed" => Ok(Self::Renewed),
            "resolved" => Ok(Self::Resolved),
            "revoked" => Ok(Self::Revoked),
            "terminated" => Ok(Self::Terminated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractLegalState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Disputed => "disputed",
            Self::EnteredInError => "entered-in-error",
            Self::Executable => "executable",
            Self::Executed => "executed",
            Self::Negotiable => "negotiable",
            Self::Offered => "offered",
            Self::Policy => "policy",
            Self::Rejected => "rejected",
            Self::Renewed => "renewed",
            Self::Resolved => "resolved",
            Self::Revoked => "revoked",
            Self::Terminated => "terminated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractLegalState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractLegalState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractPartyRole`. This CodeSystem contains FHIR-defined contract party role types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractPartyRole {
    /** # flunky

FLunky. To be completed */
    Flunky,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractPartyRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "flunky" => Ok(Self::Flunky),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractPartyRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Flunky => "flunky",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractPartyRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractPartyRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractPublicationStatus`. This CodeSystem contains FHIR-defined contract publication status types. Each definition includes usage notes explaining the precedence order in contract publication lifecycle - i.e., while only some stages are required, the order in which they may occur is deterministic.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractPublicationStatus {
    /** # amended

Amended. Contract is augmented with additional information to correct errors in a predecessor or to updated values in a predecessor. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: revised; replaced. */
    Amended,
    /** # appended

Appended. Contract is augmented with additional information that was missing from a predecessor Contract. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: updated, replaced. */
    Appended,
    /** # cancelled

Cancelled. Contract is terminated due to failure of the Grantor and/or the Grantee to fulfil one or more contract provisions. Usage: Abnormal contract termination. Precedence Order = 10. Comparable FHIR and v.3 status codes: stopped; failed; aborted. */
    Cancelled,
    /** # disputed

Disputed. Contract is pended to rectify failure of the Grantor or the Grantee to fulfil contract provision(s). E.g., Grantee complaint about Grantor's failure to comply with contract provisions. Usage: Contract pended. Precedence Order = 7. Comparable FHIR and v.3 status codes: on hold; pended; suspended. */
    Disputed,
    /** # entered-in-error

Entered in Error. Contract was created in error. No Precedence Order.  Status may be applied to a Contract with any status. */
    EnteredInError,
    /** # executable

Executable. Contract execution pending; may be executed when either the Grantor or the Grantee accepts the contract provisions by signing. I.e., where either the Grantor or the Grantee has signed, but not both. E.g., when an insurance applicant signs the insurers application, which references the policy. Usage: Optional first step of contract execution activity.  May be skipped and contracting activity moves directly to executed state. Precedence Order = 3. Comparable FHIR and v.3 status codes: draft; preliminary; planned; intended; active. */
    Executable,
    /** # executed

Executed. Contract is activated for period stipulated when both the Grantor and Grantee have signed it. Usage: Required state for normal completion of contracting activity.  Precedence Order = 6. Comparable FHIR and v.3 status codes: accepted; completed. */
    Executed,
    /** # negotiable

Negotiable. Contract execution is suspended while either or both the Grantor and Grantee propose and consider new or revised contract provisions. I.e., where the party which has not signed proposes changes to the terms.  E .g., a life insurer declines to agree to the signed application because the life insurer has evidence that the applicant, who asserted to being younger or a non-smoker to get a lower premium rate - but offers instead to agree to a higher premium based on the applicants actual age or smoking status. Usage: Optional contract activity between executable and executed state. Precedence Order = 4. Comparable FHIR and v.3 status codes: in progress; review; held. */
    Negotiable,
    /** # offered

Offered. Contract is a proposal by either the Grantor or the Grantee. Aka - A Contract hard copy or electronic 'template', 'form' or 'application'. E.g., health insurance application; consent directive form. Usage: Beginning of contract negotiation, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 2. Comparable FHIR and v.3 status codes: requested; new. */
    Offered,
    /** # policy

Policy. Contract template is available as the basis for an application or offer by the Grantor or Grantee. E.g., health insurance policy; consent directive policy.  Usage: Required initial contract activity, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 1. Comparable FHIR and v.3 status codes: proposed; intended. */
    Policy,
    /** # rejected

Rejected.  Execution of the Contract is not completed because either or both the Grantor and Grantee decline to accept some or all of the contract provisions. Usage: Optional contract activity between executable and abnormal termination. Precedence Order = 5. Comparable FHIR and v.3 status codes:  stopped; cancelled. */
    Rejected,
    /** # renewed

Renewed. Beginning of a successor Contract at the termination of predecessor Contract lifecycle. Usage: Follows termination of a preceding Contract that has reached its expiry date. Precedence Order = 13. Comparable FHIR and v.3 status codes: superseded. */
    Renewed,
    /** # resolved

Resolved. Contract is reactivated after being pended because of faulty execution. *E.g., competency of the signer(s), or where the policy is substantially different from and did not accompany the application/form so that the applicant could not compare them. Aka - ''reactivated''. Usage: Optional stage where a pended contract is reactivated. Precedence Order = 8. Comparable FHIR and v.3 status codes: reactivated. */
    Resolved,
    /** # revoked

Revoked. A Contract that is rescinded.  May be required prior to replacing with an updated Contract. Comparable FHIR and v.3 status codes: nullified. */
    Revoked,
    /** # terminated

Terminated. Contract reaches its expiry date. It might or might not be renewed or renegotiated. Usage: Normal end of contract period. Precedence Order = 12. Comparable FHIR and v.3 status codes: Obsoleted. */
    Terminated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractPublicationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "disputed" => Ok(Self::Disputed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "executable" => Ok(Self::Executable),
            "executed" => Ok(Self::Executed),
            "negotiable" => Ok(Self::Negotiable),
            "offered" => Ok(Self::Offered),
            "policy" => Ok(Self::Policy),
            "rejected" => Ok(Self::Rejected),
            "renewed" => Ok(Self::Renewed),
            "resolved" => Ok(Self::Resolved),
            "revoked" => Ok(Self::Revoked),
            "terminated" => Ok(Self::Terminated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractPublicationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Disputed => "disputed",
            Self::EnteredInError => "entered-in-error",
            Self::Executable => "executable",
            Self::Executed => "executed",
            Self::Negotiable => "negotiable",
            Self::Offered => "offered",
            Self::Policy => "policy",
            Self::Rejected => "rejected",
            Self::Renewed => "renewed",
            Self::Resolved => "resolved",
            Self::Revoked => "revoked",
            Self::Terminated => "terminated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractPublicationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractPublicationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractScope`. This CodeSystem contains FHIR-defined contract Expiration types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractScope {
    /** # policy

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractScope {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractScope {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractScope {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractScope {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractSecurityCategory`. This CodeSystem contains FHIR-defined contract security category types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractSecurityCategory {
    /** # policy

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSecurityCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSecurityCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractSecurityCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSecurityCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractSecurityClassification`. This CodeSystem contains FHIR-defined contract security classification types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractSecurityClassification {
    /** # policy

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSecurityClassification {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSecurityClassification {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractSecurityClassification {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSecurityClassification {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractSecurityControl`. This CodeSystem contains FHIR-defined contract security control types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractSecurityControl {
    /** # policy

Policy. To be completed */
    Policy,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSecurityControl {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "policy" => Ok(Self::Policy),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSecurityControl {
    fn as_ref(&self) -> &str {
        match self {
            Self::Policy => "policy",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractSecurityControl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSecurityControl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractSignerTypeCodes`. This value set includes sample Contract Signer Type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractSignerTypeCodes {
    /** # AFFL

Affiliate. An entity that has a business or professional relationship with another entity in accordance with an agreement. */
    Affl,
    /** # AGNT

Agent. An entity that acts or is authorized to act on behalf of another entity in accordance with an agreement. */
    Agnt,
    /** # AMENDER

Amender. A person who has corrected, edited, or amended pre-existing information. */
    Amender,
    /** # ASSIGNED

Assigned Entity. An agent role in which the agent is an Entity acting in the employ of an organization. The focus is on functional role on behalf of the organization, unlike the Employee role where the focus is on the 'Human Resources' relationship between the employee and the organization. */
    Assigned,
    /** # AUT

Author. An entity that authored specific content. There can be multiple authors of content, which may take such forms as a contract, a healthcare record entry or document, a policy, or a consent directive. */
    Aut,
    /** # AUTHN

Authenticator. A person in the role of verifier who attests to the accuracy of an act, but who does not have privileges to legally authenticate information content. An example would be a resident physician who sees a patient and dictates a note, then later signs it. The resident's signature constitutes an authentication. */
    Authn,
    /** # CIT

Citizen. The member of a jurisdiction afforded certain rights and encumbered with certain obligation in accordance with jurisdictional policy. */
    Cit,
    /** # CLAIMANT

Claimant. A party that makes a claim for coverage under a policy. */
    Claimant,
    /** # COAUTH

Co-Author. The entity that co-authored content. There can be multiple co-authors of content, which may take such forms as a contract, a healthcare record entry or document, a policy, or a consent directive. */
    Coauth,
    /** # CONSENTER

Consenter. A patient or patient representative who is the grantee in a healthcare related agreement such as a consent for healthcare services, advanced directive, or a privacy consent directive in accordance with jurisdictional, organizational, or patient policy. */
    Consenter,
    /** # CONSWIT

Consent Witness. A person who has witnessed and attests to observing a patient being counseled about a healthcare related agreement such as a consent for healthcare services, advanced directive, or a privacy consent directive. */
    Conswit,
    /** # CONT

Contact. A person or an organization that provides or receives information regarding another entity. Examples; patient NOK and emergency contacts; guarantor contact; employer contact. */
    Cont,
    /** # COPART

Co-Participant. A person who participates in the generation of and attest to veracity of content but is not an author or co-author. For example, a surgeon who is required by institutional, regulatory, or legal rules to sign an operative report, but who was not involved in the authorship of that report. */
    Copart,
    /** # COVPTY

Covered Party. An entity, which is the insured, that receives benefits such as healthcare services, reimbursement for out-of-pocket expenses, or compensation for losses through coverage under the terms of an insurance policy. The underwriter of that policy is the scoping entity. The covered party receives coverage because of some contractual or other relationship with the holder of that policy. Note that a particular policy may cover several individuals one of whom may be, but need not be, the policy holder. Thus the notion of covered party is a role that is distinct from that of the policy holder. */
    Covpty,
    /** # DELEGATEE

Delegatee. A party to whom some right or authority is delegated by a delegator. */
    Delegatee,
    /** # DEPEND

Dependent. A person covered under an insurance policy or program based on an association with a subscriber, which is recognized by the policy holder. The dependent has an association with the subscriber such as a financial dependency or personal relationship such as that of a spouse, or a natural or adopted child. The policy holder may be required by law to recognize certain associations or may have discretion about the associations. For example, a policy holder may dictate the criteria for the dependent status of adult children who are students, such as requiring full time enrollment, or may recognize domestic partners as dependents. Under certain circumstances, the dependent may be under the indirect authority of a responsible party acting as a surrogate for the subscriber, for example, if the subscriber is differently-abled or deceased, a guardian ad lidem or estate executor may be appointed to assume the subscriber's legal standing in the relationship with the dependent. */
    Depend,
    /** # DPOWATT

Durable Power of Attorney. A person who has been granted the authority to represent or act on another's behalf generally in a manner which is a legally binding upon the person giving such authority as if he or she personally were to do the acts. Unlike ordinary powers of attorney, durable powers can survive for long periods of time, and again, unlike standard powers of attorney, durable powers can continue after incompetency. */
    Dpowatt,
    /** # EMGCON

Emergency Contact. An entity to be contacted in the event of an emergency */
    Emgcon,
    /** # EVTWIT

Event Witness. A person who attests to observing an occurrence.  For example, the witness has observed a procedure and is attesting to this fact. */
    Evtwit,
    /** # EXCEST

Executor of Estate. A person who has been granted the authority to act as an estate executor for a deceased person who was the responsible party. */
    Excest,
    /** # GRANTEE

Grantee. A person who grants to another person the authority to represent or act on that person's behalf.  Examples include (1) exercising specific rights belonging to the grantee; (2) performing specific duties on behalf of a grantee; and (3) making specific decisions concerning a grantee. */
    Grantee,
    /** # GRANTOR

Grantor. A person who has been granted the authority to represent or act on another's behalf. Examples include (1) exercising specific rights belonging to the grantee; (2) performing specific duties on behalf of a grantee; and (3) making specific decisions concerning a grantee. */
    Grantor,
    /** # GUADLTM

Guardian ad lidem. A person appointed by the court to look out for the best interests of a minor child during the course of legal proceedings. */
    Guadltm,
    /** # GUAR

Guarantor. A person or organization contractually recognized by the issuer as an entity that has assumed fiscal responsibility (e.g., by making or giving a promise, assurance, or pledge) for another entity's financial obligations by guaranteeing to pay for amounts owed to a particular account.  In a healthcare context, the account may be a patient's billing account for services rendered by a provider or a health plan premium account. */
    Guar,
    /** # GUARD

Guardian. A person or organization legally empowered with responsibility for the care of a ward. */
    Guard,
    /** # HPOWATT

Healthcare Power of Attorney. A person who has been granted the authority to represent or act on another's behalf for healthcare related matters in a manner which is a legally binding upon the person giving such authority as if he or she personally were to do the acts. Examples include (1) exercising specific healthcare legal rights belonging to the grantee such as signing a consent directive; (2) performing specific healthcare related legal duties on behalf of a grantee such as claims payment; and (3) making specific healthcare legal decisions concerning a grantee such as consenting to healthcare services. */
    Hpowatt,
    /** # HPROV

Healthcare Provider. An entity that is authorized to provide health care services by an authorizing organization or jurisdiction. */
    Hprov,
    /** # INF

Informant. An entity that is the source of reported information (e.g., a next of kin who answers questions about the patient's history). For history questions, the patient is logically an informant, yet the informant of history questions is implicitly the subject. */
    Inf,
    /** # INSBJ

Investigation Subject. An entity that is the subject of an investigation. This role is scoped by the party responsible for the investigation. */
    Insbj,
    /** # INTPRT

Interpreter. A person who converts spoken or written language into the language of key participants in an event such as when a provider is obtaining a patient's consent to treatment or permission to disclose information. */
    Intprt,
    /** # LEGAUTHN

Legal Authenticator. A person in the role of verifier who attests to the accuracy of information content, and who has privileges to certify the legal authenticity of that content with a signature that constitutes a legal authentication.  For example, a licensed physician who signs a consult authored by a resident physician who authenticated it. */
    Legauthn,
    /** # NMDINS

Named Insured. A party to an insurance policy under which the insurer agrees to indemnify for losses, provides benefits for, or renders services. A named insured may be either a person, non-person living subject, or an organization, or a group of persons, non-person living subject that is the named insured under a comprehensive automobile, disability, or property and casualty policy.  The named insured and might or might not be the policy holder. */
    Nmdins,
    /** # NOK

Next of Kin. A person, who is a type of contact, designated to receive notifications on behalf of another person who is a relative. */
    Nok,
    /** # NOTARY

Notary. The party credentialed to legally attest to the contract binding by verifying the identity and capacity of the grantor and grantee, and witnessing their signing of the contract or agreement such as a real estate transaction, pre-nuptial agreement, or a will. */
    Notary,
    /** # PAT

Patient. A person, animal, or other living subject that is the actual or potential recipient of health care services. */
    Pat,
    /** # POWATT

Power of Attorney. A person who has been granted the authority to represent or act on another's behalf generally in a manner which is a legally binding upon the person giving such authority as if he or she personally were to do the acts. Examples include (1) exercising specific legal rights belonging to the grantee such as signing a contract; (2) performing specific legal duties on behalf of a grantee such as making loan payments; and (3) making specific legal decisions concerning a grantee such as financial investment decisions. */
    Powatt,
    /** # PRIMAUTH

Primary Author. An entity that is the primary or sole author of information content.  In the healthcare context, there can be only one primary author of health information content in a record entry or document. */
    Primauth,
    /** # PRIRECIP

Primary Responsible Party. An entity that may, should receive, or has received information or an object to which it was primarily addressed. */
    Prirecip,
    /** # RECIP

Recipient. An entity that may, should receive, or has received information or an object, which might not have been primarily addressed to it. For example, the staff of a provider, a clearinghouse, or other intermediary. */
    Recip,
    /** # RESPRSN

Responsible Party. An entity that has legal responsibility for another party. */
    Resprsn,
    /** # REVIEWER

Reviewer. A person, device, or algorithm that has used approved criteria for filtered data for inclusion into the patient record.  Examples: (1) a medical records clerk who scans a document for inclusion in the medical record, enters header information, or catalogues and classifies the data, or a combination thereof; (2) a gateway that receives data from another computer system and interprets that data or changes its format, or both, before entering it into the patient record. */
    Reviewer,
    /** # SOURCE

Source. An automated data source that generates a signature along with content. Examples: (1) the signature for an image that is generated by a device for inclusion in the patient record; (2) the signature for an ECG derived by an ECG system for inclusion in the patient record; (3) the data from a biomedical monitoring device or system that is for inclusion in the patient record. */
    Source,
    /** # SPOWATT

Special Power of Attorney. A person who has been granted the authority to represent or act on another's behalf for a limited set of specific matters in a manner which is a legally binding upon the person giving such authority as if he or she personally were to do the acts. Examples include (1) exercising specific legal rights belonging to the grantee such as drafting a will; (2) performing specific legal duties on behalf of a grantee such as making a reversible mortgage to pay for end of life expenses; and (3) making specific legal decisions concerning a grantee such as managing a trust. */
    Spowatt,
    /** # TRANS

Transcriber. An entity entering the data into the originating system. This includes the transcriptionist for dictated text transcribed into electronic form. */
    Trans,
    /** # VALID

Validator. A person who validates a health information document for inclusion in the patient record. For example, a medical student or resident is credentialed to perform history or physical examinations and to write progress notes. The attending physician signs the history and physical examination to validate the entry for inclusion in the patient's medical record. */
    Valid,
    /** # VERF

Verifier. A person who asserts the correctness and appropriateness of an act or the recording of the act, and is accountable for the assertion that the act or the recording of the act complies with jurisdictional or organizational policy. For example, a physician is required to countersign a verbal order that has previously been recorded in the medical record by a registered nurse who has carried out the verbal order. */
    Verf,
    /** # WIT

Witness. A person witnessing the signature of another party. A witness is not knowledgeable about the content being signed, much less approves of anything stated in the content. For example, an advanced directive witness or a witness that a party to a contract signed that certain demographic or financial information is truthful. */
    Wit,
    /** # delegator

Delegator. A party that delegates a right or authority to another party. */
    Delegator,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSignerTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AFFL" => Ok(Self::Affl),
            "AGNT" => Ok(Self::Agnt),
            "AMENDER" => Ok(Self::Amender),
            "ASSIGNED" => Ok(Self::Assigned),
            "AUT" => Ok(Self::Aut),
            "AUTHN" => Ok(Self::Authn),
            "CIT" => Ok(Self::Cit),
            "CLAIMANT" => Ok(Self::Claimant),
            "COAUTH" => Ok(Self::Coauth),
            "CONSENTER" => Ok(Self::Consenter),
            "CONSWIT" => Ok(Self::Conswit),
            "CONT" => Ok(Self::Cont),
            "COPART" => Ok(Self::Copart),
            "COVPTY" => Ok(Self::Covpty),
            "DELEGATEE" => Ok(Self::Delegatee),
            "DEPEND" => Ok(Self::Depend),
            "DPOWATT" => Ok(Self::Dpowatt),
            "EMGCON" => Ok(Self::Emgcon),
            "EVTWIT" => Ok(Self::Evtwit),
            "EXCEST" => Ok(Self::Excest),
            "GRANTEE" => Ok(Self::Grantee),
            "GRANTOR" => Ok(Self::Grantor),
            "GUADLTM" => Ok(Self::Guadltm),
            "GUAR" => Ok(Self::Guar),
            "GUARD" => Ok(Self::Guard),
            "HPOWATT" => Ok(Self::Hpowatt),
            "HPROV" => Ok(Self::Hprov),
            "INF" => Ok(Self::Inf),
            "INSBJ" => Ok(Self::Insbj),
            "INTPRT" => Ok(Self::Intprt),
            "LEGAUTHN" => Ok(Self::Legauthn),
            "NMDINS" => Ok(Self::Nmdins),
            "NOK" => Ok(Self::Nok),
            "NOTARY" => Ok(Self::Notary),
            "PAT" => Ok(Self::Pat),
            "POWATT" => Ok(Self::Powatt),
            "PRIMAUTH" => Ok(Self::Primauth),
            "PRIRECIP" => Ok(Self::Prirecip),
            "RECIP" => Ok(Self::Recip),
            "RESPRSN" => Ok(Self::Resprsn),
            "REVIEWER" => Ok(Self::Reviewer),
            "SOURCE" => Ok(Self::Source),
            "SPOWATT" => Ok(Self::Spowatt),
            "TRANS" => Ok(Self::Trans),
            "VALID" => Ok(Self::Valid),
            "VERF" => Ok(Self::Verf),
            "WIT" => Ok(Self::Wit),
            "delegator" => Ok(Self::Delegator),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSignerTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Affl => "AFFL",
            Self::Agnt => "AGNT",
            Self::Amender => "AMENDER",
            Self::Assigned => "ASSIGNED",
            Self::Aut => "AUT",
            Self::Authn => "AUTHN",
            Self::Cit => "CIT",
            Self::Claimant => "CLAIMANT",
            Self::Coauth => "COAUTH",
            Self::Consenter => "CONSENTER",
            Self::Conswit => "CONSWIT",
            Self::Cont => "CONT",
            Self::Copart => "COPART",
            Self::Covpty => "COVPTY",
            Self::Delegatee => "DELEGATEE",
            Self::Depend => "DEPEND",
            Self::Dpowatt => "DPOWATT",
            Self::Emgcon => "EMGCON",
            Self::Evtwit => "EVTWIT",
            Self::Excest => "EXCEST",
            Self::Grantee => "GRANTEE",
            Self::Grantor => "GRANTOR",
            Self::Guadltm => "GUADLTM",
            Self::Guar => "GUAR",
            Self::Guard => "GUARD",
            Self::Hpowatt => "HPOWATT",
            Self::Hprov => "HPROV",
            Self::Inf => "INF",
            Self::Insbj => "INSBJ",
            Self::Intprt => "INTPRT",
            Self::Legauthn => "LEGAUTHN",
            Self::Nmdins => "NMDINS",
            Self::Nok => "NOK",
            Self::Notary => "NOTARY",
            Self::Pat => "PAT",
            Self::Powatt => "POWATT",
            Self::Primauth => "PRIMAUTH",
            Self::Prirecip => "PRIRECIP",
            Self::Recip => "RECIP",
            Self::Resprsn => "RESPRSN",
            Self::Reviewer => "REVIEWER",
            Self::Source => "SOURCE",
            Self::Spowatt => "SPOWATT",
            Self::Trans => "TRANS",
            Self::Valid => "VALID",
            Self::Verf => "VERF",
            Self::Wit => "WIT",
            Self::Delegator => "delegator",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractSignerTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSignerTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractStatus`. This CodeSystem contains FHIR-defined contract status types. Each definition includes usage notes explaining the precedence order in contract lifecycle - i.e., while only some stages are required, the order in which they may occur is deterministic; and a map to comparable FHIR and v.3 status codes. It follows guidance about use of status codes in FHIR at http://build.fhir.org/sc.html.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractStatus {
    /** # amended

Amended. Contract is augmented with additional information to correct errors in a predecessor or to updated values in a predecessor. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: revised; replaced. */
    Amended,
    /** # appended

Appended. Contract is augmented with additional information that was missing from a predecessor Contract. Usage: Contract altered within effective time. Precedence Order = 9. Comparable FHIR and v.3 status codes: updated, replaced. */
    Appended,
    /** # cancelled

Cancelled. Contract is terminated due to failure of the Grantor and/or the Grantee to fulfil one or more contract provisions. Usage: Abnormal contract termination. Precedence Order = 10. Comparable FHIR and v.3 status codes: stopped; failed; aborted. */
    Cancelled,
    /** # disputed

Disputed. Contract is pended to rectify failure of the Grantor or the Grantee to fulfil contract provision(s). E.g., Grantee complaint about Grantor's failure to comply with contract provisions. Usage: Contract pended. Precedence Order = 7. Comparable FHIR and v.3 status codes: on hold; pended; suspended. */
    Disputed,
    /** # entered-in-error

Entered in Error. Contract was created in error. No Precedence Order.  Status may be applied to a Contract with any status. */
    EnteredInError,
    /** # executable

Executable. Contract execution pending; may be executed when either the Grantor or the Grantee accepts the contract provisions by signing. I.e., where either the Grantor or the Grantee has signed, but not both. E.g., when an insurance applicant signs the insurers application, which references the policy. Usage: Optional first step of contract execution activity.  May be skipped and contracting activity moves directly to executed state. Precedence Order = 3. Comparable FHIR and v.3 status codes: draft; preliminary; planned; intended; active. */
    Executable,
    /** # executed

Executed. Contract is activated for period stipulated when both the Grantor and Grantee have signed it. Usage: Required state for normal completion of contracting activity.  Precedence Order = 6. Comparable FHIR and v.3 status codes: accepted; completed. */
    Executed,
    /** # negotiable

Negotiable. Contract execution is suspended while either or both the Grantor and Grantee propose and consider new or revised contract provisions. I.e., where the party which has not signed proposes changes to the terms.  E .g., a life insurer declines to agree to the signed application because the life insurer has evidence that the applicant, who asserted to being younger or a non-smoker to get a lower premium rate - but offers instead to agree to a higher premium based on the applicants actual age or smoking status. Usage: Optional contract activity between executable and executed state. Precedence Order = 4. Comparable FHIR and v.3 status codes: in progress; review; held. */
    Negotiable,
    /** # offered

Offered. Contract is a proposal by either the Grantor or the Grantee. Aka - A Contract hard copy or electronic 'template', 'form' or 'application'. E.g., health insurance application; consent directive form. Usage: Beginning of contract negotiation, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 2. Comparable FHIR and v.3 status codes: requested; new. */
    Offered,
    /** # policy

Policy. Contract template is available as the basis for an application or offer by the Grantor or Grantee. E.g., health insurance policy; consent directive policy.  Usage: Required initial contract activity, which may have been completed as a precondition because used for 0..* contracts. Precedence Order = 1. Comparable FHIR and v.3 status codes: proposed; intended. */
    Policy,
    /** # rejected

Rejected.  Execution of the Contract is not completed because either or both the Grantor and Grantee decline to accept some or all of the contract provisions. Usage: Optional contract activity between executable and abnormal termination. Precedence Order = 5. Comparable FHIR and v.3 status codes:  stopped; cancelled. */
    Rejected,
    /** # renewed

Renewed. Beginning of a successor Contract at the termination of predecessor Contract lifecycle. Usage: Follows termination of a preceding Contract that has reached its expiry date. Precedence Order = 13. Comparable FHIR and v.3 status codes: superseded. */
    Renewed,
    /** # resolved

Resolved. Contract is reactivated after being pended because of faulty execution. *E.g., competency of the signer(s), or where the policy is substantially different from and did not accompany the application/form so that the applicant could not compare them. Aka - ''reactivated''. Usage: Optional stage where a pended contract is reactivated. Precedence Order = 8. Comparable FHIR and v.3 status codes: reactivated. */
    Resolved,
    /** # revoked

Revoked. A Contract that is rescinded.  May be required prior to replacing with an updated Contract. Comparable FHIR and v.3 status codes: nullified. */
    Revoked,
    /** # terminated

Terminated. Contract reaches its expiry date. It might or might not be renewed or renegotiated. Usage: Normal end of contract period. Precedence Order = 12. Comparable FHIR and v.3 status codes: Obsoleted. */
    Terminated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "disputed" => Ok(Self::Disputed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "executable" => Ok(Self::Executable),
            "executed" => Ok(Self::Executed),
            "negotiable" => Ok(Self::Negotiable),
            "offered" => Ok(Self::Offered),
            "policy" => Ok(Self::Policy),
            "rejected" => Ok(Self::Rejected),
            "renewed" => Ok(Self::Renewed),
            "resolved" => Ok(Self::Resolved),
            "revoked" => Ok(Self::Revoked),
            "terminated" => Ok(Self::Terminated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Disputed => "disputed",
            Self::EnteredInError => "entered-in-error",
            Self::Executable => "executable",
            Self::Executed => "executed",
            Self::Negotiable => "negotiable",
            Self::Offered => "offered",
            Self::Policy => "policy",
            Self::Rejected => "rejected",
            Self::Renewed => "renewed",
            Self::Resolved => "resolved",
            Self::Revoked => "revoked",
            Self::Terminated => "terminated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractSubtypeCodes`. This value set includes sample Contract Subtype codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractSubtypeCodes {
    /** # disclosure-ca

Disclosure-CA. Canadian health information disclosure policy. */
    DisclosureCa,
    /** # disclosure-us

Disclosure-US. United States health information disclosure policy. */
    DisclosureUs,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractSubtypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "disclosure-ca" => Ok(Self::DisclosureCa),
            "disclosure-us" => Ok(Self::DisclosureUs),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractSubtypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::DisclosureCa => "disclosure-ca",
            Self::DisclosureUs => "disclosure-us",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractSubtypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractSubtypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractTermSubtypeCodes`. This value set includes sample Contract Term SubType codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractTermSubtypeCodes {
    /** # condition

Condition. Terms that go to the very root of a contract. */
    Condition,
    /** # innominate

Innominate. Breach of which might or might not go to the root of the contract depending upon the nature of the breach */
    Innominate,
    /** # warranty

Warranty. Less imperative than a condition, so the contract will survive a breach */
    Warranty,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractTermSubtypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "condition" => Ok(Self::Condition),
            "innominate" => Ok(Self::Innominate),
            "warranty" => Ok(Self::Warranty),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractTermSubtypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Condition => "condition",
            Self::Innominate => "innominate",
            Self::Warranty => "warranty",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractTermSubtypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractTermSubtypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractTermTypeCodes`. This value set includes sample Contract Term Type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractTermTypeCodes {
    /** # statutory

Statutory. Based on specialized statutes that deal with particular subjects. */
    Statutory,
    /** # subject-to

Subject To. Execution of the term in the contract is conditional on the execution of other actions. */
    SubjectTo,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractTermTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "statutory" => Ok(Self::Statutory),
            "subject-to" => Ok(Self::SubjectTo),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractTermTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Statutory => "statutory",
            Self::SubjectTo => "subject-to",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractTermTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractTermTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContractTypeCodes`. This value set includes sample Contract Type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ContractTypeCodes {
    /** # consent

Consent. Consent Directive. */
    Consent,
    /** # disclosure

Disclosure. Information disclosure policy. */
    Disclosure,
    /** # healthinsurance

Health Insurance. Health Insurance policy. */
    Healthinsurance,
    /** # privacy

Privacy. Privacy policy. */
    Privacy,
    /** # supply

Supply Contract. Contract to supply goods or services. */
    Supply,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ContractTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "consent" => Ok(Self::Consent),
            "disclosure" => Ok(Self::Disclosure),
            "healthinsurance" => Ok(Self::Healthinsurance),
            "privacy" => Ok(Self::Privacy),
            "supply" => Ok(Self::Supply),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ContractTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consent => "consent",
            Self::Disclosure => "disclosure",
            Self::Healthinsurance => "healthinsurance",
            Self::Privacy => "privacy",
            Self::Supply => "supply",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ContractTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContractTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContributorRole`. Used to code the format of the display string.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorRole {
    /** # author

Author/Creator. An entity primarily responsible for making the resource, often called author or creator */
    Author,
    /** # editor

Editor. Entity that revises or has authority to control the content */
    Editor,
    /** # endorser

Endorser. Entity that supports, approves, or advocates for the content */
    Endorser,
    /** # funder

Funder. Entity that supplies financial support */
    Funder,
    /** # informant

Informant. Entity that supplies information */
    Informant,
    /** # publisher

Publisher. Entity that makes the content available for public use */
    Publisher,
    /** # reviewer

Reviewer. Entity that examines the content, formally or informally, and suggests revisions or comments */
    Reviewer,
}
impl ::core::str::FromStr for ContributorRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "author" => Ok(Self::Author),
            "editor" => Ok(Self::Editor),
            "endorser" => Ok(Self::Endorser),
            "funder" => Ok(Self::Funder),
            "informant" => Ok(Self::Informant),
            "publisher" => Ok(Self::Publisher),
            "reviewer" => Ok(Self::Reviewer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Author => "author",
            Self::Editor => "editor",
            Self::Endorser => "endorser",
            Self::Funder => "funder",
            Self::Informant => "informant",
            Self::Publisher => "publisher",
            Self::Reviewer => "reviewer",
        }
    }
}
impl<'de> Deserialize<'de> for ContributorRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContributorSummarySource`. Used to code the producer or rule for creating the display string.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorSummarySource {
    /** # article-copy

Copied from article. Data copied by human from article text. */
    ArticleCopy,
    /** # citation-manager

Reported by citation manager. Data copied by machine from citation manager data. */
    CitationManager,
    /** # custom

custom format. Custom format (may be described in text note). */
    Custom,
    /** # publisher-data

Publisher provided. Data copied by machine from publisher data. */
    PublisherData,
}
impl ::core::str::FromStr for ContributorSummarySource {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "article-copy" => Ok(Self::ArticleCopy),
            "citation-manager" => Ok(Self::CitationManager),
            "custom" => Ok(Self::Custom),
            "publisher-data" => Ok(Self::PublisherData),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorSummarySource {
    fn as_ref(&self) -> &str {
        match self {
            Self::ArticleCopy => "article-copy",
            Self::CitationManager => "citation-manager",
            Self::Custom => "custom",
            Self::PublisherData => "publisher-data",
        }
    }
}
impl<'de> Deserialize<'de> for ContributorSummarySource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorSummarySource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContributorSummaryStyle`. Used to code the format of the display string.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorSummaryStyle {
    /** # a1full

First author (full name) et al. Example: Jennifer Laskowski et al. */
    A1Full,
    /** # a1init

First author (last name first initials) et al. Example: Laskowski J et al. */
    A1Init,
    /** # a3full

First 3 authors (full name) et al. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, et al. */
    A3Full,
    /** # a3init

First 3 authors (last name first initials) et al. Example:  Laskowski J, Renner B, Pickering MC, et al. */
    A3Init,
    /** # a6full

First 6 authors (full name) et al. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, et al. */
    A6Full,
    /** # a6init

First 6 authors (last name first initials) et al. Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, et al. */
    A6Init,
    /** # aallfull

All authors (full name). Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, Joshua M. Thurman. */
    Aallfull,
    /** # aallfullwithampersand

All authors (full name) with an ampersand before last author. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, & Joshua M. Thurman. */
    Aallfullwithampersand,
    /** # aallfullwithand

All authors (full name) with and before last author. Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, and Joshua M. Thurman. */
    Aallfullwithand,
    /** # aallinit

All authors (last name first initials). Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, Thurman JM. */
    Aallinit,
    /** # aallinitwithampersand

All authors (last name first initials) with an ampersand before last author. Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, & Thurman JM. */
    Aallinitwithampersand,
    /** # aallinitwithand

All authors (last name first initials) with and before last author. Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, and Thurman JM. */
    Aallinitwithand,
    /** # contr-full-by-contr

Contributorship statement listed by contribution with full names. Project design by Jennnifer Laskowski (JL), Experiment design by JL and Joshua M. Thurman (JMT), technical advice and study design contribution by Matthew C. Pickering, experiments performed by JL, data collection and analysis by JL, PET imaging and associated analyses by Natalie J. Serkova and Peter M. Smith-Jones, conceptual and technical guidance by Eric T. Clambey (ETC) and Raphael A. Nemenoff (RAN), manuscript writing by JL and JMT, manuscript revised critically by JL, Brandon Renner, ETC, and RAN. */
    ContrFullByContr,
    /** # contr-full-by-person

Contributorship statement listed by person with full names. Jennnifer Laskowski designed project; developed and performed experiments; collected and analyzed data; wrote and revised manuscript. Brandon Renner performed critical review of manuscript. Matthew C. Pickering provided technical advice and contributed to study design. Natalie J. Serkova and Peter M. Smith-Jones performed PET imaging and associated analyses. Eric T. Clambey and Raphael A. Nemenoff provided conceptual and technical guidance and critical review of manuscript. Joshua M. Thurman contributed to experimental design and wrote manuscript. */
    ContrFullByPerson,
    /** # contr-init-by-contr

Contributorship statement listed by contribution with initials. Project design by JL, Experiment design by JL and JMT, technical advice and study design contribution by MCP, experiments performed by JL, data collection and analysis by JL, PET imaging and associated analyses by NJS and PMS-J, conceptual and technical guidance by ETC and RAN, manuscript writing by JL and JMT, manuscript revised critically by JL, BR, ETC, and RAN. */
    ContrInitByContr,
    /** # contr-init-by-person

Contributorship statement listed by person with initials. J.L. designed project; developed and performed experiments; collected and analyzed data; wrote and revised manuscript. B.R. performed critical review of manuscript. M.C.P. provided technical advice and contributed to study design. N.J.S and P.M.S.-J. performed PET imaging and associated analyses. E.T.C. and R.A.N provided conceptual and technical guidance and critical review of manuscript. J.M.T contributed to experimental design and wrote manuscript. */
    ContrInitByPerson,
}
impl ::core::str::FromStr for ContributorSummaryStyle {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a1full" => Ok(Self::A1Full),
            "a1init" => Ok(Self::A1Init),
            "a3full" => Ok(Self::A3Full),
            "a3init" => Ok(Self::A3Init),
            "a6full" => Ok(Self::A6Full),
            "a6init" => Ok(Self::A6Init),
            "aallfull" => Ok(Self::Aallfull),
            "aallfullwithampersand" => Ok(Self::Aallfullwithampersand),
            "aallfullwithand" => Ok(Self::Aallfullwithand),
            "aallinit" => Ok(Self::Aallinit),
            "aallinitwithampersand" => Ok(Self::Aallinitwithampersand),
            "aallinitwithand" => Ok(Self::Aallinitwithand),
            "contr-full-by-contr" => Ok(Self::ContrFullByContr),
            "contr-full-by-person" => Ok(Self::ContrFullByPerson),
            "contr-init-by-contr" => Ok(Self::ContrInitByContr),
            "contr-init-by-person" => Ok(Self::ContrInitByPerson),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorSummaryStyle {
    fn as_ref(&self) -> &str {
        match self {
            Self::A1Full => "a1full",
            Self::A1Init => "a1init",
            Self::A3Full => "a3full",
            Self::A3Init => "a3init",
            Self::A6Full => "a6full",
            Self::A6Init => "a6init",
            Self::Aallfull => "aallfull",
            Self::Aallfullwithampersand => "aallfullwithampersand",
            Self::Aallfullwithand => "aallfullwithand",
            Self::Aallinit => "aallinit",
            Self::Aallinitwithampersand => "aallinitwithampersand",
            Self::Aallinitwithand => "aallinitwithand",
            Self::ContrFullByContr => "contr-full-by-contr",
            Self::ContrFullByPerson => "contr-full-by-person",
            Self::ContrInitByContr => "contr-init-by-contr",
            Self::ContrInitByPerson => "contr-init-by-person",
        }
    }
}
impl<'de> Deserialize<'de> for ContributorSummaryStyle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorSummaryStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContributorSummaryType`. Used to code author list statement, contributorship statement, and such.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorSummaryType {
    /** # acknowledgement-list

Acknowledgment list. Display of the list of acknowledged parties as a complete string. */
    AcknowledgementList,
    /** # acknowledgment-statement

Acknowledgment statement. Statement of acknowledgment of contributions beyond those compiled for formal contributorship statements. */
    AcknowledgmentStatement,
    /** # author-string

Author string. Display of the author list as a complete string. */
    AuthorString,
    /** # competing-interests-statement

Competing interests statement. Statement of completing interests related to the creation of the cited artifact. Also called conflicts of interest or declaration of interests. */
    CompetingInterestsStatement,
    /** # contributorship-list

Contributorship list. Display of the list of contributors as a complete string. */
    ContributorshipList,
    /** # contributorship-statement

Contributorship statement. Compiled summary of contributions. */
    ContributorshipStatement,
    /** # funding-statement

Funding statement. Statement of financial support for the creation of the cited artifact. */
    FundingStatement,
}
impl ::core::str::FromStr for ContributorSummaryType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acknowledgement-list" => Ok(Self::AcknowledgementList),
            "acknowledgment-statement" => Ok(Self::AcknowledgmentStatement),
            "author-string" => Ok(Self::AuthorString),
            "competing-interests-statement" => Ok(Self::CompetingInterestsStatement),
            "contributorship-list" => Ok(Self::ContributorshipList),
            "contributorship-statement" => Ok(Self::ContributorshipStatement),
            "funding-statement" => Ok(Self::FundingStatement),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorSummaryType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AcknowledgementList => "acknowledgement-list",
            Self::AcknowledgmentStatement => "acknowledgment-statement",
            Self::AuthorString => "author-string",
            Self::CompetingInterestsStatement => "competing-interests-statement",
            Self::ContributorshipList => "contributorship-list",
            Self::ContributorshipStatement => "contributorship-statement",
            Self::FundingStatement => "funding-statement",
        }
    }
}
impl<'de> Deserialize<'de> for ContributorSummaryType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorSummaryType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ContributorType`. The type of contributor.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ContributorType {
    /** # author

Author. An author of the content of the module. */
    Author,
    /** # editor

Editor. An editor of the content of the module. */
    Editor,
    /** # endorser

Endorser. An endorser of the content of the module. */
    Endorser,
    /** # reviewer

Reviewer. A reviewer of the content of the module. */
    Reviewer,
}
impl ::core::str::FromStr for ContributorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "author" => Ok(Self::Author),
            "editor" => Ok(Self::Editor),
            "endorser" => Ok(Self::Endorser),
            "reviewer" => Ok(Self::Reviewer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ContributorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Author => "author",
            Self::Editor => "editor",
            Self::Endorser => "endorser",
            Self::Reviewer => "reviewer",
        }
    }
}
impl<'de> Deserialize<'de> for ContributorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ContributorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CoverageClassCodes`. This value set includes Coverage Class codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CoverageClassCodes {
    /** # class

Class. A class of benefits. */
    Class,
    /** # group

Group. An employee group */
    Group,
    /** # plan

Plan. A specific suite of benefits. */
    Plan,
    /** # rxbin

RX BIN. Pharmacy benefit manager's Business Identification Number. */
    Rxbin,
    /** # rxgroup

RX Group. A Pharmacy Benefit Manager specified Group number. */
    Rxgroup,
    /** # rxid

RX Id. A Pharmacy Benefit Manager specified Member ID. */
    Rxid,
    /** # rxpcn

RX PCN. A Pharmacy Benefit Manager specified Processor Control Number. */
    Rxpcn,
    /** # sequence

Sequence. A sequence number associated with a short-term continuance of the coverage. */
    Sequence,
    /** # subclass

SubClass. A subset of a class of benefits. */
    Subclass,
    /** # subgroup

SubGroup. A sub-group of an employee group */
    Subgroup,
    /** # subplan

SubPlan. A subset of a specific suite of benefits. */
    Subplan,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CoverageClassCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "class" => Ok(Self::Class),
            "group" => Ok(Self::Group),
            "plan" => Ok(Self::Plan),
            "rxbin" => Ok(Self::Rxbin),
            "rxgroup" => Ok(Self::Rxgroup),
            "rxid" => Ok(Self::Rxid),
            "rxpcn" => Ok(Self::Rxpcn),
            "sequence" => Ok(Self::Sequence),
            "subclass" => Ok(Self::Subclass),
            "subgroup" => Ok(Self::Subgroup),
            "subplan" => Ok(Self::Subplan),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CoverageClassCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Class => "class",
            Self::Group => "group",
            Self::Plan => "plan",
            Self::Rxbin => "rxbin",
            Self::Rxgroup => "rxgroup",
            Self::Rxid => "rxid",
            Self::Rxpcn => "rxpcn",
            Self::Sequence => "sequence",
            Self::Subclass => "subclass",
            Self::Subgroup => "subgroup",
            Self::Subplan => "subplan",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for CoverageClassCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CoverageClassCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CoverageCoPayTypeCodes`. This codeset includes Coverage Copayment Type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CoverageCoPayTypeCodes {
    /** # copay

Copay Amount. A standard fixed currency amount applied to all classes or service or product not otherwise specified. */
    Copay,
    /** # copaypct

Copay Percentage. A standard percentage applied to all classes or service or product not otherwise specified. */
    Copaypct,
    /** # deductible

Deductible. The accumulated amount of patient payment before the coverage begins to pay for services. */
    Deductible,
    /** # emergency

Emergency. An episode in an emergency department. */
    Emergency,
    /** # gpvisit

GP Office Visit. An office visit for a general practitioner of a discipline. */
    Gpvisit,
    /** # inpthosp

Inpatient Hospital. An episode of an Inpatient hospital stay. */
    Inpthosp,
    /** # maxoutofpocket

Maximum out of pocket. The maximum amout of payment for services which a patient, or family, is expected to incur - typically annually. */
    Maxoutofpocket,
    /** # spvisit

Specialist Office Visit. An office visit for a specialist practitioner of a discipline */
    Spvisit,
    /** # televisit

Tele-visit. A visit held where the patient is remote relative to the practitioner, e.g. by phone, computer or video conference. */
    Televisit,
    /** # urgentcare

Urgent Care. A visit to an urgent care facility - typically a community care clinic. */
    Urgentcare,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CoverageCoPayTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "copay" => Ok(Self::Copay),
            "copaypct" => Ok(Self::Copaypct),
            "deductible" => Ok(Self::Deductible),
            "emergency" => Ok(Self::Emergency),
            "gpvisit" => Ok(Self::Gpvisit),
            "inpthosp" => Ok(Self::Inpthosp),
            "maxoutofpocket" => Ok(Self::Maxoutofpocket),
            "spvisit" => Ok(Self::Spvisit),
            "televisit" => Ok(Self::Televisit),
            "urgentcare" => Ok(Self::Urgentcare),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CoverageCoPayTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Copay => "copay",
            Self::Copaypct => "copaypct",
            Self::Deductible => "deductible",
            Self::Emergency => "emergency",
            Self::Gpvisit => "gpvisit",
            Self::Inpthosp => "inpthosp",
            Self::Maxoutofpocket => "maxoutofpocket",
            Self::Spvisit => "spvisit",
            Self::Televisit => "televisit",
            Self::Urgentcare => "urgentcare",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for CoverageCoPayTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CoverageCoPayTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CoverageEligibilityResponseAuthSupportCodes`. This value set includes CoverageEligibilityResponse Auth Support codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CoverageEligibilityResponseAuthSupportCodes {
    /** # accidentreport

Accident Report. A formal accident report as would be filed with police or a simlar official body. */
    Accidentreport,
    /** # diagnosticimageorder

Diagnostic Image Order. A request or authorization for diagnostic imaging. */
    Diagnosticimageorder,
    /** # diagnosticimagereport

Diagnostic Image Report. A report on diagnostic image(s). */
    Diagnosticimagereport,
    /** # laborder

Lab Order. A request or authorization for laboratory diagnostic tests. */
    Laborder,
    /** # labreport

Lab Report. A report on laboratory diagnostic test(s). */
    Labreport,
    /** # model

Model. A physical model of the affected area. */
    Model,
    /** # picture

Picture. A photograph of the affected area. */
    Picture,
    /** # professionalreport

Professional Report. A report from a licensed professional regarding the siutation, condition or proposed treatment. */
    Professionalreport,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for CoverageEligibilityResponseAuthSupportCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accidentreport" => Ok(Self::Accidentreport),
            "diagnosticimageorder" => Ok(Self::Diagnosticimageorder),
            "diagnosticimagereport" => Ok(Self::Diagnosticimagereport),
            "laborder" => Ok(Self::Laborder),
            "labreport" => Ok(Self::Labreport),
            "model" => Ok(Self::Model),
            "picture" => Ok(Self::Picture),
            "professionalreport" => Ok(Self::Professionalreport),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for CoverageEligibilityResponseAuthSupportCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accidentreport => "accidentreport",
            Self::Diagnosticimageorder => "diagnosticimageorder",
            Self::Diagnosticimagereport => "diagnosticimagereport",
            Self::Laborder => "laborder",
            Self::Labreport => "labreport",
            Self::Model => "model",
            Self::Picture => "picture",
            Self::Professionalreport => "professionalreport",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for CoverageEligibilityResponseAuthSupportCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CoverageEligibilityResponseAuthSupportCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `CriteriaNotExistsBehavior`. Behavior a server can exhibit when a criteria state does not exist (e.g., state prior to a create or after a delete).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum CriteriaNotExistsBehavior {
    /** # test-fails

test fails. The requested conditional statement will fail if a matching state does not exist (e.g., previous state during create). */
    TestFails,
    /** # test-passes

test passes. The requested conditional statement will pass if a matching state does not exist (e.g., previous state during create). */
    TestPasses,
}
impl ::core::str::FromStr for CriteriaNotExistsBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "test-fails" => Ok(Self::TestFails),
            "test-passes" => Ok(Self::TestPasses),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for CriteriaNotExistsBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::TestFails => "test-fails",
            Self::TestPasses => "test-passes",
        }
    }
}
impl<'de> Deserialize<'de> for CriteriaNotExistsBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for CriteriaNotExistsBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DataAbsentReason`. Used to specify why the normally expected content of the data element is missing.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DataAbsentReason {
    /** # as-text

As Text. The content of the data is represented in the resource narrative. */
    AsText,
    /** # asked-declined

Asked But Declined. The source was asked but declined to answer. */
    AskedDeclined,
    /** # asked-unknown

Asked But Unknown. The source was asked but does not know the value. */
    AskedUnknown,
    /** # error

Error. Some system or workflow process error means that the information is not available. */
    Error,
    /** # masked

Masked. The information is not available due to security, privacy or related reasons. */
    Masked,
    /** # negative-infinity

Negative Infinity (NINF). The numeric value is excessively low and unrepresentable due to a floating point processing error. */
    NegativeInfinity,
    /** # not-a-number

Not a Number (NaN). The numeric value is undefined or unrepresentable due to a floating point processing error. */
    NotANumber,
    /** # not-applicable

Not Applicable. There is no proper value for this element (e.g. last menstrual period for a male). */
    NotApplicable,
    /** # not-asked

Not Asked. The workflow didn't lead to this value being known. */
    NotAsked,
    /** # not-performed

Not Performed. The value is not available because the observation procedure (test, etc.) was not performed. */
    NotPerformed,
    /** # not-permitted

Not Permitted. The value is not permitted in this context (e.g. due to profiles, or the base data types). */
    NotPermitted,
    /** # positive-infinity

Positive Infinity (PINF). The numeric value is excessively high and unrepresentable due to a floating point processing error. */
    PositiveInfinity,
    /** # temp-unknown

Temporarily Unknown. There is reason to expect (from the workflow) that the value may become known. */
    TempUnknown,
    /** # unknown

Unknown. The value is expected to exist but is not known. */
    Unknown,
    /** # unsupported

Unsupported. The source system wasn't capable of supporting this element. */
    Unsupported,
}
impl ::core::str::FromStr for DataAbsentReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "as-text" => Ok(Self::AsText),
            "asked-declined" => Ok(Self::AskedDeclined),
            "asked-unknown" => Ok(Self::AskedUnknown),
            "error" => Ok(Self::Error),
            "masked" => Ok(Self::Masked),
            "negative-infinity" => Ok(Self::NegativeInfinity),
            "not-a-number" => Ok(Self::NotANumber),
            "not-applicable" => Ok(Self::NotApplicable),
            "not-asked" => Ok(Self::NotAsked),
            "not-performed" => Ok(Self::NotPerformed),
            "not-permitted" => Ok(Self::NotPermitted),
            "positive-infinity" => Ok(Self::PositiveInfinity),
            "temp-unknown" => Ok(Self::TempUnknown),
            "unknown" => Ok(Self::Unknown),
            "unsupported" => Ok(Self::Unsupported),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DataAbsentReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::AsText => "as-text",
            Self::AskedDeclined => "asked-declined",
            Self::AskedUnknown => "asked-unknown",
            Self::Error => "error",
            Self::Masked => "masked",
            Self::NegativeInfinity => "negative-infinity",
            Self::NotANumber => "not-a-number",
            Self::NotApplicable => "not-applicable",
            Self::NotAsked => "not-asked",
            Self::NotPerformed => "not-performed",
            Self::NotPermitted => "not-permitted",
            Self::PositiveInfinity => "positive-infinity",
            Self::TempUnknown => "temp-unknown",
            Self::Unknown => "unknown",
            Self::Unsupported => "unsupported",
        }
    }
}
impl<'de> Deserialize<'de> for DataAbsentReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DataAbsentReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DataType`. A version specific list of the data types defined by the FHIR specification for use as an element  type (any of the FHIR defined data types).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DataType {
    /** # Address

Address. An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world. */
    Address,
    /** # Age

Age. A duration of time during which an organism (or a process) has existed. */
    Age,
    /** # Annotation

Annotation. A  text note which also  contains information about who made the statement and when. */
    Annotation,
    /** # Attachment

Attachment. For referring to data content defined in other formats. */
    Attachment,
    /** # BackboneElement

BackboneElement. Base definition for all elements that are defined inside a resource - but not those in a data type. */
    BackboneElement,
    /** # CodeableConcept

CodeableConcept. A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text. */
    CodeableConcept,
    /** # CodeableReference

CodeableReference. A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class). */
    CodeableReference,
    /** # Coding

Coding. A reference to a code defined by a terminology system. */
    Coding,
    /** # ContactDetail

ContactDetail. Specifies contact information for a person or organization. */
    ContactDetail,
    /** # ContactPoint

ContactPoint. Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc. */
    ContactPoint,
    /** # Contributor

Contributor. A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers. */
    Contributor,
    /** # Count

Count. A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies. */
    Count,
    /** # DataRequirement

DataRequirement. Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data. */
    DataRequirement,
    /** # Distance

Distance. A length - a value with a unit that is a physical distance. */
    Distance,
    /** # Dosage

Dosage. Indicates how the medication is/was taken or should be taken by the patient. */
    Dosage,
    /** # Duration

Duration. A length of time. */
    Duration,
    /** # Element

Element. Base definition for all elements in a resource. */
    Element,
    /** # ElementDefinition

ElementDefinition. Captures constraints on each element within the resource, profile, or extension. */
    ElementDefinition,
    /** # Expression

Expression. A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used. */
    Expression,
    /** # Extension

Extension. Optional Extension Element - found in all resources. */
    Extension,
    /** # HumanName

HumanName. A human's name with the ability to identify parts and usage. */
    HumanName,
    /** # Identifier

Identifier. An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers. */
    Identifier,
    /** # MarketingStatus

MarketingStatus. The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available. */
    MarketingStatus,
    /** # Meta

Meta. The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource. */
    Meta,
    /** # Money

Money. An amount of economic utility in some recognized currency. */
    Money,
    /** # MoneyQuantity

MoneyQuantity. */
    MoneyQuantity,
    /** # Narrative

Narrative. A human-readable summary of the resource conveying the essential clinical and business information for the resource. */
    Narrative,
    /** # ParameterDefinition

ParameterDefinition. The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse. */
    ParameterDefinition,
    /** # Period

Period. A time period defined by a start and end date and optionally time. */
    Period,
    /** # Population

Population. A populatioof people with some set of grouping criteria. */
    Population,
    /** # ProdCharacteristic

ProdCharacteristic. The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available. */
    ProdCharacteristic,
    /** # ProductShelfLife

ProductShelfLife. The shelf-life and storage information for a medicinal product item or container can be described using this class. */
    ProductShelfLife,
    /** # Quantity

Quantity. A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies. */
    Quantity,
    /** # Range

Range. A set of ordered Quantities defined by a low and high limit. */
    Range,
    /** # Ratio

Ratio. A relationship of two Quantity values - expressed as a numerator and a denominator. */
    Ratio,
    /** # RatioRange

RatioRange. A range of ratios expressed as a low and high numerator and a denominator. */
    RatioRange,
    /** # Reference

Reference. A reference from one resource to another. */
    Reference,
    /** # RelatedArtifact

RelatedArtifact. Related artifacts such as additional documentation, justification, or bibliographic references. */
    RelatedArtifact,
    /** # SampledData

SampledData. A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data. */
    SampledData,
    /** # Signature

Signature. A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities. */
    Signature,
    /** # SimpleQuantity

SimpleQuantity. */
    SimpleQuantity,
    /** # Timing

Timing. Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out. */
    Timing,
    /** # TriggerDefinition

TriggerDefinition. A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element. */
    TriggerDefinition,
    /** # UsageContext

UsageContext. Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care). */
    UsageContext,
    /** # base64Binary

base64Binary. A stream of bytes */
    Base64Binary,
    /** # boolean

boolean. Value of "true" or "false" */
    Boolean,
    /** # canonical

canonical. A URI that is a reference to a canonical URL on a FHIR resource */
    Canonical,
    /** # code

code. A string which has at least one character and no leading or trailing whitespace and where there is no whitespace other than single spaces in the contents */
    Code,
    /** # date

date. A date or partial date (e.g. just year or year + month). There is no time zone. The format is a union of the schema types gYear, gYearMonth and date.  Dates SHALL be valid dates. */
    Date,
    /** # dateTime

dateTime. A date, date-time or partial date (e.g. just year or year + month).  If hours and minutes are specified, a time zone SHALL be populated. The format is a union of the schema types gYear, gYearMonth, date and dateTime. Seconds must be provided due to schema type constraints but may be zero-filled and may be ignored.                 Dates SHALL be valid dates. */
    DateTime,
    /** # decimal

decimal. A rational number with implicit precision */
    Decimal,
    /** # id

id. Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these constraints.)  Ids are case-insensitive. */
    Id,
    /** # instant

instant. An instant in time - known at least to the second */
    Instant,
    /** # integer

integer. A whole number */
    Integer,
    /** # markdown

markdown. A string that may contain Github Flavored Markdown syntax for optional processing by a mark down presentation engine */
    Markdown,
    /** # oid

oid. An OID represented as a URI */
    Oid,
    /** # positiveInt

positiveInt. An integer with a value that is positive (e.g. >0) */
    PositiveInt,
    /** # string

string. A sequence of Unicode characters */
    String,
    /** # time

time. A time during the day, with no date specified */
    Time,
    /** # unsignedInt

unsignedInt. An integer with a value that is not negative (e.g. >= 0) */
    UnsignedInt,
    /** # uri

uri. String of characters used to identify a name or a resource */
    Uri,
    /** # url

url. A URI that is a literal reference */
    Url,
    /** # uuid

uuid. A UUID, represented as a URI */
    Uuid,
    /** # xhtml

XHTML. XHTML format, as defined by W3C, but restricted usage (mainly, no active content) */
    Xhtml,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for DataType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Address" => Ok(Self::Address),
            "Age" => Ok(Self::Age),
            "Annotation" => Ok(Self::Annotation),
            "Attachment" => Ok(Self::Attachment),
            "BackboneElement" => Ok(Self::BackboneElement),
            "CodeableConcept" => Ok(Self::CodeableConcept),
            "CodeableReference" => Ok(Self::CodeableReference),
            "Coding" => Ok(Self::Coding),
            "ContactDetail" => Ok(Self::ContactDetail),
            "ContactPoint" => Ok(Self::ContactPoint),
            "Contributor" => Ok(Self::Contributor),
            "Count" => Ok(Self::Count),
            "DataRequirement" => Ok(Self::DataRequirement),
            "Distance" => Ok(Self::Distance),
            "Dosage" => Ok(Self::Dosage),
            "Duration" => Ok(Self::Duration),
            "Element" => Ok(Self::Element),
            "ElementDefinition" => Ok(Self::ElementDefinition),
            "Expression" => Ok(Self::Expression),
            "Extension" => Ok(Self::Extension),
            "HumanName" => Ok(Self::HumanName),
            "Identifier" => Ok(Self::Identifier),
            "MarketingStatus" => Ok(Self::MarketingStatus),
            "Meta" => Ok(Self::Meta),
            "Money" => Ok(Self::Money),
            "MoneyQuantity" => Ok(Self::MoneyQuantity),
            "Narrative" => Ok(Self::Narrative),
            "ParameterDefinition" => Ok(Self::ParameterDefinition),
            "Period" => Ok(Self::Period),
            "Population" => Ok(Self::Population),
            "ProdCharacteristic" => Ok(Self::ProdCharacteristic),
            "ProductShelfLife" => Ok(Self::ProductShelfLife),
            "Quantity" => Ok(Self::Quantity),
            "Range" => Ok(Self::Range),
            "Ratio" => Ok(Self::Ratio),
            "RatioRange" => Ok(Self::RatioRange),
            "Reference" => Ok(Self::Reference),
            "RelatedArtifact" => Ok(Self::RelatedArtifact),
            "SampledData" => Ok(Self::SampledData),
            "Signature" => Ok(Self::Signature),
            "SimpleQuantity" => Ok(Self::SimpleQuantity),
            "Timing" => Ok(Self::Timing),
            "TriggerDefinition" => Ok(Self::TriggerDefinition),
            "UsageContext" => Ok(Self::UsageContext),
            "base64Binary" => Ok(Self::Base64Binary),
            "boolean" => Ok(Self::Boolean),
            "canonical" => Ok(Self::Canonical),
            "code" => Ok(Self::Code),
            "date" => Ok(Self::Date),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "id" => Ok(Self::Id),
            "instant" => Ok(Self::Instant),
            "integer" => Ok(Self::Integer),
            "markdown" => Ok(Self::Markdown),
            "oid" => Ok(Self::Oid),
            "positiveInt" => Ok(Self::PositiveInt),
            "string" => Ok(Self::String),
            "time" => Ok(Self::Time),
            "unsignedInt" => Ok(Self::UnsignedInt),
            "uri" => Ok(Self::Uri),
            "url" => Ok(Self::Url),
            "uuid" => Ok(Self::Uuid),
            "xhtml" => Ok(Self::Xhtml),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for DataType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Address => "Address",
            Self::Age => "Age",
            Self::Annotation => "Annotation",
            Self::Attachment => "Attachment",
            Self::BackboneElement => "BackboneElement",
            Self::CodeableConcept => "CodeableConcept",
            Self::CodeableReference => "CodeableReference",
            Self::Coding => "Coding",
            Self::ContactDetail => "ContactDetail",
            Self::ContactPoint => "ContactPoint",
            Self::Contributor => "Contributor",
            Self::Count => "Count",
            Self::DataRequirement => "DataRequirement",
            Self::Distance => "Distance",
            Self::Dosage => "Dosage",
            Self::Duration => "Duration",
            Self::Element => "Element",
            Self::ElementDefinition => "ElementDefinition",
            Self::Expression => "Expression",
            Self::Extension => "Extension",
            Self::HumanName => "HumanName",
            Self::Identifier => "Identifier",
            Self::MarketingStatus => "MarketingStatus",
            Self::Meta => "Meta",
            Self::Money => "Money",
            Self::MoneyQuantity => "MoneyQuantity",
            Self::Narrative => "Narrative",
            Self::ParameterDefinition => "ParameterDefinition",
            Self::Period => "Period",
            Self::Population => "Population",
            Self::ProdCharacteristic => "ProdCharacteristic",
            Self::ProductShelfLife => "ProductShelfLife",
            Self::Quantity => "Quantity",
            Self::Range => "Range",
            Self::Ratio => "Ratio",
            Self::RatioRange => "RatioRange",
            Self::Reference => "Reference",
            Self::RelatedArtifact => "RelatedArtifact",
            Self::SampledData => "SampledData",
            Self::Signature => "Signature",
            Self::SimpleQuantity => "SimpleQuantity",
            Self::Timing => "Timing",
            Self::TriggerDefinition => "TriggerDefinition",
            Self::UsageContext => "UsageContext",
            Self::Base64Binary => "base64Binary",
            Self::Boolean => "boolean",
            Self::Canonical => "canonical",
            Self::Code => "code",
            Self::Date => "date",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Id => "id",
            Self::Instant => "instant",
            Self::Integer => "integer",
            Self::Markdown => "markdown",
            Self::Oid => "oid",
            Self::PositiveInt => "positiveInt",
            Self::String => "string",
            Self::Time => "time",
            Self::UnsignedInt => "unsignedInt",
            Self::Uri => "uri",
            Self::Url => "url",
            Self::Uuid => "uuid",
            Self::Xhtml => "xhtml",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for DataType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DataType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DaysOfWeek`. The days of the week.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DaysOfWeek {
    /** # fri

Friday. Friday. */
    Fri,
    /** # mon

Monday. Monday. */
    Mon,
    /** # sat

Saturday. Saturday. */
    Sat,
    /** # sun

Sunday. Sunday. */
    Sun,
    /** # thu

Thursday. Thursday. */
    Thu,
    /** # tue

Tuesday. Tuesday. */
    Tue,
    /** # wed

Wednesday. Wednesday. */
    Wed,
}
impl ::core::str::FromStr for DaysOfWeek {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fri" => Ok(Self::Fri),
            "mon" => Ok(Self::Mon),
            "sat" => Ok(Self::Sat),
            "sun" => Ok(Self::Sun),
            "thu" => Ok(Self::Thu),
            "tue" => Ok(Self::Tue),
            "wed" => Ok(Self::Wed),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DaysOfWeek {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fri => "fri",
            Self::Mon => "mon",
            Self::Sat => "sat",
            Self::Sun => "sun",
            Self::Thu => "thu",
            Self::Tue => "tue",
            Self::Wed => "wed",
        }
    }
}
impl<'de> Deserialize<'de> for DaysOfWeek {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DaysOfWeek {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DefinitionResourceType`. A list of all the definition resource types defined in this version of the FHIR specification.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DefinitionResourceType {
    /** # ActivityDefinition

ActivityDefinition. This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context. */
    ActivityDefinition,
    /** # EventDefinition

EventDefinition. The EventDefinition resource provides a reusable description of when a particular event can occur. */
    EventDefinition,
    /** # Measure

Measure. The Measure resource provides the definition of a quality measure. */
    Measure,
    /** # OperationDefinition

OperationDefinition. A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction). */
    OperationDefinition,
    /** # PlanDefinition

PlanDefinition. This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols. */
    PlanDefinition,
    /** # Questionnaire

Questionnaire. A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection. */
    Questionnaire,
}
impl ::core::str::FromStr for DefinitionResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActivityDefinition" => Ok(Self::ActivityDefinition),
            "EventDefinition" => Ok(Self::EventDefinition),
            "Measure" => Ok(Self::Measure),
            "OperationDefinition" => Ok(Self::OperationDefinition),
            "PlanDefinition" => Ok(Self::PlanDefinition),
            "Questionnaire" => Ok(Self::Questionnaire),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActivityDefinition => "ActivityDefinition",
            Self::EventDefinition => "EventDefinition",
            Self::Measure => "Measure",
            Self::OperationDefinition => "OperationDefinition",
            Self::PlanDefinition => "PlanDefinition",
            Self::Questionnaire => "Questionnaire",
        }
    }
}
impl<'de> Deserialize<'de> for DefinitionResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DefinitionStatus`. Codes identifying the lifecycle stage of a definition.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DefinitionStatus {
    /** # active

Active. The definition is considered ready for use. */
    Active,
    /** # draft

Draft. The definition is in the design stage and is not yet considered to be "ready for use". */
    Draft,
    /** # unknown

Unknown. The authoring/source system does not know which of the status values currently applies for this resource.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply,  but the authoring/source system does not know which. */
    Unknown,
    /** # withdrawn

Withdrawn. The definition should no longer be used. */
    Withdrawn,
}
impl ::core::str::FromStr for DefinitionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "unknown" => Ok(Self::Unknown),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::Unknown => "unknown",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl<'de> Deserialize<'de> for DefinitionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DefinitionTopic`. High-level categorization of the definition, used for searching, sorting, and filtering.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DefinitionTopic {
    /** # assessment

Assessment. The definition is related to assessment of the patient. */
    Assessment,
    /** # education

Education. The definition is related to education of the patient. */
    Education,
    /** # treatment

Treatment. The definition is related to treatment of the patient. */
    Treatment,
}
impl ::core::str::FromStr for DefinitionTopic {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assessment" => Ok(Self::Assessment),
            "education" => Ok(Self::Education),
            "treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionTopic {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assessment => "assessment",
            Self::Education => "education",
            Self::Treatment => "treatment",
        }
    }
}
impl<'de> Deserialize<'de> for DefinitionTopic {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionTopic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DefinitionUseCodes`. Structure Definition Use Codes / Keywords

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DefinitionUseCodes {
    /** # archetype

Domain Analysis Model. This structure captures an analysis of a domain */
    Archetype,
    /** # custom-resource

Custom Resource. This structure is intended to be treated like a FHIR resource (e.g. on the FHIR API) */
    CustomResource,
    /** # dam

Domain Analysis Model. This structure captures an analysis of a domain */
    Dam,
    /** # fhir-structure

FHIR Structure. This structure is defined as part of the base FHIR Specification */
    FhirStructure,
    /** # template

Template. This structure is a template (n.b: 'template' has many meanings) */
    Template,
    /** # wire-format

Wire Format. This structure represents and existing structure (e.g. CDA, HL7 v2) */
    WireFormat,
}
impl ::core::str::FromStr for DefinitionUseCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "archetype" => Ok(Self::Archetype),
            "custom-resource" => Ok(Self::CustomResource),
            "dam" => Ok(Self::Dam),
            "fhir-structure" => Ok(Self::FhirStructure),
            "template" => Ok(Self::Template),
            "wire-format" => Ok(Self::WireFormat),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DefinitionUseCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Archetype => "archetype",
            Self::CustomResource => "custom-resource",
            Self::Dam => "dam",
            Self::FhirStructure => "fhir-structure",
            Self::Template => "template",
            Self::WireFormat => "wire-format",
        }
    }
}
impl<'de> Deserialize<'de> for DefinitionUseCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DefinitionUseCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DetectedIssueSeverity`. Indicates the potential degree of impact of the identified issue on the patient.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DetectedIssueSeverity {
    /** # high

High. Indicates the issue may be life-threatening or has the potential to cause permanent injury. */
    High,
    /** # low

Low. Indicates the issue may result in some adverse consequences but is unlikely to substantially affect the situation of the subject. */
    Low,
    /** # moderate

Moderate. Indicates the issue may result in noticeable adverse consequences but is unlikely to be life-threatening or cause permanent injury. */
    Moderate,
}
impl ::core::str::FromStr for DetectedIssueSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DetectedIssueSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
        }
    }
}
impl<'de> Deserialize<'de> for DetectedIssueSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DetectedIssueSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DeviceMetricCalibrationState`. Describes the state of a metric calibration.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceMetricCalibrationState {
    /** # calibrated

Calibrated. The metric has been calibrated. */
    Calibrated,
    /** # calibration-required

Calibration Required. The metric needs to be calibrated. */
    CalibrationRequired,
    /** # not-calibrated

Not Calibrated. The metric has not been calibrated. */
    NotCalibrated,
    /** # unspecified

Unspecified. The state of calibration of this metric is unspecified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCalibrationState {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calibrated" => Ok(Self::Calibrated),
            "calibration-required" => Ok(Self::CalibrationRequired),
            "not-calibrated" => Ok(Self::NotCalibrated),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCalibrationState {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calibrated => "calibrated",
            Self::CalibrationRequired => "calibration-required",
            Self::NotCalibrated => "not-calibrated",
            Self::Unspecified => "unspecified",
        }
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCalibrationState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCalibrationState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DeviceMetricCalibrationType`. Describes the type of a metric calibration.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceMetricCalibrationType {
    /** # gain

Gain. Gain metric calibration method. */
    Gain,
    /** # offset

Offset. Offset metric calibration method. */
    Offset,
    /** # two-point

Two Point. Two-point metric calibration method. */
    TwoPoint,
    /** # unspecified

Unspecified. Metric calibration method has not been identified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCalibrationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "gain" => Ok(Self::Gain),
            "offset" => Ok(Self::Offset),
            "two-point" => Ok(Self::TwoPoint),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCalibrationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Gain => "gain",
            Self::Offset => "offset",
            Self::TwoPoint => "two-point",
            Self::Unspecified => "unspecified",
        }
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCalibrationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCalibrationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DeviceMetricCategory`. Describes the category of the metric.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceMetricCategory {
    /** # calculation

Calculation. DeviceObservations generated for this DeviceMetric are calculated. */
    Calculation,
    /** # measurement

Measurement. DeviceObservations generated for this DeviceMetric are measured. */
    Measurement,
    /** # setting

Setting. DeviceObservations generated for this DeviceMetric is a setting that will influence the behavior of the Device. */
    Setting,
    /** # unspecified

Unspecified. The category of this DeviceMetric is unspecified. */
    Unspecified,
}
impl ::core::str::FromStr for DeviceMetricCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calculation" => Ok(Self::Calculation),
            "measurement" => Ok(Self::Measurement),
            "setting" => Ok(Self::Setting),
            "unspecified" => Ok(Self::Unspecified),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calculation => "calculation",
            Self::Measurement => "measurement",
            Self::Setting => "setting",
            Self::Unspecified => "unspecified",
        }
    }
}
impl<'de> Deserialize<'de> for DeviceMetricCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DeviceMetricColor`. Describes the typical color of representation.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceMetricColor {
    /** # black

Color Black. Color for representation - black. */
    Black,
    /** # blue

Color Blue. Color for representation - blue. */
    Blue,
    /** # cyan

Color Cyan. Color for representation - cyan. */
    Cyan,
    /** # green

Color Green. Color for representation - green. */
    Green,
    /** # magenta

Color Magenta. Color for representation - magenta. */
    Magenta,
    /** # red

Color Red. Color for representation - red. */
    Red,
    /** # white

Color White. Color for representation - white. */
    White,
    /** # yellow

Color Yellow. Color for representation - yellow. */
    Yellow,
}
impl ::core::str::FromStr for DeviceMetricColor {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "black" => Ok(Self::Black),
            "blue" => Ok(Self::Blue),
            "cyan" => Ok(Self::Cyan),
            "green" => Ok(Self::Green),
            "magenta" => Ok(Self::Magenta),
            "red" => Ok(Self::Red),
            "white" => Ok(Self::White),
            "yellow" => Ok(Self::Yellow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricColor {
    fn as_ref(&self) -> &str {
        match self {
            Self::Black => "black",
            Self::Blue => "blue",
            Self::Cyan => "cyan",
            Self::Green => "green",
            Self::Magenta => "magenta",
            Self::Red => "red",
            Self::White => "white",
            Self::Yellow => "yellow",
        }
    }
}
impl<'de> Deserialize<'de> for DeviceMetricColor {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricColor {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DeviceMetricOperationalStatus`. Describes the operational status of the DeviceMetric.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceMetricOperationalStatus {
    /** # entered-in-error

Entered In Error. The DeviceMetric was entered in error. */
    EnteredInError,
    /** # off

Off. The DeviceMetric is not operating. */
    Off,
    /** # on

On. The DeviceMetric is operating and will generate DeviceObservations. */
    On,
    /** # standby

Standby. The DeviceMetric is operating, but will not generate any DeviceObservations. */
    Standby,
}
impl ::core::str::FromStr for DeviceMetricOperationalStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "entered-in-error" => Ok(Self::EnteredInError),
            "off" => Ok(Self::Off),
            "on" => Ok(Self::On),
            "standby" => Ok(Self::Standby),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceMetricOperationalStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::EnteredInError => "entered-in-error",
            Self::Off => "off",
            Self::On => "on",
            Self::Standby => "standby",
        }
    }
}
impl<'de> Deserialize<'de> for DeviceMetricOperationalStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceMetricOperationalStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DeviceNameType`. The type of name the device is referred by.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceNameType {
    /** # manufacturer-name

Manufacturer name. Manufacturer name. */
    ManufacturerName,
    /** # model-name

Model name. Model name. */
    ModelName,
    /** # other

other. other. */
    Other,
    /** # patient-reported-name

Patient Reported name. Patient Reported name. */
    PatientReportedName,
    /** # udi-label-name

UDI Label name. UDI Label name. */
    UdiLabelName,
    /** # user-friendly-name

User Friendly name. User Friendly name. */
    UserFriendlyName,
}
impl ::core::str::FromStr for DeviceNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "manufacturer-name" => Ok(Self::ManufacturerName),
            "model-name" => Ok(Self::ModelName),
            "other" => Ok(Self::Other),
            "patient-reported-name" => Ok(Self::PatientReportedName),
            "udi-label-name" => Ok(Self::UdiLabelName),
            "user-friendly-name" => Ok(Self::UserFriendlyName),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ManufacturerName => "manufacturer-name",
            Self::ModelName => "model-name",
            Self::Other => "other",
            Self::PatientReportedName => "patient-reported-name",
            Self::UdiLabelName => "udi-label-name",
            Self::UserFriendlyName => "user-friendly-name",
        }
    }
}
impl<'de> Deserialize<'de> for DeviceNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DeviceUseStatementStatus`. A coded concept indicating the current status of the Device Usage.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DeviceUseStatementStatus {
    /** # active

Active. The device is still being used. */
    Active,
    /** # completed

Completed. The device is no longer being used. */
    Completed,
    /** # entered-in-error

Entered in Error. The statement was recorded incorrectly. */
    EnteredInError,
    /** # intended

Intended. The device may be used at some time in the future. */
    Intended,
    /** # on-hold

On Hold. Actions implied by the statement have been temporarily halted, but are expected to continue later. May also be called "suspended". */
    OnHold,
    /** # stopped

Stopped. Actions implied by the statement have been permanently halted, before all of them occurred. */
    Stopped,
}
impl ::core::str::FromStr for DeviceUseStatementStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "intended" => Ok(Self::Intended),
            "on-hold" => Ok(Self::OnHold),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DeviceUseStatementStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::Intended => "intended",
            Self::OnHold => "on-hold",
            Self::Stopped => "stopped",
        }
    }
}
impl<'de> Deserialize<'de> for DeviceUseStatementStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DeviceUseStatementStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DiagnosisRole`. This value set defines a set of codes that can be used to express the role of a diagnosis on the Encounter or EpisodeOfCare record.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DiagnosisRole {
    /** # AD

Admission diagnosis. */
    Ad,
    /** # CC

Chief complaint. */
    Cc,
    /** # CM

Comorbidity diagnosis. */
    Cm,
    /** # DD

Discharge diagnosis. */
    Dd,
    /** # billing

Billing. */
    Billing,
    /** # post-op

post-op diagnosis. */
    PostOp,
    /** # pre-op

pre-op diagnosis. */
    PreOp,
}
impl ::core::str::FromStr for DiagnosisRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AD" => Ok(Self::Ad),
            "CC" => Ok(Self::Cc),
            "CM" => Ok(Self::Cm),
            "DD" => Ok(Self::Dd),
            "billing" => Ok(Self::Billing),
            "post-op" => Ok(Self::PostOp),
            "pre-op" => Ok(Self::PreOp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiagnosisRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ad => "AD",
            Self::Cc => "CC",
            Self::Cm => "CM",
            Self::Dd => "DD",
            Self::Billing => "billing",
            Self::PostOp => "post-op",
            Self::PreOp => "pre-op",
        }
    }
}
impl<'de> Deserialize<'de> for DiagnosisRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiagnosisRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DiagnosticReportStatus`. The status of the diagnostic report.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DiagnosticReportStatus {
    /** # amended

Amended. Subsequent to being final, the report has been modified.  This includes any change in the results, diagnosis, narrative text, or other content of a report that has been issued. */
    Amended,
    /** # appended

Appended. Subsequent to being final, the report has been modified by adding new content. The existing content is unchanged. */
    Appended,
    /** # cancelled

Cancelled. The report is unavailable because the measurement was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** # corrected

Corrected. Subsequent to being final, the report has been modified  to correct an error in the report or referenced results. */
    Corrected,
    /** # entered-in-error

Entered in Error. The report has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** # final

Final. The report is complete and verified by an authorized person. */
    Final,
    /** # partial

Partial. This is a partial (e.g. initial, interim or preliminary) report: data in the report may be incomplete or unverified. */
    Partial,
    /** # preliminary

Preliminary. Verified early results are available, but not all  results are final. */
    Preliminary,
    /** # registered

Registered. The existence of the report is registered, but there is nothing yet available. */
    Registered,
    /** # unknown

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for DiagnosticReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "appended" => Ok(Self::Appended),
            "cancelled" => Ok(Self::Cancelled),
            "corrected" => Ok(Self::Corrected),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "partial" => Ok(Self::Partial),
            "preliminary" => Ok(Self::Preliminary),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiagnosticReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Appended => "appended",
            Self::Cancelled => "cancelled",
            Self::Corrected => "corrected",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Partial => "partial",
            Self::Preliminary => "preliminary",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for DiagnosticReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiagnosticReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `Diet`. This codesystem defines a set of codes that can be used to indicate dietary preferences or restrictions a patient may have.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Diet {
    /** # dairy-free

Dairy Free. Excludes dairy products. */
    DairyFree,
    /** # gluten-free

Gluten Free. Excludes ingredients containing gluten. */
    GlutenFree,
    /** # halal

Halal. Foods that conform to Islamic law. */
    Halal,
    /** # kosher

Kosher. Foods that conform to Jewish dietary law. */
    Kosher,
    /** # nut-free

Nut Free. Excludes ingredients containing nuts. */
    NutFree,
    /** # vegan

Vegan. Food without meat, poultry, seafood, eggs, dairy products and other animal-derived substances. */
    Vegan,
    /** # vegetarian

Vegetarian. Food without meat, poultry or seafood. */
    Vegetarian,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for Diet {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "dairy-free" => Ok(Self::DairyFree),
            "gluten-free" => Ok(Self::GlutenFree),
            "halal" => Ok(Self::Halal),
            "kosher" => Ok(Self::Kosher),
            "nut-free" => Ok(Self::NutFree),
            "vegan" => Ok(Self::Vegan),
            "vegetarian" => Ok(Self::Vegetarian),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for Diet {
    fn as_ref(&self) -> &str {
        match self {
            Self::DairyFree => "dairy-free",
            Self::GlutenFree => "gluten-free",
            Self::Halal => "halal",
            Self::Kosher => "kosher",
            Self::NutFree => "nut-free",
            Self::Vegan => "vegan",
            Self::Vegetarian => "vegetarian",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for Diet {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Diet {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DigitalMediaType`. Codes for high level media types - whether the media is an image, video, or audio.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DigitalMediaType {
    /** # audio

Audio. The media consists of a sound recording */
    Audio,
    /** # image

Image. The media consists of one or more unmoving images, including photographs, computer-generated graphs and charts, and scanned documents */
    Image,
    /** # video

Video. The media consists of a series of frames that capture a moving image */
    Video,
}
impl ::core::str::FromStr for DigitalMediaType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "audio" => Ok(Self::Audio),
            "image" => Ok(Self::Image),
            "video" => Ok(Self::Video),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DigitalMediaType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Audio => "audio",
            Self::Image => "image",
            Self::Video => "video",
        }
    }
}
impl<'de> Deserialize<'de> for DigitalMediaType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DigitalMediaType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DischargeDisposition`. This codesystem defines a set of codes that can be used to where the patient left the hospital.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DischargeDisposition {
    /** # aadvice

Left against advice. The patient self discharged against medical advice. */
    Aadvice,
    /** # alt-home

Alternative home. The patient was discharged and has indicated that they are going to return home afterwards, but not the patient's home - e.g. a family member's home. */
    AltHome,
    /** # exp

Expired. The patient has deceased during this encounter. */
    Exp,
    /** # home

Home. The patient was dicharged and has indicated that they are going to return home afterwards. */
    Home,
    /** # hosp

Hospice. The patient has been discharged into palliative care. */
    Hosp,
    /** # long

Long-term care. The patient has been discharged into long-term care where is likely to be monitored through an ongoing episode-of-care. */
    Long,
    /** # oth

Other. The discharge disposition has not otherwise defined. */
    Oth,
    /** # other-hcf

Other healthcare facility. The patient was transferred to another healthcare facility. */
    OtherHcf,
    /** # psy

Psychiatric hospital. The patient has been transferred to a psychiatric facility. */
    Psy,
    /** # rehab

Rehabilitation. The patient was discharged and is to receive post acute care rehabilitation services. */
    Rehab,
    /** # snf

Skilled nursing facility. The patient has been discharged to a skilled nursing facility for the patient to receive additional care. */
    Snf,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for DischargeDisposition {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aadvice" => Ok(Self::Aadvice),
            "alt-home" => Ok(Self::AltHome),
            "exp" => Ok(Self::Exp),
            "home" => Ok(Self::Home),
            "hosp" => Ok(Self::Hosp),
            "long" => Ok(Self::Long),
            "oth" => Ok(Self::Oth),
            "other-hcf" => Ok(Self::OtherHcf),
            "psy" => Ok(Self::Psy),
            "rehab" => Ok(Self::Rehab),
            "snf" => Ok(Self::Snf),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for DischargeDisposition {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aadvice => "aadvice",
            Self::AltHome => "alt-home",
            Self::Exp => "exp",
            Self::Home => "home",
            Self::Hosp => "hosp",
            Self::Long => "long",
            Self::Oth => "oth",
            Self::OtherHcf => "other-hcf",
            Self::Psy => "psy",
            Self::Rehab => "rehab",
            Self::Snf => "snf",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for DischargeDisposition {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DischargeDisposition {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DiscriminatorType`. How an element value is interpreted when discrimination is evaluated.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DiscriminatorType {
    /** # exists

Exists. The slices are differentiated by the presence or absence of the nominated element. */
    Exists,
    /** # pattern

Pattern. The slices have different values in the nominated element, as determined by testing them against the applicable ElementDefinition.pattern[x]. */
    Pattern,
    /** # profile

Profile. The slices are differentiated by conformance of the nominated element to a specified profile. Note that if the path specifies .resolve() then the profile is the target profile on the reference. In this case, validation by the possible profiles is required to differentiate the slices. */
    Profile,
    /** # type

Type. The slices are differentiated by type of the nominated element. */
    Type,
    /** # value

Value. The slices have different values in the nominated element. */
    Value,
}
impl ::core::str::FromStr for DiscriminatorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exists" => Ok(Self::Exists),
            "pattern" => Ok(Self::Pattern),
            "profile" => Ok(Self::Profile),
            "type" => Ok(Self::Type),
            "value" => Ok(Self::Value),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DiscriminatorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exists => "exists",
            Self::Pattern => "pattern",
            Self::Profile => "profile",
            Self::Type => "type",
            Self::Value => "value",
        }
    }
}
impl<'de> Deserialize<'de> for DiscriminatorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DiscriminatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DocumentMode`. Whether the application produces or consumes documents.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DocumentMode {
    /** # consumer

Consumer. The application consumes documents of the specified type. */
    Consumer,
    /** # producer

Producer. The application produces documents of the specified type. */
    Producer,
}
impl ::core::str::FromStr for DocumentMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "consumer" => Ok(Self::Consumer),
            "producer" => Ok(Self::Producer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consumer => "consumer",
            Self::Producer => "producer",
        }
    }
}
impl<'de> Deserialize<'de> for DocumentMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DocumentReferenceStatus`. The status of the document reference.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DocumentReferenceStatus {
    /** # current

Current. This is the current reference for this document. */
    Current,
    /** # entered-in-error

Entered in Error. This reference was created in error. */
    EnteredInError,
    /** # superseded

Superseded. This reference has been superseded by another reference. */
    Superseded,
}
impl ::core::str::FromStr for DocumentReferenceStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "current" => Ok(Self::Current),
            "entered-in-error" => Ok(Self::EnteredInError),
            "superseded" => Ok(Self::Superseded),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentReferenceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Current => "current",
            Self::EnteredInError => "entered-in-error",
            Self::Superseded => "superseded",
        }
    }
}
impl<'de> Deserialize<'de> for DocumentReferenceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentReferenceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DocumentRelationshipType`. The type of relationship between documents.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DocumentRelationshipType {
    /** # appends

Appends. This document adds additional information to the target document. */
    Appends,
    /** # replaces

Replaces. This document logically replaces or supersedes the target document. */
    Replaces,
    /** # signs

Signs. This document is a signature of the target document. */
    Signs,
    /** # transforms

Transforms. This document was generated by transforming the target document (e.g. format or language conversion). */
    Transforms,
}
impl ::core::str::FromStr for DocumentRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "appends" => Ok(Self::Appends),
            "replaces" => Ok(Self::Replaces),
            "signs" => Ok(Self::Signs),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DocumentRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Appends => "appends",
            Self::Replaces => "replaces",
            Self::Signs => "signs",
            Self::Transforms => "transforms",
        }
    }
}
impl<'de> Deserialize<'de> for DocumentRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DocumentRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `DoseAndRateType`. The kind of dose or rate specified.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum DoseAndRateType {
    /** # calculated

Calculated. The dose specified is calculated by the prescriber or the system. */
    Calculated,
    /** # ordered

Ordered. The dose specified is as ordered by the prescriber. */
    Ordered,
}
impl ::core::str::FromStr for DoseAndRateType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "calculated" => Ok(Self::Calculated),
            "ordered" => Ok(Self::Ordered),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for DoseAndRateType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calculated => "calculated",
            Self::Ordered => "ordered",
        }
    }
}
impl<'de> Deserialize<'de> for DoseAndRateType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for DoseAndRateType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EligibilityRequestPurpose`. A code specifying the types of information being requested.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EligibilityRequestPurpose {
    /** # auth-requirements

Coverage auth-requirements. The prior authorization requirements for the listed, or discovered if specified, converages for the categories of service and/or specifed biling codes are requested. */
    AuthRequirements,
    /** # benefits

Coverage benefits. The plan benefits and optionally benefits consumed  for the listed, or discovered if specified, converages are requested. */
    Benefits,
    /** # discovery

Coverage Discovery. The insurer is requested to report on any coverages which they are aware of in addition to any specifed. */
    Discovery,
    /** # validation

Coverage Validation. A check that the specified coverages are in-force is requested. */
    Validation,
}
impl ::core::str::FromStr for EligibilityRequestPurpose {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "auth-requirements" => Ok(Self::AuthRequirements),
            "benefits" => Ok(Self::Benefits),
            "discovery" => Ok(Self::Discovery),
            "validation" => Ok(Self::Validation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EligibilityRequestPurpose {
    fn as_ref(&self) -> &str {
        match self {
            Self::AuthRequirements => "auth-requirements",
            Self::Benefits => "benefits",
            Self::Discovery => "discovery",
            Self::Validation => "validation",
        }
    }
}
impl<'de> Deserialize<'de> for EligibilityRequestPurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EligibilityRequestPurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EligibilityResponsePurpose`. A code specifying the types of information being requested.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EligibilityResponsePurpose {
    /** # auth-requirements

Coverage auth-requirements. The prior authorization requirements for the listed, or discovered if specified, converages for the categories of service and/or specifed biling codes are requested. */
    AuthRequirements,
    /** # benefits

Coverage benefits. The plan benefits and optionally benefits consumed  for the listed, or discovered if specified, converages are requested. */
    Benefits,
    /** # discovery

Coverage Discovery. The insurer is requested to report on any coverages which they are aware of in addition to any specifed. */
    Discovery,
    /** # validation

Coverage Validation. A check that the specified coverages are in-force is requested. */
    Validation,
}
impl ::core::str::FromStr for EligibilityResponsePurpose {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "auth-requirements" => Ok(Self::AuthRequirements),
            "benefits" => Ok(Self::Benefits),
            "discovery" => Ok(Self::Discovery),
            "validation" => Ok(Self::Validation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EligibilityResponsePurpose {
    fn as_ref(&self) -> &str {
        match self {
            Self::AuthRequirements => "auth-requirements",
            Self::Benefits => "benefits",
            Self::Discovery => "discovery",
            Self::Validation => "validation",
        }
    }
}
impl<'de> Deserialize<'de> for EligibilityResponsePurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EligibilityResponsePurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EnableWhenBehavior`. Controls how multiple enableWhen values are interpreted -  whether all or any must be true.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EnableWhenBehavior {
    /** # all

All. Enable the question when all the enableWhen criteria are satisfied. */
    All,
    /** # any

Any. Enable the question when any of the enableWhen criteria are satisfied. */
    Any,
}
impl ::core::str::FromStr for EnableWhenBehavior {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "all" => Ok(Self::All),
            "any" => Ok(Self::Any),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EnableWhenBehavior {
    fn as_ref(&self) -> &str {
        match self {
            Self::All => "all",
            Self::Any => "any",
        }
    }
}
impl<'de> Deserialize<'de> for EnableWhenBehavior {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EnableWhenBehavior {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EncounterLocationStatus`. The status of the location.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EncounterLocationStatus {
    /** # active

Active. The patient is currently at this location, or was between the period specified.

A system may update these records when the patient leaves the location to either reserved, or completed. */
    Active,
    /** # completed

Completed. The patient was at this location during the period specified.

Not to be used when the patient is currently at the location. */
    Completed,
    /** # planned

Planned. The patient is planned to be moved to this location at some point in the future. */
    Planned,
    /** # reserved

Reserved. This location is held empty for this patient. */
    Reserved,
}
impl ::core::str::FromStr for EncounterLocationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "planned" => Ok(Self::Planned),
            "reserved" => Ok(Self::Reserved),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterLocationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::Planned => "planned",
            Self::Reserved => "reserved",
        }
    }
}
impl<'de> Deserialize<'de> for EncounterLocationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterLocationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EncounterStatus`. Current state of the encounter.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EncounterStatus {
    /** # arrived

Arrived. The Patient is present for the encounter, however is not currently meeting with a practitioner. */
    Arrived,
    /** # cancelled

Cancelled. The Encounter has ended before it has begun. */
    Cancelled,
    /** # entered-in-error

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** # finished

Finished. The Encounter has ended. */
    Finished,
    /** # in-progress

In Progress. The Encounter has begun and the patient is present / the practitioner and the patient are meeting. */
    InProgress,
    /** # onleave

On Leave. The Encounter has begun, but the patient is temporarily on leave. */
    Onleave,
    /** # planned

Planned. The Encounter has not yet started. */
    Planned,
    /** # triaged

Triaged. The patient has been assessed for the priority of their treatment based on the severity of their condition. */
    Triaged,
    /** # unknown

Unknown. The encounter status is unknown. Note that "unknown" is a value of last resort and every attempt should be made to provide a meaningful value other than "unknown". */
    Unknown,
}
impl ::core::str::FromStr for EncounterStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "arrived" => Ok(Self::Arrived),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "finished" => Ok(Self::Finished),
            "in-progress" => Ok(Self::InProgress),
            "onleave" => Ok(Self::Onleave),
            "planned" => Ok(Self::Planned),
            "triaged" => Ok(Self::Triaged),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EncounterStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Arrived => "arrived",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Finished => "finished",
            Self::InProgress => "in-progress",
            Self::Onleave => "onleave",
            Self::Planned => "planned",
            Self::Triaged => "triaged",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for EncounterStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EncounterType`. This example codesystem defines a set of codes that can be used to indicate the type of encounter: a specific code indicating type of service provided.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum EncounterType {
    /** # ADMS

Annual diabetes mellitus screening. */
    Adms,
    /** # BD/BM-clin

Bone drilling/bone marrow punction in clinic. */
    BdBmClin,
    /** # CCS60

Infant colon screening - 60 minutes. */
    Ccs60,
    /** # OKI

Outpatient Kenacort injection. */
    Oki,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EncounterType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ADMS" => Ok(Self::Adms),
            "BD/BM-clin" => Ok(Self::BdBmClin),
            "CCS60" => Ok(Self::Ccs60),
            "OKI" => Ok(Self::Oki),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EncounterType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adms => "ADMS",
            Self::BdBmClin => "BD/BM-clin",
            Self::Ccs60 => "CCS60",
            Self::Oki => "OKI",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for EncounterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EncounterType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EndpointConnectionType`. This is an example codesystem defined by the FHIR project, that could be used to represent possible connection type profile values.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum EndpointConnectionType {
    /** # dicom-qido-rs

DICOM QIDO-RS. DICOMweb RESTful Image query - http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html */
    DicomQidoRs,
    /** # dicom-stow-rs

DICOM STOW-RS. DICOMweb RESTful image sending and storage - http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.6.html */
    DicomStowRs,
    /** # dicom-wado-rs

DICOM WADO-RS. DICOMweb RESTful Image Retrieve - http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.html */
    DicomWadoRs,
    /** # dicom-wado-uri

DICOM WADO-URI. DICOMweb Image Retrieve - http://dicom.nema.org/dicom/2013/output/chtml/part18/sect_6.3.html */
    DicomWadoUri,
    /** # direct-project

Direct Project. Direct Project information - http://wiki.directproject.org/ */
    DirectProject,
    /** # hl7-fhir-msg

HL7 FHIR Messaging. Use the servers FHIR Messaging interface. Details can be found on the messaging.html page in the FHIR Specification. The FHIR server's base address is specified in the Endpoint.address property. */
    Hl7FhirMsg,
    /** # hl7-fhir-rest

HL7 FHIR. Interact with the server interface using FHIR's RESTful interface. For details on its version/capabilities you should connect the value in Endpoint.address and retrieve the FHIR CapabilityStatement. */
    Hl7FhirRest,
    /** # hl7v2-mllp

HL7 v2 MLLP. HL7v2 messages over an LLP TCP connection */
    Hl7V2Mllp,
    /** # ihe-iid

IHE IID. IHE Invoke Image Display (IID) - http://wiki.ihe.net/index.php/Invoke_Image_Display */
    IheIid,
    /** # ihe-xca

IHE XCA. IHE Cross Community Access Profile (XCA) - http://wiki.ihe.net/index.php/Cross-Community_Access */
    IheXca,
    /** # ihe-xcpd

IHE XCPD. IHE Cross Community Patient Discovery Profile (XCPD) - http://wiki.ihe.net/index.php/Cross-Community_Patient_Discovery */
    IheXcpd,
    /** # ihe-xdr

IHE XDR. IHE Cross-Enterprise Document Reliable Exchange (XDR) - http://wiki.ihe.net/index.php/Cross-enterprise_Document_Reliable_Interchange */
    IheXdr,
    /** # ihe-xds

IHE XDS. IHE Cross-Enterprise Document Sharing (XDS) - http://wiki.ihe.net/index.php/Cross-Enterprise_Document_Sharing */
    IheXds,
    /** # secure-email

Secure email. Email delivery using a digital certificate to encrypt the content using the public key, receiver must have the private key to decrypt the content */
    SecureEmail,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EndpointConnectionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "dicom-qido-rs" => Ok(Self::DicomQidoRs),
            "dicom-stow-rs" => Ok(Self::DicomStowRs),
            "dicom-wado-rs" => Ok(Self::DicomWadoRs),
            "dicom-wado-uri" => Ok(Self::DicomWadoUri),
            "direct-project" => Ok(Self::DirectProject),
            "hl7-fhir-msg" => Ok(Self::Hl7FhirMsg),
            "hl7-fhir-rest" => Ok(Self::Hl7FhirRest),
            "hl7v2-mllp" => Ok(Self::Hl7V2Mllp),
            "ihe-iid" => Ok(Self::IheIid),
            "ihe-xca" => Ok(Self::IheXca),
            "ihe-xcpd" => Ok(Self::IheXcpd),
            "ihe-xdr" => Ok(Self::IheXdr),
            "ihe-xds" => Ok(Self::IheXds),
            "secure-email" => Ok(Self::SecureEmail),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EndpointConnectionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DicomQidoRs => "dicom-qido-rs",
            Self::DicomStowRs => "dicom-stow-rs",
            Self::DicomWadoRs => "dicom-wado-rs",
            Self::DicomWadoUri => "dicom-wado-uri",
            Self::DirectProject => "direct-project",
            Self::Hl7FhirMsg => "hl7-fhir-msg",
            Self::Hl7FhirRest => "hl7-fhir-rest",
            Self::Hl7V2Mllp => "hl7v2-mllp",
            Self::IheIid => "ihe-iid",
            Self::IheXca => "ihe-xca",
            Self::IheXcpd => "ihe-xcpd",
            Self::IheXdr => "ihe-xdr",
            Self::IheXds => "ihe-xds",
            Self::SecureEmail => "secure-email",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for EndpointConnectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EndpointConnectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EndpointPayloadType`. This is an example codesystem defined by the FHIR project, it represents global concepts for no content, or any unrestricted content.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum EndpointPayloadType {
    /** # any

Any. Any payload type can be used with this endpoint, it is either a payload agnostic infrastructure (such as a storage repository), or some other type of endpoint where payload considerations are internally handled, and not available */
    Any,
    /** # none

None. This endpoint does not require any content to be sent; simply connecting to the endpoint is enough notification. This can be used as a 'ping' to wakeup a service to retrieve content, which could be to ensure security considerations are correctly handled */
    None,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EndpointPayloadType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "any" => Ok(Self::Any),
            "none" => Ok(Self::None),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EndpointPayloadType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Any => "any",
            Self::None => "none",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for EndpointPayloadType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EndpointPayloadType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EndpointStatus`. The status of the endpoint.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EndpointStatus {
    /** # active

Active. This endpoint is expected to be active and can be used. */
    Active,
    /** # entered-in-error

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** # error

Error. This endpoint has exceeded connectivity thresholds and is considered in an error state and should no longer be attempted to connect to until corrective action is taken. */
    Error,
    /** # off

Off. This endpoint is no longer to be used. */
    Off,
    /** # suspended

Suspended. This endpoint is temporarily unavailable. */
    Suspended,
    /** # test

Test. This endpoint is not intended for production usage. */
    Test,
}
impl ::core::str::FromStr for EndpointStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "error" => Ok(Self::Error),
            "off" => Ok(Self::Off),
            "suspended" => Ok(Self::Suspended),
            "test" => Ok(Self::Test),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EndpointStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Error => "error",
            Self::Off => "off",
            Self::Suspended => "suspended",
            Self::Test => "test",
        }
    }
}
impl<'de> Deserialize<'de> for EndpointStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EndpointStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EnteralFormulaAdditiveTypeCode`. EnteralFormulaAdditiveType: Codes for the type of modular component such as protein, carbohydrate or fiber to be provided in addition to or mixed with the base formula. This value set is provided as a suggestive example.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum EnteralFormulaAdditiveTypeCode {
    /** # carbohydrate

Carbohydrate. Modular carbohydrate enteral formula component */
    Carbohydrate,
    /** # fiber

Fiber. Modular fiber enteral formula component */
    Fiber,
    /** # lipid

Lipid. Modular lipid enteral formula component */
    Lipid,
    /** # protein

Protein. Modular protein enteral formula component */
    Protein,
    /** # water

Water. Added water */
    Water,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EnteralFormulaAdditiveTypeCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "carbohydrate" => Ok(Self::Carbohydrate),
            "fiber" => Ok(Self::Fiber),
            "lipid" => Ok(Self::Lipid),
            "protein" => Ok(Self::Protein),
            "water" => Ok(Self::Water),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EnteralFormulaAdditiveTypeCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Carbohydrate => "carbohydrate",
            Self::Fiber => "fiber",
            Self::Lipid => "lipid",
            Self::Protein => "protein",
            Self::Water => "water",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for EnteralFormulaAdditiveTypeCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EnteralFormulaAdditiveTypeCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EpisodeOfCareStatus`. The status of the episode of care.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EpisodeOfCareStatus {
    /** # active

Active. This episode of care is current. */
    Active,
    /** # cancelled

Cancelled. The episode of care was cancelled, or withdrawn from service, often selected during the planned stage as the patient may have gone elsewhere, or the circumstances have changed and the organization is unable to provide the care. It indicates that services terminated outside the planned/expected workflow. */
    Cancelled,
    /** # entered-in-error

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** # finished

Finished. This episode of care is finished and the organization is not expecting to be providing further care to the patient. Can also be known as "closed", "completed" or other similar terms. */
    Finished,
    /** # onhold

On Hold. This episode of care is on hold; the organization has limited responsibility for the patient (such as while on respite). */
    Onhold,
    /** # planned

Planned. This episode of care is planned to start at the date specified in the period.start. During this status, an organization may perform assessments to determine if the patient is eligible to receive services, or be organizing to make resources available to provide care services. */
    Planned,
    /** # waitlist

Waitlist. This episode has been placed on a waitlist, pending the episode being made active (or cancelled). */
    Waitlist,
}
impl ::core::str::FromStr for EpisodeOfCareStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "finished" => Ok(Self::Finished),
            "onhold" => Ok(Self::Onhold),
            "planned" => Ok(Self::Planned),
            "waitlist" => Ok(Self::Waitlist),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EpisodeOfCareStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Finished => "finished",
            Self::Onhold => "onhold",
            Self::Planned => "planned",
            Self::Waitlist => "waitlist",
        }
    }
}
impl<'de> Deserialize<'de> for EpisodeOfCareStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EpisodeOfCareStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EpisodeOfCareType`. This incomplete example codesystem defines a set of codes that can be used to express the usage type of an EpisodeOfCare record.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum EpisodeOfCareType {
    /** # cacp

Community-based aged care. */
    Cacp,
    /** # da

Drug and alcohol rehabilitation. */
    Da,
    /** # diab

Post coordinated diabetes program. */
    Diab,
    /** # hacc

Home and Community Care. */
    Hacc,
    /** # pac

Post Acute Care. */
    Pac,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EpisodeOfCareType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cacp" => Ok(Self::Cacp),
            "da" => Ok(Self::Da),
            "diab" => Ok(Self::Diab),
            "hacc" => Ok(Self::Hacc),
            "pac" => Ok(Self::Pac),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EpisodeOfCareType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cacp => "cacp",
            Self::Da => "da",
            Self::Diab => "diab",
            Self::Hacc => "hacc",
            Self::Pac => "pac",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for EpisodeOfCareType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EpisodeOfCareType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EventCapabilityMode`. The mode of a message capability statement.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EventCapabilityMode {
    /** # receiver

Receiver. The application receives requests and sends responses. */
    Receiver,
    /** # sender

Sender. The application sends requests and receives responses. */
    Sender,
}
impl ::core::str::FromStr for EventCapabilityMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "receiver" => Ok(Self::Receiver),
            "sender" => Ok(Self::Sender),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventCapabilityMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Receiver => "receiver",
            Self::Sender => "sender",
        }
    }
}
impl<'de> Deserialize<'de> for EventCapabilityMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventCapabilityMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EventResourceType`. A list of all the event resource types defined in this version of the FHIR specification.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EventResourceType {
    /** # ChargeItem

ChargeItem. Item containing charge code(s) associated with the provision of healthcare provider products. */
    ChargeItem,
    /** # ClaimResponse

ClaimResponse. Remittance resource. */
    ClaimResponse,
    /** # ClinicalImpression

ClinicalImpression. A clinical assessment performed when planning treatments and management strategies for a patient. */
    ClinicalImpression,
    /** # Communication

Communication. A record of information transmitted from a sender to a receiver. */
    Communication,
    /** # Composition

Composition. A set of resources composed into a single coherent clinical statement with clinical attestation. */
    Composition,
    /** # Condition

Condition. Detailed information about conditions, problems or diagnoses. */
    Condition,
    /** # Consent

Consent. A healthcare consumer's policy choices to permits or denies recipients or roles to perform actions for specific purposes and periods of time. */
    Consent,
    /** # Coverage

Coverage. Insurance or medical plan or a payment agreement. */
    Coverage,
    /** # DeviceUseStatement

DeviceUseStatement. Record of use of a device. */
    DeviceUseStatement,
    /** # DiagnosticReport

DiagnosticReport. A Diagnostic report - a combination of request information, atomic results, images, interpretation, as well as formatted reports. */
    DiagnosticReport,
    /** # DocumentManifest

DocumentManifest. A list that defines a set of documents. */
    DocumentManifest,
    /** # DocumentReference

DocumentReference. A reference to a document. */
    DocumentReference,
    /** # Encounter

Encounter. An interaction during which services are provided to the patient. */
    Encounter,
    /** # EnrollmentResponse

EnrollmentResponse. EnrollmentResponse resource. */
    EnrollmentResponse,
    /** # EpisodeOfCare

EpisodeOfCare. An association of a Patient with an Organization and  Healthcare Provider(s) for a period of time that the Organization assumes some level of responsibility. */
    EpisodeOfCare,
    /** # ExplanationOfBenefit

ExplanationOfBenefit. Explanation of Benefit resource. */
    ExplanationOfBenefit,
    /** # FamilyMemberHistory

FamilyMemberHistory. Information about patient's relatives, relevant for patient. */
    FamilyMemberHistory,
    /** # GuidanceResponse

GuidanceResponse. The formal response to a guidance request. */
    GuidanceResponse,
    /** # ImagingStudy

ImagingStudy. A set of images produced in single study (one or more series of references images). */
    ImagingStudy,
    /** # Immunization

Immunization. Immunization event information. */
    Immunization,
    /** # MeasureReport

MeasureReport. Results of a measure evaluation. */
    MeasureReport,
    /** # Media

Media. A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference. */
    Media,
    /** # MedicationAdministration

MedicationAdministration. Administration of medication to a patient. */
    MedicationAdministration,
    /** # MedicationDispense

MedicationDispense. Dispensing a medication to a named patient. */
    MedicationDispense,
    /** # MedicationStatement

MedicationStatement. Record of medication being taken by a patient. */
    MedicationStatement,
    /** # Observation

Observation. Measurements and simple assertions. */
    Observation,
    /** # PaymentNotice

PaymentNotice. PaymentNotice request. */
    PaymentNotice,
    /** # PaymentReconciliation

PaymentReconciliation. PaymentReconciliation resource. */
    PaymentReconciliation,
    /** # Procedure

Procedure. An action that is being or was performed on a patient. */
    Procedure,
    /** # ProcessResponse

ProcessResponse. ProcessResponse resource. */
    ProcessResponse,
    /** # QuestionnaireResponse

QuestionnaireResponse. A structured set of questions and their answers. */
    QuestionnaireResponse,
    /** # RiskAssessment

RiskAssessment. Potential outcomes for a subject with likelihood. */
    RiskAssessment,
    /** # SupplyDelivery

SupplyDelivery. Delivery of bulk Supplies. */
    SupplyDelivery,
    /** # Task

Task. A task to be performed. */
    Task,
}
impl ::core::str::FromStr for EventResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ChargeItem" => Ok(Self::ChargeItem),
            "ClaimResponse" => Ok(Self::ClaimResponse),
            "ClinicalImpression" => Ok(Self::ClinicalImpression),
            "Communication" => Ok(Self::Communication),
            "Composition" => Ok(Self::Composition),
            "Condition" => Ok(Self::Condition),
            "Consent" => Ok(Self::Consent),
            "Coverage" => Ok(Self::Coverage),
            "DeviceUseStatement" => Ok(Self::DeviceUseStatement),
            "DiagnosticReport" => Ok(Self::DiagnosticReport),
            "DocumentManifest" => Ok(Self::DocumentManifest),
            "DocumentReference" => Ok(Self::DocumentReference),
            "Encounter" => Ok(Self::Encounter),
            "EnrollmentResponse" => Ok(Self::EnrollmentResponse),
            "EpisodeOfCare" => Ok(Self::EpisodeOfCare),
            "ExplanationOfBenefit" => Ok(Self::ExplanationOfBenefit),
            "FamilyMemberHistory" => Ok(Self::FamilyMemberHistory),
            "GuidanceResponse" => Ok(Self::GuidanceResponse),
            "ImagingStudy" => Ok(Self::ImagingStudy),
            "Immunization" => Ok(Self::Immunization),
            "MeasureReport" => Ok(Self::MeasureReport),
            "Media" => Ok(Self::Media),
            "MedicationAdministration" => Ok(Self::MedicationAdministration),
            "MedicationDispense" => Ok(Self::MedicationDispense),
            "MedicationStatement" => Ok(Self::MedicationStatement),
            "Observation" => Ok(Self::Observation),
            "PaymentNotice" => Ok(Self::PaymentNotice),
            "PaymentReconciliation" => Ok(Self::PaymentReconciliation),
            "Procedure" => Ok(Self::Procedure),
            "ProcessResponse" => Ok(Self::ProcessResponse),
            "QuestionnaireResponse" => Ok(Self::QuestionnaireResponse),
            "RiskAssessment" => Ok(Self::RiskAssessment),
            "SupplyDelivery" => Ok(Self::SupplyDelivery),
            "Task" => Ok(Self::Task),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ChargeItem => "ChargeItem",
            Self::ClaimResponse => "ClaimResponse",
            Self::ClinicalImpression => "ClinicalImpression",
            Self::Communication => "Communication",
            Self::Composition => "Composition",
            Self::Condition => "Condition",
            Self::Consent => "Consent",
            Self::Coverage => "Coverage",
            Self::DeviceUseStatement => "DeviceUseStatement",
            Self::DiagnosticReport => "DiagnosticReport",
            Self::DocumentManifest => "DocumentManifest",
            Self::DocumentReference => "DocumentReference",
            Self::Encounter => "Encounter",
            Self::EnrollmentResponse => "EnrollmentResponse",
            Self::EpisodeOfCare => "EpisodeOfCare",
            Self::ExplanationOfBenefit => "ExplanationOfBenefit",
            Self::FamilyMemberHistory => "FamilyMemberHistory",
            Self::GuidanceResponse => "GuidanceResponse",
            Self::ImagingStudy => "ImagingStudy",
            Self::Immunization => "Immunization",
            Self::MeasureReport => "MeasureReport",
            Self::Media => "Media",
            Self::MedicationAdministration => "MedicationAdministration",
            Self::MedicationDispense => "MedicationDispense",
            Self::MedicationStatement => "MedicationStatement",
            Self::Observation => "Observation",
            Self::PaymentNotice => "PaymentNotice",
            Self::PaymentReconciliation => "PaymentReconciliation",
            Self::Procedure => "Procedure",
            Self::ProcessResponse => "ProcessResponse",
            Self::QuestionnaireResponse => "QuestionnaireResponse",
            Self::RiskAssessment => "RiskAssessment",
            Self::SupplyDelivery => "SupplyDelivery",
            Self::Task => "Task",
        }
    }
}
impl<'de> Deserialize<'de> for EventResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EventStatus`. Codes identifying the lifecycle stage of an event.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EventStatus {
    /** # completed

Completed. The event has now concluded. */
    Completed,
    /** # entered-in-error

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "stopped" rather than "entered-in-error".). */
    EnteredInError,
    /** # in-progress

In Progress. The event is currently occurring. */
    InProgress,
    /** # not-done

Not Done. The event was terminated prior to any activity beyond preparation.  I.e. The 'main' activity has not yet begun.  The boundary between preparatory and the 'main' activity is context-specific. */
    NotDone,
    /** # on-hold

On Hold. The event has been temporarily stopped but is expected to resume in the future. */
    OnHold,
    /** # preparation

Preparation. The core event has not started yet, but some staging activities have begun (e.g. surgical suite preparation).  Preparation stages may be tracked for billing purposes. */
    Preparation,
    /** # stopped

Stopped. The event was terminated prior to the full completion of the intended activity but after at least some of the 'main' activity (beyond preparation) has occurred. */
    Stopped,
    /** # unknown

Unknown. The authoring/source system does not know which of the status values currently applies for this event.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply,  but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for EventStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "not-done" => Ok(Self::NotDone),
            "on-hold" => Ok(Self::OnHold),
            "preparation" => Ok(Self::Preparation),
            "stopped" => Ok(Self::Stopped),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EventStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::NotDone => "not-done",
            Self::OnHold => "on-hold",
            Self::Preparation => "preparation",
            Self::Stopped => "stopped",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for EventStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EventTiming`. Real world event relating to the schedule.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum EventTiming {
    /** # AFT

Afternoon. Event occurs during the afternoon. The exact time is unspecified and established by institution convention or patient interpretation. */
    Aft,
    /** # AFT.early

Early Afternoon. Event occurs during the early afternoon. The exact time is unspecified and established by institution convention or patient interpretation. */
    AftEarly,
    /** # AFT.late

Late Afternoon. Event occurs during the late afternoon. The exact time is unspecified and established by institution convention or patient interpretation. */
    AftLate,
    /** # EVE

Evening. Event occurs during the evening. The exact time is unspecified and established by institution convention or patient interpretation. */
    Eve,
    /** # EVE.early

Early Evening. Event occurs during the early evening. The exact time is unspecified and established by institution convention or patient interpretation. */
    EveEarly,
    /** # EVE.late

Late Evening. Event occurs during the late evening. The exact time is unspecified and established by institution convention or patient interpretation. */
    EveLate,
    /** # MORN

Morning. Event occurs during the morning. The exact time is unspecified and established by institution convention or patient interpretation. */
    Morn,
    /** # MORN.early

Early Morning. Event occurs during the early morning. The exact time is unspecified and established by institution convention or patient interpretation. */
    MornEarly,
    /** # MORN.late

Late Morning. Event occurs during the late morning. The exact time is unspecified and established by institution convention or patient interpretation. */
    MornLate,
    /** # NIGHT

Night. Event occurs during the night. The exact time is unspecified and established by institution convention or patient interpretation. */
    Night,
    /** # NOON

Noon. Event occurs around 12:00pm. The exact time is unspecified and established by institution convention or patient interpretation. */
    Noon,
    /** # PHS

After Sleep. Event occurs [offset] after subject goes to sleep. The exact time is unspecified and established by institution convention or patient interpretation. */
    Phs,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for EventTiming {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AFT" => Ok(Self::Aft),
            "AFT.early" => Ok(Self::AftEarly),
            "AFT.late" => Ok(Self::AftLate),
            "EVE" => Ok(Self::Eve),
            "EVE.early" => Ok(Self::EveEarly),
            "EVE.late" => Ok(Self::EveLate),
            "MORN" => Ok(Self::Morn),
            "MORN.early" => Ok(Self::MornEarly),
            "MORN.late" => Ok(Self::MornLate),
            "NIGHT" => Ok(Self::Night),
            "NOON" => Ok(Self::Noon),
            "PHS" => Ok(Self::Phs),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for EventTiming {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aft => "AFT",
            Self::AftEarly => "AFT.early",
            Self::AftLate => "AFT.late",
            Self::Eve => "EVE",
            Self::EveEarly => "EVE.early",
            Self::EveLate => "EVE.late",
            Self::Morn => "MORN",
            Self::MornEarly => "MORN.early",
            Self::MornLate => "MORN.late",
            Self::Night => "NIGHT",
            Self::Noon => "NOON",
            Self::Phs => "PHS",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for EventTiming {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EventTiming {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EvidenceCertaintyRating`. The assessment of quality, confidence, or certainty.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceCertaintyRating {
    /** # absent

absent. possible reason for increasing quality rating was checked and found to be absent. */
    Absent,
    /** # downcode1

reduce rating: -1. reduce quality rating by 1. */
    Downcode1,
    /** # downcode2

reduce rating: -2. reduce quality rating by 2. */
    Downcode2,
    /** # downcode3

reduce rating: -3. reduce quality rating by 3. */
    Downcode3,
    /** # extremely-serious-concern

extremely serious concern. extremely serious concern. */
    ExtremelySeriousConcern,
    /** # high

High quality. High quality evidence. */
    High,
    /** # low

Low quality. Low quality evidence. */
    Low,
    /** # moderate

Moderate quality. Moderate quality evidence. */
    Moderate,
    /** # no-change

no change to rating. no change to quality rating. */
    NoChange,
    /** # no-concern

no serious concern. no serious concern. */
    NoConcern,
    /** # present

present. possible reason for increasing quality rating was checked and found to be present. */
    Present,
    /** # serious-concern

serious concern. serious concern. */
    SeriousConcern,
    /** # upcode1

increase rating: +1. increase quality rating by 1. */
    Upcode1,
    /** # upcode2

increase rating: +2. increase quality rating by 2. */
    Upcode2,
    /** # very-low

Very low quality. Very low quality evidence. */
    VeryLow,
    /** # very-serious-concern

very serious concern. very serious concern. */
    VerySeriousConcern,
}
impl ::core::str::FromStr for EvidenceCertaintyRating {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "absent" => Ok(Self::Absent),
            "downcode1" => Ok(Self::Downcode1),
            "downcode2" => Ok(Self::Downcode2),
            "downcode3" => Ok(Self::Downcode3),
            "extremely-serious-concern" => Ok(Self::ExtremelySeriousConcern),
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            "no-change" => Ok(Self::NoChange),
            "no-concern" => Ok(Self::NoConcern),
            "present" => Ok(Self::Present),
            "serious-concern" => Ok(Self::SeriousConcern),
            "upcode1" => Ok(Self::Upcode1),
            "upcode2" => Ok(Self::Upcode2),
            "very-low" => Ok(Self::VeryLow),
            "very-serious-concern" => Ok(Self::VerySeriousConcern),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceCertaintyRating {
    fn as_ref(&self) -> &str {
        match self {
            Self::Absent => "absent",
            Self::Downcode1 => "downcode1",
            Self::Downcode2 => "downcode2",
            Self::Downcode3 => "downcode3",
            Self::ExtremelySeriousConcern => "extremely-serious-concern",
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
            Self::NoChange => "no-change",
            Self::NoConcern => "no-concern",
            Self::Present => "present",
            Self::SeriousConcern => "serious-concern",
            Self::Upcode1 => "upcode1",
            Self::Upcode2 => "upcode2",
            Self::VeryLow => "very-low",
            Self::VerySeriousConcern => "very-serious-concern",
        }
    }
}
impl<'de> Deserialize<'de> for EvidenceCertaintyRating {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceCertaintyRating {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EvidenceCertaintyType`. The aspect of quality, confidence, or certainty.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceCertaintyType {
    /** # DoseResponseGradient

Dose response gradient. higher certainty due to dose response relationship. */
    DoseResponseGradient,
    /** # Imprecision

Imprecision. fuzzy or wide variability. */
    Imprecision,
    /** # Inconsistency

Inconsistency. concerns that findings are not similar enough to support certainty. */
    Inconsistency,
    /** # Indirectness

Indirectness. concerns reducing external validity. */
    Indirectness,
    /** # LargeEffect

Large effect. higher certainty due to large effect size. */
    LargeEffect,
    /** # Overall

Overall certainty. Overall certainty of evidence (quality of evidence). */
    Overall,
    /** # PlausibleConfounding

Plausible confounding. higher certainty due to risk of bias in opposite direction. */
    PlausibleConfounding,
    /** # PublicationBias

Publication bias. likelihood that what is published misrepresents what is available to publish. */
    PublicationBias,
    /** # RiskOfBias

Risk of bias. methodologic concerns reducing internal validity. */
    RiskOfBias,
}
impl ::core::str::FromStr for EvidenceCertaintyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "DoseResponseGradient" => Ok(Self::DoseResponseGradient),
            "Imprecision" => Ok(Self::Imprecision),
            "Inconsistency" => Ok(Self::Inconsistency),
            "Indirectness" => Ok(Self::Indirectness),
            "LargeEffect" => Ok(Self::LargeEffect),
            "Overall" => Ok(Self::Overall),
            "PlausibleConfounding" => Ok(Self::PlausibleConfounding),
            "PublicationBias" => Ok(Self::PublicationBias),
            "RiskOfBias" => Ok(Self::RiskOfBias),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceCertaintyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DoseResponseGradient => "DoseResponseGradient",
            Self::Imprecision => "Imprecision",
            Self::Inconsistency => "Inconsistency",
            Self::Indirectness => "Indirectness",
            Self::LargeEffect => "LargeEffect",
            Self::Overall => "Overall",
            Self::PlausibleConfounding => "PlausibleConfounding",
            Self::PublicationBias => "PublicationBias",
            Self::RiskOfBias => "RiskOfBias",
        }
    }
}
impl<'de> Deserialize<'de> for EvidenceCertaintyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceCertaintyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EvidenceClassifier`. Commonly used classifiers for evidence sets.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceClassifier {
    /** # AllocConcealNotStated

Allocation concealment not stated. Allocation concealment not stated. */
    AllocConcealNotStated,
    /** # BaselineImbalance

Baseline imbalances. Differences between groups at start of trial may confound or bias the findings. */
    BaselineImbalance,
    /** # COVID19HumanResearch

COVID-19 human data in population, exposure, or outcome. contains human COVID-19 disease in the research data as any variable (population, exposure or outcome). */
    Covid19HumanResearch,
    /** # COVID19Relevant

COVID-19 relevant (but not specific) article. Not about COVID-19 but relevant to COVID-19 management or understanding. */
    Covid19Relevant,
    /** # COVID19Specific

COVID-19 specific article. About COVID-19. */
    Covid19Specific,
    /** # Diagnosis

Article about diagnosis. about methods to distinguish having or not having a condition. */
    Diagnosis,
    /** # EarlyTrialTermination

Early trial termination. Early trial termination. */
    EarlyTrialTermination,
    /** # Guideline

Article includes guideline. for clinical practice guidelines. */
    Guideline,
    /** # NoBlinding

No blinding. No blinding. */
    NoBlinding,
    /** # NoITT

No intention-to-treat analysis. No intention-to-treat analysis. */
    NoITT,
    /** # NotAssessed

Not rated, not assessed. Neither rated as yes nor rated as no. */
    NotAssessed,
    /** # NotResearchNotGuideline

Article is neither research nor guideline. for things that are not research reports, research protocols or guidelines. */
    NotResearchNotGuideline,
    /** # OriginalResearch

Article includes original research. such as randomized trial, observational study. */
    OriginalResearch,
    /** # PreliminaryAnalysis

Preliminary analysis. Preliminary analysis. */
    PreliminaryAnalysis,
    /** # Preprint

Preprint (not final publication). Results presented in preprint (pre-final publication) form. */
    Preprint,
    /** # PreventionAndControl

Article about prevention and control. about preventive care and interventions. */
    PreventionAndControl,
    /** # PrognosisPrediction

Article about prognosis or prediction. about predicting risk for something or risk factors for it. */
    PrognosisPrediction,
    /** # RatedAsCaseControl

classified as case-control study. classified as case-control study. */
    RatedAsCaseControl,
    /** # RatedAsComparativeCohort

classified as comparative cohort study (observational). classified as comparative cohort study (observational). */
    RatedAsComparativeCohort,
    /** # RatedAsControlledTrial

classified as nonrandomized controlled trial (experimental). classified as nonrandomized controlled trial (experimental). */
    RatedAsControlledTrial,
    /** # RatedAsMixedMethods

classified as mixed-methods study. classified as mixed-methods study. */
    RatedAsMixedMethods,
    /** # RatedAsNo

Rated as no, negative, absent, or exclude. Rated as no, negative, absent, or exclude. */
    RatedAsNo,
    /** # RatedAsOther

classified as other concept (not elsewhere classified). classified as other concept (not elsewhere classified). */
    RatedAsOther,
    /** # RatedAsRCT

classified as randomized controlled trial. classified as randomized controlled trial. */
    RatedAsRCT,
    /** # RatedAsUncontrolledSeries

classified as uncontrolled cohort (case series). classified as uncontrolled cohort (case series). */
    RatedAsUncontrolledSeries,
    /** # RatedAsYes

Rated as yes, affirmative, positive, present, or include. */
    RatedAsYes,
    /** # ResearchProtocol

Article provides protocol without results. for research protocols. */
    ResearchProtocol,
    /** # ResearchSynthesis

Article includes synthesis of research. such as systematic review, meta-analysis, rapid review. */
    ResearchSynthesis,
    /** # RiskOfBias

Risk of bias assessment. Risk of bias assessment. */
    RiskOfBias,
    /** # SubgroupAnalysis

Subgroup analysis. Subgroup analysis. */
    SubgroupAnalysis,
    /** # Treatment

Article about treatment. about therapeutic interventions. */
    Treatment,
}
impl ::core::str::FromStr for EvidenceClassifier {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AllocConcealNotStated" => Ok(Self::AllocConcealNotStated),
            "BaselineImbalance" => Ok(Self::BaselineImbalance),
            "COVID19HumanResearch" => Ok(Self::Covid19HumanResearch),
            "COVID19Relevant" => Ok(Self::Covid19Relevant),
            "COVID19Specific" => Ok(Self::Covid19Specific),
            "Diagnosis" => Ok(Self::Diagnosis),
            "EarlyTrialTermination" => Ok(Self::EarlyTrialTermination),
            "Guideline" => Ok(Self::Guideline),
            "NoBlinding" => Ok(Self::NoBlinding),
            "NoITT" => Ok(Self::NoITT),
            "NotAssessed" => Ok(Self::NotAssessed),
            "NotResearchNotGuideline" => Ok(Self::NotResearchNotGuideline),
            "OriginalResearch" => Ok(Self::OriginalResearch),
            "PreliminaryAnalysis" => Ok(Self::PreliminaryAnalysis),
            "Preprint" => Ok(Self::Preprint),
            "PreventionAndControl" => Ok(Self::PreventionAndControl),
            "PrognosisPrediction" => Ok(Self::PrognosisPrediction),
            "RatedAsCaseControl" => Ok(Self::RatedAsCaseControl),
            "RatedAsComparativeCohort" => Ok(Self::RatedAsComparativeCohort),
            "RatedAsControlledTrial" => Ok(Self::RatedAsControlledTrial),
            "RatedAsMixedMethods" => Ok(Self::RatedAsMixedMethods),
            "RatedAsNo" => Ok(Self::RatedAsNo),
            "RatedAsOther" => Ok(Self::RatedAsOther),
            "RatedAsRCT" => Ok(Self::RatedAsRCT),
            "RatedAsUncontrolledSeries" => Ok(Self::RatedAsUncontrolledSeries),
            "RatedAsYes" => Ok(Self::RatedAsYes),
            "ResearchProtocol" => Ok(Self::ResearchProtocol),
            "ResearchSynthesis" => Ok(Self::ResearchSynthesis),
            "RiskOfBias" => Ok(Self::RiskOfBias),
            "SubgroupAnalysis" => Ok(Self::SubgroupAnalysis),
            "Treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceClassifier {
    fn as_ref(&self) -> &str {
        match self {
            Self::AllocConcealNotStated => "AllocConcealNotStated",
            Self::BaselineImbalance => "BaselineImbalance",
            Self::Covid19HumanResearch => "COVID19HumanResearch",
            Self::Covid19Relevant => "COVID19Relevant",
            Self::Covid19Specific => "COVID19Specific",
            Self::Diagnosis => "Diagnosis",
            Self::EarlyTrialTermination => "EarlyTrialTermination",
            Self::Guideline => "Guideline",
            Self::NoBlinding => "NoBlinding",
            Self::NoITT => "NoITT",
            Self::NotAssessed => "NotAssessed",
            Self::NotResearchNotGuideline => "NotResearchNotGuideline",
            Self::OriginalResearch => "OriginalResearch",
            Self::PreliminaryAnalysis => "PreliminaryAnalysis",
            Self::Preprint => "Preprint",
            Self::PreventionAndControl => "PreventionAndControl",
            Self::PrognosisPrediction => "PrognosisPrediction",
            Self::RatedAsCaseControl => "RatedAsCaseControl",
            Self::RatedAsComparativeCohort => "RatedAsComparativeCohort",
            Self::RatedAsControlledTrial => "RatedAsControlledTrial",
            Self::RatedAsMixedMethods => "RatedAsMixedMethods",
            Self::RatedAsNo => "RatedAsNo",
            Self::RatedAsOther => "RatedAsOther",
            Self::RatedAsRCT => "RatedAsRCT",
            Self::RatedAsUncontrolledSeries => "RatedAsUncontrolledSeries",
            Self::RatedAsYes => "RatedAsYes",
            Self::ResearchProtocol => "ResearchProtocol",
            Self::ResearchSynthesis => "ResearchSynthesis",
            Self::RiskOfBias => "RiskOfBias",
            Self::SubgroupAnalysis => "SubgroupAnalysis",
            Self::Treatment => "Treatment",
        }
    }
}
impl<'de> Deserialize<'de> for EvidenceClassifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceClassifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EvidenceDirectness`. The quality of how direct the match is.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceDirectness {
    /** # exact

Exact match between observed and intended variable. Exact matching quality between observed and intended variable, so no concern for indirectness in evidence interpretation. */
    Exact,
    /** # high

High quality match between observed and intended variable. High matching quality between observed and intended variable, so little concern for indirectness in evidence interpretation. */
    High,
    /** # low

Low quality match between observed and intended variable. Low matching quality between observed and intended variable, so very serious concern for indirectness in evidence interpretation. */
    Low,
    /** # moderate

Moderate quality match between observed and intended variable. Moderate matching quality between observed and intended variable, so serious concern for indirectness in evidence interpretation. */
    Moderate,
}
impl ::core::str::FromStr for EvidenceDirectness {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exact" => Ok(Self::Exact),
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceDirectness {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exact => "exact",
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
        }
    }
}
impl<'de> Deserialize<'de> for EvidenceDirectness {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceDirectness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EvidenceReportType`. The kind of report, such as grouping of classifiers, search results, or human-compiled expression.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceReportType {
    /** # classification

Classification. The report is primarily a listing of classifiers about the report subject. */
    Classification,
    /** # resources-compiled

Resource Compilation. The report is a composition containing one or more FHIR resources in the content. */
    ResourcesCompiled,
    /** # search-results

Search Results. The report is a composition of results generated in response to a search query. */
    SearchResults,
    /** # text-structured

Structured Text. The report is a structured representation of text. */
    TextStructured,
}
impl ::core::str::FromStr for EvidenceReportType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "classification" => Ok(Self::Classification),
            "resources-compiled" => Ok(Self::ResourcesCompiled),
            "search-results" => Ok(Self::SearchResults),
            "text-structured" => Ok(Self::TextStructured),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceReportType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Classification => "classification",
            Self::ResourcesCompiled => "resources-compiled",
            Self::SearchResults => "search-results",
            Self::TextStructured => "text-structured",
        }
    }
}
impl<'de> Deserialize<'de> for EvidenceReportType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceReportType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EvidenceVariableHandling`. The handling of the variable in statistical analysis for exposures or outcomes (E.g. Dichotomous, Continuous, Descriptive).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceVariableHandling {
    /** # continuous

continuous variable. A continuous variable is one for which, within the limits the variable ranges, any value is possible (from STATO http://purl.obolibrary.org/obo/STATO_0000251). */
    Continuous,
    /** # dichotomous

dichotomous variable. A dichotomous variable is a categorical variable which is defined to have only 2 categories or possible values (from STATO http://purl.obolibrary.org/obo/STATO_0000090). */
    Dichotomous,
    /** # ordinal

ordinal variable. An ordinal variable is a categorical variable where the discrete possible values are ordered or correspond to an implicit ranking (from STATO http://purl.obolibrary.org/obo/STATO_0000228). */
    Ordinal,
    /** # polychotomous

polychotomous variable. A polychotomous variable is a categorical variable which is defined to have minimally 2 categories or possible values. (from STATO  http://purl.obolibrary.org/obo/STATO_0000087).  Suggestion to limit code use to situations when neither dichotomous nor ordinal variables apply. */
    Polychotomous,
}
impl ::core::str::FromStr for EvidenceVariableHandling {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "continuous" => Ok(Self::Continuous),
            "dichotomous" => Ok(Self::Dichotomous),
            "ordinal" => Ok(Self::Ordinal),
            "polychotomous" => Ok(Self::Polychotomous),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceVariableHandling {
    fn as_ref(&self) -> &str {
        match self {
            Self::Continuous => "continuous",
            Self::Dichotomous => "dichotomous",
            Self::Ordinal => "ordinal",
            Self::Polychotomous => "polychotomous",
        }
    }
}
impl<'de> Deserialize<'de> for EvidenceVariableHandling {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceVariableHandling {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EvidenceVariableRole`. The role that the assertion variable plays.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceVariableRole {
    /** # confounder

confounder. variable represents a confounder. */
    Confounder,
    /** # exposure

exposure. variable represents an exposure. */
    Exposure,
    /** # measuredVariable

measured variable. variable represents a measured variable. */
    MeasuredVariable,
    /** # population

population. variable represents a population. */
    Population,
    /** # referenceExposure

reference exposure. variable represents a reference exposure. */
    ReferenceExposure,
    /** # subpopulation

subpopulation. variable represents a subpopulation. */
    Subpopulation,
}
impl ::core::str::FromStr for EvidenceVariableRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "confounder" => Ok(Self::Confounder),
            "exposure" => Ok(Self::Exposure),
            "measuredVariable" => Ok(Self::MeasuredVariable),
            "population" => Ok(Self::Population),
            "referenceExposure" => Ok(Self::ReferenceExposure),
            "subpopulation" => Ok(Self::Subpopulation),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceVariableRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Confounder => "confounder",
            Self::Exposure => "exposure",
            Self::MeasuredVariable => "measuredVariable",
            Self::Population => "population",
            Self::ReferenceExposure => "referenceExposure",
            Self::Subpopulation => "subpopulation",
        }
    }
}
impl<'de> Deserialize<'de> for EvidenceVariableRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceVariableRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `EvidenceVariableType`. The possible types of variables for exposures or outcomes (E.g. Dichotomous, Continuous, Descriptive).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum EvidenceVariableType {
    /** # continuous

Continuous. The variable is a continuous result such as a quantity. */
    Continuous,
    /** # descriptive

Descriptive. The variable is described narratively rather than quantitatively. */
    Descriptive,
    /** # dichotomous

Dichotomous. The variable is dichotomous, such as present or absent. */
    Dichotomous,
}
impl ::core::str::FromStr for EvidenceVariableType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "continuous" => Ok(Self::Continuous),
            "descriptive" => Ok(Self::Descriptive),
            "dichotomous" => Ok(Self::Dichotomous),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for EvidenceVariableType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Continuous => "continuous",
            Self::Descriptive => "descriptive",
            Self::Dichotomous => "dichotomous",
        }
    }
}
impl<'de> Deserialize<'de> for EvidenceVariableType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for EvidenceVariableType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleClaimSubTypeCodes`. This value set includes sample Claim SubType codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleClaimSubTypeCodes {
    /** # emergency

Emergency Claim. A claim for emergency services. */
    Emergency,
    /** # ortho

Orthodontic Claim. A claim for Orthodontic Services. */
    Ortho,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleClaimSubTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "emergency" => Ok(Self::Emergency),
            "ortho" => Ok(Self::Ortho),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleClaimSubTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Emergency => "emergency",
            Self::Ortho => "ortho",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleClaimSubTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleClaimSubTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleCoverageFinancialExceptionsCode`. This codeset includes Example Coverage Financial Exceptions Code.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleCoverageFinancialExceptionsCode {
    /** # foster

Foster child. Children in the foster care have all copays and deductibles waived. */
    Foster,
    /** # retired

Retired. Retired persons have all copays and deductibles reduced. */
    Retired,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleCoverageFinancialExceptionsCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "foster" => Ok(Self::Foster),
            "retired" => Ok(Self::Retired),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleCoverageFinancialExceptionsCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Foster => "foster",
            Self::Retired => "retired",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleCoverageFinancialExceptionsCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleCoverageFinancialExceptionsCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleDiagnosisOnAdmissionCodes`. This value set includes example Diagnosis on admission codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleDiagnosisOnAdmissionCodes {
    /** # n

No. Diagnosis was not present at time of inpatient admission. */
    N,
    /** # u

Unknown. Documentation insufficient to determine if condition was present at the time of inpatient admission. */
    U,
    /** # w

Undetermined. Clinically undetermined. Provider unable to clinically determine whether the condition was present at the time of inpatient admission. */
    W,
    /** # y

Yes. Diagnosis was present at time of inpatient admission. */
    Y,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleDiagnosisOnAdmissionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "n" => Ok(Self::N),
            "u" => Ok(Self::U),
            "w" => Ok(Self::W),
            "y" => Ok(Self::Y),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleDiagnosisOnAdmissionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N => "n",
            Self::U => "u",
            Self::W => "w",
            Self::Y => "y",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleDiagnosisOnAdmissionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleDiagnosisOnAdmissionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleDiagnosisRelatedGroupCodes`. This value set includes sample Diagnosis Related Group codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleDiagnosisRelatedGroupCodes {
    /** # 100

Normal Vaginal Delivery. Normal Vaginal Delivery. */
    N100,
    /** # 101

Appendectomy - uncomplicated. Appendectomy without rupture or other complications. */
    N101,
    /** # 300

Tooth abscess. Emergency department treatment of a tooth abscess. */
    N300,
    /** # 400

Head trauma - concussion. Head trauma - concussion. */
    N400,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleDiagnosisRelatedGroupCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100" => Ok(Self::N100),
            "101" => Ok(Self::N101),
            "300" => Ok(Self::N300),
            "400" => Ok(Self::N400),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleDiagnosisRelatedGroupCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100 => "100",
            Self::N101 => "101",
            Self::N300 => "300",
            Self::N400 => "400",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleDiagnosisRelatedGroupCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleDiagnosisRelatedGroupCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleDiagnosisTypeCodes`. This value set includes example Diagnosis Type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleDiagnosisTypeCodes {
    /** # admitting

Admitting Diagnosis. The diagnosis given as the reason why the patient was admitted to the hospital. */
    Admitting,
    /** # clinical

Clinical Diagnosis. A diagnosis made on the basis of medical signs and patient-reported symptoms, rather than diagnostic tests. */
    Clinical,
    /** # differential

Differential Diagnosis. One of a set of the possible diagnoses that could be connected to the signs, symptoms, and lab findings. */
    Differential,
    /** # discharge

Discharge Diagnosis. The diagnosis given when the patient is discharged from the hospital. */
    Discharge,
    /** # laboratory

Laboratory Diagnosis. A diagnosis based significantly on laboratory reports or test results, rather than the physical examination of the patient. */
    Laboratory,
    /** # nursing

Nursing Diagnosis. A diagnosis which identifies people's responses to situations in their lives, such as a readiness to change or a willingness to accept assistance. */
    Nursing,
    /** # prenatal

Prenatal Diagnosis. A diagnosis determined prior to birth. */
    Prenatal,
    /** # principal

Principal Diagnosis. The single medical diagnosis that is most relevant to the patient's chief complaint or need for treatment. */
    Principal,
    /** # radiology

Radiology Diagnosis. A diagnosis based primarily on the results from medical imaging studies. */
    Radiology,
    /** # remote

Remote Diagnosis. A diagnosis determined using telemedicine techniques. */
    Remote,
    /** # retrospective

Retrospective Diagnosis. The labeling of an illness in a specific historical event using modern knowledge, methods and disease classifications. */
    Retrospective,
    /** # self

Self Diagnosis. A diagnosis determined by the patient. */
    _Self,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleDiagnosisTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "admitting" => Ok(Self::Admitting),
            "clinical" => Ok(Self::Clinical),
            "differential" => Ok(Self::Differential),
            "discharge" => Ok(Self::Discharge),
            "laboratory" => Ok(Self::Laboratory),
            "nursing" => Ok(Self::Nursing),
            "prenatal" => Ok(Self::Prenatal),
            "principal" => Ok(Self::Principal),
            "radiology" => Ok(Self::Radiology),
            "remote" => Ok(Self::Remote),
            "retrospective" => Ok(Self::Retrospective),
            "self" => Ok(Self::_Self),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleDiagnosisTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Admitting => "admitting",
            Self::Clinical => "clinical",
            Self::Differential => "differential",
            Self::Discharge => "discharge",
            Self::Laboratory => "laboratory",
            Self::Nursing => "nursing",
            Self::Prenatal => "prenatal",
            Self::Principal => "principal",
            Self::Radiology => "radiology",
            Self::Remote => "remote",
            Self::Retrospective => "retrospective",
            Self::_Self => "self",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleDiagnosisTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleDiagnosisTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleMessageReasonCodes`. Example Message Reasons. These are the set of codes that might be used an updating an encounter using admin-update.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleMessageReasonCodes {
    /** # absent

Absent. The patient has temporarily left the institution. */
    Absent,
    /** # admit

Admit. The patient has been admitted. */
    Admit,
    /** # discharge

Discharge. The patient has been discharged. */
    Discharge,
    /** # edit

Edit. Encounter details have been updated (e.g. to correct a coding error). */
    Edit,
    /** # moved

Moved. The patient has been moved to a new location. */
    Moved,
    /** # return

Returned. The patient has returned from a temporary absence. */
    Return,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleMessageReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "absent" => Ok(Self::Absent),
            "admit" => Ok(Self::Admit),
            "discharge" => Ok(Self::Discharge),
            "edit" => Ok(Self::Edit),
            "moved" => Ok(Self::Moved),
            "return" => Ok(Self::Return),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleMessageReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Absent => "absent",
            Self::Admit => "admit",
            Self::Discharge => "discharge",
            Self::Edit => "edit",
            Self::Moved => "moved",
            Self::Return => "return",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleMessageReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleMessageReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleProcedureTypeCodes`. This value set includes example Procedure Type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleProcedureTypeCodes {
    /** # primary

Primary procedure. The first procedure in a series required to produce and overall patient outcome. */
    Primary,
    /** # secondary

Secondary procedure. The second procedure in a series required to produce and overall patient outcome. */
    Secondary,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleProcedureTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "primary" => Ok(Self::Primary),
            "secondary" => Ok(Self::Secondary),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleProcedureTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Primary => "primary",
            Self::Secondary => "secondary",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleProcedureTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleProcedureTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleProgramCodes`. This value set includes sample Program reason codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleProgramCodes {
    /** # as

Child Asthma. Child Asthma Program */
    As,
    /** # auscr

Autism Screening. Autism Screening Program. */
    Auscr,
    /** # hd

Hemodialysis. Hemodialysis Program. */
    Hd,
    /** # none

None. No program code applies. */
    None,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleProgramCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "as" => Ok(Self::As),
            "auscr" => Ok(Self::Auscr),
            "hd" => Ok(Self::Hd),
            "none" => Ok(Self::None),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleProgramCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::As => "as",
            Self::Auscr => "auscr",
            Self::Hd => "hd",
            Self::None => "none",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleProgramCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleProgramCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleProviderQualificationCodes`. This value set includes sample Provider Qualification codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleProviderQualificationCodes {
    /** # 311405

Dentist. Dentist General Practitioner (DDS, DDM). */
    N311405,
    /** # 604210

Optometrist. Optometrist. */
    N604210,
    /** # 604215

Ophthalmologist. Ophthalmologist. */
    N604215,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleProviderQualificationCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "311405" => Ok(Self::N311405),
            "604210" => Ok(Self::N604210),
            "604215" => Ok(Self::N604215),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleProviderQualificationCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N311405 => "311405",
            Self::N604210 => "604210",
            Self::N604215 => "604215",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleProviderQualificationCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleProviderQualificationCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleRelatedClaimRelationshipCodes`. This value set includes sample Related Claim Relationship codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleRelatedClaimRelationshipCodes {
    /** # associated

Associated Claim. A claim for a different suite of services which is related the suite claimed here. */
    Associated,
    /** # prior

Prior Claim. A prior claim instance for the same intended suite of services. */
    Prior,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleRelatedClaimRelationshipCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "associated" => Ok(Self::Associated),
            "prior" => Ok(Self::Prior),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleRelatedClaimRelationshipCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Associated => "associated",
            Self::Prior => "prior",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleRelatedClaimRelationshipCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleRelatedClaimRelationshipCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleRevenueCenterCodes`. This value set includes sample Revenue Center codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleRevenueCenterCodes {
    /** # 0010

Vision Clinic. Vision Clinic */
    N0010,
    /** # 0370

Anaesthesia. Anaesthesia. */
    N0370,
    /** # 0420

Physical Therapy. Physical Therapy. */
    N0420,
    /** # 0421

Physical Therapy -. Physical Therapy - visit charge. */
    N0421,
    /** # 0440

Speech-Language Pathology. Speech-Language Pathology. */
    N0440,
    /** # 0441

Speech-Language Pathology - Visit. Speech-Language Pathology- visit charge */
    N0441,
    /** # 0450

Emergency Room. Emergency Room */
    N0450,
    /** # 0451

Emergency Room - EM/EMTALA. Emergency Room - EM/EMTALA */
    N0451,
    /** # 0452

Emergency Room - beyond EMTALA. Emergency Room - beyond EMTALA */
    N0452,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleRevenueCenterCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0010" => Ok(Self::N0010),
            "0370" => Ok(Self::N0370),
            "0420" => Ok(Self::N0420),
            "0421" => Ok(Self::N0421),
            "0440" => Ok(Self::N0440),
            "0441" => Ok(Self::N0441),
            "0450" => Ok(Self::N0450),
            "0451" => Ok(Self::N0451),
            "0452" => Ok(Self::N0452),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleRevenueCenterCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0010 => "0010",
            Self::N0370 => "0370",
            Self::N0420 => "0420",
            Self::N0421 => "0421",
            Self::N0440 => "0440",
            Self::N0441 => "0441",
            Self::N0450 => "0450",
            Self::N0451 => "0451",
            Self::N0452 => "0452",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleRevenueCenterCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleRevenueCenterCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleScenarioActorType`. The type of actor - system or human.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ExampleScenarioActorType {
    /** # entity

System. A system. */
    Entity,
    /** # person

Person. A person. */
    Person,
}
impl ::core::str::FromStr for ExampleScenarioActorType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "entity" => Ok(Self::Entity),
            "person" => Ok(Self::Person),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExampleScenarioActorType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Entity => "entity",
            Self::Person => "person",
        }
    }
}
impl<'de> Deserialize<'de> for ExampleScenarioActorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleScenarioActorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleServicePlaceCodes`. This value set includes a smattering of Service Place codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleServicePlaceCodes {
    /** # 01

Pharmacy. A facility or location where drugs and other medically related items and services are sold, dispensed, or otherwise provided directly to patients. */
    N01,
    /** # 03

School. A facility whose primary purpose is education. */
    N03,
    /** # 04

Homeless Shelter. A facility or location whose primary purpose is to provide temporary housing to homeless individuals (e.g., emergency shelters, individual or family shelters). */
    N04,
    /** # 05

Indian Health Service Free-standing Facility. A facility or location, owned and operated by the Indian Health Service, which provides diagnostic, therapeutic (surgical and nonsurgical), and rehabilitation services to American Indians and Alaska Natives who do not require hospitalization. */
    N05,
    /** # 06

Indian Health Service Provider-based Facility. A facility or location, owned and operated by the Indian Health Service, which provides diagnostic, therapeutic (surgical and nonsurgical), and rehabilitation services rendered by, or under the supervision of, physicians to American Indians and Alaska Natives admitted as inpatients or outpatients. */
    N06,
    /** # 07

Tribal 638 Free-Standing Facility. A facility or location owned and operated by a federally recognized American Indian or Alaska Native tribe or tribal organization under a 638 agreement, which provides diagnostic, therapeutic (surgical and nonsurgical), and rehabilitation services to tribal members who do not require hospitalization. */
    N07,
    /** # 08

Tribal 638 Provider-Based Facility. A facility or location owned and operated by a federally recognized American Indian or Alaska Native tribe or tribal organization under a 638 agreement, which provides diagnostic, therapeutic (surgical and nonsurgical), and rehabilitation services to tribal members admitted as inpatients or outpatients. */
    N08,
    /** # 09

Prison/Correctional Facility. A prison, jail, reformatory, work farm, detention center, or any other similar facility maintained by either Federal, State or local authorities for the purpose of confinement or rehabilitation of adult or juvenile criminal offenders. */
    N09,
    /** # 11

Office. Location, other than a hospital, skilled nursing facility (SNF), military treatment facility, community health center, State or local public health clinic, or intermediate care facility (ICF), where the health professional routinely provides health examinations, diagnosis, and treatment of illness or injury on an ambulatory basis. */
    N11,
    /** # 12

Home. Location, other than a hospital or other facility, where the patient receives care in a private residence. */
    N12,
    /** # 13

Assisted Living Fa. Congregate residential facility with self-contained living units providing assessment of each resident's needs and on-site support 24 hours a day, 7 days a week, with the capacity to deliver or arrange for services including some health care and other services. */
    N13,
    /** # 14

Group Home. A residence, with shared living areas, where clients receive supervision and other services such as social and/or behavioral services, custodial service, and minimal services (e.g., medication administration). */
    N14,
    /** # 15

Mobile Unit. A facility/unit that moves from place-to-place equipped to provide preventive, screening, diagnostic, and/or treatment services. */
    N15,
    /** # 19

Off Campus-Outpatient Hospital. portion of an off-campus hospital provider-based department which provides diagnostic, therapeutic (both surgical and nonsurgical), and rehabilitation services to sick or injured persons who do not require hospitalization or institutionalization. */
    N19,
    /** # 20

Urgent Care Facility. Location, distinct from a hospital emergency room, an office, or a clinic, whose purpose is to diagnose and treat illness or injury for unscheduled, ambulatory patients seeking immediate medical attention. */
    N20,
    /** # 21

Inpatient Hospital. A facility, other than psychiatric, which primarily provides diagnostic, therapeutic (both surgical and nonsurgical), and rehabilitation services by, or under, the supervision of physicians to patients admitted for a variety of medical conditions. */
    N21,
    /** # 41

Ambulance—Land. A land vehicle specifically designed, equipped and staffed for lifesaving and transporting the sick or injured. */
    N41,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleServicePlaceCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "01" => Ok(Self::N01),
            "03" => Ok(Self::N03),
            "04" => Ok(Self::N04),
            "05" => Ok(Self::N05),
            "06" => Ok(Self::N06),
            "07" => Ok(Self::N07),
            "08" => Ok(Self::N08),
            "09" => Ok(Self::N09),
            "11" => Ok(Self::N11),
            "12" => Ok(Self::N12),
            "13" => Ok(Self::N13),
            "14" => Ok(Self::N14),
            "15" => Ok(Self::N15),
            "19" => Ok(Self::N19),
            "20" => Ok(Self::N20),
            "21" => Ok(Self::N21),
            "41" => Ok(Self::N41),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleServicePlaceCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N01 => "01",
            Self::N03 => "03",
            Self::N04 => "04",
            Self::N05 => "05",
            Self::N06 => "06",
            Self::N07 => "07",
            Self::N08 => "08",
            Self::N09 => "09",
            Self::N11 => "11",
            Self::N12 => "12",
            Self::N13 => "13",
            Self::N14 => "14",
            Self::N15 => "15",
            Self::N19 => "19",
            Self::N20 => "20",
            Self::N21 => "21",
            Self::N41 => "41",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleServicePlaceCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleServicePlaceCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleUseCodesForList`. Example use codes for the List resource - typical kinds of use.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleUseCodesForList {
    /** # adverserxns

Adverse Reactions. A list of part adverse reactions. */
    Adverserxns,
    /** # alerts

Alerts. A list of alerts for the patient. */
    Alerts,
    /** # allergies

Allergies. A list of Allergies for the patient. */
    Allergies,
    /** # medications

Medication List. A list of medication statements for the patient. */
    Medications,
    /** # plans

Care Plans. A set of care plans that apply in a particular context of care. */
    Plans,
    /** # problems

Problem List. A list of problems that the patient is known of have (or have had in the past). */
    Problems,
    /** # protocols

Protocols. A set of protocols to be followed. */
    Protocols,
    /** # waiting

Waiting List. A list of items waiting for an event (perhaps a surgical patient waiting list). */
    Waiting,
    /** # worklist

Worklist. A list of items that constitute a set of work to be performed (typically this code would be specialized for more specific uses, such as a ward round list). */
    Worklist,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleUseCodesForList {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "adverserxns" => Ok(Self::Adverserxns),
            "alerts" => Ok(Self::Alerts),
            "allergies" => Ok(Self::Allergies),
            "medications" => Ok(Self::Medications),
            "plans" => Ok(Self::Plans),
            "problems" => Ok(Self::Problems),
            "protocols" => Ok(Self::Protocols),
            "waiting" => Ok(Self::Waiting),
            "worklist" => Ok(Self::Worklist),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleUseCodesForList {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adverserxns => "adverserxns",
            Self::Alerts => "alerts",
            Self::Allergies => "allergies",
            Self::Medications => "medications",
            Self::Plans => "plans",
            Self::Problems => "problems",
            Self::Protocols => "protocols",
            Self::Waiting => "waiting",
            Self::Worklist => "worklist",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleUseCodesForList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleUseCodesForList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExampleVisionPrescriptionProductCodes`. This value set includes a smattering of Prescription Product codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExampleVisionPrescriptionProductCodes {
    /** # contact

Contact Lens. A lens to be fitted for wearing directly on an eye. */
    Contact,
    /** # lens

Lens. A lens to be fitted to a frame to comprise a pair of glasses. */
    Lens,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExampleVisionPrescriptionProductCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contact" => Ok(Self::Contact),
            "lens" => Ok(Self::Lens),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExampleVisionPrescriptionProductCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Contact => "contact",
            Self::Lens => "lens",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExampleVisionPrescriptionProductCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExampleVisionPrescriptionProductCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExceptionCodes`. This value set includes sample Exception codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExceptionCodes {
    /** # disabled

Disabled. Disabled */
    Disabled,
    /** # student

Student (Fulltime). Fulltime Student */
    Student,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExceptionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "disabled" => Ok(Self::Disabled),
            "student" => Ok(Self::Student),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExceptionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Disabled => "disabled",
            Self::Student => "student",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExceptionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExceptionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExplanationOfBenefitStatus`. A code specifying the state of the resource instance.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ExplanationOfBenefitStatus {
    /** # active

Active. The resource instance is currently in-force. */
    Active,
    /** # cancelled

Cancelled. The resource instance is withdrawn, rescinded or reversed. */
    Cancelled,
    /** # draft

Draft. A new resource instance the contents of which is not complete. */
    Draft,
    /** # entered-in-error

Entered In Error. The resource instance was entered in error. */
    EnteredInError,
}
impl ::core::str::FromStr for ExplanationOfBenefitStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExplanationOfBenefitStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
        }
    }
}
impl<'de> Deserialize<'de> for ExplanationOfBenefitStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExplanationOfBenefitStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExpressionLanguage`. The media type of the expression language.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ExpressionLanguage {
    /** # application/x-fhir-query

FHIR Query. FHIR's RESTful query syntax - typically independent of base URL. */
    ApplicationXFhirQuery,
    /** # text/cql

CQL. Clinical Quality Language. */
    TextCql,
    /** # text/cql-expression

CQL Expression. A Clinical Quality Language expression. */
    TextCqlExpression,
    /** # text/cql-identifier

CQL Identifier. A valid Clinical Quality Language identifier. */
    TextCqlIdentifier,
    /** # text/fhirpath

FHIRPath. FHIRPath. */
    TextFhirpath,
}
impl ::core::str::FromStr for ExpressionLanguage {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "application/x-fhir-query" => Ok(Self::ApplicationXFhirQuery),
            "text/cql" => Ok(Self::TextCql),
            "text/cql-expression" => Ok(Self::TextCqlExpression),
            "text/cql-identifier" => Ok(Self::TextCqlIdentifier),
            "text/fhirpath" => Ok(Self::TextFhirpath),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExpressionLanguage {
    fn as_ref(&self) -> &str {
        match self {
            Self::ApplicationXFhirQuery => "application/x-fhir-query",
            Self::TextCql => "text/cql",
            Self::TextCqlExpression => "text/cql-expression",
            Self::TextCqlIdentifier => "text/cql-identifier",
            Self::TextFhirpath => "text/fhirpath",
        }
    }
}
impl<'de> Deserialize<'de> for ExpressionLanguage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExpressionLanguage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExtensionContextType`. How an extension context is interpreted.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ExtensionContextType {
    /** # element

Element ID. The context is any element that has an ElementDefinition.id that matches that found in the expression. This includes ElementDefinition Ids that have slicing identifiers. The full path for the element is [url]#[elementid]. If there is no #, the Element id is one defined in the base specification. */
    Element,
    /** # extension

Extension URL. The context is a particular extension from a particular StructureDefinition, and the expression is just a uri that identifies the extension. */
    Extension,
    /** # fhirpath

FHIRPath. The context is all elements that match the FHIRPath query found in the expression. */
    Fhirpath,
}
impl ::core::str::FromStr for ExtensionContextType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "element" => Ok(Self::Element),
            "extension" => Ok(Self::Extension),
            "fhirpath" => Ok(Self::Fhirpath),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ExtensionContextType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Element => "element",
            Self::Extension => "extension",
            Self::Fhirpath => "fhirpath",
        }
    }
}
impl<'de> Deserialize<'de> for ExtensionContextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExtensionContextType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ExtraActivityType`. This value set includes coded concepts not well covered in any of the included valuesets.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExtraActivityType {
    /** # aggregate

aggregate. Activity resulting in a structured collection of preexisting content that does not necessarily result in an integral object with semantic context making it more than the sum of component parts, from which components could be disaggregated without loss of semantic context, e.g., the assembly of multiple stand-alone documents. */
    Aggregate,
    /** # compose

compose. Activity resulting in the structured compilation of new and preexisting content for the purposes of forming an integral object with  semantic context making it more than the sum of component parts, which would be lost if decomposed. For example, the composition of a document that includes in whole or part other documents along with new content that result in a new document that has unique semantic meaning. */
    Compose,
    /** # label

label. The means used to associate a set of security attributes with a specific information object as part of the data structure for that object. [ISO-10181-3 Access Control] */
    Label,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ExtraActivityType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "aggregate" => Ok(Self::Aggregate),
            "compose" => Ok(Self::Compose),
            "label" => Ok(Self::Label),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ExtraActivityType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Aggregate => "aggregate",
            Self::Compose => "compose",
            Self::Label => "label",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ExtraActivityType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ExtraActivityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `FamilyHistoryAbsentReason`. Codes describing the reason why a family member's history is not available.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FamilyHistoryAbsentReason {
    /** # deferred

Deferred. Patient does not have the information now, but can provide the information at a later date. */
    Deferred,
    /** # subject-unknown

Subject Unknown. Patient does not know the subject, e.g. the biological parent of an adopted patient. */
    SubjectUnknown,
    /** # unable-to-obtain

Unable To Obtain. Information cannot be obtained; e.g. unconscious patient. */
    UnableToObtain,
    /** # withheld

Information Withheld. The patient withheld or refused to share the information. */
    Withheld,
}
impl ::core::str::FromStr for FamilyHistoryAbsentReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deferred" => Ok(Self::Deferred),
            "subject-unknown" => Ok(Self::SubjectUnknown),
            "unable-to-obtain" => Ok(Self::UnableToObtain),
            "withheld" => Ok(Self::Withheld),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FamilyHistoryAbsentReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deferred => "deferred",
            Self::SubjectUnknown => "subject-unknown",
            Self::UnableToObtain => "unable-to-obtain",
            Self::Withheld => "withheld",
        }
    }
}
impl<'de> Deserialize<'de> for FamilyHistoryAbsentReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FamilyHistoryAbsentReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `FamilyHistoryStatus`. A code that identifies the status of the family history record.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FamilyHistoryStatus {
    /** # completed

Completed. All available related health information is captured as of the date (and possibly time) when the family member history was taken. */
    Completed,
    /** # entered-in-error

Entered in Error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** # health-unknown

Health Unknown. Health information for this family member is unavailable/unknown. */
    HealthUnknown,
    /** # partial

Partial. Some health information is known and captured, but not complete - see notes for details. */
    Partial,
}
impl ::core::str::FromStr for FamilyHistoryStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "health-unknown" => Ok(Self::HealthUnknown),
            "partial" => Ok(Self::Partial),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FamilyHistoryStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::HealthUnknown => "health-unknown",
            Self::Partial => "partial",
        }
    }
}
impl<'de> Deserialize<'de> for FamilyHistoryStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FamilyHistoryStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `FeedingDeviceCodes`. Materials used or needed to feed the patient. These values are provided as a suggestive example.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum FeedingDeviceCodes {
    /** # angled-utensil

Angled utensils. Angled utensils definition: */
    AngledUtensil,
    /** # autofeeding-device

Automated feeding devices. Automated feeding devices definition: */
    AutofeedingDevice,
    /** # bigcut-nipple

Enlarged, cross-cut nipple. Enlarged, cross-cut nipple definition: */
    BigcutNipple,
    /** # foam-handle

Foam handle utensils. Foam handle utensils definition: */
    FoamHandle,
    /** # glass-lid

Glass with lid/sippy cup. Glass with lid/sippy cup definition: */
    GlassLid,
    /** # haberman-bottle

Haberman bottle. Haberman bottle definition: */
    HabermanBottle,
    /** # handhold-cup

Double handhold on glass/cup. Double handhold on glass/cup definition: */
    HandholdCup,
    /** # midflo-nipple

Middle flow nipple. Middle flow nipple definition: */
    MidfloNipple,
    /** # nose-cup

Nose cup. Nose cup definition: */
    NoseCup,
    /** # ortho-nipple

Orthodontic nipple. Orthodontic nipple definition: */
    OrthoNipple,
    /** # preemie-nipple

Preemie nipple. Preemie nipple definition: */
    PreemieNipple,
    /** # provale-cup

Provale Cup. Provale Cup definition: */
    ProvaleCup,
    /** # rocker-knife

Rocker knife. Rocker knife definition: */
    RockerKnife,
    /** # rubber-mat

Rubber matting under tray. Rubber matting under tray definition: */
    RubberMat,
    /** # scoop-plate

Scoop plate. Scoop plate definition: */
    ScoopPlate,
    /** # sippy-no-valve

Sippy cup without valve. Sippy cup without valve definition: */
    SippyNoValve,
    /** # sippy-valve

Sippy cup with valve. Sippy cup with valve definition: */
    SippyValve,
    /** # sloflo-nipple

Slow flow nipple. Slow flow nipple definition: */
    SlofloNipple,
    /** # spout-cup

Spout cup. Spout cup definition: */
    SpoutCup,
    /** # standard-nipple

Standard nipple. Standard nipple definition: */
    StandardNipple,
    /** # straw

Straw. Straw definition: */
    Straw,
    /** # utensil-holder

Hand wrap utensil holder. Hand wrap utensil holder definition: */
    UtensilHolder,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for FeedingDeviceCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "angled-utensil" => Ok(Self::AngledUtensil),
            "autofeeding-device" => Ok(Self::AutofeedingDevice),
            "bigcut-nipple" => Ok(Self::BigcutNipple),
            "foam-handle" => Ok(Self::FoamHandle),
            "glass-lid" => Ok(Self::GlassLid),
            "haberman-bottle" => Ok(Self::HabermanBottle),
            "handhold-cup" => Ok(Self::HandholdCup),
            "midflo-nipple" => Ok(Self::MidfloNipple),
            "nose-cup" => Ok(Self::NoseCup),
            "ortho-nipple" => Ok(Self::OrthoNipple),
            "preemie-nipple" => Ok(Self::PreemieNipple),
            "provale-cup" => Ok(Self::ProvaleCup),
            "rocker-knife" => Ok(Self::RockerKnife),
            "rubber-mat" => Ok(Self::RubberMat),
            "scoop-plate" => Ok(Self::ScoopPlate),
            "sippy-no-valve" => Ok(Self::SippyNoValve),
            "sippy-valve" => Ok(Self::SippyValve),
            "sloflo-nipple" => Ok(Self::SlofloNipple),
            "spout-cup" => Ok(Self::SpoutCup),
            "standard-nipple" => Ok(Self::StandardNipple),
            "straw" => Ok(Self::Straw),
            "utensil-holder" => Ok(Self::UtensilHolder),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for FeedingDeviceCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::AngledUtensil => "angled-utensil",
            Self::AutofeedingDevice => "autofeeding-device",
            Self::BigcutNipple => "bigcut-nipple",
            Self::FoamHandle => "foam-handle",
            Self::GlassLid => "glass-lid",
            Self::HabermanBottle => "haberman-bottle",
            Self::HandholdCup => "handhold-cup",
            Self::MidfloNipple => "midflo-nipple",
            Self::NoseCup => "nose-cup",
            Self::OrthoNipple => "ortho-nipple",
            Self::PreemieNipple => "preemie-nipple",
            Self::ProvaleCup => "provale-cup",
            Self::RockerKnife => "rocker-knife",
            Self::RubberMat => "rubber-mat",
            Self::ScoopPlate => "scoop-plate",
            Self::SippyNoValve => "sippy-no-valve",
            Self::SippyValve => "sippy-valve",
            Self::SlofloNipple => "sloflo-nipple",
            Self::SpoutCup => "spout-cup",
            Self::StandardNipple => "standard-nipple",
            Self::Straw => "straw",
            Self::UtensilHolder => "utensil-holder",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for FeedingDeviceCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FeedingDeviceCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `FilterOperator`. The kind of operation to perform as a part of a property based filter.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FilterOperator {
    /** # =

Equals. The specified property of the code equals the provided value. */
    Equal,
    /** # descendent-of

Descendent Of (by subsumption). Includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, excluding the provided concept itself i.e. include descendant codes only). */
    DescendentOf,
    /** # exists

Exists. The specified property of the code has at least one value (if the specified value is true; if the specified value is false, then matches when the specified property of the code has no values). */
    Exists,
    /** # generalizes

Generalizes (by Subsumption). Includes all concept ids that have a transitive is-a relationship from the concept Id provided as the value, including the provided concept itself (i.e. include ancestor codes and self). */
    Generalizes,
    /** # in

In Set. The specified property of the code is in the set of codes or concepts specified in the provided value (comma separated list). */
    In,
    /** # is-a

Is A (by subsumption). Includes all concept ids that have a transitive is-a relationship with the concept Id provided as the value, including the provided concept itself (include descendant codes and self). */
    IsA,
    /** # is-not-a

Not (Is A) (by subsumption). The specified property of the code does not have an is-a relationship with the provided value. */
    IsNotA,
    /** # not-in

Not in Set. The specified property of the code is not in the set of codes or concepts specified in the provided value (comma separated list). */
    NotIn,
    /** # regex

Regular Expression. The specified property of the code  matches the regex specified in the provided value. */
    Regex,
}
impl ::core::str::FromStr for FilterOperator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "=" => Ok(Self::Equal),
            "descendent-of" => Ok(Self::DescendentOf),
            "exists" => Ok(Self::Exists),
            "generalizes" => Ok(Self::Generalizes),
            "in" => Ok(Self::In),
            "is-a" => Ok(Self::IsA),
            "is-not-a" => Ok(Self::IsNotA),
            "not-in" => Ok(Self::NotIn),
            "regex" => Ok(Self::Regex),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FilterOperator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equal => "=",
            Self::DescendentOf => "descendent-of",
            Self::Exists => "exists",
            Self::Generalizes => "generalizes",
            Self::In => "in",
            Self::IsA => "is-a",
            Self::IsNotA => "is-not-a",
            Self::NotIn => "not-in",
            Self::Regex => "regex",
        }
    }
}
impl<'de> Deserialize<'de> for FilterOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FilterOperator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `FinancialResourceStatusCodes`. This value set includes Status codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum FinancialResourceStatusCodes {
    /** # active

Active. The instance is currently in-force. */
    Active,
    /** # cancelled

Cancelled. The instance is withdrawn, rescinded or reversed. */
    Cancelled,
    /** # draft

Draft. A new instance the contents of which is not complete. */
    Draft,
    /** # entered-in-error

Entered in Error. The instance was entered in error. */
    EnteredInError,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for FinancialResourceStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for FinancialResourceStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for FinancialResourceStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FinancialResourceStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `FlagCategory`. Example list of detail codes for flagged issues. (Not complete or necessarily appropriate.)

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FlagCategory {
    /** # admin

Administrative. Flags related to administrative and financial processes. */
    Admin,
    /** # advance-directive

Advance Directive. Flags related to subject's advance directives. */
    AdvanceDirective,
    /** # behavioral

Behavioral. Flags related to behavior. */
    Behavioral,
    /** # clinical

Clinical. Flags related to the subject's clinical data. */
    Clinical,
    /** # contact

Subject Contact. Flags related to coming into contact with the patient. */
    Contact,
    /** # diet

Diet. Flags related to the subject's dietary needs. */
    Diet,
    /** # drug

Drug. Flags related to the subject's medications. */
    Drug,
    /** # lab

Lab. Flags related to performing laboratory tests and related processes (e.g. phlebotomy). */
    Lab,
    /** # research

Research. Flags related to research. */
    Research,
    /** # safety

Safety. Flags related to safety precautions. */
    Safety,
}
impl ::core::str::FromStr for FlagCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "admin" => Ok(Self::Admin),
            "advance-directive" => Ok(Self::AdvanceDirective),
            "behavioral" => Ok(Self::Behavioral),
            "clinical" => Ok(Self::Clinical),
            "contact" => Ok(Self::Contact),
            "diet" => Ok(Self::Diet),
            "drug" => Ok(Self::Drug),
            "lab" => Ok(Self::Lab),
            "research" => Ok(Self::Research),
            "safety" => Ok(Self::Safety),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FlagCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Admin => "admin",
            Self::AdvanceDirective => "advance-directive",
            Self::Behavioral => "behavioral",
            Self::Clinical => "clinical",
            Self::Contact => "contact",
            Self::Diet => "diet",
            Self::Drug => "drug",
            Self::Lab => "lab",
            Self::Research => "research",
            Self::Safety => "safety",
        }
    }
}
impl<'de> Deserialize<'de> for FlagCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FlagCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `FlagPriorityCodes`. This value set is provided as an exemplar. The value set is driven by IHE Table B.8-4: Abnormal Flags, Alert Priority.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum FlagPriorityCodes {
    /** # PH

High priority. High priority. */
    Ph,
    /** # PL

Low priority. Low priority. */
    Pl,
    /** # PM

Medium priority. Medium priority. */
    Pm,
    /** # PN

No alarm. No alarm. */
    Pn,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for FlagPriorityCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "PH" => Ok(Self::Ph),
            "PL" => Ok(Self::Pl),
            "PM" => Ok(Self::Pm),
            "PN" => Ok(Self::Pn),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for FlagPriorityCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ph => "PH",
            Self::Pl => "PL",
            Self::Pm => "PM",
            Self::Pn => "PN",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for FlagPriorityCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FlagPriorityCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `FlagStatus`. Indicates whether this flag is active and needs to be displayed to a user, or whether it is no longer needed or was entered in error.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FlagStatus {
    /** # active

Active. A current flag that should be displayed to a user. A system may use the category to determine which user roles should view the flag. */
    Active,
    /** # entered-in-error

Entered in Error. The flag was added in error and should no longer be displayed. */
    EnteredInError,
    /** # inactive

Inactive. The flag no longer needs to be displayed. */
    Inactive,
}
impl ::core::str::FromStr for FlagStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FlagStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl<'de> Deserialize<'de> for FlagStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FlagStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `FocusCharacteristicCode`. Evidence focus characteristic code.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum FocusCharacteristicCode {
    /** # citation

Citation. Used to reference a specific article. */
    Citation,
    /** # clinical-outcomes-observed

Observed outcomes are clinical outcomes. Used to denote a focus on clinical outcomes, ie evidence variable in role of outcome (measured variable) as observed is considered a "clinical outcome" (patient-important outcome such as mortality, symptoms, function or quality of life). */
    ClinicalOutcomesObserved,
    /** # comparator

Comparator. The comparator (intervention or control state) of interest. */
    Comparator,
    /** # exposure

Exposure. The exposure of interest, such as an intervention. */
    Exposure,
    /** # medication-exposures

Medication exposures. Any medication exposures. A subset of exposures or interventions that are medications. */
    MedicationExposures,
    /** # outcome

Outcome. the outcome of interest. */
    Outcome,
    /** # population

Population. The population of interest. */
    Population,
    /** # study-type

Study type. Type of research study, such as randomized trial or case-control study. */
    StudyType,
}
impl ::core::str::FromStr for FocusCharacteristicCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "citation" => Ok(Self::Citation),
            "clinical-outcomes-observed" => Ok(Self::ClinicalOutcomesObserved),
            "comparator" => Ok(Self::Comparator),
            "exposure" => Ok(Self::Exposure),
            "medication-exposures" => Ok(Self::MedicationExposures),
            "outcome" => Ok(Self::Outcome),
            "population" => Ok(Self::Population),
            "study-type" => Ok(Self::StudyType),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for FocusCharacteristicCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Citation => "citation",
            Self::ClinicalOutcomesObserved => "clinical-outcomes-observed",
            Self::Comparator => "comparator",
            Self::Exposure => "exposure",
            Self::MedicationExposures => "medication-exposures",
            Self::Outcome => "outcome",
            Self::Population => "population",
            Self::StudyType => "study-type",
        }
    }
}
impl<'de> Deserialize<'de> for FocusCharacteristicCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for FocusCharacteristicCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GenderIdentity`. This example code System defines a set of codes that can be used to indicate a patient's gender identity.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum GenderIdentity {
    /** # female

female. the patient identifies as female */
    Female,
    /** # male

male. the patient identifies as male */
    Male,
    /** # non-binary

non-binary. the patient identifies with neither/both female and male */
    NonBinary,
    /** # non-disclose

does not wish to disclose. the patient does not wish to disclose his gender identity */
    NonDisclose,
    /** # other

other. other gender identity */
    Other,
    /** # transgender-female

transgender female. the patient identifies as transgender male-to-female */
    TransgenderFemale,
    /** # transgender-male

transgender male. the patient identifies as transgender female-to-male */
    TransgenderMale,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for GenderIdentity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "female" => Ok(Self::Female),
            "male" => Ok(Self::Male),
            "non-binary" => Ok(Self::NonBinary),
            "non-disclose" => Ok(Self::NonDisclose),
            "other" => Ok(Self::Other),
            "transgender-female" => Ok(Self::TransgenderFemale),
            "transgender-male" => Ok(Self::TransgenderMale),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for GenderIdentity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Female => "female",
            Self::Male => "male",
            Self::NonBinary => "non-binary",
            Self::NonDisclose => "non-disclose",
            Self::Other => "other",
            Self::TransgenderFemale => "transgender-female",
            Self::TransgenderMale => "transgender-male",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for GenderIdentity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenderIdentity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GenderStatus`. This example value set defines a set of codes that can be used to indicate the current state of the animal's reproductive organs.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum GenderStatus {
    /** # intact

Intact. The animal's reproductive organs are intact. */
    Intact,
    /** # neutered

Neutered. The animal has been sterilized, castrated or otherwise made infertile. */
    Neutered,
    /** # unknown

Unknown. Unable to determine whether the animal has been neutered. */
    Unknown,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for GenderStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "intact" => Ok(Self::Intact),
            "neutered" => Ok(Self::Neutered),
            "unknown" => Ok(Self::Unknown),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for GenderStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Intact => "intact",
            Self::Neutered => "neutered",
            Self::Unknown => "unknown",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for GenderStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GenderStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GeneticObservationSecondaryFindings`. Codes to denote a guideline or policy statement.when a genetic test result is being shared as a secondary finding.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GeneticObservationSecondaryFindings {
    /** # acmg-version1

ACMG Version 1. First release (2013): ACMG Recommendations for Reporting of Incidental Findings in Clinical Exome and Genome Sequencing.  https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3727274/ */
    AcmgVersion1,
    /** # acmg-version2

ACMG Version 2. Second release (2016): Recommendations for reporting of secondary findings in clinical exome and genome sequencing, 2016 update (ACMG SF v2.0): a policy statement of the American College of Medical Genetics and Genomics. https://www.ncbi.nlm.nih.gov/pubmed/27854360 */
    AcmgVersion2,
}
impl ::core::str::FromStr for GeneticObservationSecondaryFindings {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acmg-version1" => Ok(Self::AcmgVersion1),
            "acmg-version2" => Ok(Self::AcmgVersion2),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GeneticObservationSecondaryFindings {
    fn as_ref(&self) -> &str {
        match self {
            Self::AcmgVersion1 => "acmg-version1",
            Self::AcmgVersion2 => "acmg-version2",
        }
    }
}
impl<'de> Deserialize<'de> for GeneticObservationSecondaryFindings {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GeneticObservationSecondaryFindings {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GoalAchievementStatus`. Describes the progression, or lack thereof, towards the goal against the target.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GoalAchievementStatus {
    /** # achieved

Achieved. The goal has been met. */
    Achieved,
    /** # improving

Improving. The goal is being sought, and is progressing. */
    Improving,
    /** # in-progress

In Progress. The goal is being sought but has not yet been reached. (Also applies if the goal was reached in the past but there has been regression and the goal is again being sought). */
    InProgress,
    /** # no-change

No Change. The goal is being sought, but the trend is flat. */
    NoChange,
    /** # no-progress

No Progress. The goal has not been met and little to no progress towards target. */
    NoProgress,
    /** # not-achieved

Not Achieved. The goal has not been met and there might or might not have been progress towards target. */
    NotAchieved,
    /** # not-attainable

Not Attainable. The goal is not possible to be met. */
    NotAttainable,
    /** # sustaining

Sustaining. The goal has been met, but ongoing activity is needed to sustain the goal objective. */
    Sustaining,
    /** # worsening

Worsening. The goal is being sought, but is regressing. */
    Worsening,
}
impl ::core::str::FromStr for GoalAchievementStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "achieved" => Ok(Self::Achieved),
            "improving" => Ok(Self::Improving),
            "in-progress" => Ok(Self::InProgress),
            "no-change" => Ok(Self::NoChange),
            "no-progress" => Ok(Self::NoProgress),
            "not-achieved" => Ok(Self::NotAchieved),
            "not-attainable" => Ok(Self::NotAttainable),
            "sustaining" => Ok(Self::Sustaining),
            "worsening" => Ok(Self::Worsening),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalAchievementStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Achieved => "achieved",
            Self::Improving => "improving",
            Self::InProgress => "in-progress",
            Self::NoChange => "no-change",
            Self::NoProgress => "no-progress",
            Self::NotAchieved => "not-achieved",
            Self::NotAttainable => "not-attainable",
            Self::Sustaining => "sustaining",
            Self::Worsening => "worsening",
        }
    }
}
impl<'de> Deserialize<'de> for GoalAchievementStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalAchievementStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GoalCategory`. Example codes for grouping goals to use for filtering or presentation.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum GoalCategory {
    /** # behavioral

Behavioral. Goals related to the manner in which the subject acts. */
    Behavioral,
    /** # dietary

Dietary. Goals related to the consumption of food and/or beverages. */
    Dietary,
    /** # nursing

Nursing. Goals related to the practice of nursing or established by nurses. */
    Nursing,
    /** # physiotherapy

Physiotherapy. Goals related to the mobility and/or motor capability of the subject. */
    Physiotherapy,
    /** # safety

Safety. Goals related to the personal protection of the subject. */
    Safety,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for GoalCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "behavioral" => Ok(Self::Behavioral),
            "dietary" => Ok(Self::Dietary),
            "nursing" => Ok(Self::Nursing),
            "physiotherapy" => Ok(Self::Physiotherapy),
            "safety" => Ok(Self::Safety),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for GoalCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Behavioral => "behavioral",
            Self::Dietary => "dietary",
            Self::Nursing => "nursing",
            Self::Physiotherapy => "physiotherapy",
            Self::Safety => "safety",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for GoalCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GoalLifecycleStatus`. Codes that reflect the current state of a goal and whether the goal is still being targeted.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GoalLifecycleStatus {
    /** # accepted

Accepted. A proposed goal was accepted or acknowledged. */
    Accepted,
    /** # active

Active. The goal is being sought actively. */
    Active,
    /** # cancelled

Cancelled. The goal has been abandoned. */
    Cancelled,
    /** # completed

Completed. The goal is no longer being sought. */
    Completed,
    /** # entered-in-error

Entered in Error. The goal was entered in error and voided. */
    EnteredInError,
    /** # on-hold

On Hold. The goal remains a long term objective but is no longer being actively pursued for a temporary period of time. */
    OnHold,
    /** # planned

Planned. A goal is planned for this patient. */
    Planned,
    /** # proposed

Proposed. A goal is proposed for this patient. */
    Proposed,
    /** # rejected

Rejected. A proposed goal was rejected. */
    Rejected,
}
impl ::core::str::FromStr for GoalLifecycleStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "on-hold" => Ok(Self::OnHold),
            "planned" => Ok(Self::Planned),
            "proposed" => Ok(Self::Proposed),
            "rejected" => Ok(Self::Rejected),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalLifecycleStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::OnHold => "on-hold",
            Self::Planned => "planned",
            Self::Proposed => "proposed",
            Self::Rejected => "rejected",
        }
    }
}
impl<'de> Deserialize<'de> for GoalLifecycleStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalLifecycleStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GoalPriority`. Indicates the level of importance associated with reaching or sustaining a goal.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GoalPriority {
    /** # high-priority

High Priority. Indicates that the goal is of considerable importance and should be a primary focus of care delivery. */
    HighPriority,
    /** # low-priority

Low Priority. The goal is desirable but is not sufficiently important to devote significant resources to.  Achievement of the goal may be sought when incidental to achieving other goals. */
    LowPriority,
    /** # medium-priority

Medium Priority. Indicates that the goal has a reasonable degree of importance and that concrete action should be taken towards the goal.  Attainment is not as critical as high-priority goals. */
    MediumPriority,
}
impl ::core::str::FromStr for GoalPriority {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high-priority" => Ok(Self::HighPriority),
            "low-priority" => Ok(Self::LowPriority),
            "medium-priority" => Ok(Self::MediumPriority),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GoalPriority {
    fn as_ref(&self) -> &str {
        match self {
            Self::HighPriority => "high-priority",
            Self::LowPriority => "low-priority",
            Self::MediumPriority => "medium-priority",
        }
    }
}
impl<'de> Deserialize<'de> for GoalPriority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GoalPriority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GraphCompartmentRule`. How a compartment must be linked.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GraphCompartmentRule {
    /** # custom

Custom. The compartment rule is defined in the accompanying FHIRPath expression. */
    Custom,
    /** # different

Different. The compartment must be different. */
    Different,
    /** # identical

Identical. The compartment must be identical (the same literal reference). */
    Identical,
    /** # matching

Matching. The compartment must be the same - the record must be about the same patient, but the reference may be different. */
    Matching,
}
impl ::core::str::FromStr for GraphCompartmentRule {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "custom" => Ok(Self::Custom),
            "different" => Ok(Self::Different),
            "identical" => Ok(Self::Identical),
            "matching" => Ok(Self::Matching),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GraphCompartmentRule {
    fn as_ref(&self) -> &str {
        match self {
            Self::Custom => "custom",
            Self::Different => "different",
            Self::Identical => "identical",
            Self::Matching => "matching",
        }
    }
}
impl<'de> Deserialize<'de> for GraphCompartmentRule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GraphCompartmentRule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GraphCompartmentUse`. Defines how a compartment rule is used.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GraphCompartmentUse {
    /** # condition

Condition. This compartment rule is a condition for whether the rule applies. */
    Condition,
    /** # requirement

Requirement. This compartment rule is enforced on any relationships that meet the conditions. */
    Requirement,
}
impl ::core::str::FromStr for GraphCompartmentUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "condition" => Ok(Self::Condition),
            "requirement" => Ok(Self::Requirement),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GraphCompartmentUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Condition => "condition",
            Self::Requirement => "requirement",
        }
    }
}
impl<'de> Deserialize<'de> for GraphCompartmentUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GraphCompartmentUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GroupMeasure`. Possible group measure aggregates (E.g. Mean, Median).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GroupMeasure {
    /** # mean

Mean. Aggregated using Mean of participant values. */
    Mean,
    /** # mean-of-mean

Mean of Study Means. Aggregated using Mean of study mean values. */
    MeanOfMean,
    /** # mean-of-median

Mean of Study Medins. Aggregated using Mean of study median values. */
    MeanOfMedian,
    /** # median

Median. Aggregated using Median of participant values. */
    Median,
    /** # median-of-mean

Median of Study Means. Aggregated using Median of study mean values. */
    MedianOfMean,
    /** # median-of-median

Median of Study Medians. Aggregated using Median of study median values. */
    MedianOfMedian,
}
impl ::core::str::FromStr for GroupMeasure {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "mean" => Ok(Self::Mean),
            "mean-of-mean" => Ok(Self::MeanOfMean),
            "mean-of-median" => Ok(Self::MeanOfMedian),
            "median" => Ok(Self::Median),
            "median-of-mean" => Ok(Self::MedianOfMean),
            "median-of-median" => Ok(Self::MedianOfMedian),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GroupMeasure {
    fn as_ref(&self) -> &str {
        match self {
            Self::Mean => "mean",
            Self::MeanOfMean => "mean-of-mean",
            Self::MeanOfMedian => "mean-of-median",
            Self::Median => "median",
            Self::MedianOfMean => "median-of-mean",
            Self::MedianOfMedian => "median-of-median",
        }
    }
}
impl<'de> Deserialize<'de> for GroupMeasure {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GroupMeasure {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GroupType`. Types of resources that are part of group.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GroupType {
    /** # animal

Animal. Group contains "animal" Patient resources. */
    Animal,
    /** # device

Device. Group contains Device resources. */
    Device,
    /** # medication

Medication. Group contains Medication resources. */
    Medication,
    /** # person

Person. Group contains "person" Patient resources. */
    Person,
    /** # practitioner

Practitioner. Group contains healthcare practitioner resources (Practitioner or PractitionerRole). */
    Practitioner,
    /** # substance

Substance. Group contains Substance resources. */
    Substance,
}
impl ::core::str::FromStr for GroupType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "animal" => Ok(Self::Animal),
            "device" => Ok(Self::Device),
            "medication" => Ok(Self::Medication),
            "person" => Ok(Self::Person),
            "practitioner" => Ok(Self::Practitioner),
            "substance" => Ok(Self::Substance),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GroupType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "animal",
            Self::Device => "device",
            Self::Medication => "medication",
            Self::Person => "person",
            Self::Practitioner => "practitioner",
            Self::Substance => "substance",
        }
    }
}
impl<'de> Deserialize<'de> for GroupType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GroupType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GuidanceResponseStatus`. The status of a guidance response.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GuidanceResponseStatus {
    /** # data-requested

Data Requested. The request was processed successfully, but more data may result in a more complete evaluation. */
    DataRequested,
    /** # data-required

Data Required. The request was processed, but more data is required to complete the evaluation. */
    DataRequired,
    /** # entered-in-error

Entered In Error. The response was entered in error. */
    EnteredInError,
    /** # failure

Failure. The request was not processed successfully. */
    Failure,
    /** # in-progress

In Progress. The request is currently being processed. */
    InProgress,
    /** # success

Success. The request was processed successfully. */
    Success,
}
impl ::core::str::FromStr for GuidanceResponseStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-requested" => Ok(Self::DataRequested),
            "data-required" => Ok(Self::DataRequired),
            "entered-in-error" => Ok(Self::EnteredInError),
            "failure" => Ok(Self::Failure),
            "in-progress" => Ok(Self::InProgress),
            "success" => Ok(Self::Success),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuidanceResponseStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataRequested => "data-requested",
            Self::DataRequired => "data-required",
            Self::EnteredInError => "entered-in-error",
            Self::Failure => "failure",
            Self::InProgress => "in-progress",
            Self::Success => "success",
        }
    }
}
impl<'de> Deserialize<'de> for GuidanceResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuidanceResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GuidePageGeneration`. A code that indicates how the page is generated.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GuidePageGeneration {
    /** # generated

Generated. Page will be generated by the publication process - no source to bring across. */
    Generated,
    /** # html

HTML. Page is proper xhtml with no templating.  Will be brought across unchanged for standard post-processing. */
    Html,
    /** # markdown

Markdown. Page is markdown with templating.  Will use the template to create a file that imports the markdown file prior to post-processing. */
    Markdown,
    /** # xml

XML. Page is xml with templating.  Will use the template to create a file that imports the source file and run the nominated XSLT transform (see parameters) if present prior to post-processing. */
    Xml,
}
impl ::core::str::FromStr for GuidePageGeneration {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "generated" => Ok(Self::Generated),
            "html" => Ok(Self::Html),
            "markdown" => Ok(Self::Markdown),
            "xml" => Ok(Self::Xml),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuidePageGeneration {
    fn as_ref(&self) -> &str {
        match self {
            Self::Generated => "generated",
            Self::Html => "html",
            Self::Markdown => "markdown",
            Self::Xml => "xml",
        }
    }
}
impl<'de> Deserialize<'de> for GuidePageGeneration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuidePageGeneration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `GuideParameterCode`. Code of parameter that is input to the guide.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum GuideParameterCode {
    /** # apply

Apply Metadata Value. If the value of this string 0..* parameter is one of the metadata fields then all conformance resources will have any specified [Resource].[field] overwritten with the ImplementationGuide.[field], where field is one of: version, date, status, publisher, contact, copyright, experimental, jurisdiction, useContext. */
    Apply,
    /** # expansion-parameter

Expansion Profile. The value of this string 0..* parameter is a parameter (name=value) when expanding value sets for this implementation guide. This is particularly used to specify the versions of published terminologies such as SNOMED CT. */
    ExpansionParameter,
    /** # generate-json

Generate JSON. The value of this boolean 0..1 parameter specifies whether the IG publisher creates examples in JSON format. If not present, the Publication Tool decides whether to generate JSON. */
    GenerateJson,
    /** # generate-turtle

Generate Turtle. The value of this boolean 0..1 parameter specifies whether the IG publisher creates examples in Turtle format. If not present, the Publication Tool decides whether to generate Turtle. */
    GenerateTurtle,
    /** # generate-xml

Generate XML. The value of this boolean 0..1 parameter specifies whether the IG publisher creates examples in XML format. If not present, the Publication Tool decides whether to generate XML. */
    GenerateXml,
    /** # html-template

HTML Template. The value of this string singleton parameter is the name of the file to use as the builder template for each generated page (see templating). */
    HtmlTemplate,
    /** # path-pages

Pages Path. The value of this string 0..1 parameter is a subfolder of the build context's location that contains files that are part of the html content processed by the builder. */
    PathPages,
    /** # path-resource

Resource Path. The value of this string 0..* parameter is a subfolder of the build context's location that is to be scanned to load resources. Scope is (if present) a particular resource type. */
    PathResource,
    /** # path-tx-cache

Terminology Cache Path. The value of this string 0..1 parameter is a subfolder of the build context's location that is used as the terminology cache. If this is not present, the terminology cache is on the local system, not under version control. */
    PathTxCache,
    /** # rule-broken-links

Broken Links Rule. The value of this string 0..1 parameter is either "warning" or "error" (default = "error"). If the value is "warning" then IG build tools allow the IG to be considered successfully build even when there is no internal broken links. */
    RuleBrokenLinks,
}
impl ::core::str::FromStr for GuideParameterCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "apply" => Ok(Self::Apply),
            "expansion-parameter" => Ok(Self::ExpansionParameter),
            "generate-json" => Ok(Self::GenerateJson),
            "generate-turtle" => Ok(Self::GenerateTurtle),
            "generate-xml" => Ok(Self::GenerateXml),
            "html-template" => Ok(Self::HtmlTemplate),
            "path-pages" => Ok(Self::PathPages),
            "path-resource" => Ok(Self::PathResource),
            "path-tx-cache" => Ok(Self::PathTxCache),
            "rule-broken-links" => Ok(Self::RuleBrokenLinks),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for GuideParameterCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Apply => "apply",
            Self::ExpansionParameter => "expansion-parameter",
            Self::GenerateJson => "generate-json",
            Self::GenerateTurtle => "generate-turtle",
            Self::GenerateXml => "generate-xml",
            Self::HtmlTemplate => "html-template",
            Self::PathPages => "path-pages",
            Self::PathResource => "path-resource",
            Self::PathTxCache => "path-tx-cache",
            Self::RuleBrokenLinks => "rule-broken-links",
        }
    }
}
impl<'de> Deserialize<'de> for GuideParameterCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for GuideParameterCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `HandlingConditionSet`. Set of handling instructions prior testing of the specimen.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum HandlingConditionSet {
    /** # frozen

frozen. frozen temperature. */
    Frozen,
    /** # refrigerated

refrigerated. refrigerated temperature. */
    Refrigerated,
    /** # room

room temperature. room temperature. */
    Room,
}
impl ::core::str::FromStr for HandlingConditionSet {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "frozen" => Ok(Self::Frozen),
            "refrigerated" => Ok(Self::Refrigerated),
            "room" => Ok(Self::Room),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for HandlingConditionSet {
    fn as_ref(&self) -> &str {
        match self {
            Self::Frozen => "frozen",
            Self::Refrigerated => "refrigerated",
            Self::Room => "room",
        }
    }
}
impl<'de> Deserialize<'de> for HandlingConditionSet {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for HandlingConditionSet {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `HumanNameAssemblyOrder`. A code that represents the preferred display order of the components of a human name.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum HumanNameAssemblyOrder {
    /** # NL1

Own Name. */
    Nl1,
    /** # NL2

Partner Name. */
    Nl2,
    /** # NL3

Partner Name followed by Maiden Name. */
    Nl3,
    /** # NL4

Own Name followed by Partner Name. */
    Nl4,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for HumanNameAssemblyOrder {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "NL1" => Ok(Self::Nl1),
            "NL2" => Ok(Self::Nl2),
            "NL3" => Ok(Self::Nl3),
            "NL4" => Ok(Self::Nl4),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for HumanNameAssemblyOrder {
    fn as_ref(&self) -> &str {
        match self {
            Self::Nl1 => "NL1",
            Self::Nl2 => "NL2",
            Self::Nl3 => "NL3",
            Self::Nl4 => "NL4",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for HumanNameAssemblyOrder {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for HumanNameAssemblyOrder {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `IdentifierUse`. Identifies the purpose for this identifier, if known .

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IdentifierUse {
    /** # official

Official. The identifier considered to be most trusted for the identification of this item. Sometimes also known as "primary" and "main". The determination of "official" is subjective and implementation guides often provide additional guidelines for use. */
    Official,
    /** # old

Old. The identifier id no longer considered valid, but may be relevant for search purposes.  E.g. Changes to identifier schemes, account merges, etc. */
    Old,
    /** # secondary

Secondary. An identifier that was assigned in secondary use - it serves to identify the object in a relative context, but cannot be consistently assigned to the same object again in a different context. */
    Secondary,
    /** # temp

Temp. A temporary identifier. */
    Temp,
    /** # usual

Usual. The identifier recommended for display and use in real-world interactions. */
    Usual,
}
impl ::core::str::FromStr for IdentifierUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "official" => Ok(Self::Official),
            "old" => Ok(Self::Old),
            "secondary" => Ok(Self::Secondary),
            "temp" => Ok(Self::Temp),
            "usual" => Ok(Self::Usual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IdentifierUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Official => "official",
            Self::Old => "old",
            Self::Secondary => "secondary",
            Self::Temp => "temp",
            Self::Usual => "usual",
        }
    }
}
impl<'de> Deserialize<'de> for IdentifierUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IdentifierUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `IdentityAssuranceLevel`. The level of confidence that this link represents the same actual person, based on NIST Authentication Levels.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IdentityAssuranceLevel {
    /** # level1

Level 1. Little or no confidence in the asserted identity's accuracy. */
    Level1,
    /** # level2

Level 2. Some confidence in the asserted identity's accuracy. */
    Level2,
    /** # level3

Level 3. High confidence in the asserted identity's accuracy. */
    Level3,
    /** # level4

Level 4. Very high confidence in the asserted identity's accuracy. */
    Level4,
}
impl ::core::str::FromStr for IdentityAssuranceLevel {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "level1" => Ok(Self::Level1),
            "level2" => Ok(Self::Level2),
            "level3" => Ok(Self::Level3),
            "level4" => Ok(Self::Level4),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IdentityAssuranceLevel {
    fn as_ref(&self) -> &str {
        match self {
            Self::Level1 => "level1",
            Self::Level2 => "level2",
            Self::Level3 => "level3",
            Self::Level4 => "level4",
        }
    }
}
impl<'de> Deserialize<'de> for IdentityAssuranceLevel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IdentityAssuranceLevel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ImagingStudyStatus`. The status of the ImagingStudy.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ImagingStudyStatus {
    /** # available

Available. At least one instance has been associated with this imaging study. */
    Available,
    /** # cancelled

Cancelled. The imaging study is unavailable because the imaging study was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** # entered-in-error

Entered in Error. The imaging study has been withdrawn following a previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** # registered

Registered. The existence of the imaging study is registered, but there is nothing yet available. */
    Registered,
    /** # unknown

Unknown. The system does not know which of the status values currently applies for this request. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for ImagingStudyStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "cancelled" => Ok(Self::Cancelled),
            "entered-in-error" => Ok(Self::EnteredInError),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ImagingStudyStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::Cancelled => "cancelled",
            Self::EnteredInError => "entered-in-error",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for ImagingStudyStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImagingStudyStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ImmunizationEvaluationDoseStatusCodes`. This code system supports describing the validity of a dose relative to a particular recommended schedule.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ImmunizationEvaluationDoseStatusCodes {
    /** # notvalid

Not valid. The dose does not count toward fulfilling a path to immunity for a patient. */
    Notvalid,
    /** # valid

Valid. The dose counts toward fulfilling a path to immunity for a patient, providing protection against the target disease. */
    Valid,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEvaluationDoseStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "notvalid" => Ok(Self::Notvalid),
            "valid" => Ok(Self::Valid),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEvaluationDoseStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Notvalid => "notvalid",
            Self::Valid => "valid",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ImmunizationEvaluationDoseStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEvaluationDoseStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ImmunizationEvaluationDoseStatusReasonCodes`. This code system supports describing the reason why an administered dose has been assigned a particular status. Often, this reason describes why a dose is considered invalid.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ImmunizationEvaluationDoseStatusReasonCodes {
    /** # advstorage

Adverse storage condition. The product was stored in a manner inconsistent with manufacturer guidelines potentially reducing the effectiveness of the product. */
    Advstorage,
    /** # coldchbrk

Cold chain break. The product was stored at a temperature inconsistent with manufacturer guidelines potentially reducing the effectiveness of the product. */
    Coldchbrk,
    /** # explot

Expired lot. The product was administered after the expiration date associated with lot of vaccine. */
    Explot,
    /** # outsidesched

Administered outside recommended schedule. The product was administered at a time inconsistent with the documented schedule. */
    Outsidesched,
    /** # prodrecall

Product recall. The product administered has been recalled by the manufacturer. */
    Prodrecall,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEvaluationDoseStatusReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "advstorage" => Ok(Self::Advstorage),
            "coldchbrk" => Ok(Self::Coldchbrk),
            "explot" => Ok(Self::Explot),
            "outsidesched" => Ok(Self::Outsidesched),
            "prodrecall" => Ok(Self::Prodrecall),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEvaluationDoseStatusReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Advstorage => "advstorage",
            Self::Coldchbrk => "coldchbrk",
            Self::Explot => "explot",
            Self::Outsidesched => "outsidesched",
            Self::Prodrecall => "prodrecall",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ImmunizationEvaluationDoseStatusReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEvaluationDoseStatusReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ImmunizationEventFundingSource`. This code system supports describing the source of the vaccine actually administered. This may be different than the patient eligbility (e.g. the patient may be eligibile for a publically purchased vaccine but due to inventory issues, vaccine purchased with private funds was actually administered).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ImmunizationEventFundingSource {
    /** # private

Private. The vaccine was purchased with private funds. */
    Private,
    /** # public

Public. The vaccine was purchased with public funds. */
    Public,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEventFundingSource {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "private" => Ok(Self::Private),
            "public" => Ok(Self::Public),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEventFundingSource {
    fn as_ref(&self) -> &str {
        match self {
            Self::Private => "private",
            Self::Public => "public",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ImmunizationEventFundingSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEventFundingSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ImmunizationEventOrigin`. This code system supports describing the source of the data when the report of the immunization event is not based on information from the person, entity or organization who administered the vaccine.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ImmunizationEventOrigin {
    /** # jurisdiction

Jurisdictional IIS. The data for the immunization event originated with an immunization information system (IIS) or registry operating within the jurisdiction. */
    Jurisdiction,
    /** # provider

Other Provider. The data for the immunization event originated with another provider. */
    Provider,
    /** # recall

Parent/Guardian/Patient Recall. The data for the immunization event originated from the recollection of the patient or parent/guardian of the patient. */
    Recall,
    /** # record

Written Record. The data for the immunization event originated with a written record for the patient. */
    Record,
    /** # school

School Record. The data for the immunization event originated with a school record for the patient. */
    School,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEventOrigin {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "jurisdiction" => Ok(Self::Jurisdiction),
            "provider" => Ok(Self::Provider),
            "recall" => Ok(Self::Recall),
            "record" => Ok(Self::Record),
            "school" => Ok(Self::School),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEventOrigin {
    fn as_ref(&self) -> &str {
        match self {
            Self::Jurisdiction => "jurisdiction",
            Self::Provider => "provider",
            Self::Recall => "recall",
            Self::Record => "record",
            Self::School => "school",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ImmunizationEventOrigin {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEventOrigin {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ImmunizationEventProgramEligibility`. This code system supports describing the source of the patient's eligibility for a vaccination program.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ImmunizationEventProgramEligibility {
    /** # ineligible

Not Eligible. The patient is not eligible for the funding program. */
    Ineligible,
    /** # uninsured

Uninsured. The patient is eligible for the funding program because they are uninsured. */
    Uninsured,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEventProgramEligibility {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ineligible" => Ok(Self::Ineligible),
            "uninsured" => Ok(Self::Uninsured),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEventProgramEligibility {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ineligible => "ineligible",
            Self::Uninsured => "uninsured",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ImmunizationEventProgramEligibility {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEventProgramEligibility {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ImmunizationEventSubpotentReason`. This code system supports describing the reason why a dose is considered to be subpotent.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ImmunizationEventSubpotentReason {
    /** # coldchainbreak

Cold Chain Break. The vaccine experienced a cold chain break. */
    Coldchainbreak,
    /** # partial

Partial Dose. The full volume of the dose was not administered to the patient. */
    Partial,
    /** # recall

Manufacturer Recall. The vaccine was recalled by the manufacturer. */
    Recall,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationEventSubpotentReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "coldchainbreak" => Ok(Self::Coldchainbreak),
            "partial" => Ok(Self::Partial),
            "recall" => Ok(Self::Recall),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationEventSubpotentReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::Coldchainbreak => "coldchainbreak",
            Self::Partial => "partial",
            Self::Recall => "recall",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ImmunizationEventSubpotentReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationEventSubpotentReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ImmunizationRecommendationStatusCodes`. The value set to instantiate this attribute should be drawn from a terminologically robust code system that consists of or contains concepts to support describing the status of the patient relative to a recommended dose. This value set is provided as a suggestive example.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ImmunizationRecommendationStatusCodes {
    /** # complete

Complete. The patient is fully protected and no further doses are recommended. */
    Complete,
    /** # contraindicated

Contraindicated. The patient is contraindicated for futher doses. */
    Contraindicated,
    /** # due

Due. The patient is due for their next vaccination. */
    Due,
    /** # immune

Immune. The patient is immune to the target disease and further immunization against the disease is not likely to provide benefit. */
    Immune,
    /** # overdue

Overdue. The patient is considered overdue for their next vaccination. */
    Overdue,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ImmunizationRecommendationStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "contraindicated" => Ok(Self::Contraindicated),
            "due" => Ok(Self::Due),
            "immune" => Ok(Self::Immune),
            "overdue" => Ok(Self::Overdue),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ImmunizationRecommendationStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Contraindicated => "contraindicated",
            Self::Due => "due",
            Self::Immune => "immune",
            Self::Overdue => "overdue",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ImmunizationRecommendationStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ImmunizationRecommendationStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `Indicator`. This value set captures the set of indicator codes defined by the CDS Hooks specification.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum Indicator {
    /** # critical

The response is critical and indicates the workflow should not be allowed to proceed. */
    Critical,
    /** # info

The response is informational. */
    Info,
    /** # warning

The response is a warning. */
    Warning,
}
impl ::core::str::FromStr for Indicator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "critical" => Ok(Self::Critical),
            "info" => Ok(Self::Info),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Indicator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Critical => "critical",
            Self::Info => "info",
            Self::Warning => "warning",
        }
    }
}
impl<'de> Deserialize<'de> for Indicator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Indicator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `IngredientFunction`. A classification of the ingredient identifying its precise purpose(s) in the drug product (beyond e.g. active/inactive).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IngredientFunction {
    /** # AlkalizingAgent

Alkalizing Agent. */
    AlkalizingAgent,
    /** # Antioxidant

Antioxidant. */
    Antioxidant,
}
impl ::core::str::FromStr for IngredientFunction {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "AlkalizingAgent" => Ok(Self::AlkalizingAgent),
            "Antioxidant" => Ok(Self::Antioxidant),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IngredientFunction {
    fn as_ref(&self) -> &str {
        match self {
            Self::AlkalizingAgent => "AlkalizingAgent",
            Self::Antioxidant => "Antioxidant",
        }
    }
}
impl<'de> Deserialize<'de> for IngredientFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IngredientFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `IngredientManufacturerRole`. The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IngredientManufacturerRole {
    /** # actual

Manufacturer actually makes this particular ingredient. */
    Actual,
    /** # allowed

Manufacturer is specifically allowed for this ingredient. */
    Allowed,
    /** # possible

Manufacturer is known to make this ingredient in general. */
    Possible,
}
impl ::core::str::FromStr for IngredientManufacturerRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "actual" => Ok(Self::Actual),
            "allowed" => Ok(Self::Allowed),
            "possible" => Ok(Self::Possible),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IngredientManufacturerRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Actual => "actual",
            Self::Allowed => "allowed",
            Self::Possible => "possible",
        }
    }
}
impl<'de> Deserialize<'de> for IngredientManufacturerRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IngredientManufacturerRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `IngredientRole`. A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IngredientRole {
    /** # 100000072072

Active. */
    N100000072072,
    /** # 100000072073

Adjuvant. */
    N100000072073,
    /** # 100000072082

Excipient. */
    N100000072082,
    /** # 100000136065

Starting material for excipient. */
    N100000136065,
    /** # 100000136066

Solvent / Diluent. */
    N100000136066,
    /** # 100000136178

Raw materials used in the manufacture of the product. */
    N100000136178,
    /** # 100000136179

Starting material for active substance. */
    N100000136179,
    /** # 100000136561

Overage. */
    N100000136561,
    /** # 200000003427

bioenhancer. */
    N200000003427,
}
impl ::core::str::FromStr for IngredientRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000072072" => Ok(Self::N100000072072),
            "100000072073" => Ok(Self::N100000072073),
            "100000072082" => Ok(Self::N100000072082),
            "100000136065" => Ok(Self::N100000136065),
            "100000136066" => Ok(Self::N100000136066),
            "100000136178" => Ok(Self::N100000136178),
            "100000136179" => Ok(Self::N100000136179),
            "100000136561" => Ok(Self::N100000136561),
            "200000003427" => Ok(Self::N200000003427),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IngredientRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000072072 => "100000072072",
            Self::N100000072073 => "100000072073",
            Self::N100000072082 => "100000072082",
            Self::N100000136065 => "100000136065",
            Self::N100000136066 => "100000136066",
            Self::N100000136178 => "100000136178",
            Self::N100000136179 => "100000136179",
            Self::N100000136561 => "100000136561",
            Self::N200000003427 => "200000003427",
        }
    }
}
impl<'de> Deserialize<'de> for IngredientRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IngredientRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `InsurancePlanType`. This example value set defines a set of codes that can be used to indicate a type of product plan.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum InsurancePlanType {
    /** # Drug

Drug. */
    Drug,
    /** # dental

Dental. */
    Dental,
    /** # home

Home Health. */
    Home,
    /** # hospice

Hospice. */
    Hospice,
    /** # long-term

Long Term Care. */
    LongTerm,
    /** # medical

Medical. */
    Medical,
    /** # mental

Mental Health. */
    Mental,
    /** # short-term

Short Term. */
    ShortTerm,
    /** # subst-ab

Substance Abuse. */
    SubstAb,
    /** # vision

Vision. */
    Vision,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for InsurancePlanType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Drug" => Ok(Self::Drug),
            "dental" => Ok(Self::Dental),
            "home" => Ok(Self::Home),
            "hospice" => Ok(Self::Hospice),
            "long-term" => Ok(Self::LongTerm),
            "medical" => Ok(Self::Medical),
            "mental" => Ok(Self::Mental),
            "short-term" => Ok(Self::ShortTerm),
            "subst-ab" => Ok(Self::SubstAb),
            "vision" => Ok(Self::Vision),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for InsurancePlanType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Drug => "Drug",
            Self::Dental => "dental",
            Self::Home => "home",
            Self::Hospice => "hospice",
            Self::LongTerm => "long-term",
            Self::Medical => "medical",
            Self::Mental => "mental",
            Self::ShortTerm => "short-term",
            Self::SubstAb => "subst-ab",
            Self::Vision => "vision",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for InsurancePlanType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InsurancePlanType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `InteractionIncidence`. A categorisation for a frequency of occurence of an undesirable effect.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InteractionIncidence {
    /** # Observed

Observed. */
    Observed,
    /** # Theoretical

Theoretical. */
    Theoretical,
}
impl ::core::str::FromStr for InteractionIncidence {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Observed" => Ok(Self::Observed),
            "Theoretical" => Ok(Self::Theoretical),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InteractionIncidence {
    fn as_ref(&self) -> &str {
        match self {
            Self::Observed => "Observed",
            Self::Theoretical => "Theoretical",
        }
    }
}
impl<'de> Deserialize<'de> for InteractionIncidence {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InteractionIncidence {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `InteractionType`. A categorisation for an interaction between two substances.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InteractionType {
    /** # drug-drug

drug to drug interaction. */
    DrugDrug,
    /** # drug-food

drug to food interaction. */
    DrugFood,
    /** # drug-test

drug to laboratory test interaction. */
    DrugTest,
    /** # other

other interaction. */
    Other,
}
impl ::core::str::FromStr for InteractionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "drug-drug" => Ok(Self::DrugDrug),
            "drug-food" => Ok(Self::DrugFood),
            "drug-test" => Ok(Self::DrugTest),
            "other" => Ok(Self::Other),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InteractionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DrugDrug => "drug-drug",
            Self::DrugFood => "drug-food",
            Self::DrugTest => "drug-test",
            Self::Other => "other",
        }
    }
}
impl<'de> Deserialize<'de> for InteractionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InteractionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `InvoicePriceComponentType`. Codes indicating the kind of the price component.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InvoicePriceComponentType {
    /** # base

base price. the amount is the base price used for calculating the total price before applying surcharges, discount or taxes. */
    Base,
    /** # deduction

deduction. the amount is a deduction applied on the base price. */
    Deduction,
    /** # discount

discount. the amount is a discount applied on the base price. */
    Discount,
    /** # informational

informational. the amount is of informational character, it has not been applied in the calculation of the total price. */
    Informational,
    /** # surcharge

surcharge. the amount is a surcharge applied on the base price. */
    Surcharge,
    /** # tax

tax. the amount is the tax component of the total price. */
    Tax,
}
impl ::core::str::FromStr for InvoicePriceComponentType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "base" => Ok(Self::Base),
            "deduction" => Ok(Self::Deduction),
            "discount" => Ok(Self::Discount),
            "informational" => Ok(Self::Informational),
            "surcharge" => Ok(Self::Surcharge),
            "tax" => Ok(Self::Tax),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InvoicePriceComponentType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Base => "base",
            Self::Deduction => "deduction",
            Self::Discount => "discount",
            Self::Informational => "informational",
            Self::Surcharge => "surcharge",
            Self::Tax => "tax",
        }
    }
}
impl<'de> Deserialize<'de> for InvoicePriceComponentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InvoicePriceComponentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `InvoiceStatus`. Codes identifying the lifecycle stage of an Invoice.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum InvoiceStatus {
    /** # balanced

balanced. the invoice has been balaced / completely paid. */
    Balanced,
    /** # cancelled

cancelled. the invoice was cancelled. */
    Cancelled,
    /** # draft

draft. the invoice has been prepared but not yet finalized. */
    Draft,
    /** # entered-in-error

entered in error. the invoice was determined as entered in error before it was issued. */
    EnteredInError,
    /** # issued

issued. the invoice has been finalized and sent to the recipient. */
    Issued,
}
impl ::core::str::FromStr for InvoiceStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "balanced" => Ok(Self::Balanced),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "issued" => Ok(Self::Issued),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for InvoiceStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Balanced => "balanced",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Issued => "issued",
        }
    }
}
impl<'de> Deserialize<'de> for InvoiceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for InvoiceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `IssueSeverity`. How the issue affects the success of the action.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IssueSeverity {
    /** # error

Error. The issue is sufficiently important to cause the action to fail. */
    Error,
    /** # fatal

Fatal. The issue caused the action to fail and no further checking could be performed. */
    Fatal,
    /** # information

Information. The issue has no relation to the degree of success of the action. */
    Information,
    /** # warning

Warning. The issue is not important enough to cause the action to fail but may cause it to be performed suboptimally or in a way that is not as desired. */
    Warning,
}
impl ::core::str::FromStr for IssueSeverity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "fatal" => Ok(Self::Fatal),
            "information" => Ok(Self::Information),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IssueSeverity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Fatal => "fatal",
            Self::Information => "information",
            Self::Warning => "warning",
        }
    }
}
impl<'de> Deserialize<'de> for IssueSeverity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IssueSeverity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `IssueType`. A code that describes the type of issue.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum IssueType {
    /** # business-rule

Business Rule Violation. The content/operation failed to pass some business rule and so could not proceed. */
    BusinessRule,
    /** # code-invalid

Invalid Code. The code or system could not be understood, or it was not valid in the context of a particular ValueSet.code. */
    CodeInvalid,
    /** # conflict

Edit Version Conflict. Content could not be accepted because of an edit conflict (i.e. version aware updates). (In a pure RESTful environment, this would be an HTTP 409 error, but this code may be used where the conflict is discovered further into the application architecture.). */
    Conflict,
    /** # deleted

Deleted. The reference pointed to content (usually a resource) that has been deleted. */
    Deleted,
    /** # duplicate

Duplicate. An attempt was made to create a duplicate record. */
    Duplicate,
    /** # exception

Exception. An unexpected internal error has occurred. */
    Exception,
    /** # expired

Session Expired. User session expired; a login may be required. */
    Expired,
    /** # extension

Unacceptable Extension. An extension was found that was not acceptable, could not be resolved, or a modifierExtension was not recognized. */
    Extension,
    /** # forbidden

Forbidden. The user does not have the rights to perform this action. */
    Forbidden,
    /** # incomplete

Incomplete Results. Not all data sources typically accessed could be reached or responded in time, so the returned information might not be complete (applies to search interactions and some operations). */
    Incomplete,
    /** # informational

Informational Note. A message unrelated to the processing success of the completed operation (examples of the latter include things like reminders of password expiry, system maintenance times, etc.). */
    Informational,
    /** # invalid

Invalid Content. Content invalid against the specification or a profile. */
    Invalid,
    /** # invariant

Validation rule failed. A content validation rule failed - e.g. a schematron rule. */
    Invariant,
    /** # lock-error

Lock Error. A resource/record locking failure (usually in an underlying database). */
    LockError,
    /** # login

Login Required. The client needs to initiate an authentication process. */
    Login,
    /** # multiple-matches

Multiple Matches. Multiple matching records were found when the operation required only one match. */
    MultipleMatches,
    /** # no-store

No Store Available. The persistent store is unavailable; e.g. the database is down for maintenance or similar action, and the interaction or operation cannot be processed. */
    NoStore,
    /** # not-found

Not Found. The reference provided was not found. In a pure RESTful environment, this would be an HTTP 404 error, but this code may be used where the content is not found further into the application architecture. */
    NotFound,
    /** # not-supported

Content not supported. The interaction, operation, resource or profile is not supported. */
    NotSupported,
    /** # processing

Processing Failure. Processing issues. These are expected to be final e.g. there is no point resubmitting the same content unchanged. */
    Processing,
    /** # required

Required element missing. A required element is missing. */
    Required,
    /** # security

Security Problem. An authentication/authorization/permissions issue of some kind. */
    Security,
    /** # structure

Structural Issue. A structural issue in the content such as wrong namespace, unable to parse the content completely, invalid syntax, etc. */
    Structure,
    /** # suppressed

Information  Suppressed. Some information was not or might not have been returned due to business rules, consent or privacy rules, or access permission constraints.  This information may be accessible through alternate processes. */
    Suppressed,
    /** # throttled

Throttled. The system is not prepared to handle this request due to load management. */
    Throttled,
    /** # timeout

Timeout. An internal timeout has occurred. */
    Timeout,
    /** # too-costly

Operation Too Costly. The operation was stopped to protect server resources; e.g. a request for a value set expansion on all of SNOMED CT. */
    TooCostly,
    /** # too-long

Content Too Long. Provided content is too long (typically, this is a denial of service protection type of error). */
    TooLong,
    /** # transient

Transient Issue. Transient processing issues. The system receiving the message may be able to resubmit the same content once an underlying issue is resolved. */
    Transient,
    /** # unknown

Unknown User. The user or system was not able to be authenticated (either there is no process, or the proferred token is unacceptable). */
    Unknown,
    /** # value

Element value invalid. An element or header value is invalid. */
    Value,
}
impl ::core::str::FromStr for IssueType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "business-rule" => Ok(Self::BusinessRule),
            "code-invalid" => Ok(Self::CodeInvalid),
            "conflict" => Ok(Self::Conflict),
            "deleted" => Ok(Self::Deleted),
            "duplicate" => Ok(Self::Duplicate),
            "exception" => Ok(Self::Exception),
            "expired" => Ok(Self::Expired),
            "extension" => Ok(Self::Extension),
            "forbidden" => Ok(Self::Forbidden),
            "incomplete" => Ok(Self::Incomplete),
            "informational" => Ok(Self::Informational),
            "invalid" => Ok(Self::Invalid),
            "invariant" => Ok(Self::Invariant),
            "lock-error" => Ok(Self::LockError),
            "login" => Ok(Self::Login),
            "multiple-matches" => Ok(Self::MultipleMatches),
            "no-store" => Ok(Self::NoStore),
            "not-found" => Ok(Self::NotFound),
            "not-supported" => Ok(Self::NotSupported),
            "processing" => Ok(Self::Processing),
            "required" => Ok(Self::Required),
            "security" => Ok(Self::Security),
            "structure" => Ok(Self::Structure),
            "suppressed" => Ok(Self::Suppressed),
            "throttled" => Ok(Self::Throttled),
            "timeout" => Ok(Self::Timeout),
            "too-costly" => Ok(Self::TooCostly),
            "too-long" => Ok(Self::TooLong),
            "transient" => Ok(Self::Transient),
            "unknown" => Ok(Self::Unknown),
            "value" => Ok(Self::Value),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for IssueType {
    fn as_ref(&self) -> &str {
        match self {
            Self::BusinessRule => "business-rule",
            Self::CodeInvalid => "code-invalid",
            Self::Conflict => "conflict",
            Self::Deleted => "deleted",
            Self::Duplicate => "duplicate",
            Self::Exception => "exception",
            Self::Expired => "expired",
            Self::Extension => "extension",
            Self::Forbidden => "forbidden",
            Self::Incomplete => "incomplete",
            Self::Informational => "informational",
            Self::Invalid => "invalid",
            Self::Invariant => "invariant",
            Self::LockError => "lock-error",
            Self::Login => "login",
            Self::MultipleMatches => "multiple-matches",
            Self::NoStore => "no-store",
            Self::NotFound => "not-found",
            Self::NotSupported => "not-supported",
            Self::Processing => "processing",
            Self::Required => "required",
            Self::Security => "security",
            Self::Structure => "structure",
            Self::Suppressed => "suppressed",
            Self::Throttled => "throttled",
            Self::Timeout => "timeout",
            Self::TooCostly => "too-costly",
            Self::TooLong => "too-long",
            Self::Transient => "transient",
            Self::Unknown => "unknown",
            Self::Value => "value",
        }
    }
}
impl<'de> Deserialize<'de> for IssueType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for IssueType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `KnowledgeResourceType`. A list of all the knowledge resource types defined in this version of the FHIR specification.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum KnowledgeResourceType {
    /** # ActivityDefinition

ActivityDefinition. The definition of a specific activity to be taken, independent of any particular patient or context. */
    ActivityDefinition,
    /** # CodeSystem

CodeSystem. A set of codes drawn from one or more code systems. */
    CodeSystem,
    /** # ConceptMap

ConceptMap. A map from one set of concepts to one or more other concepts. */
    ConceptMap,
    /** # Library

Library. Represents a library of quality improvement components. */
    Library,
    /** # Measure

Measure. A quality measure definition. */
    Measure,
    /** # PlanDefinition

PlanDefinition. The definition of a plan for a series of actions, independent of any specific patient or context. */
    PlanDefinition,
    /** # StructureDefinition

StructureDefinition. Structural Definition. */
    StructureDefinition,
    /** # StructureMap

StructureMap. A Map of relationships between 2 structures that can be used to transform data. */
    StructureMap,
    /** # ValueSet

ValueSet. A set of codes drawn from one or more code systems. */
    ValueSet,
}
impl ::core::str::FromStr for KnowledgeResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActivityDefinition" => Ok(Self::ActivityDefinition),
            "CodeSystem" => Ok(Self::CodeSystem),
            "ConceptMap" => Ok(Self::ConceptMap),
            "Library" => Ok(Self::Library),
            "Measure" => Ok(Self::Measure),
            "PlanDefinition" => Ok(Self::PlanDefinition),
            "StructureDefinition" => Ok(Self::StructureDefinition),
            "StructureMap" => Ok(Self::StructureMap),
            "ValueSet" => Ok(Self::ValueSet),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for KnowledgeResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActivityDefinition => "ActivityDefinition",
            Self::CodeSystem => "CodeSystem",
            Self::ConceptMap => "ConceptMap",
            Self::Library => "Library",
            Self::Measure => "Measure",
            Self::PlanDefinition => "PlanDefinition",
            Self::StructureDefinition => "StructureDefinition",
            Self::StructureMap => "StructureMap",
            Self::ValueSet => "ValueSet",
        }
    }
}
impl<'de> Deserialize<'de> for KnowledgeResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for KnowledgeResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `LanguagePreferenceType`. This code system defines a defines the set of codes for describing the type or mode of the patient's preferred language.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum LanguagePreferenceType {
    /** # verbal

verbal. The patient prefers to verbally communicate with the associated language. */
    Verbal,
    /** # written

written. The patient prefers to communicate in writing with the associated language. */
    Written,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for LanguagePreferenceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "verbal" => Ok(Self::Verbal),
            "written" => Ok(Self::Written),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for LanguagePreferenceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Verbal => "verbal",
            Self::Written => "written",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for LanguagePreferenceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LanguagePreferenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `LegalStatusOfSupply`. The prescription supply types appropriate to a medicinal product

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LegalStatusOfSupply {
    /** # 100000072076

Medicinal product not subject to medical prescription. */
    N100000072076,
    /** # 100000072077

Medicinal product on medical prescription for renewable or non-renewable delivery. */
    N100000072077,
    /** # 100000072078

Medicinal product subject to restricted medical prescription. */
    N100000072078,
    /** # 100000072079

Medicinal product on medical prescription for non-renewable delivery. */
    N100000072079,
    /** # 100000072084

Medicinal product subject to medical prescription. */
    N100000072084,
    /** # 100000072085

Medicinal product subject to special medical prescription. */
    N100000072085,
    /** # 100000072086

Medicinal product on medical prescription for renewable delivery. */
    N100000072086,
    /** # 100000157313

Medicinal product subject to special and restricted medical prescription. */
    N100000157313,
}
impl ::core::str::FromStr for LegalStatusOfSupply {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000072076" => Ok(Self::N100000072076),
            "100000072077" => Ok(Self::N100000072077),
            "100000072078" => Ok(Self::N100000072078),
            "100000072079" => Ok(Self::N100000072079),
            "100000072084" => Ok(Self::N100000072084),
            "100000072085" => Ok(Self::N100000072085),
            "100000072086" => Ok(Self::N100000072086),
            "100000157313" => Ok(Self::N100000157313),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LegalStatusOfSupply {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000072076 => "100000072076",
            Self::N100000072077 => "100000072077",
            Self::N100000072078 => "100000072078",
            Self::N100000072079 => "100000072079",
            Self::N100000072084 => "100000072084",
            Self::N100000072085 => "100000072085",
            Self::N100000072086 => "100000072086",
            Self::N100000157313 => "100000157313",
        }
    }
}
impl<'de> Deserialize<'de> for LegalStatusOfSupply {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LegalStatusOfSupply {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `LibraryType`. The type of knowledge asset this library contains.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LibraryType {
    /** # asset-collection

Asset Collection. The resource is a collection of knowledge assets. */
    AssetCollection,
    /** # logic-library

Logic Library. The resource is a shareable library of formalized knowledge. */
    LogicLibrary,
    /** # model-definition

Model Definition. The resource is a definition of an information model. */
    ModelDefinition,
    /** # module-definition

Module Definition. The resource defines the dependencies, parameters, and data requirements for a particular module or evaluation context. */
    ModuleDefinition,
}
impl ::core::str::FromStr for LibraryType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "asset-collection" => Ok(Self::AssetCollection),
            "logic-library" => Ok(Self::LogicLibrary),
            "model-definition" => Ok(Self::ModelDefinition),
            "module-definition" => Ok(Self::ModuleDefinition),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LibraryType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AssetCollection => "asset-collection",
            Self::LogicLibrary => "logic-library",
            Self::ModelDefinition => "model-definition",
            Self::ModuleDefinition => "module-definition",
        }
    }
}
impl<'de> Deserialize<'de> for LibraryType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LibraryType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `LinkType`. The type of link between this patient resource and another patient resource.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LinkType {
    /** # refer

Refer. The patient resource containing this link is in use and valid but not considered the main source of information about a patient. The link points forward to another patient resource that should be consulted to retrieve additional patient information. */
    Refer,
    /** # replaced-by

Replaced-by. The patient resource containing this link must no longer be used. The link points forward to another patient resource that must be used in lieu of the patient resource that contains this link. */
    ReplacedBy,
    /** # replaces

Replaces. The patient resource containing this link is the current active patient record. The link points back to an inactive patient resource that has been merged into this resource, and should be consulted to retrieve additional referenced information. */
    Replaces,
    /** # seealso

See also. The patient resource containing this link is in use and valid, but points to another patient resource that is known to contain data about the same person. Data in this resource might overlap or contradict information found in the other patient resource. This link does not indicate any relative importance of the resources concerned, and both should be regarded as equally valid. */
    Seealso,
}
impl ::core::str::FromStr for LinkType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "refer" => Ok(Self::Refer),
            "replaced-by" => Ok(Self::ReplacedBy),
            "replaces" => Ok(Self::Replaces),
            "seealso" => Ok(Self::Seealso),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LinkType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Refer => "refer",
            Self::ReplacedBy => "replaced-by",
            Self::Replaces => "replaces",
            Self::Seealso => "seealso",
        }
    }
}
impl<'de> Deserialize<'de> for LinkType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LinkType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `LinkageType`. Used to distinguish different roles a resource can play within a set of linked resources.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LinkageType {
    /** # alternate

Alternate Record. The resource represents an alternative view of the underlying event/condition/etc.  The resource may still be actively maintained, even though it is not considered to be the source of truth. */
    Alternate,
    /** # historical

Historical/Obsolete Record. The resource represents an obsolete record of the underlying event/condition/etc.  It is not expected to be actively maintained. */
    Historical,
    /** # source

Source of Truth. The resource represents the "source of truth" (from the perspective of this Linkage resource) for the underlying event/condition/etc. */
    Source,
}
impl ::core::str::FromStr for LinkageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alternate" => Ok(Self::Alternate),
            "historical" => Ok(Self::Historical),
            "source" => Ok(Self::Source),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LinkageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alternate => "alternate",
            Self::Historical => "historical",
            Self::Source => "source",
        }
    }
}
impl<'de> Deserialize<'de> for LinkageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LinkageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ListEmptyReasons`. General reasons for a list to be empty. Reasons are either related to a summary list (i.e. problem or medication list) or to a workflow related list (i.e. consultation list).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ListEmptyReasons {
    /** # closed

Closed. This list has now closed or has ceased to be relevant or useful. */
    Closed,
    /** # nilknown

Nil Known. Clinical judgment that there are no known items for this list after reasonable investigation. Note that this a positive statement by a clinical user, and not a default position asserted by a computer system in the lack of other information. Example uses:  * For allergies: the patient or patient's agent/guardian has asserted that he/she is not aware of any allergies (NKA - nil known allergies)  * For medications: the patient or patient's agent/guardian has asserted that the patient is known to be taking no medications  * For diagnoses, problems and procedures: the patient or patient's agent/guardian has asserted that there is no known event to record. */
    Nilknown,
    /** # notasked

Not Asked. The investigation to find out whether there are items for this list has not occurred. */
    Notasked,
    /** # notstarted

Not Started. The work to populate this list has not yet begun. */
    Notstarted,
    /** # unavailable

Unavailable. Information to populate this list cannot be obtained; e.g. unconscious patient. */
    Unavailable,
    /** # withheld

Information Withheld. The content of the list was not provided due to privacy or confidentiality concerns. Note that it should not be assumed that this means that the particular information in question was withheld due to its contents - it can also be a policy decision. */
    Withheld,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ListEmptyReasons {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "closed" => Ok(Self::Closed),
            "nilknown" => Ok(Self::Nilknown),
            "notasked" => Ok(Self::Notasked),
            "notstarted" => Ok(Self::Notstarted),
            "unavailable" => Ok(Self::Unavailable),
            "withheld" => Ok(Self::Withheld),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ListEmptyReasons {
    fn as_ref(&self) -> &str {
        match self {
            Self::Closed => "closed",
            Self::Nilknown => "nilknown",
            Self::Notasked => "notasked",
            Self::Notstarted => "notstarted",
            Self::Unavailable => "unavailable",
            Self::Withheld => "withheld",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ListEmptyReasons {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListEmptyReasons {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ListMode`. The processing mode that applies to this list.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ListMode {
    /** # changes

Change List. A point-in-time list that shows what changes have been made or recommended.  E.g. a discharge medication list showing what was added and removed during an encounter. */
    Changes,
    /** # snapshot

Snapshot List. This list was prepared as a snapshot. It should not be assumed to be current. */
    Snapshot,
    /** # working

Working List. This list is the master list, maintained in an ongoing fashion with regular updates as the real world list it is tracking changes. */
    Working,
}
impl ::core::str::FromStr for ListMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "changes" => Ok(Self::Changes),
            "snapshot" => Ok(Self::Snapshot),
            "working" => Ok(Self::Working),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Changes => "changes",
            Self::Snapshot => "snapshot",
            Self::Working => "working",
        }
    }
}
impl<'de> Deserialize<'de> for ListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ListOrderCodes`. Base values for the order of the items in a list resource.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ListOrderCodes {
    /** # alphabetic

Sorted Alphabetically. The list is sorted alphabetically by an unspecified property of the items in the list. */
    Alphabetic,
    /** # category

Sorted by Category. The list is sorted categorically by an unspecified property of the items in the list. */
    Category,
    /** # entry-date

Sorted by Item Date. The list is sorted by the date the item was added to the list. Note that the date added to the list is not explicit in the list itself. */
    EntryDate,
    /** # event-date

Sorted by Event Date. The list is sorted by the data of the event. This can be used when the list has items which are dates with past or future events. */
    EventDate,
    /** # patient

Sorted by Patient. The list is sorted by patient, with items for each patient grouped together. */
    Patient,
    /** # priority

Sorted by Priority. The list is sorted by priority. The exact method in which priority has been determined is not specified. */
    Priority,
    /** # system

Sorted by System. The list was sorted by the system. The criteria the user used are not specified; define additional codes to specify a particular order (or use other defined codes). */
    System,
    /** # user

Sorted by User. The list was sorted by a user. The criteria the user used are not specified. */
    User,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ListOrderCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alphabetic" => Ok(Self::Alphabetic),
            "category" => Ok(Self::Category),
            "entry-date" => Ok(Self::EntryDate),
            "event-date" => Ok(Self::EventDate),
            "patient" => Ok(Self::Patient),
            "priority" => Ok(Self::Priority),
            "system" => Ok(Self::System),
            "user" => Ok(Self::User),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ListOrderCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alphabetic => "alphabetic",
            Self::Category => "category",
            Self::EntryDate => "entry-date",
            Self::EventDate => "event-date",
            Self::Patient => "patient",
            Self::Priority => "priority",
            Self::System => "system",
            Self::User => "user",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ListOrderCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListOrderCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ListStatus`. The current state of the list.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ListStatus {
    /** # current

Current. The list is considered to be an active part of the patient's record. */
    Current,
    /** # entered-in-error

Entered In Error. The list was never accurate.  It is retained for medico-legal purposes only. */
    EnteredInError,
    /** # retired

Retired. The list is "old" and should no longer be considered accurate or relevant. */
    Retired,
}
impl ::core::str::FromStr for ListStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "current" => Ok(Self::Current),
            "entered-in-error" => Ok(Self::EnteredInError),
            "retired" => Ok(Self::Retired),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ListStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Current => "current",
            Self::EnteredInError => "entered-in-error",
            Self::Retired => "retired",
        }
    }
}
impl<'de> Deserialize<'de> for ListStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ListStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `LocationMode`. Indicates whether a resource instance represents a specific location or a class of locations.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LocationMode {
    /** # instance

Instance. The Location resource represents a specific instance of a location (e.g. Operating Theatre 1A). */
    Instance,
    /** # kind

Kind. The Location represents a class of locations (e.g. Any Operating Theatre) although this class of locations could be constrained within a specific boundary (such as organization, or parent location, address etc.). */
    Kind,
}
impl ::core::str::FromStr for LocationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "instance" => Ok(Self::Instance),
            "kind" => Ok(Self::Kind),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Instance => "instance",
            Self::Kind => "kind",
        }
    }
}
impl<'de> Deserialize<'de> for LocationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `LocationStatus`. Indicates whether the location is still in use.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum LocationStatus {
    /** # active

Active. The location is operational. */
    Active,
    /** # inactive

Inactive. The location is no longer used. */
    Inactive,
    /** # suspended

Suspended. The location is temporarily closed. */
    Suspended,
}
impl ::core::str::FromStr for LocationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "inactive" => Ok(Self::Inactive),
            "suspended" => Ok(Self::Suspended),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for LocationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Inactive => "inactive",
            Self::Suspended => "suspended",
        }
    }
}
impl<'de> Deserialize<'de> for LocationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `LocationType`. This example value set defines a set of codes that can be used to indicate the physical form of the Location.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum LocationType {
    /** # area

Area. A defined physical boundary of something, such as a flood risk zone, region, postcode */
    Area,
    /** # bd

Bed. A space that is allocated for sleeping/laying on. This is not the physical bed/trolley that may be moved about, but the space it may occupy. */
    Bd,
    /** # bu

Building. Any Building or structure. This may contain rooms, corridors, wings, etc. It might not have walls, or a roof, but is considered a defined/allocated space. */
    Bu,
    /** # ca

Cabinet. A container that can store goods, equipment, medications or other items. */
    Ca,
    /** # co

Corridor. Any corridor within a Building, that may connect rooms. */
    Co,
    /** # ho

House. A residential dwelling. Usually used to reference a location that a person/patient may reside. */
    Ho,
    /** # jdn

Jurisdiction. A wide scope that covers a conceptual domain, such as a Nation (Country wide community or Federal Government - e.g. Ministry of Health),  Province or State (community or Government), Business (throughout the enterprise), Nation with a business scope of an agency (e.g. CDC, FDA etc.) or a Business segment (UK Pharmacy), not just an physical boundary */
    Jdn,
    /** # lvl

Level. A Level in a multi-level Building/Structure. */
    Lvl,
    /** # rd

Road. A defined path to travel between 2 points that has a known name. */
    Rd,
    /** # ro

Room. A space that is allocated as a room, it may have walls/roof etc., but does not require these. */
    Ro,
    /** # si

Site. A collection of buildings or other locations such as a site or a campus. */
    Si,
    /** # ve

Vehicle. A means of transportation. */
    Ve,
    /** # wa

Ward. A Ward is a section of a medical facility that may contain rooms and other types of location. */
    Wa,
    /** # wi

Wing. A Wing within a Building, this often contains levels, rooms and corridors. */
    Wi,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for LocationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "area" => Ok(Self::Area),
            "bd" => Ok(Self::Bd),
            "bu" => Ok(Self::Bu),
            "ca" => Ok(Self::Ca),
            "co" => Ok(Self::Co),
            "ho" => Ok(Self::Ho),
            "jdn" => Ok(Self::Jdn),
            "lvl" => Ok(Self::Lvl),
            "rd" => Ok(Self::Rd),
            "ro" => Ok(Self::Ro),
            "si" => Ok(Self::Si),
            "ve" => Ok(Self::Ve),
            "wa" => Ok(Self::Wa),
            "wi" => Ok(Self::Wi),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for LocationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Area => "area",
            Self::Bd => "bd",
            Self::Bu => "bu",
            Self::Ca => "ca",
            Self::Co => "co",
            Self::Ho => "ho",
            Self::Jdn => "jdn",
            Self::Lvl => "lvl",
            Self::Rd => "rd",
            Self::Ro => "ro",
            Self::Si => "si",
            Self::Ve => "ve",
            Self::Wa => "wa",
            Self::Wi => "wi",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for LocationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for LocationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ManufacturedDoseForm`. Dose form for a medication, as manufactured (and before any mixing etc.), not necessarily ready for administration to the patient.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ManufacturedDoseForm {
    /** # 100000073362

Oral suspension. */
    N100000073362,
    /** # 100000073363

Oral gel. */
    N100000073363,
    /** # 100000073364

Powder for oral solution. */
    N100000073364,
    /** # 100000073365

Granules for oral solution. */
    N100000073365,
    /** # 100000073367

Lyophilisate for suspension. */
    N100000073367,
    /** # 100000073368

Powder for syrup. */
    N100000073368,
    /** # 100000073369

Soluble tablet. */
    N100000073369,
    /** # 100000073370

Herbal tea. */
    N100000073370,
    /** # 100000073371

Instant herbal tea. */
    N100000073371,
    /** # 100000073372

Granules. */
    N100000073372,
    /** # 100000073373

Gastro-resistant granules. */
    N100000073373,
    /** # 100000073374

Modified-release granules. */
    N100000073374,
    /** # 100000073375

Capsule, hard. */
    N100000073375,
    /** # 100000073376

Gastro-resistant capsule, hard. */
    N100000073376,
    /** # 100000073377

Chewable capsule, soft. */
    N100000073377,
    /** # 100000073378

Prolonged-release capsule, soft. */
    N100000073378,
    /** # 100000073379

Modified-release capsule, soft. */
    N100000073379,
    /** # 100000073380

Coated tablet. */
    N100000073380,
    /** # 100000073642

Oral drops, solution. */
    N100000073642,
    /** # 100000073643

Oral drops, suspension. */
    N100000073643,
    /** # 100000073644

Oral drops, emulsion. */
    N100000073644,
    /** # 100000073645

Oral liquid. */
    N100000073645,
    /** # 100000073646

Oral solution. */
    N100000073646,
    /** # 100000073647

Oral emulsion. */
    N100000073647,
    /** # 100000073648

Oral paste. */
    N100000073648,
    /** # 100000073649

Powder for oral suspension. */
    N100000073649,
    /** # 100000073650

Granules for oral suspension. */
    N100000073650,
    /** # 100000073652

Syrup. */
    N100000073652,
    /** # 100000073653

Granules for syrup. */
    N100000073653,
    /** # 100000073654

Dispersible tablet. */
    N100000073654,
    /** # 100000073655

Oral powder. */
    N100000073655,
    /** # 100000073656

Effervescent powder. */
    N100000073656,
    /** # 100000073657

Effervescent granules. */
    N100000073657,
    /** # 100000073658

Prolonged-release granules. */
    N100000073658,
    /** # 100000073659

Cachet. */
    N100000073659,
    /** # 100000073660

Capsule, soft. */
    N100000073660,
    /** # 100000073661

Gastro-resistant capsule, soft. */
    N100000073661,
    /** # 100000073662

Prolonged-release capsule, hard. */
    N100000073662,
    /** # 100000073663

Modified-release capsule, hard. */
    N100000073663,
    /** # 100000073664

Tablet. */
    N100000073664,
    /** # 100000073665

Film-coated tablet. */
    N100000073665,
    /** # 100000073666

Orodispersible tablet. */
    N100000073666,
    /** # 100000073667

Gastro-resistant tablet. */
    N100000073667,
    /** # 100000073668

Modified-release tablet. */
    N100000073668,
    /** # 100000073669

Medicated chewing-gum. */
    N100000073669,
    /** # 100000073670

Pillules. */
    N100000073670,
    /** # 100000073671

Pulsatile-release intraruminal device. */
    N100000073671,
    /** # 100000073672

Premix for medicated feeding stuff. */
    N100000073672,
    /** # 100000073673

Gargle. */
    N100000073673,
    /** # 100000073674

Gargle, powder for solution. */
    N100000073674,
    /** # 100000073675

Oromucosal suspension. */
    N100000073675,
    /** # 100000073676

Oromucosal spray. */
    N100000073676,
    /** # 100000073677

Mouthwash. */
    N100000073677,
    /** # 100000073678

Gingival solution. */
    N100000073678,
    /** # 100000073679

Oromucosal paste. */
    N100000073679,
    /** # 100000073680

Gingival gel. */
    N100000073680,
    /** # 100000073681

Effervescent tablet. */
    N100000073681,
    /** # 100000073682

Oral lyophilisate. */
    N100000073682,
    /** # 100000073683

Prolonged-release tablet. */
    N100000073683,
    /** # 100000073684

Chewable tablet. */
    N100000073684,
    /** # 100000073685

Oral gum. */
    N100000073685,
    /** # 100000073686

Continuous-release intraruminal device. */
    N100000073686,
    /** # 100000073687

Lick block. */
    N100000073687,
    /** # 100000073688

Medicated pellets. */
    N100000073688,
    /** # 100000073689

Concentrate for gargle. */
    N100000073689,
    /** # 100000073690

Gargle, tablet for solution. */
    N100000073690,
    /** # 100000073691

Oromucosal solution. */
    N100000073691,
    /** # 100000073692

Oromucosal drops. */
    N100000073692,
    /** # 100000073693

Sublingual spray. */
    N100000073693,
    /** # 100000073694

Mouthwash, tablet for solution. */
    N100000073694,
    /** # 100000073695

Oromucosal gel. */
    N100000073695,
    /** # 100000073696

Oromucosal cream. */
    N100000073696,
    /** # 100000073697

Gingival paste. */
    N100000073697,
    /** # 100000073698

Sublingual tablet. */
    N100000073698,
    /** # 100000073699

Buccal tablet. */
    N100000073699,
    /** # 100000073700

Compressed lozenge. */
    N100000073700,
    /** # 100000073701

Oromucosal capsule. */
    N100000073701,
    /** # 100000073702

Muco-adhesive buccal tablet. */
    N100000073702,
    /** # 100000073703

Lozenge. */
    N100000073703,
    /** # 100000073704

Pastille. */
    N100000073704,
    /** # 100000073705

Dental gel. */
    N100000073705,
    /** # 100000073706

Dental insert. */
    N100000073706,
    /** # 100000073707

Dental powder. */
    N100000073707,
    /** # 100000073708

Dental suspension. */
    N100000073708,
    /** # 100000073709

Toothpaste. */
    N100000073709,
    /** # 100000073710

Periodontal gel. */
    N100000073710,
    /** # 100000073711

Bath additive. */
    N100000073711,
    /** # 100000073712

Cream. */
    N100000073712,
    /** # 100000073713

Ointment. */
    N100000073713,
    /** # 100000073714

Medicated plaster. */
    N100000073714,
    /** # 100000073715

Shampoo. */
    N100000073715,
    /** # 100000073716

Cutaneous spray, suspension. */
    N100000073716,
    /** # 100000073717

Cutaneous liquid. */
    N100000073717,
    /** # 100000073718

Concentrate for cutaneous solution. */
    N100000073718,
    /** # 100000073719

Cutaneous emulsion. */
    N100000073719,
    /** # 100000073720

Cutaneous patch. */
    N100000073720,
    /** # 100000073721

Periodontal powder. */
    N100000073721,
    /** # 100000073722

Dental stick. */
    N100000073722,
    /** # 100000073723

Dental solution. */
    N100000073723,
    /** # 100000073724

Dental emulsion. */
    N100000073724,
    /** # 100000073725

Periodontal insert. */
    N100000073725,
    /** # 100000073726

Gel. */
    N100000073726,
    /** # 100000073727

Cutaneous paste. */
    N100000073727,
    /** # 100000073728

Cutaneous foam. */
    N100000073728,
    /** # 100000073729

Cutaneous spray, solution. */
    N100000073729,
    /** # 100000073730

Cutaneous spray, powder. */
    N100000073730,
    /** # 100000073731

Cutaneous solution. */
    N100000073731,
    /** # 100000073732

Cutaneous suspension. */
    N100000073732,
    /** # 100000073733

Cutaneous powder. */
    N100000073733,
    /** # 100000073734

Solution for iontophoresis. */
    N100000073734,
    /** # 100000073735

Collodion. */
    N100000073735,
    /** # 100000073736

Poultice. */
    N100000073736,
    /** # 100000073737

Cutaneous sponge. */
    N100000073737,
    /** # 100000073738

Collar. */
    N100000073738,
    /** # 100000073739

Ear tag. */
    N100000073739,
    /** # 100000073740

Dip suspension. */
    N100000073740,
    /** # 100000073741

Transdermal patch. */
    N100000073741,
    /** # 100000073742

Medicated nail lacquer. */
    N100000073742,
    /** # 100000073743

Cutaneous stick. */
    N100000073743,
    /** # 100000073744

Impregnated dressing. */
    N100000073744,
    /** # 100000073745

Medicated pendant. */
    N100000073745,
    /** # 100000073746

Dip solution. */
    N100000073746,
    /** # 100000073747

Dip emulsion. */
    N100000073747,
    /** # 100000073748

Concentrate for dip suspension. */
    N100000073748,
    /** # 100000073749

Powder for dip solution. */
    N100000073749,
    /** # 100000073750

Powder for suspension for fish treatment. */
    N100000073750,
    /** # 100000073751

Pour-on suspension. */
    N100000073751,
    /** # 100000073752

Spot-on solution. */
    N100000073752,
    /** # 100000073753

Spot-on emulsion. */
    N100000073753,
    /** # 100000073754

Teat dip suspension. */
    N100000073754,
    /** # 100000073755

Teat spray solution. */
    N100000073755,
    /** # 100000073756

Solution for skin-prick test. */
    N100000073756,
    /** # 100000073757

Plaster for provocation test. */
    N100000073757,
    /** # 100000073758

Eye gel. */
    N100000073758,
    /** # 100000073759

Eye drops, solution. */
    N100000073759,
    /** # 100000073760

Eye drops, suspension. */
    N100000073760,
    /** # 100000073761

Concentrate for dip solution. */
    N100000073761,
    /** # 100000073762

Concentrate for dip emulsion. */
    N100000073762,
    /** # 100000073763

Concentrate for solution for fish treatment. */
    N100000073763,
    /** # 100000073764

Pour-on solution. */
    N100000073764,
    /** # 100000073765

Pour-on emulsion. */
    N100000073765,
    /** # 100000073766

Spot-on suspension. */
    N100000073766,
    /** # 100000073767

Teat dip solution. */
    N100000073767,
    /** # 100000073768

Teat dip emulsion. */
    N100000073768,
    /** # 100000073769

Transdermal system. */
    N100000073769,
    /** # 100000073770

Solution for skin-scratch test. */
    N100000073770,
    /** # 100000073771

Eye cream. */
    N100000073771,
    /** # 100000073772

Eye ointment. */
    N100000073772,
    /** # 100000073773

Eye drops, emulsion. */
    N100000073773,
    /** # 100000073775

Eye drops, solvent for reconstitution. */
    N100000073775,
    /** # 100000073776

Eye lotion. */
    N100000073776,
    /** # 100000073777

Ophthalmic insert. */
    N100000073777,
    /** # 100000073778

Ear cream. */
    N100000073778,
    /** # 100000073779

Ear ointment. */
    N100000073779,
    /** # 100000073780

Ear drops, suspension. */
    N100000073780,
    /** # 100000073782

Eye drops, prolonged-release. */
    N100000073782,
    /** # 100000073783

Eye lotion, solvent for reconstitution. */
    N100000073783,
    /** # 100000073784

Ophthalmic strip. */
    N100000073784,
    /** # 100000073785

Ear gel. */
    N100000073785,
    /** # 100000073786

Ear drops, solution. */
    N100000073786,
    /** # 100000073787

Ear drops, emulsion. */
    N100000073787,
    /** # 100000073788

Ear powder. */
    N100000073788,
    /** # 100000073789

Ear spray, suspension. */
    N100000073789,
    /** # 100000073790

Ear wash, solution. */
    N100000073790,
    /** # 100000073791

Ear tampon. */
    N100000073791,
    /** # 100000073792

Nasal cream. */
    N100000073792,
    /** # 100000073793

Nasal gel. */
    N100000073793,
    /** # 100000073794

Nasal drops, solution. */
    N100000073794,
    /** # 100000073795

Nasal drops, emulsion. */
    N100000073795,
    /** # 100000073796

Nasal spray, solution. */
    N100000073796,
    /** # 100000073797

Nasal spray, emulsion. */
    N100000073797,
    /** # 100000073798

Nasal stick. */
    N100000073798,
    /** # 100000073799

Vaginal gel. */
    N100000073799,
    /** # 100000073800

Vaginal foam. */
    N100000073800,
    /** # 100000073802

Ear spray, solution. */
    N100000073802,
    /** # 100000073803

Ear spray, emulsion. */
    N100000073803,
    /** # 100000073804

Ear wash, emulsion. */
    N100000073804,
    /** # 100000073805

Ear stick. */
    N100000073805,
    /** # 100000073806

Nasal ointment. */
    N100000073806,
    /** # 100000073807

Nasal drops, suspension. */
    N100000073807,
    /** # 100000073808

Nasal powder. */
    N100000073808,
    /** # 100000073809

Nasal spray, suspension. */
    N100000073809,
    /** # 100000073810

Nasal wash. */
    N100000073810,
    /** # 100000073811

Vaginal cream. */
    N100000073811,
    /** # 100000073812

Vaginal ointment. */
    N100000073812,
    /** # 100000073813

Vaginal solution. */
    N100000073813,
    /** # 100000073814

Vaginal emulsion. */
    N100000073814,
    /** # 100000073815

Pessary. */
    N100000073815,
    /** # 100000073816

Vaginal capsule, soft. */
    N100000073816,
    /** # 100000073817

Effervescent vaginal tablet. */
    N100000073817,
    /** # 100000073818

Vaginal delivery system. */
    N100000073818,
    /** # 100000073819

Rectal cream. */
    N100000073819,
    /** # 100000073820

Rectal foam. */
    N100000073820,
    /** # 100000073821

Vaginal suspension. */
    N100000073821,
    /** # 100000073822

Tablet for vaginal solution. */
    N100000073822,
    /** # 100000073823

Vaginal capsule, hard. */
    N100000073823,
    /** # 100000073824

Vaginal tablet. */
    N100000073824,
    /** # 100000073825

Medicated vaginal tampon. */
    N100000073825,
    /** # 100000073826

Vaginal sponge. */
    N100000073826,
    /** # 100000073827

Rectal gel. */
    N100000073827,
    /** # 100000073863

Solution for injection. */
    N100000073863,
}
impl ::core::str::FromStr for ManufacturedDoseForm {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073362" => Ok(Self::N100000073362),
            "100000073363" => Ok(Self::N100000073363),
            "100000073364" => Ok(Self::N100000073364),
            "100000073365" => Ok(Self::N100000073365),
            "100000073367" => Ok(Self::N100000073367),
            "100000073368" => Ok(Self::N100000073368),
            "100000073369" => Ok(Self::N100000073369),
            "100000073370" => Ok(Self::N100000073370),
            "100000073371" => Ok(Self::N100000073371),
            "100000073372" => Ok(Self::N100000073372),
            "100000073373" => Ok(Self::N100000073373),
            "100000073374" => Ok(Self::N100000073374),
            "100000073375" => Ok(Self::N100000073375),
            "100000073376" => Ok(Self::N100000073376),
            "100000073377" => Ok(Self::N100000073377),
            "100000073378" => Ok(Self::N100000073378),
            "100000073379" => Ok(Self::N100000073379),
            "100000073380" => Ok(Self::N100000073380),
            "100000073642" => Ok(Self::N100000073642),
            "100000073643" => Ok(Self::N100000073643),
            "100000073644" => Ok(Self::N100000073644),
            "100000073645" => Ok(Self::N100000073645),
            "100000073646" => Ok(Self::N100000073646),
            "100000073647" => Ok(Self::N100000073647),
            "100000073648" => Ok(Self::N100000073648),
            "100000073649" => Ok(Self::N100000073649),
            "100000073650" => Ok(Self::N100000073650),
            "100000073652" => Ok(Self::N100000073652),
            "100000073653" => Ok(Self::N100000073653),
            "100000073654" => Ok(Self::N100000073654),
            "100000073655" => Ok(Self::N100000073655),
            "100000073656" => Ok(Self::N100000073656),
            "100000073657" => Ok(Self::N100000073657),
            "100000073658" => Ok(Self::N100000073658),
            "100000073659" => Ok(Self::N100000073659),
            "100000073660" => Ok(Self::N100000073660),
            "100000073661" => Ok(Self::N100000073661),
            "100000073662" => Ok(Self::N100000073662),
            "100000073663" => Ok(Self::N100000073663),
            "100000073664" => Ok(Self::N100000073664),
            "100000073665" => Ok(Self::N100000073665),
            "100000073666" => Ok(Self::N100000073666),
            "100000073667" => Ok(Self::N100000073667),
            "100000073668" => Ok(Self::N100000073668),
            "100000073669" => Ok(Self::N100000073669),
            "100000073670" => Ok(Self::N100000073670),
            "100000073671" => Ok(Self::N100000073671),
            "100000073672" => Ok(Self::N100000073672),
            "100000073673" => Ok(Self::N100000073673),
            "100000073674" => Ok(Self::N100000073674),
            "100000073675" => Ok(Self::N100000073675),
            "100000073676" => Ok(Self::N100000073676),
            "100000073677" => Ok(Self::N100000073677),
            "100000073678" => Ok(Self::N100000073678),
            "100000073679" => Ok(Self::N100000073679),
            "100000073680" => Ok(Self::N100000073680),
            "100000073681" => Ok(Self::N100000073681),
            "100000073682" => Ok(Self::N100000073682),
            "100000073683" => Ok(Self::N100000073683),
            "100000073684" => Ok(Self::N100000073684),
            "100000073685" => Ok(Self::N100000073685),
            "100000073686" => Ok(Self::N100000073686),
            "100000073687" => Ok(Self::N100000073687),
            "100000073688" => Ok(Self::N100000073688),
            "100000073689" => Ok(Self::N100000073689),
            "100000073690" => Ok(Self::N100000073690),
            "100000073691" => Ok(Self::N100000073691),
            "100000073692" => Ok(Self::N100000073692),
            "100000073693" => Ok(Self::N100000073693),
            "100000073694" => Ok(Self::N100000073694),
            "100000073695" => Ok(Self::N100000073695),
            "100000073696" => Ok(Self::N100000073696),
            "100000073697" => Ok(Self::N100000073697),
            "100000073698" => Ok(Self::N100000073698),
            "100000073699" => Ok(Self::N100000073699),
            "100000073700" => Ok(Self::N100000073700),
            "100000073701" => Ok(Self::N100000073701),
            "100000073702" => Ok(Self::N100000073702),
            "100000073703" => Ok(Self::N100000073703),
            "100000073704" => Ok(Self::N100000073704),
            "100000073705" => Ok(Self::N100000073705),
            "100000073706" => Ok(Self::N100000073706),
            "100000073707" => Ok(Self::N100000073707),
            "100000073708" => Ok(Self::N100000073708),
            "100000073709" => Ok(Self::N100000073709),
            "100000073710" => Ok(Self::N100000073710),
            "100000073711" => Ok(Self::N100000073711),
            "100000073712" => Ok(Self::N100000073712),
            "100000073713" => Ok(Self::N100000073713),
            "100000073714" => Ok(Self::N100000073714),
            "100000073715" => Ok(Self::N100000073715),
            "100000073716" => Ok(Self::N100000073716),
            "100000073717" => Ok(Self::N100000073717),
            "100000073718" => Ok(Self::N100000073718),
            "100000073719" => Ok(Self::N100000073719),
            "100000073720" => Ok(Self::N100000073720),
            "100000073721" => Ok(Self::N100000073721),
            "100000073722" => Ok(Self::N100000073722),
            "100000073723" => Ok(Self::N100000073723),
            "100000073724" => Ok(Self::N100000073724),
            "100000073725" => Ok(Self::N100000073725),
            "100000073726" => Ok(Self::N100000073726),
            "100000073727" => Ok(Self::N100000073727),
            "100000073728" => Ok(Self::N100000073728),
            "100000073729" => Ok(Self::N100000073729),
            "100000073730" => Ok(Self::N100000073730),
            "100000073731" => Ok(Self::N100000073731),
            "100000073732" => Ok(Self::N100000073732),
            "100000073733" => Ok(Self::N100000073733),
            "100000073734" => Ok(Self::N100000073734),
            "100000073735" => Ok(Self::N100000073735),
            "100000073736" => Ok(Self::N100000073736),
            "100000073737" => Ok(Self::N100000073737),
            "100000073738" => Ok(Self::N100000073738),
            "100000073739" => Ok(Self::N100000073739),
            "100000073740" => Ok(Self::N100000073740),
            "100000073741" => Ok(Self::N100000073741),
            "100000073742" => Ok(Self::N100000073742),
            "100000073743" => Ok(Self::N100000073743),
            "100000073744" => Ok(Self::N100000073744),
            "100000073745" => Ok(Self::N100000073745),
            "100000073746" => Ok(Self::N100000073746),
            "100000073747" => Ok(Self::N100000073747),
            "100000073748" => Ok(Self::N100000073748),
            "100000073749" => Ok(Self::N100000073749),
            "100000073750" => Ok(Self::N100000073750),
            "100000073751" => Ok(Self::N100000073751),
            "100000073752" => Ok(Self::N100000073752),
            "100000073753" => Ok(Self::N100000073753),
            "100000073754" => Ok(Self::N100000073754),
            "100000073755" => Ok(Self::N100000073755),
            "100000073756" => Ok(Self::N100000073756),
            "100000073757" => Ok(Self::N100000073757),
            "100000073758" => Ok(Self::N100000073758),
            "100000073759" => Ok(Self::N100000073759),
            "100000073760" => Ok(Self::N100000073760),
            "100000073761" => Ok(Self::N100000073761),
            "100000073762" => Ok(Self::N100000073762),
            "100000073763" => Ok(Self::N100000073763),
            "100000073764" => Ok(Self::N100000073764),
            "100000073765" => Ok(Self::N100000073765),
            "100000073766" => Ok(Self::N100000073766),
            "100000073767" => Ok(Self::N100000073767),
            "100000073768" => Ok(Self::N100000073768),
            "100000073769" => Ok(Self::N100000073769),
            "100000073770" => Ok(Self::N100000073770),
            "100000073771" => Ok(Self::N100000073771),
            "100000073772" => Ok(Self::N100000073772),
            "100000073773" => Ok(Self::N100000073773),
            "100000073775" => Ok(Self::N100000073775),
            "100000073776" => Ok(Self::N100000073776),
            "100000073777" => Ok(Self::N100000073777),
            "100000073778" => Ok(Self::N100000073778),
            "100000073779" => Ok(Self::N100000073779),
            "100000073780" => Ok(Self::N100000073780),
            "100000073782" => Ok(Self::N100000073782),
            "100000073783" => Ok(Self::N100000073783),
            "100000073784" => Ok(Self::N100000073784),
            "100000073785" => Ok(Self::N100000073785),
            "100000073786" => Ok(Self::N100000073786),
            "100000073787" => Ok(Self::N100000073787),
            "100000073788" => Ok(Self::N100000073788),
            "100000073789" => Ok(Self::N100000073789),
            "100000073790" => Ok(Self::N100000073790),
            "100000073791" => Ok(Self::N100000073791),
            "100000073792" => Ok(Self::N100000073792),
            "100000073793" => Ok(Self::N100000073793),
            "100000073794" => Ok(Self::N100000073794),
            "100000073795" => Ok(Self::N100000073795),
            "100000073796" => Ok(Self::N100000073796),
            "100000073797" => Ok(Self::N100000073797),
            "100000073798" => Ok(Self::N100000073798),
            "100000073799" => Ok(Self::N100000073799),
            "100000073800" => Ok(Self::N100000073800),
            "100000073802" => Ok(Self::N100000073802),
            "100000073803" => Ok(Self::N100000073803),
            "100000073804" => Ok(Self::N100000073804),
            "100000073805" => Ok(Self::N100000073805),
            "100000073806" => Ok(Self::N100000073806),
            "100000073807" => Ok(Self::N100000073807),
            "100000073808" => Ok(Self::N100000073808),
            "100000073809" => Ok(Self::N100000073809),
            "100000073810" => Ok(Self::N100000073810),
            "100000073811" => Ok(Self::N100000073811),
            "100000073812" => Ok(Self::N100000073812),
            "100000073813" => Ok(Self::N100000073813),
            "100000073814" => Ok(Self::N100000073814),
            "100000073815" => Ok(Self::N100000073815),
            "100000073816" => Ok(Self::N100000073816),
            "100000073817" => Ok(Self::N100000073817),
            "100000073818" => Ok(Self::N100000073818),
            "100000073819" => Ok(Self::N100000073819),
            "100000073820" => Ok(Self::N100000073820),
            "100000073821" => Ok(Self::N100000073821),
            "100000073822" => Ok(Self::N100000073822),
            "100000073823" => Ok(Self::N100000073823),
            "100000073824" => Ok(Self::N100000073824),
            "100000073825" => Ok(Self::N100000073825),
            "100000073826" => Ok(Self::N100000073826),
            "100000073827" => Ok(Self::N100000073827),
            "100000073863" => Ok(Self::N100000073863),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ManufacturedDoseForm {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073362 => "100000073362",
            Self::N100000073363 => "100000073363",
            Self::N100000073364 => "100000073364",
            Self::N100000073365 => "100000073365",
            Self::N100000073367 => "100000073367",
            Self::N100000073368 => "100000073368",
            Self::N100000073369 => "100000073369",
            Self::N100000073370 => "100000073370",
            Self::N100000073371 => "100000073371",
            Self::N100000073372 => "100000073372",
            Self::N100000073373 => "100000073373",
            Self::N100000073374 => "100000073374",
            Self::N100000073375 => "100000073375",
            Self::N100000073376 => "100000073376",
            Self::N100000073377 => "100000073377",
            Self::N100000073378 => "100000073378",
            Self::N100000073379 => "100000073379",
            Self::N100000073380 => "100000073380",
            Self::N100000073642 => "100000073642",
            Self::N100000073643 => "100000073643",
            Self::N100000073644 => "100000073644",
            Self::N100000073645 => "100000073645",
            Self::N100000073646 => "100000073646",
            Self::N100000073647 => "100000073647",
            Self::N100000073648 => "100000073648",
            Self::N100000073649 => "100000073649",
            Self::N100000073650 => "100000073650",
            Self::N100000073652 => "100000073652",
            Self::N100000073653 => "100000073653",
            Self::N100000073654 => "100000073654",
            Self::N100000073655 => "100000073655",
            Self::N100000073656 => "100000073656",
            Self::N100000073657 => "100000073657",
            Self::N100000073658 => "100000073658",
            Self::N100000073659 => "100000073659",
            Self::N100000073660 => "100000073660",
            Self::N100000073661 => "100000073661",
            Self::N100000073662 => "100000073662",
            Self::N100000073663 => "100000073663",
            Self::N100000073664 => "100000073664",
            Self::N100000073665 => "100000073665",
            Self::N100000073666 => "100000073666",
            Self::N100000073667 => "100000073667",
            Self::N100000073668 => "100000073668",
            Self::N100000073669 => "100000073669",
            Self::N100000073670 => "100000073670",
            Self::N100000073671 => "100000073671",
            Self::N100000073672 => "100000073672",
            Self::N100000073673 => "100000073673",
            Self::N100000073674 => "100000073674",
            Self::N100000073675 => "100000073675",
            Self::N100000073676 => "100000073676",
            Self::N100000073677 => "100000073677",
            Self::N100000073678 => "100000073678",
            Self::N100000073679 => "100000073679",
            Self::N100000073680 => "100000073680",
            Self::N100000073681 => "100000073681",
            Self::N100000073682 => "100000073682",
            Self::N100000073683 => "100000073683",
            Self::N100000073684 => "100000073684",
            Self::N100000073685 => "100000073685",
            Self::N100000073686 => "100000073686",
            Self::N100000073687 => "100000073687",
            Self::N100000073688 => "100000073688",
            Self::N100000073689 => "100000073689",
            Self::N100000073690 => "100000073690",
            Self::N100000073691 => "100000073691",
            Self::N100000073692 => "100000073692",
            Self::N100000073693 => "100000073693",
            Self::N100000073694 => "100000073694",
            Self::N100000073695 => "100000073695",
            Self::N100000073696 => "100000073696",
            Self::N100000073697 => "100000073697",
            Self::N100000073698 => "100000073698",
            Self::N100000073699 => "100000073699",
            Self::N100000073700 => "100000073700",
            Self::N100000073701 => "100000073701",
            Self::N100000073702 => "100000073702",
            Self::N100000073703 => "100000073703",
            Self::N100000073704 => "100000073704",
            Self::N100000073705 => "100000073705",
            Self::N100000073706 => "100000073706",
            Self::N100000073707 => "100000073707",
            Self::N100000073708 => "100000073708",
            Self::N100000073709 => "100000073709",
            Self::N100000073710 => "100000073710",
            Self::N100000073711 => "100000073711",
            Self::N100000073712 => "100000073712",
            Self::N100000073713 => "100000073713",
            Self::N100000073714 => "100000073714",
            Self::N100000073715 => "100000073715",
            Self::N100000073716 => "100000073716",
            Self::N100000073717 => "100000073717",
            Self::N100000073718 => "100000073718",
            Self::N100000073719 => "100000073719",
            Self::N100000073720 => "100000073720",
            Self::N100000073721 => "100000073721",
            Self::N100000073722 => "100000073722",
            Self::N100000073723 => "100000073723",
            Self::N100000073724 => "100000073724",
            Self::N100000073725 => "100000073725",
            Self::N100000073726 => "100000073726",
            Self::N100000073727 => "100000073727",
            Self::N100000073728 => "100000073728",
            Self::N100000073729 => "100000073729",
            Self::N100000073730 => "100000073730",
            Self::N100000073731 => "100000073731",
            Self::N100000073732 => "100000073732",
            Self::N100000073733 => "100000073733",
            Self::N100000073734 => "100000073734",
            Self::N100000073735 => "100000073735",
            Self::N100000073736 => "100000073736",
            Self::N100000073737 => "100000073737",
            Self::N100000073738 => "100000073738",
            Self::N100000073739 => "100000073739",
            Self::N100000073740 => "100000073740",
            Self::N100000073741 => "100000073741",
            Self::N100000073742 => "100000073742",
            Self::N100000073743 => "100000073743",
            Self::N100000073744 => "100000073744",
            Self::N100000073745 => "100000073745",
            Self::N100000073746 => "100000073746",
            Self::N100000073747 => "100000073747",
            Self::N100000073748 => "100000073748",
            Self::N100000073749 => "100000073749",
            Self::N100000073750 => "100000073750",
            Self::N100000073751 => "100000073751",
            Self::N100000073752 => "100000073752",
            Self::N100000073753 => "100000073753",
            Self::N100000073754 => "100000073754",
            Self::N100000073755 => "100000073755",
            Self::N100000073756 => "100000073756",
            Self::N100000073757 => "100000073757",
            Self::N100000073758 => "100000073758",
            Self::N100000073759 => "100000073759",
            Self::N100000073760 => "100000073760",
            Self::N100000073761 => "100000073761",
            Self::N100000073762 => "100000073762",
            Self::N100000073763 => "100000073763",
            Self::N100000073764 => "100000073764",
            Self::N100000073765 => "100000073765",
            Self::N100000073766 => "100000073766",
            Self::N100000073767 => "100000073767",
            Self::N100000073768 => "100000073768",
            Self::N100000073769 => "100000073769",
            Self::N100000073770 => "100000073770",
            Self::N100000073771 => "100000073771",
            Self::N100000073772 => "100000073772",
            Self::N100000073773 => "100000073773",
            Self::N100000073775 => "100000073775",
            Self::N100000073776 => "100000073776",
            Self::N100000073777 => "100000073777",
            Self::N100000073778 => "100000073778",
            Self::N100000073779 => "100000073779",
            Self::N100000073780 => "100000073780",
            Self::N100000073782 => "100000073782",
            Self::N100000073783 => "100000073783",
            Self::N100000073784 => "100000073784",
            Self::N100000073785 => "100000073785",
            Self::N100000073786 => "100000073786",
            Self::N100000073787 => "100000073787",
            Self::N100000073788 => "100000073788",
            Self::N100000073789 => "100000073789",
            Self::N100000073790 => "100000073790",
            Self::N100000073791 => "100000073791",
            Self::N100000073792 => "100000073792",
            Self::N100000073793 => "100000073793",
            Self::N100000073794 => "100000073794",
            Self::N100000073795 => "100000073795",
            Self::N100000073796 => "100000073796",
            Self::N100000073797 => "100000073797",
            Self::N100000073798 => "100000073798",
            Self::N100000073799 => "100000073799",
            Self::N100000073800 => "100000073800",
            Self::N100000073802 => "100000073802",
            Self::N100000073803 => "100000073803",
            Self::N100000073804 => "100000073804",
            Self::N100000073805 => "100000073805",
            Self::N100000073806 => "100000073806",
            Self::N100000073807 => "100000073807",
            Self::N100000073808 => "100000073808",
            Self::N100000073809 => "100000073809",
            Self::N100000073810 => "100000073810",
            Self::N100000073811 => "100000073811",
            Self::N100000073812 => "100000073812",
            Self::N100000073813 => "100000073813",
            Self::N100000073814 => "100000073814",
            Self::N100000073815 => "100000073815",
            Self::N100000073816 => "100000073816",
            Self::N100000073817 => "100000073817",
            Self::N100000073818 => "100000073818",
            Self::N100000073819 => "100000073819",
            Self::N100000073820 => "100000073820",
            Self::N100000073821 => "100000073821",
            Self::N100000073822 => "100000073822",
            Self::N100000073823 => "100000073823",
            Self::N100000073824 => "100000073824",
            Self::N100000073825 => "100000073825",
            Self::N100000073826 => "100000073826",
            Self::N100000073827 => "100000073827",
            Self::N100000073863 => "100000073863",
        }
    }
}
impl<'de> Deserialize<'de> for ManufacturedDoseForm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ManufacturedDoseForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureDataUsage`. The intended usage for supplemental data elements in the measure.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureDataUsage {
    /** # risk-adjustment-factor

Risk Adjustment Factor. The data is intended to be used to calculate and apply a risk adjustment model for the measure. */
    RiskAdjustmentFactor,
    /** # supplemental-data

Supplemental Data. The data is intended to be provided as additional information alongside the measure results. */
    SupplementalData,
}
impl ::core::str::FromStr for MeasureDataUsage {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "risk-adjustment-factor" => Ok(Self::RiskAdjustmentFactor),
            "supplemental-data" => Ok(Self::SupplementalData),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureDataUsage {
    fn as_ref(&self) -> &str {
        match self {
            Self::RiskAdjustmentFactor => "risk-adjustment-factor",
            Self::SupplementalData => "supplemental-data",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureDataUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureDataUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureGroupExample`. Example Measure Groups for the Measure Resource.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureGroupExample {
    /** # primary-rate

Primary Rate. Primary Measure Group. */
    PrimaryRate,
    /** # secondary-rate

Secondary Rate. Secondary Measure Group */
    SecondaryRate,
}
impl ::core::str::FromStr for MeasureGroupExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "primary-rate" => Ok(Self::PrimaryRate),
            "secondary-rate" => Ok(Self::SecondaryRate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureGroupExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::PrimaryRate => "primary-rate",
            Self::SecondaryRate => "secondary-rate",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureGroupExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureGroupExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureImprovementNotation`. Observation values that indicate what change in a measurement value or score is indicative of an improvement in the measured item or scored issue.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureImprovementNotation {
    /** # decrease

Decreased score indicates improvement. Improvement is indicated as a decrease in the score or measurement (e.g. Lower score indicates better quality). */
    Decrease,
    /** # increase

Increased score indicates improvement. Improvement is indicated as an increase in the score or measurement (e.g. Higher score indicates better quality). */
    Increase,
}
impl ::core::str::FromStr for MeasureImprovementNotation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "decrease" => Ok(Self::Decrease),
            "increase" => Ok(Self::Increase),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureImprovementNotation {
    fn as_ref(&self) -> &str {
        match self {
            Self::Decrease => "decrease",
            Self::Increase => "increase",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureImprovementNotation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureImprovementNotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasurePopulationType`. The type of population.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasurePopulationType {
    /** # denominator

Denominator. The lower portion of a fraction used to calculate a rate, proportion, or ratio. The denominator can be the same as the initial population, or a subset of the initial population to further constrain the population for the purpose of the measure. */
    Denominator,
    /** # denominator-exception

Denominator Exception. Denominator exceptions are conditions that should remove a patient or event from the denominator of a measure only if the numerator criteria are not met. Denominator exception allows for adjustment of the calculated score for those providers with higher risk populations. Denominator exception criteria are only used in proportion measures. */
    DenominatorException,
    /** # denominator-exclusion

Denominator Exclusion. Denominator exclusion criteria define patients or events that should be removed from the denominator before determining if numerator criteria are met. Denominator exclusions are used in proportion and ratio measures to help narrow the denominator. For example, patients with bilateral lower extremity amputations would be listed as a denominator exclusion for a measure requiring foot exams. */
    DenominatorExclusion,
    /** # initial-population

Initial Population. The initial population refers to all patients or events to be evaluated by a quality measure involving patients who share a common set of specified characterstics. All patients or events counted (for example, as numerator, as denominator) are drawn from the initial population. */
    InitialPopulation,
    /** # measure-observation

Measure Observation. Defines the individual observation to be performed for each patient or event in the measure population. Measure observations for each case in the population are aggregated to determine the overall measure score for the population. */
    MeasureObservation,
    /** # measure-population

Measure Population. Measure population criteria define the patients or events for which the individual observation for the measure should be taken. Measure populations are used for continuous variable measures rather than numerator and denominator criteria. */
    MeasurePopulation,
    /** # measure-population-exclusion

Measure Population Exclusion. Measure population criteria define the patients or events that should be removed from the measure population before determining the outcome of one or more continuous variables defined for the measure observation. Measure population exclusion criteria are used within continuous variable measures to help narrow the measure population. */
    MeasurePopulationExclusion,
    /** # numerator

Numerator. The upper portion of a fraction used to calculate a rate, proportion, or ratio. Also called the measure focus, it is the target process, condition, event, or outcome. Numerator criteria are the processes or outcomes expected for each patient, or event defined in the denominator. A numerator statement describes the clinical action that satisfies the conditions of the measure. */
    Numerator,
    /** # numerator-exclusion

Numerator Exclusion. Numerator exclusion criteria define patients or events to be removed from the numerator. Numerator exclusions are used in proportion and ratio measures to help narrow the numerator (for inverted measures). */
    NumeratorExclusion,
}
impl ::core::str::FromStr for MeasurePopulationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "denominator" => Ok(Self::Denominator),
            "denominator-exception" => Ok(Self::DenominatorException),
            "denominator-exclusion" => Ok(Self::DenominatorExclusion),
            "initial-population" => Ok(Self::InitialPopulation),
            "measure-observation" => Ok(Self::MeasureObservation),
            "measure-population" => Ok(Self::MeasurePopulation),
            "measure-population-exclusion" => Ok(Self::MeasurePopulationExclusion),
            "numerator" => Ok(Self::Numerator),
            "numerator-exclusion" => Ok(Self::NumeratorExclusion),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasurePopulationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Denominator => "denominator",
            Self::DenominatorException => "denominator-exception",
            Self::DenominatorExclusion => "denominator-exclusion",
            Self::InitialPopulation => "initial-population",
            Self::MeasureObservation => "measure-observation",
            Self::MeasurePopulation => "measure-population",
            Self::MeasurePopulationExclusion => "measure-population-exclusion",
            Self::Numerator => "numerator",
            Self::NumeratorExclusion => "numerator-exclusion",
        }
    }
}
impl<'de> Deserialize<'de> for MeasurePopulationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasurePopulationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureReportStatus`. The status of the measure report.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureReportStatus {
    /** # complete

Complete. The report is complete and ready for use. */
    Complete,
    /** # error

Error. An error occurred attempting to generate the report. */
    Error,
    /** # pending

Pending. The report is currently being generated. */
    Pending,
}
impl ::core::str::FromStr for MeasureReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "error" => Ok(Self::Error),
            "pending" => Ok(Self::Pending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Error => "error",
            Self::Pending => "pending",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureReportStratifierValueExample`. Example Region Value Measure Groups for the Measure Resource.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureReportStratifierValueExample {
    /** # northeast

Northeast. Northeast region stratification. */
    Northeast,
    /** # northwest

Northwest. Northwest region stratification. */
    Northwest,
    /** # southeast

Southeast. Southeast region stratification. */
    Southeast,
    /** # southwest

Soutwest. Soutwest region stratification. */
    Southwest,
}
impl ::core::str::FromStr for MeasureReportStratifierValueExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "northeast" => Ok(Self::Northeast),
            "northwest" => Ok(Self::Northwest),
            "southeast" => Ok(Self::Southeast),
            "southwest" => Ok(Self::Southwest),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportStratifierValueExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Northeast => "northeast",
            Self::Northwest => "northwest",
            Self::Southeast => "southeast",
            Self::Southwest => "southwest",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureReportStratifierValueExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportStratifierValueExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureReportType`. The type of the measure report.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureReportType {
    /** # data-collection

Data Collection. A data collection report that contains data-of-interest for the measure. */
    DataCollection,
    /** # individual

Individual. An individual report that provides information on the performance for a given measure with respect to a single subject. */
    Individual,
    /** # subject-list

Subject List. A subject list report that includes a listing of subjects that satisfied each population criteria in the measure. */
    SubjectList,
    /** # summary

Summary. A summary report that returns the number of members in each population criteria for the measure. */
    Summary,
}
impl ::core::str::FromStr for MeasureReportType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-collection" => Ok(Self::DataCollection),
            "individual" => Ok(Self::Individual),
            "subject-list" => Ok(Self::SubjectList),
            "summary" => Ok(Self::Summary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureReportType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataCollection => "data-collection",
            Self::Individual => "individual",
            Self::SubjectList => "subject-list",
            Self::Summary => "summary",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureReportType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureReportType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureScoring`. The scoring type of the measure.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureScoring {
    /** # cohort

Cohort. The measure is a cohort definition. */
    Cohort,
    /** # continuous-variable

Continuous Variable. The score is defined by a calculation of some quantity. */
    ContinuousVariable,
    /** # proportion

Proportion. The measure score is defined using a proportion. */
    Proportion,
    /** # ratio

Ratio. The measure score is defined using a ratio. */
    Ratio,
}
impl ::core::str::FromStr for MeasureScoring {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cohort" => Ok(Self::Cohort),
            "continuous-variable" => Ok(Self::ContinuousVariable),
            "proportion" => Ok(Self::Proportion),
            "ratio" => Ok(Self::Ratio),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureScoring {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cohort => "cohort",
            Self::ContinuousVariable => "continuous-variable",
            Self::Proportion => "proportion",
            Self::Ratio => "ratio",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureScoring {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureScoring {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureStratifierExample`. Identifier subgroups in a population for measuring purposes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureStratifierExample {
    /** # age

Age. Age Stratification. */
    Age,
    /** # gender

Gender. Gender Stratification. */
    Gender,
    /** # region

Region. Region Stratification. */
    Region,
}
impl ::core::str::FromStr for MeasureStratifierExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "age" => Ok(Self::Age),
            "gender" => Ok(Self::Gender),
            "region" => Ok(Self::Region),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureStratifierExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Age => "age",
            Self::Gender => "gender",
            Self::Region => "region",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureStratifierExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureStratifierExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureSupplementalDataExample`. Identifier supplemental data in a population for measuring purposes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureSupplementalDataExample {
    /** # age

Age. Age Supplemental Data. */
    Age,
    /** # ethnicity

Ethnicity. Ethnicity Supplemental Data . */
    Ethnicity,
    /** # gender

Gender. Gender Supplemental Data . */
    Gender,
    /** # payer

Payer. Payer Supplemental Data. */
    Payer,
}
impl ::core::str::FromStr for MeasureSupplementalDataExample {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "age" => Ok(Self::Age),
            "ethnicity" => Ok(Self::Ethnicity),
            "gender" => Ok(Self::Gender),
            "payer" => Ok(Self::Payer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureSupplementalDataExample {
    fn as_ref(&self) -> &str {
        match self {
            Self::Age => "age",
            Self::Ethnicity => "ethnicity",
            Self::Gender => "gender",
            Self::Payer => "payer",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureSupplementalDataExample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureSupplementalDataExample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MeasureType`. The type of measure (includes codes from 2.16.840.1.113883.1.11.20368).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MeasureType {
    /** # composite

Composite. A measure that combines multiple component measures in to a single quality measure. */
    Composite,
    /** # outcome

Outcome. A measure that indicates the result of the performance (or non-performance) of a function or process. */
    Outcome,
    /** # patient-reported-outcome

Patient Reported Outcome. A measure that focuses on patient-reported information such as patient engagement or patient experience measures. */
    PatientReportedOutcome,
    /** # process

Process. A measure which focuses on a process which leads to a certain outcome, meaning that a scientific basis exists for believing that the process, when executed well, will increase the probability of achieving a desired outcome. */
    Process,
    /** # structure

Structure. A measure that focuses on a health care provider's capacity, systems, and processes to provide high-quality care. */
    Structure,
}
impl ::core::str::FromStr for MeasureType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "composite" => Ok(Self::Composite),
            "outcome" => Ok(Self::Outcome),
            "patient-reported-outcome" => Ok(Self::PatientReportedOutcome),
            "process" => Ok(Self::Process),
            "structure" => Ok(Self::Structure),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MeasureType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Composite => "composite",
            Self::Outcome => "outcome",
            Self::PatientReportedOutcome => "patient-reported-outcome",
            Self::Process => "process",
            Self::Structure => "structure",
        }
    }
}
impl<'de> Deserialize<'de> for MeasureType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MeasureType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MediaSubType`. Detailed information about the type of the image - its kind, purpose, or the kind of equipment used to generate it.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MediaSubType {
    /** # diagram

Diagram. A diagram. Often used in diagnostic reports */
    Diagram,
    /** # face

Face Scan. A face scan used for identification purposes */
    Face,
    /** # fax

Fax. A digital record of a fax document */
    Fax,
    /** # fingerprint

Fingerprint. A finger print scan used for identification purposes */
    Fingerprint,
    /** # iris

Iris Scan. An iris scan used for identification purposes */
    Iris,
    /** # palm

Palm Scan. A palm scan used for identification purposes */
    Palm,
    /** # retina

Retina Scan. A retinal image used for identification purposes */
    Retina,
    /** # scan

Scanned Document. A digital scan of a document. This is reserved for when there is not enough metadata to create a document reference */
    Scan,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for MediaSubType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "diagram" => Ok(Self::Diagram),
            "face" => Ok(Self::Face),
            "fax" => Ok(Self::Fax),
            "fingerprint" => Ok(Self::Fingerprint),
            "iris" => Ok(Self::Iris),
            "palm" => Ok(Self::Palm),
            "retina" => Ok(Self::Retina),
            "scan" => Ok(Self::Scan),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for MediaSubType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Diagram => "diagram",
            Self::Face => "face",
            Self::Fax => "fax",
            Self::Fingerprint => "fingerprint",
            Self::Iris => "iris",
            Self::Palm => "palm",
            Self::Retina => "retina",
            Self::Scan => "scan",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for MediaSubType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MediaSubType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MedicinalProductDomain`. Applicable domain for this product (e.g. human, veterinary).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicinalProductDomain {
    /** # Human

Human use. Product intended for use with humans */
    Human,
    /** # HumanAndVeterinary

Human and Veterinary use. Product intended for use with both humans and animals */
    HumanAndVeterinary,
    /** # Veterinary

Veterinary use. Product intended for use with animals */
    Veterinary,
}
impl ::core::str::FromStr for MedicinalProductDomain {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Human" => Ok(Self::Human),
            "HumanAndVeterinary" => Ok(Self::HumanAndVeterinary),
            "Veterinary" => Ok(Self::Veterinary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicinalProductDomain {
    fn as_ref(&self) -> &str {
        match self {
            Self::Human => "Human",
            Self::HumanAndVeterinary => "HumanAndVeterinary",
            Self::Veterinary => "Veterinary",
        }
    }
}
impl<'de> Deserialize<'de> for MedicinalProductDomain {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicinalProductDomain {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MedicinalProductPackageType`. Types of medicinal product packs

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicinalProductPackageType {
    /** # 100000073490

Ampoule. */
    N100000073490,
    /** # 100000073491

Applicator. */
    N100000073491,
    /** # 100000073492

Automatic injection device. */
    N100000073492,
    /** # 100000073493

Bag. */
    N100000073493,
    /** # 100000073494

Balling gun. */
    N100000073494,
    /** # 100000073495

Barrel. */
    N100000073495,
    /** # 100000073496

Blister. */
    N100000073496,
    /** # 100000073497

Bottle. */
    N100000073497,
    /** # 100000073498

Box. */
    N100000073498,
    /** # 100000073547

Sachet. */
    N100000073547,
    /** # 100000073563

Vial. */
    N100000073563,
    /** # 100000143555

Pack. */
    N100000143555,
}
impl ::core::str::FromStr for MedicinalProductPackageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073490" => Ok(Self::N100000073490),
            "100000073491" => Ok(Self::N100000073491),
            "100000073492" => Ok(Self::N100000073492),
            "100000073493" => Ok(Self::N100000073493),
            "100000073494" => Ok(Self::N100000073494),
            "100000073495" => Ok(Self::N100000073495),
            "100000073496" => Ok(Self::N100000073496),
            "100000073497" => Ok(Self::N100000073497),
            "100000073498" => Ok(Self::N100000073498),
            "100000073547" => Ok(Self::N100000073547),
            "100000073563" => Ok(Self::N100000073563),
            "100000143555" => Ok(Self::N100000143555),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicinalProductPackageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073490 => "100000073490",
            Self::N100000073491 => "100000073491",
            Self::N100000073492 => "100000073492",
            Self::N100000073493 => "100000073493",
            Self::N100000073494 => "100000073494",
            Self::N100000073495 => "100000073495",
            Self::N100000073496 => "100000073496",
            Self::N100000073497 => "100000073497",
            Self::N100000073498 => "100000073498",
            Self::N100000073547 => "100000073547",
            Self::N100000073563 => "100000073563",
            Self::N100000143555 => "100000143555",
        }
    }
}
impl<'de> Deserialize<'de> for MedicinalProductPackageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicinalProductPackageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MedicinalProductType`. Overall defining type of this Medicinal Product.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MedicinalProductType {
    /** # InvestigationalProduct

Investigational Medicinal Product. An investigational medicinal product. */
    InvestigationalProduct,
    /** # MedicinalProduct

Medicinal Product. A standard medicinal product. */
    MedicinalProduct,
}
impl ::core::str::FromStr for MedicinalProductType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "InvestigationalProduct" => Ok(Self::InvestigationalProduct),
            "MedicinalProduct" => Ok(Self::MedicinalProduct),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MedicinalProductType {
    fn as_ref(&self) -> &str {
        match self {
            Self::InvestigationalProduct => "InvestigationalProduct",
            Self::MedicinalProduct => "MedicinalProduct",
        }
    }
}
impl<'de> Deserialize<'de> for MedicinalProductType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MedicinalProductType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MessageEvent`. One of the message events defined as part of this version of FHIR.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MessageEvent {
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for MessageEvent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for MessageEvent {
    fn as_ref(&self) -> &str {
        match self {
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for MessageEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MessageSignificanceCategory`. The impact of the content of a message.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MessageSignificanceCategory {
    /** # consequence

Consequence. The message represents/requests a change that should not be processed more than once; e.g., making a booking for an appointment. */
    Consequence,
    /** # currency

Currency. The message represents a response to query for current information. Retrospective processing is wrong and/or wasteful. */
    Currency,
    /** # notification

Notification. The content is not necessarily intended to be current, and it can be reprocessed, though there may be version issues created by processing old notifications. */
    Notification,
}
impl ::core::str::FromStr for MessageSignificanceCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "consequence" => Ok(Self::Consequence),
            "currency" => Ok(Self::Currency),
            "notification" => Ok(Self::Notification),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageSignificanceCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Consequence => "consequence",
            Self::Currency => "currency",
            Self::Notification => "notification",
        }
    }
}
impl<'de> Deserialize<'de> for MessageSignificanceCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageSignificanceCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MessageTransport`. The protocol used for message transport.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum MessageTransport {
    /** # ftp

FTP. The application sends or receives messages using File Transfer Protocol. */
    Ftp,
    /** # http

HTTP. The application sends or receives messages using HTTP POST (may be over http: or https:). */
    Http,
    /** # mllp

MLLP. The application sends or receives messages using HL7's Minimal Lower Level Protocol. */
    Mllp,
}
impl ::core::str::FromStr for MessageTransport {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ftp" => Ok(Self::Ftp),
            "http" => Ok(Self::Http),
            "mllp" => Ok(Self::Mllp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for MessageTransport {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ftp => "ftp",
            Self::Http => "http",
            Self::Mllp => "mllp",
        }
    }
}
impl<'de> Deserialize<'de> for MessageTransport {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MessageTransport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `MissingToothReasonCodes`. This value set includes sample Missing Tooth Reason codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MissingToothReasonCodes {
    /** # c

C. Congenital */
    C,
    /** # e

E. Extraction */
    E,
    /** # o

O. Other */
    O,
    /** # u

U. Unknown */
    U,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for MissingToothReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "c" => Ok(Self::C),
            "e" => Ok(Self::E),
            "o" => Ok(Self::O),
            "u" => Ok(Self::U),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for MissingToothReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::C => "c",
            Self::E => "e",
            Self::O => "o",
            Self::U => "u",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for MissingToothReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for MissingToothReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ModifierTypeCodes`. This value set includes sample Modifier type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ModifierTypeCodes {
    /** # a

Repair of prior service or installation. Repair of prior service or installation. */
    A,
    /** # b

Temporary service or installation. Temporary service or installation. */
    B,
    /** # c

TMJ treatment. Treatment associated with TMJ. */
    C,
    /** # e

Implant or associated with an implant. Implant or associated with an implant. */
    E,
    /** # rooh

Rush or Outside of office hours. A Rush service or service performed outside of normal office hours. */
    Rooh,
    /** # x

None. None. */
    X,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ModifierTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a" => Ok(Self::A),
            "b" => Ok(Self::B),
            "c" => Ok(Self::C),
            "e" => Ok(Self::E),
            "rooh" => Ok(Self::Rooh),
            "x" => Ok(Self::X),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ModifierTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::A => "a",
            Self::B => "b",
            Self::C => "c",
            Self::E => "e",
            Self::Rooh => "rooh",
            Self::X => "x",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ModifierTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ModifierTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `NameUse`. The use of a human name.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NameUse {
    /** # anonymous

Anonymous. Anonymous assigned name, alias, or pseudonym (used to protect a person's identity for privacy reasons). */
    Anonymous,
    /** # maiden

Name changed for Marriage. A name used prior to changing name because of marriage. This name use is for use by applications that collect and store names that were used prior to a marriage. Marriage naming customs vary greatly around the world, and are constantly changing. This term is not gender specific. The use of this term does not imply any particular history for a person's name. */
    Maiden,
    /** # nickname

Nickname. A name that is used to address the person in an informal manner, but is not part of their formal or usual name. */
    Nickname,
    /** # official

Official. The formal name as registered in an official (government) registry, but which name might not be commonly used. May be called "legal name". */
    Official,
    /** # old

Old. This name is no longer in use (or was never correct, but retained for records). */
    Old,
    /** # temp

Temp. A temporary name. Name.period can provide more detailed information. This may also be used for temporary names assigned at birth or in emergency situations. */
    Temp,
    /** # usual

Usual. Known as/conventional/the one you normally use. */
    Usual,
}
impl ::core::str::FromStr for NameUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "anonymous" => Ok(Self::Anonymous),
            "maiden" => Ok(Self::Maiden),
            "nickname" => Ok(Self::Nickname),
            "official" => Ok(Self::Official),
            "old" => Ok(Self::Old),
            "temp" => Ok(Self::Temp),
            "usual" => Ok(Self::Usual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NameUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Anonymous => "anonymous",
            Self::Maiden => "maiden",
            Self::Nickname => "nickname",
            Self::Official => "official",
            Self::Old => "old",
            Self::Temp => "temp",
            Self::Usual => "usual",
        }
    }
}
impl<'de> Deserialize<'de> for NameUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NameUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `NamingSystemIdentifierType`. Identifies the style of unique identifier used to identify a namespace.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NamingSystemIdentifierType {
    /** # oid

OID. An ISO object identifier; e.g. 1.2.3.4.5. */
    Oid,
    /** # other

Other. Some other type of unique identifier; e.g. HL7-assigned reserved string such as LN for LOINC. */
    Other,
    /** # uri

URI. A uniform resource identifier (ideally a URL - uniform resource locator); e.g. http://unitsofmeasure.org. */
    Uri,
    /** # uuid

UUID. A universally unique identifier of the form a5afddf4-e880-459b-876e-e4591b0acc11. */
    Uuid,
}
impl ::core::str::FromStr for NamingSystemIdentifierType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "oid" => Ok(Self::Oid),
            "other" => Ok(Self::Other),
            "uri" => Ok(Self::Uri),
            "uuid" => Ok(Self::Uuid),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NamingSystemIdentifierType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Oid => "oid",
            Self::Other => "other",
            Self::Uri => "uri",
            Self::Uuid => "uuid",
        }
    }
}
impl<'de> Deserialize<'de> for NamingSystemIdentifierType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NamingSystemIdentifierType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `NamingSystemType`. Identifies the purpose of the naming system.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NamingSystemType {
    /** # codesystem

Code System. The naming system is used to define concepts and symbols to represent those concepts; e.g. UCUM, LOINC, NDC code, local lab codes, etc. */
    Codesystem,
    /** # identifier

Identifier. The naming system is used to manage identifiers (e.g. license numbers, order numbers, etc.). */
    Identifier,
    /** # root

Root. The naming system is used as the root for other identifiers and naming systems. */
    Root,
}
impl ::core::str::FromStr for NamingSystemType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "codesystem" => Ok(Self::Codesystem),
            "identifier" => Ok(Self::Identifier),
            "root" => Ok(Self::Root),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NamingSystemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Codesystem => "codesystem",
            Self::Identifier => "identifier",
            Self::Root => "root",
        }
    }
}
impl<'de> Deserialize<'de> for NamingSystemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NamingSystemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `NarrativeStatus`. The status of a resource narrative.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NarrativeStatus {
    /** # additional

Additional. The contents of the narrative may contain additional information not found in the structured data. Note that there is no computable way to determine what the extra information is, other than by human inspection. */
    Additional,
    /** # empty

Empty. The contents of the narrative are some equivalent of "No human-readable text provided in this case". */
    Empty,
    /** # extensions

Extensions. The contents of the narrative are entirely generated from the core elements in the content and some of the content is generated from extensions. The narrative SHALL reflect the impact of all modifier extensions. */
    Extensions,
    /** # generated

Generated. The contents of the narrative are entirely generated from the core elements in the content. */
    Generated,
}
impl ::core::str::FromStr for NarrativeStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "additional" => Ok(Self::Additional),
            "empty" => Ok(Self::Empty),
            "extensions" => Ok(Self::Extensions),
            "generated" => Ok(Self::Generated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NarrativeStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Additional => "additional",
            Self::Empty => "empty",
            Self::Extensions => "extensions",
            Self::Generated => "generated",
        }
    }
}
impl<'de> Deserialize<'de> for NarrativeStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NarrativeStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `NetworkTypeCodes`. This value set includes a smattering of Network type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum NetworkTypeCodes {
    /** # in

In Network. Services rendered by a Network provider */
    In,
    /** # out

Out of Network. Services rendered by a provider who is not in the Network */
    Out,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for NetworkTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for NetworkTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::In => "in",
            Self::Out => "out",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for NetworkTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NetworkTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `NoteType`. The presentation types of notes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NoteType {
    /** # display

Display. Display the note. */
    Display,
    /** # print

Print (Form). Print the note on the form. */
    Print,
    /** # printoper

Print (Operator). Print the note for the operator. */
    Printoper,
}
impl ::core::str::FromStr for NoteType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "display" => Ok(Self::Display),
            "print" => Ok(Self::Print),
            "printoper" => Ok(Self::Printoper),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NoteType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Display => "display",
            Self::Print => "print",
            Self::Printoper => "printoper",
        }
    }
}
impl<'de> Deserialize<'de> for NoteType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NoteType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `NutritionProductStatus`. Codes identifying the lifecycle stage of a product.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum NutritionProductStatus {
    /** # active

Active. The product can be used. */
    Active,
    /** # entered-in-error

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** # inactive

Inactive. The product is not expected or allowed to be used. */
    Inactive,
}
impl ::core::str::FromStr for NutritionProductStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "entered-in-error" => Ok(Self::EnteredInError),
            "inactive" => Ok(Self::Inactive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for NutritionProductStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::EnteredInError => "entered-in-error",
            Self::Inactive => "inactive",
        }
    }
}
impl<'de> Deserialize<'de> for NutritionProductStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for NutritionProductStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ObservationCategoryCodes`. Observation Category codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ObservationCategoryCodes {
    /** # activity

Activity. Observations that measure or record any bodily activity that enhances or maintains physical fitness and overall health and wellness.  Not under direct supervision of practitioner such as a physical therapist. (e.g., laps swum, steps, sleep data) */
    Activity,
    /** # exam

Exam. Observations generated by physical exam findings including direct observations made by a clinician and use of simple instruments and the result of simple maneuvers performed directly on the patient's body. */
    Exam,
    /** # imaging

Imaging. Observations generated by imaging. The scope includes observations regarding plain x-ray, ultrasound, CT, MRI, angiography, echocardiography, and nuclear medicine. */
    Imaging,
    /** # laboratory

Laboratory. The results of observations generated by laboratories.  Laboratory results are typically generated by laboratories providing analytic services in areas such as chemistry, hematology, serology, histology, cytology, anatomic pathology (including digital pathology), microbiology, and/or virology. These observations are based on analysis of specimens obtained from the patient and submitted to the laboratory. */
    Laboratory,
    /** # procedure

Procedure. Observations generated by other procedures.  This category includes observations resulting from interventional and non-interventional procedures excluding laboratory and imaging (e.g., cardiology catheterization, endoscopy, electrodiagnostics, etc.).  Procedure results are typically generated by a clinician to provide more granular information about component observations made during a procedure.  An example would be when a gastroenterologist reports the size of a polyp observed during a colonoscopy. */
    Procedure,
    /** # social-history

Social History. Social History Observations define the patient's occupational, personal (e.g., lifestyle), social, familial, and environmental history and health risk factors that may impact the patient's health. */
    SocialHistory,
    /** # survey

Survey. Assessment tool/survey instrument observations (e.g., Apgar Scores, Montreal Cognitive Assessment (MoCA)). */
    Survey,
    /** # therapy

Therapy. Observations generated by non-interventional treatment protocols (e.g. occupational, physical, radiation, nutritional and medication therapy) */
    Therapy,
    /** # vital-signs

Vital Signs.  Clinical observations measure the body's basic functions such as blood pressure, heart rate, respiratory rate, height, weight, body mass index, head circumference, pulse oximetry, temperature, and body surface area. */
    VitalSigns,
}
impl ::core::str::FromStr for ObservationCategoryCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "activity" => Ok(Self::Activity),
            "exam" => Ok(Self::Exam),
            "imaging" => Ok(Self::Imaging),
            "laboratory" => Ok(Self::Laboratory),
            "procedure" => Ok(Self::Procedure),
            "social-history" => Ok(Self::SocialHistory),
            "survey" => Ok(Self::Survey),
            "therapy" => Ok(Self::Therapy),
            "vital-signs" => Ok(Self::VitalSigns),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationCategoryCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Activity => "activity",
            Self::Exam => "exam",
            Self::Imaging => "imaging",
            Self::Laboratory => "laboratory",
            Self::Procedure => "procedure",
            Self::SocialHistory => "social-history",
            Self::Survey => "survey",
            Self::Therapy => "therapy",
            Self::VitalSigns => "vital-signs",
        }
    }
}
impl<'de> Deserialize<'de> for ObservationCategoryCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationCategoryCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ObservationDataType`. Permitted data type for observation value.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ObservationDataType {
    /** # CodeableConcept

CodeableConcept. A coded concept from a reference terminology and/or text. */
    CodeableConcept,
    /** # Period

Period. A time range defined by start and end date/time. */
    Period,
    /** # Quantity

Quantity. A measured amount. */
    Quantity,
    /** # Range

Range. A set of values bounded by low and high. */
    Range,
    /** # Ratio

Ratio. A ratio of two Quantity values - a numerator and a denominator. */
    Ratio,
    /** # SampledData

SampledData. A series of measurements taken by a device. */
    SampledData,
    /** # boolean

boolean. true or false. */
    Boolean,
    /** # dateTime

dateTime. A date, date-time or partial date (e.g. just year or year + month) as used in human communication. */
    DateTime,
    /** # integer

integer. A signed integer. */
    Integer,
    /** # string

string. A sequence of Unicode characters. */
    String,
    /** # time

time. A time during the day, in the format hh:mm:ss. */
    Time,
}
impl ::core::str::FromStr for ObservationDataType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CodeableConcept" => Ok(Self::CodeableConcept),
            "Period" => Ok(Self::Period),
            "Quantity" => Ok(Self::Quantity),
            "Range" => Ok(Self::Range),
            "Ratio" => Ok(Self::Ratio),
            "SampledData" => Ok(Self::SampledData),
            "boolean" => Ok(Self::Boolean),
            "dateTime" => Ok(Self::DateTime),
            "integer" => Ok(Self::Integer),
            "string" => Ok(Self::String),
            "time" => Ok(Self::Time),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationDataType {
    fn as_ref(&self) -> &str {
        match self {
            Self::CodeableConcept => "CodeableConcept",
            Self::Period => "Period",
            Self::Quantity => "Quantity",
            Self::Range => "Range",
            Self::Ratio => "Ratio",
            Self::SampledData => "SampledData",
            Self::Boolean => "boolean",
            Self::DateTime => "dateTime",
            Self::Integer => "integer",
            Self::String => "string",
            Self::Time => "time",
        }
    }
}
impl<'de> Deserialize<'de> for ObservationDataType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationDataType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ObservationRangeCategory`. Codes identifying the category of observation range.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ObservationRangeCategory {
    /** # absolute

absolute range. Absolute Range for Ordinal and Continuous Observations. Results outside this range are not possible. */
    Absolute,
    /** # critical

critical range. Critical Range for Ordinal and Continuous Observations. */
    Critical,
    /** # reference

reference range. Reference (Normal) Range for Ordinal and Continuous Observations. */
    Reference,
}
impl ::core::str::FromStr for ObservationRangeCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "absolute" => Ok(Self::Absolute),
            "critical" => Ok(Self::Critical),
            "reference" => Ok(Self::Reference),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationRangeCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Absolute => "absolute",
            Self::Critical => "critical",
            Self::Reference => "reference",
        }
    }
}
impl<'de> Deserialize<'de> for ObservationRangeCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationRangeCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ObservationReferenceRangeMeaningCodes`. This value set defines a set of codes that can be used to indicate the meaning/use of a reference range.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ObservationReferenceRangeMeaningCodes {
    /** # endocrine

Endocrine. Endocrine related states that change the expected value. */
    Endocrine,
    /** # follicular

Follicular Stage. An expected range in an individual during the follicular stage of the cycle. */
    Follicular,
    /** # luteal

Luteal. An expected range in an individual during the luteal stage of the cycle. */
    Luteal,
    /** # midcycle

MidCycle. An expected range in an individual during the midcycle stage of the cycle. */
    Midcycle,
    /** # normal

Normal Range. Values expected for a normal member of the relevant control population being measured. Typically each results producer such as a laboratory has specific normal ranges and they are usually defined as within two standard deviations from the mean and account for 95.45% of this population. */
    Normal,
    /** # post

Post Therapeutic Desired Level. The optimal range for best therapeutic outcomes for a specimen taken immediately after administration. */
    Post,
    /** # postmenopausal

Post-Menopause. An expected range in an individual post-menopause. */
    Postmenopausal,
    /** # pre

Pre Therapeutic Desired Level. The optimal range for best therapeutic outcomes for a specimen taken immediately before administration. */
    Pre,
    /** # pre-puberty

Pre-Puberty. An expected range in an individual prior to puberty. */
    PrePuberty,
    /** # recommended

Recommended Range. The range that is recommended by a relevant professional body. */
    Recommended,
    /** # therapeutic

Therapeutic Desired Level. The optimal range for best therapeutic outcomes. */
    Therapeutic,
    /** # treatment

Treatment Range. The range at which treatment would/should be considered. */
    Treatment,
    /** # type

Type. General types of reference range. */
    Type,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ObservationReferenceRangeMeaningCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "endocrine" => Ok(Self::Endocrine),
            "follicular" => Ok(Self::Follicular),
            "luteal" => Ok(Self::Luteal),
            "midcycle" => Ok(Self::Midcycle),
            "normal" => Ok(Self::Normal),
            "post" => Ok(Self::Post),
            "postmenopausal" => Ok(Self::Postmenopausal),
            "pre" => Ok(Self::Pre),
            "pre-puberty" => Ok(Self::PrePuberty),
            "recommended" => Ok(Self::Recommended),
            "therapeutic" => Ok(Self::Therapeutic),
            "treatment" => Ok(Self::Treatment),
            "type" => Ok(Self::Type),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ObservationReferenceRangeMeaningCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Endocrine => "endocrine",
            Self::Follicular => "follicular",
            Self::Luteal => "luteal",
            Self::Midcycle => "midcycle",
            Self::Normal => "normal",
            Self::Post => "post",
            Self::Postmenopausal => "postmenopausal",
            Self::Pre => "pre",
            Self::PrePuberty => "pre-puberty",
            Self::Recommended => "recommended",
            Self::Therapeutic => "therapeutic",
            Self::Treatment => "treatment",
            Self::Type => "type",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ObservationReferenceRangeMeaningCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationReferenceRangeMeaningCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ObservationStatus`. Codes providing the status of an observation.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ObservationStatus {
    /** # amended

Amended. Subsequent to being Final, the observation has been modified subsequent.  This includes updates/new information and corrections. */
    Amended,
    /** # cancelled

Cancelled. The observation is unavailable because the measurement was not started or not completed (also sometimes called "aborted"). */
    Cancelled,
    /** # corrected

Corrected. Subsequent to being Final, the observation has been modified to correct an error in the test result. */
    Corrected,
    /** # entered-in-error

Entered in Error. The observation has been withdrawn following previous final release.  This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** # final

Final. The observation is complete and there are no further actions needed. Additional information such "released", "signed", etc would be represented using [Provenance](provenance.html) which provides not only the act but also the actors and dates and other related data. These act states would be associated with an observation status of `preliminary` until they are all completed and then a status of `final` would be applied. */
    Final,
    /** # preliminary

Preliminary. This is an initial or interim observation: data may be incomplete or unverified. */
    Preliminary,
    /** # registered

Registered. The existence of the observation is registered, but there is no result yet available. */
    Registered,
    /** # unknown

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for ObservationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "cancelled" => Ok(Self::Cancelled),
            "corrected" => Ok(Self::Corrected),
            "entered-in-error" => Ok(Self::EnteredInError),
            "final" => Ok(Self::Final),
            "preliminary" => Ok(Self::Preliminary),
            "registered" => Ok(Self::Registered),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ObservationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Cancelled => "cancelled",
            Self::Corrected => "corrected",
            Self::EnteredInError => "entered-in-error",
            Self::Final => "final",
            Self::Preliminary => "preliminary",
            Self::Registered => "registered",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for ObservationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ObservationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `OperationKind`. Whether an operation is a normal operation or a query.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum OperationKind {
    /** # operation

Operation. This operation is invoked as an operation. */
    Operation,
    /** # query

Query. This operation is a named query, invoked using the search mechanism. */
    Query,
}
impl ::core::str::FromStr for OperationKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "operation" => Ok(Self::Operation),
            "query" => Ok(Self::Query),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OperationKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::Operation => "operation",
            Self::Query => "query",
        }
    }
}
impl<'de> Deserialize<'de> for OperationKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `OperationParameterUse`. Whether an operation parameter is an input or an output parameter.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum OperationParameterUse {
    /** # in

In. This is an input parameter. */
    In,
    /** # out

Out. This is an output parameter. */
    Out,
}
impl ::core::str::FromStr for OperationParameterUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for OperationParameterUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::In => "in",
            Self::Out => "out",
        }
    }
}
impl<'de> Deserialize<'de> for OperationParameterUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OperationParameterUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `OralSiteCodes`. This value set includes a smattering of FDI oral site codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum OralSiteCodes {
    /** # 0

Oral cavity. Oral cavity. */
    N0,
    /** # 1

1. Permanent teeth Maxillary right. */
    N1,
    /** # 11

11. Upper Right Tooth 1 from the central axis, permanent dentition. */
    N11,
    /** # 12

12. Upper Right Tooth 2 from the central axis, permanent dentition. */
    N12,
    /** # 13

13. Upper Right Tooth 3 from the central axis, permanent dentition. */
    N13,
    /** # 14

14. Upper Right Tooth 4 from the central axis, permanent dentition. */
    N14,
    /** # 15

15. Upper Right Tooth 5 from the central axis, permanent dentition. */
    N15,
    /** # 16

16. Upper Right Tooth 6 from the central axis, permanent dentition. */
    N16,
    /** # 17

17. Upper Right Tooth 7 from the central axis, permanent dentition. */
    N17,
    /** # 18

18. Upper Right Tooth 8 from the central axis, permanent dentition. */
    N18,
    /** # 2

2. Permanent teeth Maxillary left. */
    N2,
    /** # 21

21. Upper Left Tooth 1 from the central axis, permanent dentition. */
    N21,
    /** # 22

22. Upper Left Tooth 2 from the central axis, permanent dentition. */
    N22,
    /** # 23

23. Upper Left Tooth 3 from the central axis, permanent dentition. */
    N23,
    /** # 24

24. Upper Left Tooth 4 from the central axis, permanent dentition. */
    N24,
    /** # 25

25. Upper Left Tooth 5 from the central axis, permanent dentition. */
    N25,
    /** # 26

26. Upper Left Tooth 6 from the central axis, permanent dentition. */
    N26,
    /** # 27

27. Upper Left Tooth 7 from the central axis, permanent dentition. */
    N27,
    /** # 28

28. Upper Left Tooth 8 from the central axis, permanent dentition. */
    N28,
    /** # 3

3. Permanent teeth Mandibular right. */
    N3,
    /** # 31

31. Lower Left Tooth 1 from the central axis, permanent dentition. */
    N31,
    /** # 32

32. Lower Left Tooth 2 from the central axis, permanent dentition. */
    N32,
    /** # 33

33. Lower Left Tooth 3 from the central axis, permanent dentition. */
    N33,
    /** # 34

34. Lower Left Tooth 4 from the central axis, permanent dentition. */
    N34,
    /** # 35

35. Lower Left Tooth 5 from the central axis, permanent dentition. */
    N35,
    /** # 36

36. Lower Left Tooth 6 from the central axis, permanent dentition. */
    N36,
    /** # 37

37. Lower Left Tooth 7 from the central axis, permanent dentition. */
    N37,
    /** # 38

38. Lower Left Tooth 8 from the central axis, permanent dentition. */
    N38,
    /** # 4

4. Permanent teeth Mandibular left. */
    N4,
    /** # 41

41. Lower Right Tooth 1 from the central axis, permanent dentition. */
    N41,
    /** # 42

42. Lower Right Tooth 2 from the central axis, permanent dentition. */
    N42,
    /** # 43

43. Lower Right Tooth 3 from the central axis, permanent dentition. */
    N43,
    /** # 44

44. Lower Right Tooth 4 from the central axis, permanent dentition. */
    N44,
    /** # 45

45. Lower Right Tooth 5 from the central axis, permanent dentition. */
    N45,
    /** # 46

46. Lower Right Tooth 6 from the central axis, permanent dentition. */
    N46,
    /** # 47

47. Lower Right Tooth 7 from the central axis, permanent dentition. */
    N47,
    /** # 48

48. Lower Right Tooth 8 from the central axis, permanent dentition. */
    N48,
    /** # 5

5. Deciduous teeth Maxillary right. */
    N5,
    /** # 6

6. Deciduous teeth Maxillary left. */
    N6,
    /** # 7

7. Deciduous teeth Mandibular right. */
    N7,
    /** # 8

8. Deciduous teeth Mandibular left. */
    N8,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for OralSiteCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0" => Ok(Self::N0),
            "1" => Ok(Self::N1),
            "11" => Ok(Self::N11),
            "12" => Ok(Self::N12),
            "13" => Ok(Self::N13),
            "14" => Ok(Self::N14),
            "15" => Ok(Self::N15),
            "16" => Ok(Self::N16),
            "17" => Ok(Self::N17),
            "18" => Ok(Self::N18),
            "2" => Ok(Self::N2),
            "21" => Ok(Self::N21),
            "22" => Ok(Self::N22),
            "23" => Ok(Self::N23),
            "24" => Ok(Self::N24),
            "25" => Ok(Self::N25),
            "26" => Ok(Self::N26),
            "27" => Ok(Self::N27),
            "28" => Ok(Self::N28),
            "3" => Ok(Self::N3),
            "31" => Ok(Self::N31),
            "32" => Ok(Self::N32),
            "33" => Ok(Self::N33),
            "34" => Ok(Self::N34),
            "35" => Ok(Self::N35),
            "36" => Ok(Self::N36),
            "37" => Ok(Self::N37),
            "38" => Ok(Self::N38),
            "4" => Ok(Self::N4),
            "41" => Ok(Self::N41),
            "42" => Ok(Self::N42),
            "43" => Ok(Self::N43),
            "44" => Ok(Self::N44),
            "45" => Ok(Self::N45),
            "46" => Ok(Self::N46),
            "47" => Ok(Self::N47),
            "48" => Ok(Self::N48),
            "5" => Ok(Self::N5),
            "6" => Ok(Self::N6),
            "7" => Ok(Self::N7),
            "8" => Ok(Self::N8),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for OralSiteCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0 => "0",
            Self::N1 => "1",
            Self::N11 => "11",
            Self::N12 => "12",
            Self::N13 => "13",
            Self::N14 => "14",
            Self::N15 => "15",
            Self::N16 => "16",
            Self::N17 => "17",
            Self::N18 => "18",
            Self::N2 => "2",
            Self::N21 => "21",
            Self::N22 => "22",
            Self::N23 => "23",
            Self::N24 => "24",
            Self::N25 => "25",
            Self::N26 => "26",
            Self::N27 => "27",
            Self::N28 => "28",
            Self::N3 => "3",
            Self::N31 => "31",
            Self::N32 => "32",
            Self::N33 => "33",
            Self::N34 => "34",
            Self::N35 => "35",
            Self::N36 => "36",
            Self::N37 => "37",
            Self::N38 => "38",
            Self::N4 => "4",
            Self::N41 => "41",
            Self::N42 => "42",
            Self::N43 => "43",
            Self::N44 => "44",
            Self::N45 => "45",
            Self::N46 => "46",
            Self::N47 => "47",
            Self::N48 => "48",
            Self::N5 => "5",
            Self::N6 => "6",
            Self::N7 => "7",
            Self::N8 => "8",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for OralSiteCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OralSiteCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `OrganizationAffiliationRole`. This example value set defines a set of codes that can be used to indicate the role of one Organization in relation to its affiliation with another.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum OrganizationAffiliationRole {
    /** # HIE/HIO

HIE/HIO. An organization that facilitates electronic clinical data exchange between entities */
    HieHio,
    /** # agency

Agency. An organization such as a public health agency, community/social services provider, etc. */
    Agency,
    /** # diagnostics

Diagnostics. An organization providing diagnostic testing/laboratory services */
    Diagnostics,
    /** # member

Member. A type of non-ownership relationship between entities (encompasses partnerships, collaboration, joint ventures, etc.) */
    Member,
    /** # payer

Payer. An organization providing reimbursement, payment, or related services */
    Payer,
    /** # provider

Provider. */
    Provider,
    /** # research

Research. An organization providing research-related services such as conducting research, recruiting research participants, analyzing data, etc. */
    Research,
    /** # supplier

Supplier. An organization that provides medical supplies (e.g. medical devices, equipment, pharmaceutical products, etc.) */
    Supplier,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for OrganizationAffiliationRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "HIE/HIO" => Ok(Self::HieHio),
            "agency" => Ok(Self::Agency),
            "diagnostics" => Ok(Self::Diagnostics),
            "member" => Ok(Self::Member),
            "payer" => Ok(Self::Payer),
            "provider" => Ok(Self::Provider),
            "research" => Ok(Self::Research),
            "supplier" => Ok(Self::Supplier),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for OrganizationAffiliationRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::HieHio => "HIE/HIO",
            Self::Agency => "agency",
            Self::Diagnostics => "diagnostics",
            Self::Member => "member",
            Self::Payer => "payer",
            Self::Provider => "provider",
            Self::Research => "research",
            Self::Supplier => "supplier",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for OrganizationAffiliationRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OrganizationAffiliationRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `OrganizationType`. This example value set defines a set of codes that can be used to indicate a type of organization.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum OrganizationType {
    /** # bus

Non-Healthcare Business or Corporation. An organization that is a registered business or corporation but not identified by other types. */
    Bus,
    /** # cg

Community Group. An un-incorporated community group. */
    Cg,
    /** # crs

Clinical Research Sponsor. An organization that is identified as a Pharmaceutical/Clinical Research Sponsor. */
    Crs,
    /** # dept

Hospital Department. A department or ward within a hospital (Generally is not applicable to top level organizations) */
    Dept,
    /** # edu

Educational Institute. An educational institution that provides education or research facilities. */
    Edu,
    /** # govt

Government. A political body, often used when including organization records for government bodies such as a Federal Government, State or Local Government. */
    Govt,
    /** # ins

Insurance Company. A company that provides insurance to its subscribers that may include healthcare related policies. */
    Ins,
    /** # other

Other. Other type of organization not already specified. */
    Other,
    /** # pay

Payer. A company, charity, or governmental organization, which processes claims and/or issues payments to providers on behalf of patients or groups of patients. */
    Pay,
    /** # prov

Healthcare Provider. An organization that provides healthcare services. */
    Prov,
    /** # reli

Religious Institution. An organization that is identified as a part of a religious institution. */
    Reli,
    /** # team

Organizational team. An organizational team is usually a grouping of practitioners that perform a specific function within an organization (which could be a top level organization, or a department). */
    Team,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for OrganizationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "bus" => Ok(Self::Bus),
            "cg" => Ok(Self::Cg),
            "crs" => Ok(Self::Crs),
            "dept" => Ok(Self::Dept),
            "edu" => Ok(Self::Edu),
            "govt" => Ok(Self::Govt),
            "ins" => Ok(Self::Ins),
            "other" => Ok(Self::Other),
            "pay" => Ok(Self::Pay),
            "prov" => Ok(Self::Prov),
            "reli" => Ok(Self::Reli),
            "team" => Ok(Self::Team),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for OrganizationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bus => "bus",
            Self::Cg => "cg",
            Self::Crs => "crs",
            Self::Dept => "dept",
            Self::Edu => "edu",
            Self::Govt => "govt",
            Self::Ins => "ins",
            Self::Other => "other",
            Self::Pay => "pay",
            Self::Prov => "prov",
            Self::Reli => "reli",
            Self::Team => "team",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for OrganizationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for OrganizationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PackageCharacteristic`. A characteristic of a package.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PackageCharacteristic {
    /** # CalendarPack

Calendar pack. */
    CalendarPack,
    /** # HospitalPack

Hospital pack. */
    HospitalPack,
    /** # NursePrescribable

Nurse prescribable. */
    NursePrescribable,
}
impl ::core::str::FromStr for PackageCharacteristic {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CalendarPack" => Ok(Self::CalendarPack),
            "HospitalPack" => Ok(Self::HospitalPack),
            "NursePrescribable" => Ok(Self::NursePrescribable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackageCharacteristic {
    fn as_ref(&self) -> &str {
        match self {
            Self::CalendarPack => "CalendarPack",
            Self::HospitalPack => "HospitalPack",
            Self::NursePrescribable => "NursePrescribable",
        }
    }
}
impl<'de> Deserialize<'de> for PackageCharacteristic {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackageCharacteristic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PackageMaterial`. A material used in the construction of packages and their components.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PackageMaterial {
    /** # 200000003200

Aluminium. */
    N200000003200,
    /** # 200000003201

Cyclic Olefin Copolymer. */
    N200000003201,
    /** # 200000003202

Epoxyphenol. */
    N200000003202,
    /** # 200000003203

Glass. */
    N200000003203,
    /** # 200000003204

Glass type I. */
    N200000003204,
    /** # 200000003205

Glass type II. */
    N200000003205,
    /** # 200000003206

Glass type III. */
    N200000003206,
    /** # 200000003207

Paper. */
    N200000003207,
    /** # 200000003208

Plastic. */
    N200000003208,
    /** # 200000003209

PolyAmide. */
    N200000003209,
    /** # 200000003210

Orientated PolyAmide. */
    N200000003210,
    /** # 200000003211

PolyCarbonate. */
    N200000003211,
    /** # 200000003212

PolyChloroTriFluoroEthylene. */
    N200000003212,
    /** # 200000003213

Polyester. */
    N200000003213,
    /** # 200000003214

PolyEthylene. */
    N200000003214,
    /** # 200000003215

High Density PolyEthylene. */
    N200000003215,
    /** # 200000003216

Low Density PolyEthylene. */
    N200000003216,
    /** # 200000003217

PolyEthylene TerePhthalate. */
    N200000003217,
    /** # 200000003218

Polyolefin. */
    N200000003218,
    /** # 200000003219

PolyPropylene. */
    N200000003219,
    /** # 200000003220

PolyStyrene. */
    N200000003220,
    /** # 200000003221

PolyVinyl Acetate. */
    N200000003221,
    /** # 200000003222

PolyVinyl Chloride. */
    N200000003222,
    /** # 200000003223

Plasticised PolyVinyl Chloride. */
    N200000003223,
    /** # 200000003224

Non-plasticised PolyVinyl Chloride / Unplasticised PolyVinyl Chloride. */
    N200000003224,
    /** # 200000003225

PolyVinylidene Chloride. */
    N200000003225,
    /** # 200000003226

Rubber. */
    N200000003226,
    /** # 200000003227

Silicone oil. */
    N200000003227,
    /** # 200000003228

Silicone elastomer. */
    N200000003228,
    /** # 200000003229

Steel. */
    N200000003229,
    /** # 200000003529

Cardboard. */
    N200000003529,
    /** # 200000012514

PolyAcryloNitrile. */
    N200000012514,
    /** # 200000012515

Ethylene acrylic acid copolymer. */
    N200000012515,
    /** # 200000012521

Ethylene meta-acrylic acid. */
    N200000012521,
    /** # 200000012522

Ethylene-Vinyl Alcohol copolymer. */
    N200000012522,
    /** # 200000012523

PolyVinylidene Fluoride. */
    N200000012523,
    /** # 200000012524

Medium Density PolyEthylene. */
    N200000012524,
    /** # 200000012538

Syndiotactic Polypropylene. */
    N200000012538,
    /** # 200000015521

PolyEthylene copolymer. */
    N200000015521,
    /** # 200000023330

Expanded Polyethylene. */
    N200000023330,
    /** # 200000023332

Cyclic Olefin Polymer. */
    N200000023332,
    /** # 200000025255

Silica gel. */
    N200000025255,
    /** # 200000025257

Linear Low Density PolyEthylene. */
    N200000025257,
}
impl ::core::str::FromStr for PackageMaterial {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "200000003200" => Ok(Self::N200000003200),
            "200000003201" => Ok(Self::N200000003201),
            "200000003202" => Ok(Self::N200000003202),
            "200000003203" => Ok(Self::N200000003203),
            "200000003204" => Ok(Self::N200000003204),
            "200000003205" => Ok(Self::N200000003205),
            "200000003206" => Ok(Self::N200000003206),
            "200000003207" => Ok(Self::N200000003207),
            "200000003208" => Ok(Self::N200000003208),
            "200000003209" => Ok(Self::N200000003209),
            "200000003210" => Ok(Self::N200000003210),
            "200000003211" => Ok(Self::N200000003211),
            "200000003212" => Ok(Self::N200000003212),
            "200000003213" => Ok(Self::N200000003213),
            "200000003214" => Ok(Self::N200000003214),
            "200000003215" => Ok(Self::N200000003215),
            "200000003216" => Ok(Self::N200000003216),
            "200000003217" => Ok(Self::N200000003217),
            "200000003218" => Ok(Self::N200000003218),
            "200000003219" => Ok(Self::N200000003219),
            "200000003220" => Ok(Self::N200000003220),
            "200000003221" => Ok(Self::N200000003221),
            "200000003222" => Ok(Self::N200000003222),
            "200000003223" => Ok(Self::N200000003223),
            "200000003224" => Ok(Self::N200000003224),
            "200000003225" => Ok(Self::N200000003225),
            "200000003226" => Ok(Self::N200000003226),
            "200000003227" => Ok(Self::N200000003227),
            "200000003228" => Ok(Self::N200000003228),
            "200000003229" => Ok(Self::N200000003229),
            "200000003529" => Ok(Self::N200000003529),
            "200000012514" => Ok(Self::N200000012514),
            "200000012515" => Ok(Self::N200000012515),
            "200000012521" => Ok(Self::N200000012521),
            "200000012522" => Ok(Self::N200000012522),
            "200000012523" => Ok(Self::N200000012523),
            "200000012524" => Ok(Self::N200000012524),
            "200000012538" => Ok(Self::N200000012538),
            "200000015521" => Ok(Self::N200000015521),
            "200000023330" => Ok(Self::N200000023330),
            "200000023332" => Ok(Self::N200000023332),
            "200000025255" => Ok(Self::N200000025255),
            "200000025257" => Ok(Self::N200000025257),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackageMaterial {
    fn as_ref(&self) -> &str {
        match self {
            Self::N200000003200 => "200000003200",
            Self::N200000003201 => "200000003201",
            Self::N200000003202 => "200000003202",
            Self::N200000003203 => "200000003203",
            Self::N200000003204 => "200000003204",
            Self::N200000003205 => "200000003205",
            Self::N200000003206 => "200000003206",
            Self::N200000003207 => "200000003207",
            Self::N200000003208 => "200000003208",
            Self::N200000003209 => "200000003209",
            Self::N200000003210 => "200000003210",
            Self::N200000003211 => "200000003211",
            Self::N200000003212 => "200000003212",
            Self::N200000003213 => "200000003213",
            Self::N200000003214 => "200000003214",
            Self::N200000003215 => "200000003215",
            Self::N200000003216 => "200000003216",
            Self::N200000003217 => "200000003217",
            Self::N200000003218 => "200000003218",
            Self::N200000003219 => "200000003219",
            Self::N200000003220 => "200000003220",
            Self::N200000003221 => "200000003221",
            Self::N200000003222 => "200000003222",
            Self::N200000003223 => "200000003223",
            Self::N200000003224 => "200000003224",
            Self::N200000003225 => "200000003225",
            Self::N200000003226 => "200000003226",
            Self::N200000003227 => "200000003227",
            Self::N200000003228 => "200000003228",
            Self::N200000003229 => "200000003229",
            Self::N200000003529 => "200000003529",
            Self::N200000012514 => "200000012514",
            Self::N200000012515 => "200000012515",
            Self::N200000012521 => "200000012521",
            Self::N200000012522 => "200000012522",
            Self::N200000012523 => "200000012523",
            Self::N200000012524 => "200000012524",
            Self::N200000012538 => "200000012538",
            Self::N200000015521 => "200000015521",
            Self::N200000023330 => "200000023330",
            Self::N200000023332 => "200000023332",
            Self::N200000025255 => "200000025255",
            Self::N200000025257 => "200000025257",
        }
    }
}
impl<'de> Deserialize<'de> for PackageMaterial {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackageMaterial {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PackageType`. A high level categorisation of a package.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PackageType {
    /** # MedicinalProductPack

Medicinal product pack. */
    MedicinalProductPack,
    /** # RawMaterialPackage

Raw material package. */
    RawMaterialPackage,
    /** # Shipping-TransportContainer

Shipping or transport container. */
    ShippingTransportContainer,
}
impl ::core::str::FromStr for PackageType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "MedicinalProductPack" => Ok(Self::MedicinalProductPack),
            "RawMaterialPackage" => Ok(Self::RawMaterialPackage),
            "Shipping-TransportContainer" => Ok(Self::ShippingTransportContainer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackageType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MedicinalProductPack => "MedicinalProductPack",
            Self::RawMaterialPackage => "RawMaterialPackage",
            Self::ShippingTransportContainer => "Shipping-TransportContainer",
        }
    }
}
impl<'de> Deserialize<'de> for PackageType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PackagingType`. A type of packaging.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PackagingType {
    /** # 100000073490

Ampoule. */
    N100000073490,
    /** # 100000073491

Applicator. */
    N100000073491,
    /** # 100000073492

Automatic injection device. */
    N100000073492,
    /** # 100000073493

Bag. */
    N100000073493,
    /** # 100000073494

Balling gun. */
    N100000073494,
    /** # 100000073495

Barrel. */
    N100000073495,
    /** # 100000073496

Blister. */
    N100000073496,
    /** # 100000073497

Bottle. */
    N100000073497,
    /** # 100000073498

Box. */
    N100000073498,
    /** # 100000073499

Brush. */
    N100000073499,
    /** # 100000073500

Brush applicator. */
    N100000073500,
    /** # 100000073501

Cannula. */
    N100000073501,
    /** # 100000073502

Cap. */
    N100000073502,
    /** # 100000073503

Cartridge. */
    N100000073503,
    /** # 100000073504

Child-resistant closure. */
    N100000073504,
    /** # 100000073505

Cup. */
    N100000073505,
    /** # 100000073506

Dabbing applicator. */
    N100000073506,
    /** # 100000073507

Dart. */
    N100000073507,
    /** # 100000073508

Dredging applicator. */
    N100000073508,
    /** # 100000073509

Dredging container. */
    N100000073509,
    /** # 100000073510

Drench gun. */
    N100000073510,
    /** # 100000073511

Dropper applicator. */
    N100000073511,
    /** # 100000073512

Dropper container. */
    N100000073512,
    /** # 100000073513

Fixed cryogenic vessel. */
    N100000073513,
    /** # 100000073514

Gas cylinder. */
    N100000073514,
    /** # 100000073515

High pressure transdermal delivery device. */
    N100000073515,
    /** # 100000073516

Implanter. */
    N100000073516,
    /** # 100000073517

Inhaler. */
    N100000073517,
    /** # 100000073518

In-ovo injection device. */
    N100000073518,
    /** # 100000073519

Injection needle. */
    N100000073519,
    /** # 100000073520

Injection syringe. */
    N100000073520,
    /** # 100000073521

Internal graduated calibration chamber. */
    N100000073521,
    /** # 100000073522

Intramammary syringe. */
    N100000073522,
    /** # 100000073523

Jar. */
    N100000073523,
    /** # 100000073524

Measuring device. */
    N100000073524,
    /** # 100000073525

Measuring spoon. */
    N100000073525,
    /** # 100000073526

Metering pump. */
    N100000073526,
    /** # 100000073527

Metering valve. */
    N100000073527,
    /** # 100000073528

Mobile cryogenic vessel. */
    N100000073528,
    /** # 100000073529

Mouthpiece. */
    N100000073529,
    /** # 100000073530

Multidose container. */
    N100000073530,
    /** # 100000073531

Multidose container with airless pump. */
    N100000073531,
    /** # 100000073532

Multipuncturer. */
    N100000073532,
    /** # 100000073533

Nasal applicator. */
    N100000073533,
    /** # 100000073534

Nebuliser. */
    N100000073534,
    /** # 100000073535

Needle applicator. */
    N100000073535,
    /** # 100000073536

Nozzle. */
    N100000073536,
    /** # 100000073537

Oral syringe. */
    N100000073537,
    /** # 100000073538

Pipette. */
    N100000073538,
    /** # 100000073539

Pipette applicator. */
    N100000073539,
    /** # 100000073540

Pouch. */
    N100000073540,
    /** # 100000073541

Pour-on container. */
    N100000073541,
    /** # 100000073542

Pre-filled gastroenteral tube. */
    N100000073542,
    /** # 100000073543

Pre-filled pen. */
    N100000073543,
    /** # 100000073544

Pre-filled syringe. */
    N100000073544,
    /** # 100000073545

Pressurised container. */
    N100000073545,
    /** # 100000073546

Prick test applicator. */
    N100000073546,
    /** # 100000073547

Sachet. */
    N100000073547,
    /** # 100000073548

Scarifier. */
    N100000073548,
    /** # 100000073549

Screw cap. */
    N100000073549,
    /** # 100000073550

Single-dose container. */
    N100000073550,
    /** # 100000073551

Spatula. */
    N100000073551,
    /** # 100000073552

Spot-on applicator. */
    N100000073552,
    /** # 100000073553

Spray container. */
    N100000073553,
    /** # 100000073554

Spray pump. */
    N100000073554,
    /** # 100000073555

Spray valve. */
    N100000073555,
    /** # 100000073556

Stab vaccinator. */
    N100000073556,
    /** # 100000073557

Stopper. */
    N100000073557,
    /** # 100000073558

Straw. */
    N100000073558,
    /** # 100000073559

Strip. */
    N100000073559,
    /** # 100000073560

Tablet container. */
    N100000073560,
    /** # 100000073561

Tube. */
    N100000073561,
    /** # 100000073562

Vaginal sponge applicator. */
    N100000073562,
    /** # 100000073563

Vial. */
    N100000073563,
    /** # 100000075664

Administration system. */
    N100000075664,
    /** # 100000116195

Calendar package. */
    N100000116195,
    /** # 100000116196

Needle-free injector. */
    N100000116196,
    /** # 100000116197

Roll-on container. */
    N100000116197,
    /** # 100000125779

Multidose container with pump. */
    N100000125779,
    /** # 100000137702

Container. */
    N100000137702,
    /** # 100000137703

Oral applicator. */
    N100000137703,
    /** # 100000143554

Multidose container with metering pump. */
    N100000143554,
    /** # 100000143555

Pack. */
    N100000143555,
    /** # 100000163233

disk. */
    N100000163233,
    /** # 100000163234

plunger. */
    N100000163234,
    /** # 100000164143

infusion port. */
    N100000164143,
    /** # 100000166980

Valve. */
    N100000166980,
    /** # 100000169899

Jerrycan. */
    N100000169899,
    /** # 100000173982

Oral applicator. */
    N100000173982,
    /** # 100000173983

Dose dispenser. */
    N100000173983,
    /** # 100000174066

Unit-dose blister. */
    N100000174066,
    /** # 100000174067

Pre-filled injector. */
    N100000174067,
    /** # 100000174068

Pre-filled oral syringe. */
    N100000174068,
    /** # 100000174069

Pre-filled oral applicator. */
    N100000174069,
    /** # 100000174070

Dose-dispenser cartridge. */
    N100000174070,
    /** # 200000005068

Pen. */
    N200000005068,
    /** # 200000005585

Wrapper. */
    N200000005585,
    /** # 200000010647

Lid. */
    N200000010647,
    /** # 200000011726

Capsule for opening. */
    N200000011726,
    /** # 200000012539

Child-resistant sachet. */
    N200000012539,
    /** # 200000013191

Tamper-evident closure. */
    N200000013191,
    /** # 200000024874

Tablet tube. */
    N200000024874,
}
impl ::core::str::FromStr for PackagingType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000073490" => Ok(Self::N100000073490),
            "100000073491" => Ok(Self::N100000073491),
            "100000073492" => Ok(Self::N100000073492),
            "100000073493" => Ok(Self::N100000073493),
            "100000073494" => Ok(Self::N100000073494),
            "100000073495" => Ok(Self::N100000073495),
            "100000073496" => Ok(Self::N100000073496),
            "100000073497" => Ok(Self::N100000073497),
            "100000073498" => Ok(Self::N100000073498),
            "100000073499" => Ok(Self::N100000073499),
            "100000073500" => Ok(Self::N100000073500),
            "100000073501" => Ok(Self::N100000073501),
            "100000073502" => Ok(Self::N100000073502),
            "100000073503" => Ok(Self::N100000073503),
            "100000073504" => Ok(Self::N100000073504),
            "100000073505" => Ok(Self::N100000073505),
            "100000073506" => Ok(Self::N100000073506),
            "100000073507" => Ok(Self::N100000073507),
            "100000073508" => Ok(Self::N100000073508),
            "100000073509" => Ok(Self::N100000073509),
            "100000073510" => Ok(Self::N100000073510),
            "100000073511" => Ok(Self::N100000073511),
            "100000073512" => Ok(Self::N100000073512),
            "100000073513" => Ok(Self::N100000073513),
            "100000073514" => Ok(Self::N100000073514),
            "100000073515" => Ok(Self::N100000073515),
            "100000073516" => Ok(Self::N100000073516),
            "100000073517" => Ok(Self::N100000073517),
            "100000073518" => Ok(Self::N100000073518),
            "100000073519" => Ok(Self::N100000073519),
            "100000073520" => Ok(Self::N100000073520),
            "100000073521" => Ok(Self::N100000073521),
            "100000073522" => Ok(Self::N100000073522),
            "100000073523" => Ok(Self::N100000073523),
            "100000073524" => Ok(Self::N100000073524),
            "100000073525" => Ok(Self::N100000073525),
            "100000073526" => Ok(Self::N100000073526),
            "100000073527" => Ok(Self::N100000073527),
            "100000073528" => Ok(Self::N100000073528),
            "100000073529" => Ok(Self::N100000073529),
            "100000073530" => Ok(Self::N100000073530),
            "100000073531" => Ok(Self::N100000073531),
            "100000073532" => Ok(Self::N100000073532),
            "100000073533" => Ok(Self::N100000073533),
            "100000073534" => Ok(Self::N100000073534),
            "100000073535" => Ok(Self::N100000073535),
            "100000073536" => Ok(Self::N100000073536),
            "100000073537" => Ok(Self::N100000073537),
            "100000073538" => Ok(Self::N100000073538),
            "100000073539" => Ok(Self::N100000073539),
            "100000073540" => Ok(Self::N100000073540),
            "100000073541" => Ok(Self::N100000073541),
            "100000073542" => Ok(Self::N100000073542),
            "100000073543" => Ok(Self::N100000073543),
            "100000073544" => Ok(Self::N100000073544),
            "100000073545" => Ok(Self::N100000073545),
            "100000073546" => Ok(Self::N100000073546),
            "100000073547" => Ok(Self::N100000073547),
            "100000073548" => Ok(Self::N100000073548),
            "100000073549" => Ok(Self::N100000073549),
            "100000073550" => Ok(Self::N100000073550),
            "100000073551" => Ok(Self::N100000073551),
            "100000073552" => Ok(Self::N100000073552),
            "100000073553" => Ok(Self::N100000073553),
            "100000073554" => Ok(Self::N100000073554),
            "100000073555" => Ok(Self::N100000073555),
            "100000073556" => Ok(Self::N100000073556),
            "100000073557" => Ok(Self::N100000073557),
            "100000073558" => Ok(Self::N100000073558),
            "100000073559" => Ok(Self::N100000073559),
            "100000073560" => Ok(Self::N100000073560),
            "100000073561" => Ok(Self::N100000073561),
            "100000073562" => Ok(Self::N100000073562),
            "100000073563" => Ok(Self::N100000073563),
            "100000075664" => Ok(Self::N100000075664),
            "100000116195" => Ok(Self::N100000116195),
            "100000116196" => Ok(Self::N100000116196),
            "100000116197" => Ok(Self::N100000116197),
            "100000125779" => Ok(Self::N100000125779),
            "100000137702" => Ok(Self::N100000137702),
            "100000137703" => Ok(Self::N100000137703),
            "100000143554" => Ok(Self::N100000143554),
            "100000143555" => Ok(Self::N100000143555),
            "100000163233" => Ok(Self::N100000163233),
            "100000163234" => Ok(Self::N100000163234),
            "100000164143" => Ok(Self::N100000164143),
            "100000166980" => Ok(Self::N100000166980),
            "100000169899" => Ok(Self::N100000169899),
            "100000173982" => Ok(Self::N100000173982),
            "100000173983" => Ok(Self::N100000173983),
            "100000174066" => Ok(Self::N100000174066),
            "100000174067" => Ok(Self::N100000174067),
            "100000174068" => Ok(Self::N100000174068),
            "100000174069" => Ok(Self::N100000174069),
            "100000174070" => Ok(Self::N100000174070),
            "200000005068" => Ok(Self::N200000005068),
            "200000005585" => Ok(Self::N200000005585),
            "200000010647" => Ok(Self::N200000010647),
            "200000011726" => Ok(Self::N200000011726),
            "200000012539" => Ok(Self::N200000012539),
            "200000013191" => Ok(Self::N200000013191),
            "200000024874" => Ok(Self::N200000024874),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PackagingType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000073490 => "100000073490",
            Self::N100000073491 => "100000073491",
            Self::N100000073492 => "100000073492",
            Self::N100000073493 => "100000073493",
            Self::N100000073494 => "100000073494",
            Self::N100000073495 => "100000073495",
            Self::N100000073496 => "100000073496",
            Self::N100000073497 => "100000073497",
            Self::N100000073498 => "100000073498",
            Self::N100000073499 => "100000073499",
            Self::N100000073500 => "100000073500",
            Self::N100000073501 => "100000073501",
            Self::N100000073502 => "100000073502",
            Self::N100000073503 => "100000073503",
            Self::N100000073504 => "100000073504",
            Self::N100000073505 => "100000073505",
            Self::N100000073506 => "100000073506",
            Self::N100000073507 => "100000073507",
            Self::N100000073508 => "100000073508",
            Self::N100000073509 => "100000073509",
            Self::N100000073510 => "100000073510",
            Self::N100000073511 => "100000073511",
            Self::N100000073512 => "100000073512",
            Self::N100000073513 => "100000073513",
            Self::N100000073514 => "100000073514",
            Self::N100000073515 => "100000073515",
            Self::N100000073516 => "100000073516",
            Self::N100000073517 => "100000073517",
            Self::N100000073518 => "100000073518",
            Self::N100000073519 => "100000073519",
            Self::N100000073520 => "100000073520",
            Self::N100000073521 => "100000073521",
            Self::N100000073522 => "100000073522",
            Self::N100000073523 => "100000073523",
            Self::N100000073524 => "100000073524",
            Self::N100000073525 => "100000073525",
            Self::N100000073526 => "100000073526",
            Self::N100000073527 => "100000073527",
            Self::N100000073528 => "100000073528",
            Self::N100000073529 => "100000073529",
            Self::N100000073530 => "100000073530",
            Self::N100000073531 => "100000073531",
            Self::N100000073532 => "100000073532",
            Self::N100000073533 => "100000073533",
            Self::N100000073534 => "100000073534",
            Self::N100000073535 => "100000073535",
            Self::N100000073536 => "100000073536",
            Self::N100000073537 => "100000073537",
            Self::N100000073538 => "100000073538",
            Self::N100000073539 => "100000073539",
            Self::N100000073540 => "100000073540",
            Self::N100000073541 => "100000073541",
            Self::N100000073542 => "100000073542",
            Self::N100000073543 => "100000073543",
            Self::N100000073544 => "100000073544",
            Self::N100000073545 => "100000073545",
            Self::N100000073546 => "100000073546",
            Self::N100000073547 => "100000073547",
            Self::N100000073548 => "100000073548",
            Self::N100000073549 => "100000073549",
            Self::N100000073550 => "100000073550",
            Self::N100000073551 => "100000073551",
            Self::N100000073552 => "100000073552",
            Self::N100000073553 => "100000073553",
            Self::N100000073554 => "100000073554",
            Self::N100000073555 => "100000073555",
            Self::N100000073556 => "100000073556",
            Self::N100000073557 => "100000073557",
            Self::N100000073558 => "100000073558",
            Self::N100000073559 => "100000073559",
            Self::N100000073560 => "100000073560",
            Self::N100000073561 => "100000073561",
            Self::N100000073562 => "100000073562",
            Self::N100000073563 => "100000073563",
            Self::N100000075664 => "100000075664",
            Self::N100000116195 => "100000116195",
            Self::N100000116196 => "100000116196",
            Self::N100000116197 => "100000116197",
            Self::N100000125779 => "100000125779",
            Self::N100000137702 => "100000137702",
            Self::N100000137703 => "100000137703",
            Self::N100000143554 => "100000143554",
            Self::N100000143555 => "100000143555",
            Self::N100000163233 => "100000163233",
            Self::N100000163234 => "100000163234",
            Self::N100000164143 => "100000164143",
            Self::N100000166980 => "100000166980",
            Self::N100000169899 => "100000169899",
            Self::N100000173982 => "100000173982",
            Self::N100000173983 => "100000173983",
            Self::N100000174066 => "100000174066",
            Self::N100000174067 => "100000174067",
            Self::N100000174068 => "100000174068",
            Self::N100000174069 => "100000174069",
            Self::N100000174070 => "100000174070",
            Self::N200000005068 => "200000005068",
            Self::N200000005585 => "200000005585",
            Self::N200000010647 => "200000010647",
            Self::N200000011726 => "200000011726",
            Self::N200000012539 => "200000012539",
            Self::N200000013191 => "200000013191",
            Self::N200000024874 => "200000024874",
        }
    }
}
impl<'de> Deserialize<'de> for PackagingType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PackagingType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ParticipantRequired`. Is the Participant required to attend the appointment.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ParticipantRequired {
    /** # information-only

Information Only. The participant is excluded from the appointment, and might not be informed of the appointment taking place. (Appointment is about them, not for them - such as 2 doctors discussing results about a patient's test). */
    InformationOnly,
    /** # optional

Optional. The participant may optionally attend the appointment. */
    Optional,
    /** # required

Required. The participant is required to attend the appointment. */
    Required,
}
impl ::core::str::FromStr for ParticipantRequired {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "information-only" => Ok(Self::InformationOnly),
            "optional" => Ok(Self::Optional),
            "required" => Ok(Self::Required),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ParticipantRequired {
    fn as_ref(&self) -> &str {
        match self {
            Self::InformationOnly => "information-only",
            Self::Optional => "optional",
            Self::Required => "required",
        }
    }
}
impl<'de> Deserialize<'de> for ParticipantRequired {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipantRequired {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ParticipantType`. This codesystem defines a set of codes that can be used to indicate how an individual participates in an encounter.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ParticipantType {
    /** # emergency

Emergency. A person to be contacted in case of an emergency during the encounter. */
    Emergency,
    /** # translator

Translator. A translator who is facilitating communication with the patient during the encounter. */
    Translator,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "emergency" => Ok(Self::Emergency),
            "translator" => Ok(Self::Translator),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Emergency => "emergency",
            Self::Translator => "translator",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ParticipationStatus`. The Participation status of an appointment.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ParticipationStatus {
    /** # accepted

Accepted. The participant has accepted the appointment. */
    Accepted,
    /** # declined

Declined. The participant has declined the appointment and will not participate in the appointment. */
    Declined,
    /** # needs-action

Needs Action. The participant needs to indicate if they accept the appointment by changing this status to one of the other statuses. */
    NeedsAction,
    /** # tentative

Tentative. The participant has  tentatively accepted the appointment. This could be automatically created by a system and requires further processing before it can be accepted. There is no commitment that attendance will occur. */
    Tentative,
}
impl ::core::str::FromStr for ParticipationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "declined" => Ok(Self::Declined),
            "needs-action" => Ok(Self::NeedsAction),
            "tentative" => Ok(Self::Tentative),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ParticipationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Declined => "declined",
            Self::NeedsAction => "needs-action",
            Self::Tentative => "tentative",
        }
    }
}
impl<'de> Deserialize<'de> for ParticipationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ParticipationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PatientMedicineChangeTypes`. Example Item Flags for the List Resource. In this case, these are the kind of flags that would be used on a medication list at the end of a consultation.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PatientMedicineChangeTypes {
    /** # 01

Unchanged. No change has been made to the status of this medicine item. */
    N01,
    /** # 02

Changed. The medicine item has changed. The change may be described in an extension (not defined yet) */
    N02,
    /** # 03

Cancelled. The prescription for this medicine item was cancelled by an authorized health care provider. The patient may be advised to complete the course of the prescribed medicine. This advice is a clinical decision made based on assessment of the patient's clinical condition. */
    N03,
    /** # 04

Prescribed. A new medicine item has been prescribed */
    N04,
    /** # 05

Ceased. Administration of this medication item that the patient is currently taking is stopped or recommended to be stopped (i.e. instructed to be ceased by a health care provider). This cessation is anticipated to be permanent. The Change Description should describe the reason for cessation. Example uses: the medication in question is considered ineffective or has caused serious adverse effects. This value applies both to the cessation of a medication that is prescribed by another healthcare provider or patient self-administration of OTC medicines. */
    N05,
    /** # 06

Suspended. Administration of this medication item that the patient is currently taking is on hold, or instructed or recommended by a health care provider to be temporarily stopped, or subject to clinical review (i.e. the stop may be temporary or permanent depending on the outcome of clinical review), or temporarily suspended as a pre-requisite to certain surgical or diagnostic procedures. */
    N06,
}
impl ::core::str::FromStr for PatientMedicineChangeTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "01" => Ok(Self::N01),
            "02" => Ok(Self::N02),
            "03" => Ok(Self::N03),
            "04" => Ok(Self::N04),
            "05" => Ok(Self::N05),
            "06" => Ok(Self::N06),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PatientMedicineChangeTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N01 => "01",
            Self::N02 => "02",
            Self::N03 => "03",
            Self::N04 => "04",
            Self::N05 => "05",
            Self::N06 => "06",
        }
    }
}
impl<'de> Deserialize<'de> for PatientMedicineChangeTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PatientMedicineChangeTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PaymentAdjustmentReasonCodes`. This value set includes smattering of Payment Adjustment Reason codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PaymentAdjustmentReasonCodes {
    /** # a001

Prior Payment Reversal. Prior Payment Reversal */
    A001,
    /** # a002

Prior Overpayment. Prior Overpayment */
    A002,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PaymentAdjustmentReasonCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a001" => Ok(Self::A001),
            "a002" => Ok(Self::A002),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PaymentAdjustmentReasonCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::A001 => "a001",
            Self::A002 => "a002",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for PaymentAdjustmentReasonCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PaymentAdjustmentReasonCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PaymentStatusCodes`. This value set includes a sample set of Payment Status codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PaymentStatusCodes {
    /** # cleared

Cleared. The payment has been received by the payee. */
    Cleared,
    /** # paid

Paid. The payment has been sent physically or electronically. */
    Paid,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PaymentStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cleared" => Ok(Self::Cleared),
            "paid" => Ok(Self::Paid),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PaymentStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cleared => "cleared",
            Self::Paid => "paid",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for PaymentStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PaymentStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PaymentTypeCodes`. This value set includes a smattering of Payment Type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PaymentTypeCodes {
    /** # complete

Complete. Complete (final) payment of the benefit under the Claim less any adjustments. */
    Complete,
    /** # partial

Partial. Partial payment of the benefit under the Claim less any adjustments. */
    Partial,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PaymentTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "partial" => Ok(Self::Partial),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PaymentTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Partial => "partial",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for PaymentTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PaymentTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PediatricUse`. Suitability for age groups, in particular children.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PediatricUse {
    /** # Adolescents

Adolescents (12 to < 18 years). Adolescents (12 to < 18 years) */
    Adolescents,
    /** # Adults

Adults (18 to < 65 years). Adults (18 to < 65 years) */
    Adults,
    /** # AdultsAndElderly

Adult and elderly population (> 18 years). Adult and elderly population (> 18 years) */
    AdultsAndElderly,
    /** # All

All. All */
    All,
    /** # Children

Children (2 to < 12 years). Children (2 to < 12 years) */
    Children,
    /** # Elderly

Elderly (≥ 65 years). Elderly (≥ 65 years) */
    Elderly,
    /** # InUtero

In utero. In utero */
    InUtero,
    /** # Infants

Infants and toddlers (28 days – 23 months). Infants and toddlers (28 days – 23 months) */
    Infants,
    /** # Neonate

Neonate. Neonate */
    Neonate,
    /** # PediatricPopulation

Pediatric Population (< 18 years). Pediatric Population (< 18 years) */
    PediatricPopulation,
    /** # Prepubertal

Prepubertal children (2 years to onset of puberty). Prepubertal children (2 years to onset of puberty) */
    Prepubertal,
    /** # PretermNewborn

Preterm newborn infants (0 – 27 days). Preterm newborn infants (0 – 27 days) */
    PretermNewborn,
    /** # PubertalAndPostpubertal

Pubertal and postpubertal adolescents (onset of puberty to < 18 years). Pubertal and postpubertal adolescents (onset of puberty to < 18 years) */
    PubertalAndPostpubertal,
    /** # TermNewborn

Term newborn infants (0 – 27 days). Term newborn infants (0 – 27 days) */
    TermNewborn,
}
impl ::core::str::FromStr for PediatricUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Adolescents" => Ok(Self::Adolescents),
            "Adults" => Ok(Self::Adults),
            "AdultsAndElderly" => Ok(Self::AdultsAndElderly),
            "All" => Ok(Self::All),
            "Children" => Ok(Self::Children),
            "Elderly" => Ok(Self::Elderly),
            "InUtero" => Ok(Self::InUtero),
            "Infants" => Ok(Self::Infants),
            "Neonate" => Ok(Self::Neonate),
            "PediatricPopulation" => Ok(Self::PediatricPopulation),
            "Prepubertal" => Ok(Self::Prepubertal),
            "PretermNewborn" => Ok(Self::PretermNewborn),
            "PubertalAndPostpubertal" => Ok(Self::PubertalAndPostpubertal),
            "TermNewborn" => Ok(Self::TermNewborn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PediatricUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adolescents => "Adolescents",
            Self::Adults => "Adults",
            Self::AdultsAndElderly => "AdultsAndElderly",
            Self::All => "All",
            Self::Children => "Children",
            Self::Elderly => "Elderly",
            Self::InUtero => "InUtero",
            Self::Infants => "Infants",
            Self::Neonate => "Neonate",
            Self::PediatricPopulation => "PediatricPopulation",
            Self::Prepubertal => "Prepubertal",
            Self::PretermNewborn => "PretermNewborn",
            Self::PubertalAndPostpubertal => "PubertalAndPostpubertal",
            Self::TermNewborn => "TermNewborn",
        }
    }
}
impl<'de> Deserialize<'de> for PediatricUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PediatricUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PlanDefinitionType`. The type of PlanDefinition.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PlanDefinitionType {
    /** # clinical-protocol

Clinical Protocol. Defines a desired/typical sequence of clinical activities including preconditions, triggers and temporal relationships. */
    ClinicalProtocol,
    /** # eca-rule

ECA Rule. A decision support rule of the form [on Event] if Condition then Action. It is intended to be a shareable, computable definition of actions that should be taken whenever some condition is met in response to a particular event or events. */
    EcaRule,
    /** # order-set

Order Set. A pre-defined and approved group of orders related to a particular clinical condition (e.g. hypertension treatment and monitoring) or stage of care (e.g. hospital admission to Coronary Care Unit). An order set is used as a checklist for the clinician when managing a patient with a specific condition. It is a structured collection of orders relevant to that condition and presented to the clinician in a computerized provider order entry (CPOE) system. */
    OrderSet,
    /** # workflow-definition

Workflow Definition. Defines the steps for a group of one or more systems in an event flow process along with the step constraints, sequence, pre-conditions and decision points to complete a particular objective. */
    WorkflowDefinition,
}
impl ::core::str::FromStr for PlanDefinitionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "clinical-protocol" => Ok(Self::ClinicalProtocol),
            "eca-rule" => Ok(Self::EcaRule),
            "order-set" => Ok(Self::OrderSet),
            "workflow-definition" => Ok(Self::WorkflowDefinition),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PlanDefinitionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ClinicalProtocol => "clinical-protocol",
            Self::EcaRule => "eca-rule",
            Self::OrderSet => "order-set",
            Self::WorkflowDefinition => "workflow-definition",
        }
    }
}
impl<'de> Deserialize<'de> for PlanDefinitionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PlanDefinitionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PolicyCodes`. FHIR Specific Example codes for Consent Policy

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PolicyCodes {
    /** # at-elga

AT ELGA Opt-in Consent. Pursuant to Sec. 2 no. 9 Health Telematics Act 2012, ELGA Health Data ( “ELGA-Gesundheitsdaten”) = Medical documents. Austria opted for an opt-out approach. This means that a person is by default ‘ELGA participant’ unless he/she objects. ELGA participants have the following options: General opt out: No participation in ELGA, Partial opt-out: No participation in a particular ELGA application, e.g. eMedication and Case-specific opt-out: No participation in ELGA only regarding a particular case/treatment. There is the possibility to opt-in again. ELGA participants can also exclude the access of a particular ELGA healthcare provider to a particular piece of or all of their ELGA data. http://ec.europa.eu/health/ehealth/docs/laws_austria_en.pdf */
    AtElga,
    /** # cric

Common Rule Informed Consent. 45 CFR part 46 §46.116 General requirements for informed consent; and §46.117 Documentation of informed consent. https://www.gpo.gov/fdsys/pkg/FR-2017-01-19/pdf/2017-01058.pdf */
    Cric,
    /** # dch-3927

Michigan behavior and mental health consent. Michigan DCH-3927 Consent to Share Behavioral Health Information for Care Coordination Purposes, which combines 42 CFR Part 2 and Michigan Mental Health Code, Act 258 of 1974. Form is available at http://www.michigan.gov/documents/mdch/DCH-3927_Consent_to_Share_Health_Information_477005_7.docx */
    Dch3927,
    /** # ga4gh

Population origins and ancestry research consent. Global Alliance for Genomic Health Data Sharing Consent Form is an example of the GA4GH Population origins and ancestry research consent form. Consenters agree to permitting a specified research project to collect ancestry and genetic information in controlled-access databases, and to allow other researchers to use deidentified information from those databases. http://www.commonaccord.org/index.php?action=doc&file=Wx/org/genomicsandhealth/REWG/Demo/Roberta_Robinson_US */
    Ga4Gh,
    /** # hipaa-auth

HIPAA Authorization. HIPAA 45 CFR Section 164.508 Uses and disclosures for which an authorization is required. (a) Standard: Authorizations for uses and disclosures. (1) Authorization required: General rule. Except as otherwise permitted or required by this subchapter, a covered entity SHALL not use or disclose protected health information without an authorization that is valid under this section. When a covered entity obtains or receives a valid authorization for its use or disclosure of protected health information, such use or disclosure must be consistent with such authorization. Usage Note: Authorizations governed under this regulation meet the definition of an opt in class of consent directive. */
    HipaaAuth,
    /** # hipaa-npp

HIPAA Notice of Privacy Practices. 164.520  Notice of privacy practices for protected health information. (1) Right to notice. Except as provided by paragraph (a)(2) or (3) of this section, an individual has a right to adequate notice of the uses and disclosures of protected health information that may be made by the covered entity, and of the individual's rights and the covered entity's legal duties with respect to protected health information. Usage Note: Restrictions governed under this regulation meet the definition of an implied with an opportunity to dissent class of consent directive. */
    HipaaNpp,
    /** # hipaa-research

HIPAA Research Authorization. HIPAA 45 CFR 164.508 - Uses and disclosures for which an authorization is required. (a) Standard: Authorizations for uses and disclosures. (3) Compound authorizations. An authorization for use or disclosure of protected health information SHALL NOT be combined with any other document to create a compound authorization, except as follows: (i) An authorization for the use or disclosure of protected health information for a research study may be combined with any other type of written permission for the same or another research study. This exception includes combining an authorization for the use or disclosure of protected health information for a research study with another authorization for the same research study, with an authorization for the creation or maintenance of a research database or repository, or with a consent to participate in research. Where a covered health care provider has conditioned the provision of research-related treatment on the provision of one of the authorizations, as permitted under paragraph (b)(4)(i) of this section, any compound authorization created under this paragraph must clearly differentiate between the conditioned and unconditioned components and provide the individual with an opportunity to opt in to the research activities described in the unconditioned authorization. Usage Notes: See HHS http://www.hhs.gov/hipaa/for-professionals/special-topics/research/index.html and OCR http://www.hhs.gov/hipaa/for-professionals/special-topics/research/index.html */
    HipaaResearch,
    /** # hipaa-restrictions

HIPAA Restrictions. HIPAA 45 CFR 164.510 - Uses and disclosures requiring an opportunity for the individual to agree or to object. A covered entity may use or disclose protected health information, provided that the individual is informed in advance of the use or disclosure and has the opportunity to agree to or prohibit or restrict the use or disclosure, in accordance with the applicable requirements of this section. The covered entity may orally inform the individual of and obtain the individual's oral agreement or objection to a use or disclosure permitted by this section. Usage Note: Restrictions governed under this regulation meet the definition of an opt out with exception class of consent directive. */
    HipaaRestrictions,
    /** # hipaa-self-pay

HIPAA Self-Pay Restriction. HIPAA 45 CFR 164.522(a) Right To Request a Restriction of Uses and Disclosures. (vi) A covered entity must agree to the request of an individual to restrict disclosure of protected health information about the individual to a health plan if: (A) The disclosure is for the purpose of carrying out payment or health care operations and is not otherwise required by law; and (B) The protected health information pertains solely to a health care item or service for which the individual, or person other than the health plan on behalf of the individual, has paid the covered entity in full. Usage Note: Restrictions governed under this regulation meet the definition of an opt out with exception class of consent directive. Opt out is limited to disclosures to a payer for payment and operations purpose of use. See HL7 HIPAA Self-Pay code in ActPrivacyLaw (2.16.840.1.113883.1.11.20426). */
    HipaaSelfPay,
    /** # illinois-minor-procedure

Illinois Consent by Minors to Medical Procedures. The consent to the performance of a medical or surgical procedure by a physician licensed to practice medicine and surgery, a licensed advanced practice nurse, or a licensed physician assistant executed by a married person who is a minor, by a parent who is a minor, by a pregnant woman who is a minor, or by any person 18 years of age or older, is not voidable because of such minority, and, for such purpose, a married person who is a minor, a parent who is a minor, a pregnant woman who is a minor, or any person 18 years of age or older, is deemed to have the same legal capacity to act and has the same powers and obligations as has a person of legal age. Consent by Minors to Medical Procedures Act. (410 ILCS 210/0.01) (from Ch. 111, par. 4500) Sec. 0.01. Short title. This Act may be cited as the Consent by Minors to Medical Procedures Act. (Source: P.A. 86-1324.) http://www.ilga.gov/legislation/ilcs/ilcs3.asp?ActID=1539&ChapterID=35 */
    IllinoisMinorProcedure,
    /** # mdhhs-5515

Michigan MDHHS-5515 Consent to Share Behavioral Health Information for Care Coordination Purposes. On January 1, 2015, the Michigan Department of Health and Human Services (MDHHS) released a standard consent form for the sharing of health information specific to behavioral health and substance use treatment in accordance with Public Act 129 of 2014. In Michigan, while providers are not required to use this new standard form (MDHHS-5515), they are required to accept it. Note: Form is available at http://www.michigan.gov/documents/mdhhs/Consent_to_Share_Behavioral_Health_Information_for_Care_Coordination_Purposes_548835_7.docx For more information see http://www.michigan.gov/documents/mdhhs/Behavioral_Health_Consent_Form_Background_Information_548864_7.pdf */
    Mdhhs5515,
    /** # nci

NCI Cancer Clinical Trial consent. see http://ctep.cancer.gov/protocolDevelopment/docs/Informed_Consent_Template.docx */
    Nci,
    /** # nih-527

NIH Authorization for the Release of Medical Information. NIH Authorization for the Release of Medical Information is a patient’s consent for the National Institutes of Health Clinical Center to release medical information to care providers, which can be revoked. Note: Consent Form available @ http://cc.nih.gov/participate/_pdf/NIH-527.pdf */
    Nih527,
    /** # nih-grdr

NIH Global Rare Disease Patient Registry and Data Repository consent. Global Rare Disease Patient Registry and Data Repository (GRDR) consent is an agreement of a healthcare consumer to permit collection, access, use and disclosure of de-identified rare disease information and collection of bio-specimens, medical information, family history and other related information from patients to permit the registry collection of health and genetic information, and specimens for pseudonymized disclosure for research purpose of use. https://rarediseases.info.nih.gov/files/informed_consent_template.pdf */
    NihGrdr,
    /** # nih-hipaa

HHS NIH HIPAA Research Authorization. Guidance and template form https://privacyruleandresearch.nih.gov/pdf/authorization.pdf */
    NihHipaa,
    /** # nl-lsp

NL LSP Permission. LSP (National Exchange Point) requires that providers, hospitals and pharmacy obtain explicit permission [opt-in] from healthcare consumers to submit and retrieve all or only some of a subject of care’s health information collected by the LSP for purpose of treatment, which can be revoked.  Without permission, a provider cannot access LSP information even in an emergency. The LSP provides healthcare consumers with accountings of disclosures. https://www.vzvz.nl/uploaded/FILES/htmlcontent/Formulieren/TOESTEMMINGSFORMULIER.pdf, https://www.ikgeeftoestemming.nl/en, https://www.ikgeeftoestemming.nl/en/registration/find-healthcare-provider */
    NlLsp,
    /** # nyssipp

New York State Surgical and Invasive Procedure Protocol. The New York State Surgical and Invasive Procedure Protocol (NYSSIPP) applies to all operative and invasive procedures including endoscopy, general surgery or interventional radiology. Other procedures that involve puncture or incision of the skin, or insertion of an instrument or foreign material into the body are within the scope of the protocol. This protocol also applies to those anesthesia procedures either prior to a surgical procedure or independent of a surgical procedure such as spinal facet blocks. Example: Certain 'minor' procedures such as venipuncture, peripheral IV placement, insertion of nasogastric tube and foley catheter insertion are not within the scope of the protocol. From http://www.health.ny.gov/professionals/protocols_and_guidelines/surgical_and_invasive_procedure/nyssipp_faq.htm Note: HHC 100B-1 Form is available at http://www.downstate.edu/emergency_medicine/documents/Consent_CT_with_contrast.pdf */
    Nyssipp,
    /** # squaxin

Squaxin Indian behavioral health and HIPAA consent. Squaxin Indian HIPAA and 42 CFR Part 2 Consent for Release and Exchange of Confidential Information, which permits consenter to select healthcare record type and types of treatment purposes.  This consent requires disclosers and recipients to comply with 42 C.F.R. Part 2, and HIPAA 45 C.F.R. parts 160 and 164. It includes patient notice of the refrain policy not to disclose without consent, and revocation rights. https://www.ncsacw.samhsa.gov/files/SI_ConsentForReleaseAndExchange.PDF */
    Squaxin,
    /** # ssa-827

SSA Authorization to Disclose. SA Form SSA-827 (Authorization to Disclose Information to the Social Security Administration (SSA)). Form is available at https://www.socialsecurity.gov/forms/ssa-827-inst-sp.pdf */
    Ssa827,
    /** # va-10-0484

VA Form 10-0484. VA Form 10-0484 Revocation for Release of Individually-Identifiable Health Information enables a veteran to revoke authorization for the VA to release specified copies of individually-identifiable health information with the non-VA health care provider organizations participating in the eHealth Exchange and partnering with VA. Comment: Opt-in Consent Directive with status = rescinded (aka 'revoked'). Note: Form is available at http://www.va.gov/vaforms/medical/pdf/vha-10-0484-fill.pdf */
    Va100484,
    /** # va-10-0485

VA Form 10-0485. VA Form 10-0485 Request for and Authorization to Release Protected Health Information to eHealth Exchange enables a veteran to request and authorize a VA health care facility to release protected health information (PHI) for treatment purposes only to the communities that are participating in the eHealth Exchange, VLER Directive, and other Health Information Exchanges with who VA has an agreement. This information may consist of the diagnosis of Sickle Cell Anemia, the treatment of or referral for Drug Abuse, treatment of or referral for Alcohol Abuse or the treatment of or testing for infection with Human Immunodeficiency Virus. This authorization covers the diagnoses that I may have upon signing of the authorization and the diagnoses that I may acquire in the future including those protected by 38 U.S.C. 7332. Comment: Opt-in Consent Directive. Note: Form is available at http://www.va.gov/vaforms/medical/pdf/10-0485-fill.pdf */
    Va100485,
    /** # va-10-10116

VA Form 10-10-10116. VA Form 10-10116 Revocation of Authorization for Use and Release of Individually Identifiable Health Information for Veterans Health Administration Research. Comment: Opt-in with Restriction Consent Directive with status = 'completed'. Note: Form is available at http://www.northerncalifornia.va.gov/northerncalifornia/services/rnd/docs/vha-10-10116.pdf */
    Va1010116,
    /** # va-10-5345

VA Form 10-5345. VA Form 10-5345 Request for and Authorization to Release Medical Records or Health Information enables a veteran to request and authorize the VA to release specified copies of protected health information (PHI), such as hospital summary or outpatient treatment notes, which may include information about conditions governed under Title 38 Section 7332 (drug abuse, alcoholism or alcohol abuse, testing for or infection with HIV, and sickle cell anemia). Comment: Opt-in Consent Directive. Note: Form is available at http://www.va.gov/vaforms/medical/pdf/vha-10-5345-fill.pdf */
    Va105345,
    /** # va-10-5345a

VA Form 10-5345a. VA Form 10-5345a Individuals' Request for a Copy of Their Own Health Information enables a veteran to request and authorize the VA to release specified copies of protected health information (PHI), such as hospital summary or outpatient treatment notes. Note: Form is available at http://www.va.gov/vaforms/medical/pdf/vha-10-5345a-fill.pdf */
    Va105345A,
    /** # va-10-5345a-mhv

VA Form 10-5345a-MHV. VA Form 10-5345a-MHV Individual's Request for a Copy of their own health information from MyHealtheVet enables a veteran to receive a copy of all available personal health information to be delivered through the veteran's My HealtheVet account. Note: Form is available at http://www.va.gov/vaforms/medical/pdf/vha-10-5345a-MHV-fill.pdf */
    Va105345AMhv,
    /** # va-21-4142

VA Form 21-4142. VA Form 21-4142 (Authorization and Consent to Release Information to the Department of Veterans Affairs (VA) enables a veteran to authorize the US Veterans Administration [VA] to request veteran's health information from non-VA providers. Aka VA Compensation Application Note: Form is available at http://www.vba.va.gov/pubs/forms/VBA-21-4142-ARE.pdf . For additional information regarding VA Form 21-4142, refer to the following website: www.benefits.va.gov/compensation/consent_privateproviders */
    Va214142,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PolicyCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "at-elga" => Ok(Self::AtElga),
            "cric" => Ok(Self::Cric),
            "dch-3927" => Ok(Self::Dch3927),
            "ga4gh" => Ok(Self::Ga4Gh),
            "hipaa-auth" => Ok(Self::HipaaAuth),
            "hipaa-npp" => Ok(Self::HipaaNpp),
            "hipaa-research" => Ok(Self::HipaaResearch),
            "hipaa-restrictions" => Ok(Self::HipaaRestrictions),
            "hipaa-self-pay" => Ok(Self::HipaaSelfPay),
            "illinois-minor-procedure" => Ok(Self::IllinoisMinorProcedure),
            "mdhhs-5515" => Ok(Self::Mdhhs5515),
            "nci" => Ok(Self::Nci),
            "nih-527" => Ok(Self::Nih527),
            "nih-grdr" => Ok(Self::NihGrdr),
            "nih-hipaa" => Ok(Self::NihHipaa),
            "nl-lsp" => Ok(Self::NlLsp),
            "nyssipp" => Ok(Self::Nyssipp),
            "squaxin" => Ok(Self::Squaxin),
            "ssa-827" => Ok(Self::Ssa827),
            "va-10-0484" => Ok(Self::Va100484),
            "va-10-0485" => Ok(Self::Va100485),
            "va-10-10116" => Ok(Self::Va1010116),
            "va-10-5345" => Ok(Self::Va105345),
            "va-10-5345a" => Ok(Self::Va105345A),
            "va-10-5345a-mhv" => Ok(Self::Va105345AMhv),
            "va-21-4142" => Ok(Self::Va214142),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PolicyCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::AtElga => "at-elga",
            Self::Cric => "cric",
            Self::Dch3927 => "dch-3927",
            Self::Ga4Gh => "ga4gh",
            Self::HipaaAuth => "hipaa-auth",
            Self::HipaaNpp => "hipaa-npp",
            Self::HipaaResearch => "hipaa-research",
            Self::HipaaRestrictions => "hipaa-restrictions",
            Self::HipaaSelfPay => "hipaa-self-pay",
            Self::IllinoisMinorProcedure => "illinois-minor-procedure",
            Self::Mdhhs5515 => "mdhhs-5515",
            Self::Nci => "nci",
            Self::Nih527 => "nih-527",
            Self::NihGrdr => "nih-grdr",
            Self::NihHipaa => "nih-hipaa",
            Self::NlLsp => "nl-lsp",
            Self::Nyssipp => "nyssipp",
            Self::Squaxin => "squaxin",
            Self::Ssa827 => "ssa-827",
            Self::Va100484 => "va-10-0484",
            Self::Va100485 => "va-10-0485",
            Self::Va1010116 => "va-10-10116",
            Self::Va105345 => "va-10-5345",
            Self::Va105345A => "va-10-5345a",
            Self::Va105345AMhv => "va-10-5345a-mhv",
            Self::Va214142 => "va-21-4142",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for PolicyCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PolicyCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PriorityCodes`. This value set includes the financial processing priority codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PriorityCodes {
    /** # deferred

Deferred. Later, when possible. */
    Deferred,
    /** # normal

Normal. With best effort. */
    Normal,
    /** # stat

Immediate. Immediately in real time. */
    Stat,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for PriorityCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deferred" => Ok(Self::Deferred),
            "normal" => Ok(Self::Normal),
            "stat" => Ok(Self::Stat),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for PriorityCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deferred => "deferred",
            Self::Normal => "normal",
            Self::Stat => "stat",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for PriorityCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PriorityCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProcedureDeviceActionCodes`. Example value set for Procedure Device Action code (what happened to a device during a procedure.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ProcedureDeviceActionCodes {
    /** # explanted

Explanted. The device was explanted from the patient during the procedure. */
    Explanted,
    /** # implanted

Implanted. The device was implanted in the patient during the procedure. */
    Implanted,
    /** # manipulated

Manipulated. The device remains in the patient, but its location, settings, or functionality was changed. */
    Manipulated,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ProcedureDeviceActionCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "explanted" => Ok(Self::Explanted),
            "implanted" => Ok(Self::Implanted),
            "manipulated" => Ok(Self::Manipulated),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ProcedureDeviceActionCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Explanted => "explanted",
            Self::Implanted => "implanted",
            Self::Manipulated => "manipulated",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ProcedureDeviceActionCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProcedureDeviceActionCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProcedureProgressStatusCodes`. This value set is provided as an exemplar. The value set to instantiate this attribute should be drawn from a terminologically robust code system that consists of or contains concepts to support the procedure performance process.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ProcedureProgressStatusCodes {
    /** # anesthesia-induced

Anesthesia Induced. The patient is under anesthesia. */
    AnesthesiaInduced,
    /** # closed-incision

Closed Incision. The patient has incision(s) closed. */
    ClosedIncision,
    /** # in-operating-room

In Operating Room. A patient is in the Operating Room. */
    InOperatingRoom,
    /** # in-recovery-room

In Recovery Room. The patient is in the recovery room. */
    InRecoveryRoom,
    /** # open-incision

Open Incision. The patient has open incision(s). */
    OpenIncision,
    /** # prepared

Prepared. The patient is prepared for a procedure. */
    Prepared,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ProcedureProgressStatusCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "anesthesia-induced" => Ok(Self::AnesthesiaInduced),
            "closed-incision" => Ok(Self::ClosedIncision),
            "in-operating-room" => Ok(Self::InOperatingRoom),
            "in-recovery-room" => Ok(Self::InRecoveryRoom),
            "open-incision" => Ok(Self::OpenIncision),
            "prepared" => Ok(Self::Prepared),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ProcedureProgressStatusCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::AnesthesiaInduced => "anesthesia-induced",
            Self::ClosedIncision => "closed-incision",
            Self::InOperatingRoom => "in-operating-room",
            Self::InRecoveryRoom => "in-recovery-room",
            Self::OpenIncision => "open-incision",
            Self::Prepared => "prepared",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ProcedureProgressStatusCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProcedureProgressStatusCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProductConfidentiality`. Confidentiality rating, e.g. commercial sensitivity for a Medicinal Product.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductConfidentiality {
    /** # CommerciallySensitive

Commercially Sensitive. Commercially Sensitive */
    CommerciallySensitive,
    /** # NotCommerciallySensitive

Not Commercially Sensitive. Not Commercially Sensitive */
    NotCommerciallySensitive,
}
impl ::core::str::FromStr for ProductConfidentiality {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CommerciallySensitive" => Ok(Self::CommerciallySensitive),
            "NotCommerciallySensitive" => Ok(Self::NotCommerciallySensitive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductConfidentiality {
    fn as_ref(&self) -> &str {
        match self {
            Self::CommerciallySensitive => "CommerciallySensitive",
            Self::NotCommerciallySensitive => "NotCommerciallySensitive",
        }
    }
}
impl<'de> Deserialize<'de> for ProductConfidentiality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductConfidentiality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProductContactType`. Contact type for a Medicinal Product.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductContactType {
    /** # PVEnquiries

Pharmacovigilance Enquiry Information. Pharmacovigilance Enquiry Information */
    Pvenquiries,
    /** # ProcedureContactAfter

Person/Company authorised for Communication after procedure. Person/Company authorised for Communication between MAH and Authorities after Authorisation */
    ProcedureContactAfter,
    /** # ProcedureContactDuring

Person/Company authorised for Communication during procedure. Person/Company authorised for Communication on behalf of the Applicant during the Procedure */
    ProcedureContactDuring,
    /** # ProposedMAH

Proposed Marketing Authorisation Holder/Person. Proposed Marketing Authorisation Holder/Person */
    ProposedMAH,
    /** # QPPV

Qualified Person Responsible for Pharmacovigilance. Qualified Person Responsible for Pharmacovigilance */
    Qppv,
}
impl ::core::str::FromStr for ProductContactType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "PVEnquiries" => Ok(Self::Pvenquiries),
            "ProcedureContactAfter" => Ok(Self::ProcedureContactAfter),
            "ProcedureContactDuring" => Ok(Self::ProcedureContactDuring),
            "ProposedMAH" => Ok(Self::ProposedMAH),
            "QPPV" => Ok(Self::Qppv),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductContactType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Pvenquiries => "PVEnquiries",
            Self::ProcedureContactAfter => "ProcedureContactAfter",
            Self::ProcedureContactDuring => "ProcedureContactDuring",
            Self::ProposedMAH => "ProposedMAH",
            Self::Qppv => "QPPV",
        }
    }
}
impl<'de> Deserialize<'de> for ProductContactType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductContactType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProductCrossReferenceType`. Relationship to another Medicinal Product.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductCrossReferenceType {
    /** # ActualProduct

Link Virtual to Actual Product. Link Virtual to Actual Product */
    ActualProduct,
    /** # BrandedProduct

Link Generic to Branded Product. Link Generic to Branded Product */
    BrandedProduct,
    /** # GenericProduct

Link Branded to Generic Product. Link Branded to Generic Product */
    GenericProduct,
    /** # InvestigationalProduct

Link to Investigational Product. Link to Investigational (Development) Product */
    InvestigationalProduct,
    /** # Parallel

Link to Parallel Import Product. Link to Parallel Import Product */
    Parallel,
    /** # VirtualProduct

Link Actual to Virtual Product. Link Actual to Virtual Product */
    VirtualProduct,
}
impl ::core::str::FromStr for ProductCrossReferenceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActualProduct" => Ok(Self::ActualProduct),
            "BrandedProduct" => Ok(Self::BrandedProduct),
            "GenericProduct" => Ok(Self::GenericProduct),
            "InvestigationalProduct" => Ok(Self::InvestigationalProduct),
            "Parallel" => Ok(Self::Parallel),
            "VirtualProduct" => Ok(Self::VirtualProduct),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductCrossReferenceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActualProduct => "ActualProduct",
            Self::BrandedProduct => "BrandedProduct",
            Self::GenericProduct => "GenericProduct",
            Self::InvestigationalProduct => "InvestigationalProduct",
            Self::Parallel => "Parallel",
            Self::VirtualProduct => "VirtualProduct",
        }
    }
}
impl<'de> Deserialize<'de> for ProductCrossReferenceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductCrossReferenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProductIntendedUse`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductIntendedUse {
    /** # Alleviation

Alleviation. */
    Alleviation,
    /** # Diagnosis

Diagnosis. */
    Diagnosis,
    /** # Monitoring

Monitoring. */
    Monitoring,
    /** # Prevention

Prevention. */
    Prevention,
    /** # Treatment

Treatment. */
    Treatment,
}
impl ::core::str::FromStr for ProductIntendedUse {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Alleviation" => Ok(Self::Alleviation),
            "Diagnosis" => Ok(Self::Diagnosis),
            "Monitoring" => Ok(Self::Monitoring),
            "Prevention" => Ok(Self::Prevention),
            "Treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductIntendedUse {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alleviation => "Alleviation",
            Self::Diagnosis => "Diagnosis",
            Self::Monitoring => "Monitoring",
            Self::Prevention => "Prevention",
            Self::Treatment => "Treatment",
        }
    }
}
impl<'de> Deserialize<'de> for ProductIntendedUse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductIntendedUse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProductNamePartType`. Type of part of a name for a Medicinal Product.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductNamePartType {
    /** # ContainerPart

Container or pack part. */
    ContainerPart,
    /** # DelimiterPart

Delimiter part. */
    DelimiterPart,
    /** # DevicePart

Device part. */
    DevicePart,
    /** # DoseFormPart

Pharmaceutical dose form part. */
    DoseFormPart,
    /** # FlavorPart

Flavor part. */
    FlavorPart,
    /** # FormulationPart

Formulation part. */
    FormulationPart,
    /** # FullName

Full name. */
    FullName,
    /** # IntendedUsePart

Intended use part. */
    IntendedUsePart,
    /** # InventedNamePart

Invented name part. */
    InventedNamePart,
    /** # LegacyNamePart

Legacy name. */
    LegacyNamePart,
    /** # PopulationPart

Target population part. */
    PopulationPart,
    /** # ScientificNamePart

Scientific name part. */
    ScientificNamePart,
    /** # SpeciesNamePart

Target species name part. */
    SpeciesNamePart,
    /** # StrengthPart

Strength part. */
    StrengthPart,
    /** # TimeOrPeriodPart

Time/Period part. */
    TimeOrPeriodPart,
    /** # TrademarkOrCompanyPart

Trademark or company name part. */
    TrademarkOrCompanyPart,
}
impl ::core::str::FromStr for ProductNamePartType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ContainerPart" => Ok(Self::ContainerPart),
            "DelimiterPart" => Ok(Self::DelimiterPart),
            "DevicePart" => Ok(Self::DevicePart),
            "DoseFormPart" => Ok(Self::DoseFormPart),
            "FlavorPart" => Ok(Self::FlavorPart),
            "FormulationPart" => Ok(Self::FormulationPart),
            "FullName" => Ok(Self::FullName),
            "IntendedUsePart" => Ok(Self::IntendedUsePart),
            "InventedNamePart" => Ok(Self::InventedNamePart),
            "LegacyNamePart" => Ok(Self::LegacyNamePart),
            "PopulationPart" => Ok(Self::PopulationPart),
            "ScientificNamePart" => Ok(Self::ScientificNamePart),
            "SpeciesNamePart" => Ok(Self::SpeciesNamePart),
            "StrengthPart" => Ok(Self::StrengthPart),
            "TimeOrPeriodPart" => Ok(Self::TimeOrPeriodPart),
            "TrademarkOrCompanyPart" => Ok(Self::TrademarkOrCompanyPart),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductNamePartType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ContainerPart => "ContainerPart",
            Self::DelimiterPart => "DelimiterPart",
            Self::DevicePart => "DevicePart",
            Self::DoseFormPart => "DoseFormPart",
            Self::FlavorPart => "FlavorPart",
            Self::FormulationPart => "FormulationPart",
            Self::FullName => "FullName",
            Self::IntendedUsePart => "IntendedUsePart",
            Self::InventedNamePart => "InventedNamePart",
            Self::LegacyNamePart => "LegacyNamePart",
            Self::PopulationPart => "PopulationPart",
            Self::ScientificNamePart => "ScientificNamePart",
            Self::SpeciesNamePart => "SpeciesNamePart",
            Self::StrengthPart => "StrengthPart",
            Self::TimeOrPeriodPart => "TimeOrPeriodPart",
            Self::TrademarkOrCompanyPart => "TrademarkOrCompanyPart",
        }
    }
}
impl<'de> Deserialize<'de> for ProductNamePartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductNamePartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProductNameType`. Type of a name for a Medicinal Product.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProductNameType {
    /** # BAN

British Approved Name. */
    Ban,
    /** # INN

International Non-Proprietary Name. */
    Inn,
    /** # INNM

Modified International Non-Proprietary Name. */
    Innm,
    /** # pINN

Proposed International Non-Proprietary Name. */
    Pinn,
    /** # rINN

Recommended International Non-Proprietary Name. */
    Rinn,
}
impl ::core::str::FromStr for ProductNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BAN" => Ok(Self::Ban),
            "INN" => Ok(Self::Inn),
            "INNM" => Ok(Self::Innm),
            "pINN" => Ok(Self::Pinn),
            "rINN" => Ok(Self::Rinn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProductNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ban => "BAN",
            Self::Inn => "INN",
            Self::Innm => "INNM",
            Self::Pinn => "pINN",
            Self::Rinn => "rINN",
        }
    }
}
impl<'de> Deserialize<'de> for ProductNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProductNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `Program`. This value set defines an example set of codes for health program names that could exist for various jurisdictions.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Program {
    /** # 1

Acquired Brain Injury (ABI) Program . */
    N1,
    /** # 10

Cognitive Dementia Memory Service (CDAMS). */
    N10,
    /** # 11

ChildFIRST. */
    N11,
    /** # 12

Children's Contact Services. */
    N12,
    /** # 13

Community Visitors Scheme. */
    N13,
    /** # 14

CPP (Community Partners Program). */
    N14,
    /** # 15

Closing the Gap (CTG). */
    N15,
    /** # 16

Coordinated Veterans' Care (CVC) Program. */
    N16,
    /** # 17

Day Program. */
    N17,
    /** # 18

Drop In Program. */
    N18,
    /** # 19

Early Years Program. */
    N19,
    /** # 2

ABI Slow To Recover (ABI STR) Program. */
    N2,
    /** # 20

Employee Assistance Program. */
    N20,
    /** # 21

Home And Community Care (HACC). */
    N21,
    /** # 22

Hospital Admission Risk Program (HARP). */
    N22,
    /** # 23

Hospital in the Home (HITH) Program. */
    N23,
    /** # 24

ICTP (Intensive Community Treatment Program). */
    N24,
    /** # 25

IFSS (Intensive Family Support Program). */
    N25,
    /** # 26

JPET (Job Placement, Education and Training). */
    N26,
    /** # 27

Koori Juvenile Justice Program. */
    N27,
    /** # 28

Language Literacy and Numeracy Program. */
    N28,
    /** # 29

Life Skills Program. */
    N29,
    /** # 3

Access Programs. */
    N3,
    /** # 30

LMP (Lifestyle Modification Program). */
    N30,
    /** # 31

MedsCheck Program. */
    N31,
    /** # 32

Methadone/Buprenorphine Program. */
    N32,
    /** # 33

National Disabilities Insurance Scheme (NDIS). */
    N33,
    /** # 34

National Diabetes Services Scheme (NDSS). */
    N34,
    /** # 35

Needle/Syringe Program. */
    N35,
    /** # 36

nPEP Program. */
    N36,
    /** # 37

Personal Support Program. */
    N37,
    /** # 38

Partners in Recovery (PIR) Program. */
    N38,
    /** # 39

Pre-employment Program. */
    N39,
    /** # 4

Adult and Further Education (ACFE) Program. */
    N4,
    /** # 40

Reconnect Program. */
    N40,
    /** # 41

Sexual Abuse Counselling and Prevention Program (SACPP). */
    N41,
    /** # 42

Social Support Programs. */
    N42,
    /** # 43

Supported Residential Service (SRS). */
    N43,
    /** # 44

Tasmanian Aboriginal Centre (TAC). */
    N44,
    /** # 45

Victim's Assistance Program. */
    N45,
    /** # 5

Adult Day Activity and Support Services (ADASS) Program. */
    N5,
    /** # 6

Adult Day Care Program. */
    N6,
    /** # 7

ATSS (Adult Training Support Service). */
    N7,
    /** # 8

Community Aged Care Packages (CACP). */
    N8,
    /** # 9

Care Coordination & Supplementary Services (CCSS). */
    N9,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for Program {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "10" => Ok(Self::N10),
            "11" => Ok(Self::N11),
            "12" => Ok(Self::N12),
            "13" => Ok(Self::N13),
            "14" => Ok(Self::N14),
            "15" => Ok(Self::N15),
            "16" => Ok(Self::N16),
            "17" => Ok(Self::N17),
            "18" => Ok(Self::N18),
            "19" => Ok(Self::N19),
            "2" => Ok(Self::N2),
            "20" => Ok(Self::N20),
            "21" => Ok(Self::N21),
            "22" => Ok(Self::N22),
            "23" => Ok(Self::N23),
            "24" => Ok(Self::N24),
            "25" => Ok(Self::N25),
            "26" => Ok(Self::N26),
            "27" => Ok(Self::N27),
            "28" => Ok(Self::N28),
            "29" => Ok(Self::N29),
            "3" => Ok(Self::N3),
            "30" => Ok(Self::N30),
            "31" => Ok(Self::N31),
            "32" => Ok(Self::N32),
            "33" => Ok(Self::N33),
            "34" => Ok(Self::N34),
            "35" => Ok(Self::N35),
            "36" => Ok(Self::N36),
            "37" => Ok(Self::N37),
            "38" => Ok(Self::N38),
            "39" => Ok(Self::N39),
            "4" => Ok(Self::N4),
            "40" => Ok(Self::N40),
            "41" => Ok(Self::N41),
            "42" => Ok(Self::N42),
            "43" => Ok(Self::N43),
            "44" => Ok(Self::N44),
            "45" => Ok(Self::N45),
            "5" => Ok(Self::N5),
            "6" => Ok(Self::N6),
            "7" => Ok(Self::N7),
            "8" => Ok(Self::N8),
            "9" => Ok(Self::N9),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for Program {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N10 => "10",
            Self::N11 => "11",
            Self::N12 => "12",
            Self::N13 => "13",
            Self::N14 => "14",
            Self::N15 => "15",
            Self::N16 => "16",
            Self::N17 => "17",
            Self::N18 => "18",
            Self::N19 => "19",
            Self::N2 => "2",
            Self::N20 => "20",
            Self::N21 => "21",
            Self::N22 => "22",
            Self::N23 => "23",
            Self::N24 => "24",
            Self::N25 => "25",
            Self::N26 => "26",
            Self::N27 => "27",
            Self::N28 => "28",
            Self::N29 => "29",
            Self::N3 => "3",
            Self::N30 => "30",
            Self::N31 => "31",
            Self::N32 => "32",
            Self::N33 => "33",
            Self::N34 => "34",
            Self::N35 => "35",
            Self::N36 => "36",
            Self::N37 => "37",
            Self::N38 => "38",
            Self::N39 => "39",
            Self::N4 => "4",
            Self::N40 => "40",
            Self::N41 => "41",
            Self::N42 => "42",
            Self::N43 => "43",
            Self::N44 => "44",
            Self::N45 => "45",
            Self::N5 => "5",
            Self::N6 => "6",
            Self::N7 => "7",
            Self::N8 => "8",
            Self::N9 => "9",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for Program {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Program {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PropertyRepresentation`. How a property is represented when serialized.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PropertyRepresentation {
    /** # cdaText

CDA Text Format. Use CDA narrative instead of XHTML. */
    CdaText,
    /** # typeAttr

Type Attribute. The type of this element is indicated using xsi:type. */
    TypeAttr,
    /** # xhtml

XHTML. The property is represented using XHTML. */
    Xhtml,
    /** # xmlAttr

XML Attribute. In XML, this property is represented as an attribute not an element. */
    XmlAttr,
    /** # xmlText

XML Text. This element is represented using the XML text attribute (primitives only). */
    XmlText,
}
impl ::core::str::FromStr for PropertyRepresentation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cdaText" => Ok(Self::CdaText),
            "typeAttr" => Ok(Self::TypeAttr),
            "xhtml" => Ok(Self::Xhtml),
            "xmlAttr" => Ok(Self::XmlAttr),
            "xmlText" => Ok(Self::XmlText),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PropertyRepresentation {
    fn as_ref(&self) -> &str {
        match self {
            Self::CdaText => "cdaText",
            Self::TypeAttr => "typeAttr",
            Self::Xhtml => "xhtml",
            Self::XmlAttr => "xmlAttr",
            Self::XmlText => "xmlText",
        }
    }
}
impl<'de> Deserialize<'de> for PropertyRepresentation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PropertyRepresentation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PropertyType`. The type of a property value.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PropertyType {
    /** # Coding

Coding (external reference). The property  value is a code defined in an external code system. This may be used for translations, but is not the intent. */
    Coding,
    /** # boolean

boolean. The property value is a boolean true | false. */
    Boolean,
    /** # code

code (internal reference). The property value is a code that identifies a concept defined in the code system. */
    Code,
    /** # dateTime

dateTime. The property is a date or a date + time. */
    DateTime,
    /** # decimal

decimal. The property value is a decimal number. */
    Decimal,
    /** # integer

integer. The property value is a string (often used to assign ranking values to concepts for supporting score assessments). */
    Integer,
    /** # string

string. The property value is a string. */
    String,
}
impl ::core::str::FromStr for PropertyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Coding" => Ok(Self::Coding),
            "boolean" => Ok(Self::Boolean),
            "code" => Ok(Self::Code),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "integer" => Ok(Self::Integer),
            "string" => Ok(Self::String),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PropertyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Coding => "Coding",
            Self::Boolean => "boolean",
            Self::Code => "code",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Integer => "integer",
            Self::String => "string",
        }
    }
}
impl<'de> Deserialize<'de> for PropertyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PropertyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProvenanceEntityRole`. How an entity was used in an activity.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProvenanceEntityRole {
    /** # derivation

Derivation. A transformation of an entity into another, an update of an entity resulting in a new one, or the construction of a new entity based on a pre-existing entity. */
    Derivation,
    /** # quotation

Quotation. The repeat of (some or all of) an entity, such as text or image, by someone who might or might not be its original author. */
    Quotation,
    /** # removal

Removal. A derivation for which the entity is removed from accessibility usually through the use of the Delete operation. */
    Removal,
    /** # revision

Revision. A derivation for which the resulting entity is a revised version of some original. */
    Revision,
    /** # source

Source. A primary source for a topic refers to something produced by some agent with direct experience and knowledge about the topic, at the time of the topic's study, without benefit from hindsight. */
    Source,
}
impl ::core::str::FromStr for ProvenanceEntityRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "derivation" => Ok(Self::Derivation),
            "quotation" => Ok(Self::Quotation),
            "removal" => Ok(Self::Removal),
            "revision" => Ok(Self::Revision),
            "source" => Ok(Self::Source),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProvenanceEntityRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Derivation => "derivation",
            Self::Quotation => "quotation",
            Self::Removal => "removal",
            Self::Revision => "revision",
            Self::Source => "source",
        }
    }
}
impl<'de> Deserialize<'de> for ProvenanceEntityRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProvenanceEntityRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProvenanceParticipantRole`. The role that a provenance participant played

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProvenanceParticipantRole {
    /** # assembler

Assembler. A device that operates independently of an author on custodian's algorithms for data extraction of existing information for purpose of generating a new artifact. */
    Assembler,
    /** # attester

Attester. A verifier who attests to the accuracy of the resource */
    Attester,
    /** # author

Author. A party that originates the resource and therefore has responsibility for the information given in the resource and ownership of this resource */
    Author,
    /** # composer

Composer. A device used by an author to record new information, which may also be used by the author to select existing information for aggregation with newly recorded information for the purpose of generating a new artifact. */
    Composer,
    /** # custodian

Custodian. The entity that is accountable for maintaining a true an accurate copy of the original record */
    Custodian,
    /** # enterer

Enterer. A person entering the data into the originating system */
    Enterer,
    /** # informant

Informant. A person who reported information that contributed to the resource */
    Informant,
    /** # legal

Legal Authenticator. The person authenticated the content and accepted legal responsibility for its content */
    Legal,
    /** # performer

Performer. A person, animal, organization or device that who actually and principally carries out the activity */
    Performer,
    /** # verifier

Verifier. A person who verifies the correctness and appropriateness of activity */
    Verifier,
}
impl ::core::str::FromStr for ProvenanceParticipantRole {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assembler" => Ok(Self::Assembler),
            "attester" => Ok(Self::Attester),
            "author" => Ok(Self::Author),
            "composer" => Ok(Self::Composer),
            "custodian" => Ok(Self::Custodian),
            "enterer" => Ok(Self::Enterer),
            "informant" => Ok(Self::Informant),
            "legal" => Ok(Self::Legal),
            "performer" => Ok(Self::Performer),
            "verifier" => Ok(Self::Verifier),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProvenanceParticipantRole {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assembler => "assembler",
            Self::Attester => "attester",
            Self::Author => "author",
            Self::Composer => "composer",
            Self::Custodian => "custodian",
            Self::Enterer => "enterer",
            Self::Informant => "informant",
            Self::Legal => "legal",
            Self::Performer => "performer",
            Self::Verifier => "verifier",
        }
    }
}
impl<'de> Deserialize<'de> for ProvenanceParticipantRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProvenanceParticipantRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ProvenanceParticipantType`. The type of participation that a provenance agent (participant) played

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ProvenanceParticipantType {
    /** # assembler

Assembler. A device that operates independently of an author on custodian's algorithms for data extraction of existing information for purpose of generating a new artifact. */
    Assembler,
    /** # attester

Attester. A verifier who attests to the accuracy of the resource */
    Attester,
    /** # author

Author. A party that originates the resource and therefore has responsibility for the information given in the resource and ownership of this resource */
    Author,
    /** # composer

Composer. A device used by an author to record new information, which may also be used by the author to select existing information for aggregation with newly recorded information for the purpose of generating a new artifact. */
    Composer,
    /** # custodian

Custodian. The entity that is accountable for maintaining a true an accurate copy of the original record */
    Custodian,
    /** # enterer

Enterer. A person entering the data into the originating system */
    Enterer,
    /** # informant

Informant. A person who reported information that contributed to the resource */
    Informant,
    /** # legal

Legal Authenticator. The person authenticated the content and accepted legal responsibility for its content */
    Legal,
    /** # performer

Performer. A person, animal, organization or device that who actually and principally carries out the activity */
    Performer,
    /** # verifier

Verifier. A person who verifies the correctness and appropriateness of activity */
    Verifier,
}
impl ::core::str::FromStr for ProvenanceParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "assembler" => Ok(Self::Assembler),
            "attester" => Ok(Self::Attester),
            "author" => Ok(Self::Author),
            "composer" => Ok(Self::Composer),
            "custodian" => Ok(Self::Custodian),
            "enterer" => Ok(Self::Enterer),
            "informant" => Ok(Self::Informant),
            "legal" => Ok(Self::Legal),
            "performer" => Ok(Self::Performer),
            "verifier" => Ok(Self::Verifier),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ProvenanceParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assembler => "assembler",
            Self::Attester => "attester",
            Self::Author => "author",
            Self::Composer => "composer",
            Self::Custodian => "custodian",
            Self::Enterer => "enterer",
            Self::Informant => "informant",
            Self::Legal => "legal",
            Self::Performer => "performer",
            Self::Verifier => "verifier",
        }
    }
}
impl<'de> Deserialize<'de> for ProvenanceParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ProvenanceParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PublicationStatus`. The lifecycle status of an artifact.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PublicationStatus {
    /** # active

Active. This resource is ready for normal use. */
    Active,
    /** # draft

Draft. This resource is still under development and is not yet considered to be ready for normal use. */
    Draft,
    /** # retired

Retired. This resource has been withdrawn or superseded and should no longer be used. */
    Retired,
    /** # unknown

Unknown. The authoring system does not know which of the status values currently applies for this resource.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, it's just not known which one. */
    Unknown,
}
impl ::core::str::FromStr for PublicationStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "draft" => Ok(Self::Draft),
            "retired" => Ok(Self::Retired),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PublicationStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Draft => "draft",
            Self::Retired => "retired",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for PublicationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PublicationStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `PublishedInType`. The type of publication such as book, database, or journal.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum PublishedInType {
    /** # D001877

Book. Non-periodical written or printed works consisting of sheets of pages fastened or bound together within covers. */
    D001877,
    /** # D019991

Database. A structured file of information or a set of logically related data stored and retrieved using computer-based means. */
    D019991,
    /** # D020492

Periodical. Publication intended to be issued on an ongoing basis, generally more frequently than annually, containing separate articles, stories, or writings. */
    D020492,
    /** # D064886

Dataset. Works consisting of organized collections of data, which have been stored permanently in a formalized manner suitable for communication, interpretation, or processing. */
    D064886,
}
impl ::core::str::FromStr for PublishedInType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "D001877" => Ok(Self::D001877),
            "D019991" => Ok(Self::D019991),
            "D020492" => Ok(Self::D020492),
            "D064886" => Ok(Self::D064886),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for PublishedInType {
    fn as_ref(&self) -> &str {
        match self {
            Self::D001877 => "D001877",
            Self::D019991 => "D019991",
            Self::D020492 => "D020492",
            Self::D064886 => "D064886",
        }
    }
}
impl<'de> Deserialize<'de> for PublishedInType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for PublishedInType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `QualityOfEvidenceRating`. A rating system that describes the quality of evidence such as the GRADE, DynaMed, or Oxford CEBM systems.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QualityOfEvidenceRating {
    /** # high

High quality. High quality evidence. */
    High,
    /** # low

Low quality. Low quality evidence. */
    Low,
    /** # moderate

Moderate quality. Moderate quality evidence. */
    Moderate,
    /** # very-low

Very low quality. Very low quality evidence. */
    VeryLow,
}
impl ::core::str::FromStr for QualityOfEvidenceRating {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            "very-low" => Ok(Self::VeryLow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QualityOfEvidenceRating {
    fn as_ref(&self) -> &str {
        match self {
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
            Self::VeryLow => "very-low",
        }
    }
}
impl<'de> Deserialize<'de> for QualityOfEvidenceRating {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QualityOfEvidenceRating {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `QuantityComparator`. How the Quantity should be understood and represented.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuantityComparator {
    /** # <

Less than. The actual value is less than the given value. */
    Less,
    /** # <=

Less or Equal to. The actual value is less than or equal to the given value. */
    LessOrEqual,
    /** # >

Greater than. The actual value is greater than the given value. */
    Greater,
    /** # >=

Greater or Equal to. The actual value is greater than or equal to the given value. */
    GreaterOrEqual,
}
impl ::core::str::FromStr for QuantityComparator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "<" => Ok(Self::Less),
            "<=" => Ok(Self::LessOrEqual),
            ">" => Ok(Self::Greater),
            ">=" => Ok(Self::GreaterOrEqual),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuantityComparator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Less => "<",
            Self::LessOrEqual => "<=",
            Self::Greater => ">",
            Self::GreaterOrEqual => ">=",
        }
    }
}
impl<'de> Deserialize<'de> for QuantityComparator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuantityComparator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `QuestionnaireItemOperator`. The criteria by which a question is enabled.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuestionnaireItemOperator {
    /** # !=

Not Equals. True if whether at least no answer has a value that is equal to the enableWhen answer. */
    NotEqual,
    /** # <

Less Than. True if whether at least no answer has a value that is less than the enableWhen answer. */
    Less,
    /** # <=

Less or Equals. True if whether at least no answer has a value that is less or equal to the enableWhen answer. */
    LessOrEqual,
    /** # =

Equals. True if whether at least one answer has a value that is equal to the enableWhen answer. */
    Equal,
    /** # >

Greater Than. True if whether at least no answer has a value that is greater than the enableWhen answer. */
    Greater,
    /** # >=

Greater or Equals. True if whether at least no answer has a value that is greater or equal to the enableWhen answer. */
    GreaterOrEqual,
    /** # exists

Exists. True if whether an answer exists is equal to the enableWhen answer (which must be a boolean). */
    Exists,
}
impl ::core::str::FromStr for QuestionnaireItemOperator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "!=" => Ok(Self::NotEqual),
            "<" => Ok(Self::Less),
            "<=" => Ok(Self::LessOrEqual),
            "=" => Ok(Self::Equal),
            ">" => Ok(Self::Greater),
            ">=" => Ok(Self::GreaterOrEqual),
            "exists" => Ok(Self::Exists),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemOperator {
    fn as_ref(&self) -> &str {
        match self {
            Self::NotEqual => "!=",
            Self::Less => "<",
            Self::LessOrEqual => "<=",
            Self::Equal => "=",
            Self::Greater => ">",
            Self::GreaterOrEqual => ">=",
            Self::Exists => "exists",
        }
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemOperator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `QuestionnaireItemType`. Distinguishes groups from questions and display text and indicates data type for questions.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuestionnaireItemType {
    /** # attachment

Attachment. Question with binary content such as an image, PDF, etc. as an answer (valueAttachment). */
    Attachment,
    /** # boolean

Boolean. Question with a yes/no answer (valueBoolean). */
    Boolean,
    /** # choice

Choice. Question with a Coding drawn from a list of possible answers (specified in either the answerOption property, or via the valueset referenced in the answerValueSet property) as an answer (valueCoding). */
    Choice,
    /** # date

Date. Question with a date answer (valueDate). */
    Date,
    /** # dateTime

Date Time. Question with a date and time answer (valueDateTime). */
    DateTime,
    /** # decimal

Decimal. Question with is a real number answer (valueDecimal). */
    Decimal,
    /** # display

Display. Text for display that will not capture an answer or have child items. */
    Display,
    /** # group

Group. An item with no direct answer but should have at least one child item. */
    Group,
    /** # integer

Integer. Question with an integer answer (valueInteger). */
    Integer,
    /** # open-choice

Open Choice. Answer is a Coding drawn from a list of possible answers (as with the choice type) or a free-text entry in a string (valueCoding or valueString). */
    OpenChoice,
    /** # quantity

Quantity. Question with a combination of a numeric value and unit, potentially with a comparator (<, >, etc.) as an answer. (valueQuantity) There is an extension 'http://hl7.org/fhir/StructureDefinition/questionnaire-unit' that can be used to define what unit should be captured (or the unit that has a ucum conversion from the provided unit). */
    Quantity,
    /** # question

Question. An item that defines a specific answer to be captured, and which may have child items. (the answer provided in the QuestionnaireResponse should be of the defined datatype). */
    Question,
    /** # reference

Reference. Question with a reference to another resource (practitioner, organization, etc.) as an answer (valueReference). */
    Reference,
    /** # string

String. Question with a short (few words to short sentence) free-text entry answer (valueString). */
    String,
    /** # text

Text. Question with a long (potentially multi-paragraph) free-text entry answer (valueString). */
    Text,
    /** # time

Time. Question with a time (hour:minute:second) answer independent of date. (valueTime). */
    Time,
    /** # url

Url. Question with a URL (website, FTP site, etc.) answer (valueUri). */
    Url,
}
impl ::core::str::FromStr for QuestionnaireItemType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "attachment" => Ok(Self::Attachment),
            "boolean" => Ok(Self::Boolean),
            "choice" => Ok(Self::Choice),
            "date" => Ok(Self::Date),
            "dateTime" => Ok(Self::DateTime),
            "decimal" => Ok(Self::Decimal),
            "display" => Ok(Self::Display),
            "group" => Ok(Self::Group),
            "integer" => Ok(Self::Integer),
            "open-choice" => Ok(Self::OpenChoice),
            "quantity" => Ok(Self::Quantity),
            "question" => Ok(Self::Question),
            "reference" => Ok(Self::Reference),
            "string" => Ok(Self::String),
            "text" => Ok(Self::Text),
            "time" => Ok(Self::Time),
            "url" => Ok(Self::Url),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Attachment => "attachment",
            Self::Boolean => "boolean",
            Self::Choice => "choice",
            Self::Date => "date",
            Self::DateTime => "dateTime",
            Self::Decimal => "decimal",
            Self::Display => "display",
            Self::Group => "group",
            Self::Integer => "integer",
            Self::OpenChoice => "open-choice",
            Self::Quantity => "quantity",
            Self::Question => "question",
            Self::Reference => "reference",
            Self::String => "string",
            Self::Text => "text",
            Self::Time => "time",
            Self::Url => "url",
        }
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `QuestionnaireItemUIControlCodes`. Starter set of user interface control/display mechanisms that might be used when rendering an item in a questionnaire.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuestionnaireItemUIControlCodes {
    /** # atable

Answer Table. This table has one row - for the question.  Permitted answers are columns.  Used for choice questions. */
    Atable,
    /** # autocomplete

Auto-complete. A control which provides a list of potential matches based on text entered into a control.  Used for large choice sets where text-matching is an appropriate discovery mechanism. */
    Autocomplete,
    /** # check-box

Check-box. A control where choices are listed with a box beside them.  The box can be toggled to select or de-select a given choice.  Multiple selections may be possible. */
    CheckBox,
    /** # drop-down

Drop down. A control where an item (or multiple items) can be selected from a list that is only displayed when the user is editing the field. */
    DropDown,
    /** # flyover

Fly-over. Text is temporarily visible over top of an item if the mouse is positioned over top of the text for the containing item */
    Flyover,
    /** # footer

Footer. The group is to be continuously visible at the bottom of the questionnaire */
    Footer,
    /** # group

UI controls relevant to organizing groups of questions */
    Group,
    /** # gtable

Group Table. Questions within the group are columns in the table with each group repetition as a row.  Used for single-answer questions. */
    Gtable,
    /** # header

Header. The group is to be continuously visible at the top of the questionnaire */
    Header,
    /** # help

Help-Button. Text is displayed in a dialog box or similar control if invoked by pushing a button or some other UI-appropriate action to request 'help' for a question, group or the questionnaire as a whole (depending what the text is nested within) */
    Help,
    /** # htable

Horizontal Answer Table. Questions within the group are columns in the table with possible answers as rows.  Used for 'choice' questions. */
    Htable,
    /** # inline

In-line. Text is displayed as a paragraph in a sequential position between sibling items (default behavior) */
    Inline,
    /** # list

List. Questions within the group should be listed sequentially */
    List,
    /** # lookup

Lookup. A control where editing an item spawns a separate dialog box or screen permitting a user to navigate, filter or otherwise discover an appropriate match.  Useful for large choice sets where text matching is not an appropriate discovery mechanism.  Such screens must generally be tuned for the specific choice list structure. */
    Lookup,
    /** # lower

Lower-bound. Text is displayed to the left of the set of answer choices or a scaling control for the parent question item to indicate the meaning of the 'lower' bound.  E.g. 'Strongly disagree' */
    Lower,
    /** # prompt

Prompt. Text is displayed immediately below or within the answer-entry area of the containing question item (typically as a guide for what to enter) */
    Prompt,
    /** # question

UI controls relevant to capturing question data */
    Question,
    /** # radio-button

Radio Button. A control where choices are listed with a button beside them.  The button can be toggled to select or de-select a given choice.  Selecting one item deselects all others. */
    RadioButton,
    /** # slider

Slider. A control where an axis is displayed between the high and low values and the control can be visually manipulated to select a value anywhere on the axis. */
    Slider,
    /** # spinner

Spinner. A control where a list of numeric or other ordered values can be scrolled through via arrows. */
    Spinner,
    /** # table

Vertical Answer Table. Questions within the group are rows in the table with possible answers as columns.  Used for 'choice' questions. */
    Table,
    /** # text

UI controls relevant to rendering questionnaire text items */
    Text,
    /** # text-box

Text Box. A control where a user can type in their answer freely. */
    TextBox,
    /** # unit

Unit. Text is displayed adjacent (horizontally or vertically) to the answer space for the parent question, typically to indicate a unit of measure */
    Unit,
    /** # upper

Upper-bound. Text is displayed to the right of the set of answer choices or a scaling control for the parent question item to indicate the meaning of the 'upper' bound.  E.g. 'Strongly agree' */
    Upper,
}
impl ::core::str::FromStr for QuestionnaireItemUIControlCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "atable" => Ok(Self::Atable),
            "autocomplete" => Ok(Self::Autocomplete),
            "check-box" => Ok(Self::CheckBox),
            "drop-down" => Ok(Self::DropDown),
            "flyover" => Ok(Self::Flyover),
            "footer" => Ok(Self::Footer),
            "group" => Ok(Self::Group),
            "gtable" => Ok(Self::Gtable),
            "header" => Ok(Self::Header),
            "help" => Ok(Self::Help),
            "htable" => Ok(Self::Htable),
            "inline" => Ok(Self::Inline),
            "list" => Ok(Self::List),
            "lookup" => Ok(Self::Lookup),
            "lower" => Ok(Self::Lower),
            "prompt" => Ok(Self::Prompt),
            "question" => Ok(Self::Question),
            "radio-button" => Ok(Self::RadioButton),
            "slider" => Ok(Self::Slider),
            "spinner" => Ok(Self::Spinner),
            "table" => Ok(Self::Table),
            "text" => Ok(Self::Text),
            "text-box" => Ok(Self::TextBox),
            "unit" => Ok(Self::Unit),
            "upper" => Ok(Self::Upper),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireItemUIControlCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Atable => "atable",
            Self::Autocomplete => "autocomplete",
            Self::CheckBox => "check-box",
            Self::DropDown => "drop-down",
            Self::Flyover => "flyover",
            Self::Footer => "footer",
            Self::Group => "group",
            Self::Gtable => "gtable",
            Self::Header => "header",
            Self::Help => "help",
            Self::Htable => "htable",
            Self::Inline => "inline",
            Self::List => "list",
            Self::Lookup => "lookup",
            Self::Lower => "lower",
            Self::Prompt => "prompt",
            Self::Question => "question",
            Self::RadioButton => "radio-button",
            Self::Slider => "slider",
            Self::Spinner => "spinner",
            Self::Table => "table",
            Self::Text => "text",
            Self::TextBox => "text-box",
            Self::Unit => "unit",
            Self::Upper => "upper",
        }
    }
}
impl<'de> Deserialize<'de> for QuestionnaireItemUIControlCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireItemUIControlCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `QuestionnaireResponseStatus`. Lifecycle status of the questionnaire response.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuestionnaireResponseStatus {
    /** # amended

Amended. This QuestionnaireResponse has been filled out with answers, then marked as complete, yet changes or additions have been made to it afterwards. */
    Amended,
    /** # completed

Completed. This QuestionnaireResponse has been filled out with answers and the current content is regarded as definitive. */
    Completed,
    /** # entered-in-error

Entered in Error. This QuestionnaireResponse was entered in error and voided. */
    EnteredInError,
    /** # in-progress

In Progress. This QuestionnaireResponse has been partially filled out with answers but changes or additions are still expected to be made to it. */
    InProgress,
    /** # stopped

Stopped. This QuestionnaireResponse has been partially filled out with answers but has been abandoned. It is unknown whether changes or additions are expected to be made to it. */
    Stopped,
}
impl ::core::str::FromStr for QuestionnaireResponseStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amended" => Ok(Self::Amended),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "stopped" => Ok(Self::Stopped),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireResponseStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Amended => "amended",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Stopped => "stopped",
        }
    }
}
impl<'de> Deserialize<'de> for QuestionnaireResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `QuestionnaireTextCategories`. Codes defining the purpose of a Questionnaire item of type 'text'.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum QuestionnaireTextCategories {
    /** # help

Help. The text provides additional guidance on populating the containing item.  Help text isn't necessarily expected to be rendered as part of the form, but may instead be made available through fly-over, pop-up button, link to a "help" page, etc. */
    Help,
    /** # instructions

Instructions. The text provides guidance on how to populate or use a portion of the questionnaire (or the questionnaire as a whole). */
    Instructions,
    /** # security

Security. The text provides guidance on how the information should be or will be handled from a security/confidentiality/access control perspective when completed */
    Security,
}
impl ::core::str::FromStr for QuestionnaireTextCategories {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "help" => Ok(Self::Help),
            "instructions" => Ok(Self::Instructions),
            "security" => Ok(Self::Security),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for QuestionnaireTextCategories {
    fn as_ref(&self) -> &str {
        match self {
            Self::Help => "help",
            Self::Instructions => "instructions",
            Self::Security => "security",
        }
    }
}
impl<'de> Deserialize<'de> for QuestionnaireTextCategories {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for QuestionnaireTextCategories {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ReasonMedicationGivenCodes`. This value set is provided as an example. The value set to instantiate this attribute should be drawn from a robust terminology code system that consists of or contains concepts to support the medication process.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ReasonMedicationGivenCodes {
    /** # a

None. No reason known. */
    A,
    /** # b

Given as Ordered. The administration was following an ordered protocol. */
    B,
    /** # c

Emergency. The administration was needed to treat an emergency. */
    C,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ReasonMedicationGivenCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a" => Ok(Self::A),
            "b" => Ok(Self::B),
            "c" => Ok(Self::C),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ReasonMedicationGivenCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::A => "a",
            Self::B => "b",
            Self::C => "c",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ReasonMedicationGivenCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReasonMedicationGivenCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ReasonMedicationNotGivenCodes`. This value set is provided as an example. The value set to instantiate this attribute should be drawn from a robust terminology code system that consists of or contains concepts to support the medication process.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ReasonMedicationNotGivenCodes {
    /** # a

None. No reason known. */
    A,
    /** # b

Away. The patient was not available when the dose was scheduled. */
    B,
    /** # c

Asleep. The patient was asleep when the dose was scheduled. */
    C,
    /** # d

Vomit. The patient was given the medication and immediately vomited it back. */
    D,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ReasonMedicationNotGivenCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "a" => Ok(Self::A),
            "b" => Ok(Self::B),
            "c" => Ok(Self::C),
            "d" => Ok(Self::D),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ReasonMedicationNotGivenCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::A => "a",
            Self::B => "b",
            Self::C => "c",
            Self::D => "d",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ReasonMedicationNotGivenCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReasonMedicationNotGivenCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ReferenceHandlingPolicy`. A set of flags that defines how references are supported.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ReferenceHandlingPolicy {
    /** # enforced

Reference Integrity Enforced. The server enforces that references have integrity - e.g. it ensures that references can always be resolved. This is typically the case for clinical record systems, but often not the case for middleware/proxy systems. */
    Enforced,
    /** # literal

Literal References. The server supports and populates Literal references (i.e. using Reference.reference) where they are known (this code does not guarantee that all references are literal; see 'enforced'). */
    Literal,
    /** # local

Local References Only. The server does not support references that point to other servers. */
    Local,
    /** # logical

Logical References. The server allows logical references (i.e. using Reference.identifier). */
    Logical,
    /** # resolves

Resolves References. The server will attempt to resolve logical references to literal references - i.e. converting Reference.identifier to Reference.reference (if resolution fails, the server may still accept resources; see logical). */
    Resolves,
}
impl ::core::str::FromStr for ReferenceHandlingPolicy {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "enforced" => Ok(Self::Enforced),
            "literal" => Ok(Self::Literal),
            "local" => Ok(Self::Local),
            "logical" => Ok(Self::Logical),
            "resolves" => Ok(Self::Resolves),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferenceHandlingPolicy {
    fn as_ref(&self) -> &str {
        match self {
            Self::Enforced => "enforced",
            Self::Literal => "literal",
            Self::Local => "local",
            Self::Logical => "logical",
            Self::Resolves => "resolves",
        }
    }
}
impl<'de> Deserialize<'de> for ReferenceHandlingPolicy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferenceHandlingPolicy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ReferenceVersionRules`. Whether a reference needs to be version specific or version independent, or whether either can be used.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ReferenceVersionRules {
    /** # either

Either Specific or independent. The reference may be either version independent or version specific. */
    Either,
    /** # independent

Version independent. The reference must be version independent. */
    Independent,
    /** # specific

Version Specific. The reference must be version specific. */
    Specific,
}
impl ::core::str::FromStr for ReferenceVersionRules {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "either" => Ok(Self::Either),
            "independent" => Ok(Self::Independent),
            "specific" => Ok(Self::Specific),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferenceVersionRules {
    fn as_ref(&self) -> &str {
        match self {
            Self::Either => "either",
            Self::Independent => "independent",
            Self::Specific => "specific",
        }
    }
}
impl<'de> Deserialize<'de> for ReferenceVersionRules {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferenceVersionRules {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ReferralMethod`. The methods of referral can be used when referring to a specific HealthCareService resource.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ReferralMethod {
    /** # elec

Secure Messaging. Referrals may be accepted via a secure messaging system. To determine the types of secure messaging systems supported, refer to the identifiers collection. Callers will need to understand the specific identifier system used to know that they are able to transmit messages. */
    Elec,
    /** # fax

Fax. Referrals may be accepted by fax. */
    Fax,
    /** # mail

Mail. Referrals may be accepted via regular postage (or hand delivered). */
    Mail,
    /** # phone

Phone. Referrals may be accepted over the phone from a practitioner. */
    Phone,
    /** # semail

Secure Email. Referrals may be accepted via a secure email. To send please encrypt with the services public key. */
    Semail,
}
impl ::core::str::FromStr for ReferralMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "elec" => Ok(Self::Elec),
            "fax" => Ok(Self::Fax),
            "mail" => Ok(Self::Mail),
            "phone" => Ok(Self::Phone),
            "semail" => Ok(Self::Semail),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReferralMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Elec => "elec",
            Self::Fax => "fax",
            Self::Mail => "mail",
            Self::Phone => "phone",
            Self::Semail => "semail",
        }
    }
}
impl<'de> Deserialize<'de> for ReferralMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReferralMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RegulatedAuthorizationBasis`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RegulatedAuthorizationBasis {
    /** # Bibliographical

Bibliographical application (stand-alone). */
    Bibliographical,
    /** # Full

Full application. */
    Full,
    /** # KnownHumanBlood

Known human blood/plasma derived ancillary medicinal substance. */
    KnownHumanBlood,
    /** # KnownSubstance

Known active substance. */
    KnownSubstance,
    /** # NewSubstance

New active substance. */
    NewSubstance,
    /** # ParallelTrade

Parallel traded products. */
    ParallelTrade,
    /** # SimilarBiological

Similar biological application. */
    SimilarBiological,
    /** # TemporaryUse

Authorisations for temporary use. */
    TemporaryUse,
    /** # TraditionalUse

Traditional use registration for herbal medicinal product application. */
    TraditionalUse,
    /** # Well-establishedUse

Well-established use application. */
    WellEstablishedUse,
}
impl ::core::str::FromStr for RegulatedAuthorizationBasis {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Bibliographical" => Ok(Self::Bibliographical),
            "Full" => Ok(Self::Full),
            "KnownHumanBlood" => Ok(Self::KnownHumanBlood),
            "KnownSubstance" => Ok(Self::KnownSubstance),
            "NewSubstance" => Ok(Self::NewSubstance),
            "ParallelTrade" => Ok(Self::ParallelTrade),
            "SimilarBiological" => Ok(Self::SimilarBiological),
            "TemporaryUse" => Ok(Self::TemporaryUse),
            "TraditionalUse" => Ok(Self::TraditionalUse),
            "Well-establishedUse" => Ok(Self::WellEstablishedUse),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RegulatedAuthorizationBasis {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bibliographical => "Bibliographical",
            Self::Full => "Full",
            Self::KnownHumanBlood => "KnownHumanBlood",
            Self::KnownSubstance => "KnownSubstance",
            Self::NewSubstance => "NewSubstance",
            Self::ParallelTrade => "ParallelTrade",
            Self::SimilarBiological => "SimilarBiological",
            Self::TemporaryUse => "TemporaryUse",
            Self::TraditionalUse => "TraditionalUse",
            Self::WellEstablishedUse => "Well-establishedUse",
        }
    }
}
impl<'de> Deserialize<'de> for RegulatedAuthorizationBasis {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RegulatedAuthorizationBasis {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RegulatedAuthorizationCaseType`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RegulatedAuthorizationCaseType {
    /** # 100000155699

Specific Obligation. */
    N100000155699,
    /** # AnnualReassessment

Annual Reassessment. */
    AnnualReassessment,
    /** # FLU

FLU STRAIN UPDATE. */
    Flu,
    /** # Follow-up

Follow-up Measure. */
    FollowUp,
    /** # InitialMAA

Initial Marketing Authorisation Application. */
    InitialMAA,
    /** # LiftingSuspension

Lifting of a Suspension. */
    LiftingSuspension,
    /** # LineExtension

Line Extension. */
    LineExtension,
    /** # Orphan

Orphan Designation Application. */
    Orphan,
    /** # PANDEMIC

PANDEMIC UPDATE. */
    Pandemic,
    /** # PSUR

Periodic Safety Update Report. */
    Psur,
    /** # PaediatricSubmission

Paediatric Submission. */
    PaediatricSubmission,
    /** # RMP

Risk Management Plan. */
    Rmp,
    /** # Reformatting

Reformatting. */
    Reformatting,
    /** # Renewal

Renewal. */
    Renewal,
    /** # RepeatUse

Repeat Use Procedure. */
    RepeatUse,
    /** # ReviewSuspension

Review of a Suspension of MA. */
    ReviewSuspension,
    /** # SignalDetection

Signal detection. */
    SignalDetection,
    /** # SupplementalInformation

Supplemental Information. */
    SupplementalInformation,
    /** # TransferMA

Transfer of a marketing authorisation. */
    TransferMA,
    /** # UrgentSafetyRestriction

Urgent Safety Restriction. */
    UrgentSafetyRestriction,
    /** # Variation

Variation. */
    Variation,
    /** # Withdrawal

Withdrawal. */
    Withdrawal,
}
impl ::core::str::FromStr for RegulatedAuthorizationCaseType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000155699" => Ok(Self::N100000155699),
            "AnnualReassessment" => Ok(Self::AnnualReassessment),
            "FLU" => Ok(Self::Flu),
            "Follow-up" => Ok(Self::FollowUp),
            "InitialMAA" => Ok(Self::InitialMAA),
            "LiftingSuspension" => Ok(Self::LiftingSuspension),
            "LineExtension" => Ok(Self::LineExtension),
            "Orphan" => Ok(Self::Orphan),
            "PANDEMIC" => Ok(Self::Pandemic),
            "PSUR" => Ok(Self::Psur),
            "PaediatricSubmission" => Ok(Self::PaediatricSubmission),
            "RMP" => Ok(Self::Rmp),
            "Reformatting" => Ok(Self::Reformatting),
            "Renewal" => Ok(Self::Renewal),
            "RepeatUse" => Ok(Self::RepeatUse),
            "ReviewSuspension" => Ok(Self::ReviewSuspension),
            "SignalDetection" => Ok(Self::SignalDetection),
            "SupplementalInformation" => Ok(Self::SupplementalInformation),
            "TransferMA" => Ok(Self::TransferMA),
            "UrgentSafetyRestriction" => Ok(Self::UrgentSafetyRestriction),
            "Variation" => Ok(Self::Variation),
            "Withdrawal" => Ok(Self::Withdrawal),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RegulatedAuthorizationCaseType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000155699 => "100000155699",
            Self::AnnualReassessment => "AnnualReassessment",
            Self::Flu => "FLU",
            Self::FollowUp => "Follow-up",
            Self::InitialMAA => "InitialMAA",
            Self::LiftingSuspension => "LiftingSuspension",
            Self::LineExtension => "LineExtension",
            Self::Orphan => "Orphan",
            Self::Pandemic => "PANDEMIC",
            Self::Psur => "PSUR",
            Self::PaediatricSubmission => "PaediatricSubmission",
            Self::Rmp => "RMP",
            Self::Reformatting => "Reformatting",
            Self::Renewal => "Renewal",
            Self::RepeatUse => "RepeatUse",
            Self::ReviewSuspension => "ReviewSuspension",
            Self::SignalDetection => "SignalDetection",
            Self::SupplementalInformation => "SupplementalInformation",
            Self::TransferMA => "TransferMA",
            Self::UrgentSafetyRestriction => "UrgentSafetyRestriction",
            Self::Variation => "Variation",
            Self::Withdrawal => "Withdrawal",
        }
    }
}
impl<'de> Deserialize<'de> for RegulatedAuthorizationCaseType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RegulatedAuthorizationCaseType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RegulatedAuthorizationType`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RegulatedAuthorizationType {
    /** # MarketingAuth

Marketing Authorization. */
    MarketingAuth,
    /** # Orphan

Orphan Drug Authorization. */
    Orphan,
    /** # Pediatric

Pediatric Use Drug Authorization. */
    Pediatric,
}
impl ::core::str::FromStr for RegulatedAuthorizationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "MarketingAuth" => Ok(Self::MarketingAuth),
            "Orphan" => Ok(Self::Orphan),
            "Pediatric" => Ok(Self::Pediatric),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RegulatedAuthorizationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::MarketingAuth => "MarketingAuth",
            Self::Orphan => "Orphan",
            Self::Pediatric => "Pediatric",
        }
    }
}
impl<'de> Deserialize<'de> for RegulatedAuthorizationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RegulatedAuthorizationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RejectionCriterion`. Criterion for rejection of the specimen by laboratory.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RejectionCriterion {
    /** # broken

broken specimen container. specimen container broken. */
    Broken,
    /** # clotted

specimen clotted. specimen clotted. */
    Clotted,
    /** # hemolized

hemolized specimen. blood specimen hemolized. */
    Hemolized,
    /** # insufficient

insufficient specimen volume. insufficient quantity of specimen. */
    Insufficient,
    /** # wrong-temperature

specimen temperature inappropriate. specimen temperature inappropriate. */
    WrongTemperature,
}
impl ::core::str::FromStr for RejectionCriterion {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "broken" => Ok(Self::Broken),
            "clotted" => Ok(Self::Clotted),
            "hemolized" => Ok(Self::Hemolized),
            "insufficient" => Ok(Self::Insufficient),
            "wrong-temperature" => Ok(Self::WrongTemperature),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RejectionCriterion {
    fn as_ref(&self) -> &str {
        match self {
            Self::Broken => "broken",
            Self::Clotted => "clotted",
            Self::Hemolized => "hemolized",
            Self::Insufficient => "insufficient",
            Self::WrongTemperature => "wrong-temperature",
        }
    }
}
impl<'de> Deserialize<'de> for RejectionCriterion {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RejectionCriterion {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RelatedArtifactType`. The type of relationship to the related artifact.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RelatedArtifactType {
    /** # citation

Citation. Bibliographic citation for papers, references, or other relevant material for the knowledge resource. This is intended to allow for citation of related material, but that was not necessarily specifically prepared in connection with this knowledge resource. */
    Citation,
    /** # composed-of

Composed Of. The knowledge resource is composed of the given related artifact. */
    ComposedOf,
    /** # depends-on

Depends On. The knowledge resource depends on the given related artifact. */
    DependsOn,
    /** # derived-from

Derived From. The knowledge resource is derived from the related artifact. This is intended to capture the relationship in which a particular knowledge resource is based on the content of another artifact, but is modified to capture either a different set of overall requirements, or a more specific set of requirements such as those involved in a particular institution or clinical setting. */
    DerivedFrom,
    /** # documentation

Documentation. Additional documentation for the knowledge resource. This would include additional instructions on usage as well as additional information on clinical context or appropriateness. */
    Documentation,
    /** # justification

Justification. A summary of the justification for the knowledge resource including supporting evidence, relevant guidelines, or other clinically important information. This information is intended to provide a way to make the justification for the knowledge resource available to the consumer of interventions or results produced by the knowledge resource. */
    Justification,
    /** # predecessor

Predecessor. The previous version of the knowledge resource. */
    Predecessor,
    /** # successor

Successor. The next version of the knowledge resource. */
    Successor,
}
impl ::core::str::FromStr for RelatedArtifactType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "citation" => Ok(Self::Citation),
            "composed-of" => Ok(Self::ComposedOf),
            "depends-on" => Ok(Self::DependsOn),
            "derived-from" => Ok(Self::DerivedFrom),
            "documentation" => Ok(Self::Documentation),
            "justification" => Ok(Self::Justification),
            "predecessor" => Ok(Self::Predecessor),
            "successor" => Ok(Self::Successor),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RelatedArtifactType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Citation => "citation",
            Self::ComposedOf => "composed-of",
            Self::DependsOn => "depends-on",
            Self::DerivedFrom => "derived-from",
            Self::Documentation => "documentation",
            Self::Justification => "justification",
            Self::Predecessor => "predecessor",
            Self::Successor => "successor",
        }
    }
}
impl<'de> Deserialize<'de> for RelatedArtifactType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RelatedArtifactType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RemittanceOutcome`. The outcome of the processing.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RemittanceOutcome {
    /** # complete

Complete. The processing completed without errors. */
    Complete,
    /** # error

Error. The processing identified errors. */
    Error,
    /** # partial

Partial. No errors have been detected and some of the adjudication has been performed. */
    Partial,
    /** # queued

Queued. The Claim/Pre-authorization/Pre-determination has been received but processing has not begun. */
    Queued,
}
impl ::core::str::FromStr for RemittanceOutcome {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complete" => Ok(Self::Complete),
            "error" => Ok(Self::Error),
            "partial" => Ok(Self::Partial),
            "queued" => Ok(Self::Queued),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RemittanceOutcome {
    fn as_ref(&self) -> &str {
        match self {
            Self::Complete => "complete",
            Self::Error => "error",
            Self::Partial => "partial",
            Self::Queued => "queued",
        }
    }
}
impl<'de> Deserialize<'de> for RemittanceOutcome {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RemittanceOutcome {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ReportRelationshipType`. The type of relationship between reports.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ReportRelationshipType {
    /** # amendedWith

Amended With. This document was. */
    AmendedWith,
    /** # amends

Amends. This document notes corrections or changes to replace or supersede parts of the target document. */
    Amends,
    /** # appendedWith

Appended With. This document was. */
    AppendedWith,
    /** # appends

Appends. This document adds additional information to the target document. */
    Appends,
    /** # replacedWith

Replaced With. This document was. */
    ReplacedWith,
    /** # replaces

Replaces. This document replaces or supersedes the target document. */
    Replaces,
    /** # transformedWith

Transformed With. This document was. */
    TransformedWith,
    /** # transforms

Transforms. This document was generated by transforming the target document (eg format or language conversion). */
    Transforms,
}
impl ::core::str::FromStr for ReportRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "amendedWith" => Ok(Self::AmendedWith),
            "amends" => Ok(Self::Amends),
            "appendedWith" => Ok(Self::AppendedWith),
            "appends" => Ok(Self::Appends),
            "replacedWith" => Ok(Self::ReplacedWith),
            "replaces" => Ok(Self::Replaces),
            "transformedWith" => Ok(Self::TransformedWith),
            "transforms" => Ok(Self::Transforms),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReportRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::AmendedWith => "amendedWith",
            Self::Amends => "amends",
            Self::AppendedWith => "appendedWith",
            Self::Appends => "appends",
            Self::ReplacedWith => "replacedWith",
            Self::Replaces => "replaces",
            Self::TransformedWith => "transformedWith",
            Self::Transforms => "transforms",
        }
    }
}
impl<'de> Deserialize<'de> for ReportRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReportRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ReportSectionType`. Evidence Report Section Type.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ReportSectionType {
    /** # Assertion

Assertion. Assertion. */
    Assertion,
    /** # Certainty-of-Evidence

Certainty of Evidence. Certainty of Evidence. */
    CertaintyOfEvidence,
    /** # Column-Header

Column Header. Denotes the header to use for the column for a tabular report. */
    ColumnHeader,
    /** # Column-Headers

Column Headers. Denotes a section specifying column headers for a tabular report. */
    ColumnHeaders,
    /** # Control-group-alone-Evidence

Evidence Results for the control exposure only. Evidence Results for the control exposure only. */
    ControlGroupAloneEvidence,
    /** # Efficacy-outcomes

Efficacy-outcomes. Outcomes related to efficacy or potential benefits of interventions. */
    EfficacyOutcomes,
    /** # Evidence

Evidence Results. Evidence Results. */
    Evidence,
    /** # Evidence-Classifier

Evidence Classifier section. This section is used for classifiers of the evidence. */
    EvidenceClassifier,
    /** # EvidenceVariable

Evidence Variables used. Evidence Variables used. */
    EvidenceVariable,
    /** # EvidenceVariable-exposure

Evidence Variable in variable role Exposure. Evidence Variable in variable role Exposure. */
    EvidenceVariableExposure,
    /** # EvidenceVariable-intended

Evidence Variables intended for interpretation. Evidence Variables intended for interpretation. */
    EvidenceVariableIntended,
    /** # EvidenceVariable-observed

Evidence Variables actually observed. Evidence Variables as observed in the research data. */
    EvidenceVariableObserved,
    /** # EvidenceVariable-outcome

Evidence Variable in variable role Outcome (MeasuredVariable). Evidence Variable in variable role Outcome (MeasuredVariable). */
    EvidenceVariableOutcome,
    /** # EvidenceVariable-population

Evidence Variable in variable role Population. Evidence Variable in variable role Population. */
    EvidenceVariablePopulation,
    /** # Harms-outcomes

Harms outcomes. Outcomes related to adverse effects or potential harms of interventions. */
    HarmsOutcomes,
    /** # Header

Header. Denotes the header to use for a Text Summary or above a Table. */
    Header,
    /** # Intervention-group-alone-Evidence

Evidence Results for the intervention exposure only. Evidence Results for the intervention exposure only. */
    InterventionGroupAloneEvidence,
    /** # Intervention-vs-Control-Evidence

Evidence Results for comparison of Intervention and Control. Evidence Results for comparison of Intervention and Control. */
    InterventionVsControlEvidence,
    /** # Reasons

Reasons. Reasons. */
    Reasons,
    /** # References

References. References. */
    References,
    /** # Row-Headers

Row Headers. Denotes a section specifying row headers for a tabular report. */
    RowHeaders,
    /** # SampleSize

Sample Size. Sample Size. */
    SampleSize,
    /** # SummaryOfBodyOfEvidenceFindings

Summary of Body of Evidence Findings. Summary of Body of Evidence Findings. */
    SummaryOfBodyOfEvidenceFindings,
    /** # SummaryOfIndividualStudyFindings

Summary of Individual Study Findings. Summary of Individual Study Findings. */
    SummaryOfIndividualStudyFindings,
    /** # Table

Table. */
    Table,
    /** # Tables

Tables. Tables. */
    Tables,
    /** # Text-Summary

Text Summary. Denotes a section specifying text summary for a report. */
    TextSummary,
    /** # Warnings

Warnings. Warnings. */
    Warnings,
}
impl ::core::str::FromStr for ReportSectionType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Assertion" => Ok(Self::Assertion),
            "Certainty-of-Evidence" => Ok(Self::CertaintyOfEvidence),
            "Column-Header" => Ok(Self::ColumnHeader),
            "Column-Headers" => Ok(Self::ColumnHeaders),
            "Control-group-alone-Evidence" => Ok(Self::ControlGroupAloneEvidence),
            "Efficacy-outcomes" => Ok(Self::EfficacyOutcomes),
            "Evidence" => Ok(Self::Evidence),
            "Evidence-Classifier" => Ok(Self::EvidenceClassifier),
            "EvidenceVariable" => Ok(Self::EvidenceVariable),
            "EvidenceVariable-exposure" => Ok(Self::EvidenceVariableExposure),
            "EvidenceVariable-intended" => Ok(Self::EvidenceVariableIntended),
            "EvidenceVariable-observed" => Ok(Self::EvidenceVariableObserved),
            "EvidenceVariable-outcome" => Ok(Self::EvidenceVariableOutcome),
            "EvidenceVariable-population" => Ok(Self::EvidenceVariablePopulation),
            "Harms-outcomes" => Ok(Self::HarmsOutcomes),
            "Header" => Ok(Self::Header),
            "Intervention-group-alone-Evidence" => {
                Ok(Self::InterventionGroupAloneEvidence)
            }
            "Intervention-vs-Control-Evidence" => Ok(Self::InterventionVsControlEvidence),
            "Reasons" => Ok(Self::Reasons),
            "References" => Ok(Self::References),
            "Row-Headers" => Ok(Self::RowHeaders),
            "SampleSize" => Ok(Self::SampleSize),
            "SummaryOfBodyOfEvidenceFindings" => {
                Ok(Self::SummaryOfBodyOfEvidenceFindings)
            }
            "SummaryOfIndividualStudyFindings" => {
                Ok(Self::SummaryOfIndividualStudyFindings)
            }
            "Table" => Ok(Self::Table),
            "Tables" => Ok(Self::Tables),
            "Text-Summary" => Ok(Self::TextSummary),
            "Warnings" => Ok(Self::Warnings),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ReportSectionType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Assertion => "Assertion",
            Self::CertaintyOfEvidence => "Certainty-of-Evidence",
            Self::ColumnHeader => "Column-Header",
            Self::ColumnHeaders => "Column-Headers",
            Self::ControlGroupAloneEvidence => "Control-group-alone-Evidence",
            Self::EfficacyOutcomes => "Efficacy-outcomes",
            Self::Evidence => "Evidence",
            Self::EvidenceClassifier => "Evidence-Classifier",
            Self::EvidenceVariable => "EvidenceVariable",
            Self::EvidenceVariableExposure => "EvidenceVariable-exposure",
            Self::EvidenceVariableIntended => "EvidenceVariable-intended",
            Self::EvidenceVariableObserved => "EvidenceVariable-observed",
            Self::EvidenceVariableOutcome => "EvidenceVariable-outcome",
            Self::EvidenceVariablePopulation => "EvidenceVariable-population",
            Self::HarmsOutcomes => "Harms-outcomes",
            Self::Header => "Header",
            Self::InterventionGroupAloneEvidence => "Intervention-group-alone-Evidence",
            Self::InterventionVsControlEvidence => "Intervention-vs-Control-Evidence",
            Self::Reasons => "Reasons",
            Self::References => "References",
            Self::RowHeaders => "Row-Headers",
            Self::SampleSize => "SampleSize",
            Self::SummaryOfBodyOfEvidenceFindings => "SummaryOfBodyOfEvidenceFindings",
            Self::SummaryOfIndividualStudyFindings => "SummaryOfIndividualStudyFindings",
            Self::Table => "Table",
            Self::Tables => "Tables",
            Self::TextSummary => "Text-Summary",
            Self::Warnings => "Warnings",
        }
    }
}
impl<'de> Deserialize<'de> for ReportSectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ReportSectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RequestIntent`. Codes indicating the degree of authority/intentionality associated with a request.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RequestIntent {
    /** # directive

Directive. The request represents a legally binding instruction authored by a Patient or RelatedPerson. */
    Directive,
    /** # filler-order

Filler Order. The request represents the view of an authorization instantiated by a fulfilling system representing the details of the fulfiller's intention to act upon a submitted order. */
    FillerOrder,
    /** # instance-order

Instance Order. An order created in fulfillment of a broader order that represents the authorization for a single activity occurrence.  E.g. The administration of a single dose of a drug. */
    InstanceOrder,
    /** # option

Option. The request represents a component or option for a RequestGroup that establishes timing, conditionality and/or other constraints among a set of requests.  Refer to [[[RequestGroup]]] for additional information on how this status is used. */
    Option,
    /** # order

Order. The request represents a request/demand and authorization for action by a Practitioner. */
    Order,
    /** # original-order

Original Order. The request represents an original authorization for action. */
    OriginalOrder,
    /** # plan

Plan. The request represents an intention to ensure something occurs without providing an authorization for others to act. */
    Plan,
    /** # proposal

Proposal. The request is a suggestion made by someone/something that does not have an intention to ensure it occurs and without providing an authorization to act. */
    Proposal,
    /** # reflex-order

Reflex Order. The request represents an automatically generated supplemental authorization for action based on a parent authorization together with initial results of the action taken against that parent authorization. */
    ReflexOrder,
}
impl ::core::str::FromStr for RequestIntent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "directive" => Ok(Self::Directive),
            "filler-order" => Ok(Self::FillerOrder),
            "instance-order" => Ok(Self::InstanceOrder),
            "option" => Ok(Self::Option),
            "order" => Ok(Self::Order),
            "original-order" => Ok(Self::OriginalOrder),
            "plan" => Ok(Self::Plan),
            "proposal" => Ok(Self::Proposal),
            "reflex-order" => Ok(Self::ReflexOrder),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Directive => "directive",
            Self::FillerOrder => "filler-order",
            Self::InstanceOrder => "instance-order",
            Self::Option => "option",
            Self::Order => "order",
            Self::OriginalOrder => "original-order",
            Self::Plan => "plan",
            Self::Proposal => "proposal",
            Self::ReflexOrder => "reflex-order",
        }
    }
}
impl<'de> Deserialize<'de> for RequestIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RequestPriority`. Identifies the level of importance to be assigned to actioning the request.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RequestPriority {
    /** # asap

ASAP. The request should be actioned as soon as possible - higher priority than urgent. */
    Asap,
    /** # routine

Routine. The request has normal priority. */
    Routine,
    /** # stat

STAT. The request should be actioned immediately - highest possible priority.  E.g. an emergency. */
    Stat,
    /** # urgent

Urgent. The request should be actioned promptly - higher priority than routine. */
    Urgent,
}
impl ::core::str::FromStr for RequestPriority {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "asap" => Ok(Self::Asap),
            "routine" => Ok(Self::Routine),
            "stat" => Ok(Self::Stat),
            "urgent" => Ok(Self::Urgent),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestPriority {
    fn as_ref(&self) -> &str {
        match self {
            Self::Asap => "asap",
            Self::Routine => "routine",
            Self::Stat => "stat",
            Self::Urgent => "urgent",
        }
    }
}
impl<'de> Deserialize<'de> for RequestPriority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestPriority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RequestResourceType`. A list of all the request resource types defined in this version of the FHIR specification.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RequestResourceType {
    /** # Appointment

Appointment. A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s). */
    Appointment,
    /** # AppointmentResponse

AppointmentResponse. A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection. */
    AppointmentResponse,
    /** # CarePlan

CarePlan. Healthcare plan for patient or group. */
    CarePlan,
    /** # Claim

Claim. Claim, Pre-determination or Pre-authorization. */
    Claim,
    /** # CommunicationRequest

CommunicationRequest. A request for information to be sent to a receiver. */
    CommunicationRequest,
    /** # Contract

Contract. Legal Agreement. */
    Contract,
    /** # DeviceRequest

DeviceRequest. Medical device request. */
    DeviceRequest,
    /** # EnrollmentRequest

EnrollmentRequest. Enrollment request. */
    EnrollmentRequest,
    /** # ImmunizationRecommendation

ImmunizationRecommendation. Guidance or advice relating to an immunization. */
    ImmunizationRecommendation,
    /** # MedicationRequest

MedicationRequest. Ordering of medication for patient or group. */
    MedicationRequest,
    /** # NutritionOrder

NutritionOrder. Diet, formula or nutritional supplement request. */
    NutritionOrder,
    /** # ServiceRequest

ServiceRequest. A record of a request for service such as diagnostic investigations, treatments, or operations to be performed. */
    ServiceRequest,
    /** # SupplyRequest

SupplyRequest. Request for a medication, substance or device. */
    SupplyRequest,
    /** # Task

Task. A task to be performed. */
    Task,
    /** # VisionPrescription

VisionPrescription. Prescription for vision correction products for a patient. */
    VisionPrescription,
}
impl ::core::str::FromStr for RequestResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Appointment" => Ok(Self::Appointment),
            "AppointmentResponse" => Ok(Self::AppointmentResponse),
            "CarePlan" => Ok(Self::CarePlan),
            "Claim" => Ok(Self::Claim),
            "CommunicationRequest" => Ok(Self::CommunicationRequest),
            "Contract" => Ok(Self::Contract),
            "DeviceRequest" => Ok(Self::DeviceRequest),
            "EnrollmentRequest" => Ok(Self::EnrollmentRequest),
            "ImmunizationRecommendation" => Ok(Self::ImmunizationRecommendation),
            "MedicationRequest" => Ok(Self::MedicationRequest),
            "NutritionOrder" => Ok(Self::NutritionOrder),
            "ServiceRequest" => Ok(Self::ServiceRequest),
            "SupplyRequest" => Ok(Self::SupplyRequest),
            "Task" => Ok(Self::Task),
            "VisionPrescription" => Ok(Self::VisionPrescription),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Appointment => "Appointment",
            Self::AppointmentResponse => "AppointmentResponse",
            Self::CarePlan => "CarePlan",
            Self::Claim => "Claim",
            Self::CommunicationRequest => "CommunicationRequest",
            Self::Contract => "Contract",
            Self::DeviceRequest => "DeviceRequest",
            Self::EnrollmentRequest => "EnrollmentRequest",
            Self::ImmunizationRecommendation => "ImmunizationRecommendation",
            Self::MedicationRequest => "MedicationRequest",
            Self::NutritionOrder => "NutritionOrder",
            Self::ServiceRequest => "ServiceRequest",
            Self::SupplyRequest => "SupplyRequest",
            Self::Task => "Task",
            Self::VisionPrescription => "VisionPrescription",
        }
    }
}
impl<'de> Deserialize<'de> for RequestResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RequestStatus`. Codes identifying the lifecycle stage of a request.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RequestStatus {
    /** # active

Active. The request is in force and ready to be acted upon. */
    Active,
    /** # completed

Completed. The activity described by the request has been fully performed.  No further activity will occur. */
    Completed,
    /** # draft

Draft. The request has been created but is not yet complete or ready for action. */
    Draft,
    /** # entered-in-error

Entered in Error. This request should never have existed and should be considered 'void'.  (It is possible that real-world decisions were based on it.  If real-world activity has occurred, the status should be "revoked" rather than "entered-in-error".). */
    EnteredInError,
    /** # on-hold

On Hold. The request (and any implicit authorization to act) has been temporarily withdrawn but is expected to resume in the future. */
    OnHold,
    /** # revoked

Revoked. The request (and any implicit authorization to act) has been terminated prior to the known full completion of the intended actions.  No further activity should occur. */
    Revoked,
    /** # unknown

Unknown. The authoring/source system does not know which of the status values currently applies for this request.  Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply,  but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for RequestStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "on-hold" => Ok(Self::OnHold),
            "revoked" => Ok(Self::Revoked),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RequestStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::OnHold => "on-hold",
            Self::Revoked => "revoked",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for RequestStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RequestStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResearchElementType`. The possible types of research elements (E.g. Population, Exposure, Outcome).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchElementType {
    /** # exposure

Exposure. The element defines an exposure within the population that is being researched. */
    Exposure,
    /** # outcome

Outcome. The element defines an outcome within the population that is being researched. */
    Outcome,
    /** # population

Population. The element defines the population that forms the basis for research. */
    Population,
}
impl ::core::str::FromStr for ResearchElementType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exposure" => Ok(Self::Exposure),
            "outcome" => Ok(Self::Outcome),
            "population" => Ok(Self::Population),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchElementType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exposure => "exposure",
            Self::Outcome => "outcome",
            Self::Population => "population",
        }
    }
}
impl<'de> Deserialize<'de> for ResearchElementType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchElementType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResearchStudyObjectiveType`. Codes for the kind of study objective.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyObjectiveType {
    /** # exploratory

Exploratory. Exploratory questions to be answered in the study. */
    Exploratory,
    /** # primary

Primary. The main question to be answered, and the one that drives any statistical planning for the study—e.g., calculation of the sample size to provide the appropriate power for statistical testing. */
    Primary,
    /** # secondary

Secondary. Question to be answered in the study that is of lesser importance than the primary objective. */
    Secondary,
}
impl ::core::str::FromStr for ResearchStudyObjectiveType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "exploratory" => Ok(Self::Exploratory),
            "primary" => Ok(Self::Primary),
            "secondary" => Ok(Self::Secondary),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyObjectiveType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Exploratory => "exploratory",
            Self::Primary => "primary",
            Self::Secondary => "secondary",
        }
    }
}
impl<'de> Deserialize<'de> for ResearchStudyObjectiveType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyObjectiveType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResearchStudyPhase`. Codes for the stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyPhase {
    /** # early-phase-1

Early Phase 1. Designation for optional exploratory trials conducted in accordance with the United States Food and Drug Administration's (FDA) 2006 Guidance on Exploratory Investigational New Drug (IND) Studies. Formerly called Phase 0. */
    EarlyPhase1,
    /** # n-a

N/A. Trials without phases (for example, studies of devices or behavioral interventions). */
    NA,
    /** # phase-1

Phase 1. Includes initial studies to determine the metabolism and pharmacologic actions of drugs in humans, the side effects associated with increasing doses, and to gain early evidence of effectiveness; may include healthy participants and/or patients. */
    Phase1,
    /** # phase-1-phase-2

Phase 1/Phase 2. Trials that are a combination of phases 1 and 2. */
    Phase1Phase2,
    /** # phase-2

Phase 2. Includes controlled clinical studies conducted to evaluate the effectiveness of the drug for a particular indication or indications in participants with the disease or condition under study and to determine the common short-term side effects and risks. */
    Phase2,
    /** # phase-2-phase-3

Phase 2/Phase 3. Trials that are a combination of phases 2 and 3. */
    Phase2Phase3,
    /** # phase-3

Phase 3. Includes trials conducted after preliminary evidence suggesting effectiveness of the drug has been obtained, and are intended to gather additional information to evaluate the overall benefit-risk relationship of the drug. */
    Phase3,
    /** # phase-4

Phase 4. Studies of FDA-approved drugs to delineate additional information including the drug's risks, benefits, and optimal use. */
    Phase4,
}
impl ::core::str::FromStr for ResearchStudyPhase {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "early-phase-1" => Ok(Self::EarlyPhase1),
            "n-a" => Ok(Self::NA),
            "phase-1" => Ok(Self::Phase1),
            "phase-1-phase-2" => Ok(Self::Phase1Phase2),
            "phase-2" => Ok(Self::Phase2),
            "phase-2-phase-3" => Ok(Self::Phase2Phase3),
            "phase-3" => Ok(Self::Phase3),
            "phase-4" => Ok(Self::Phase4),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyPhase {
    fn as_ref(&self) -> &str {
        match self {
            Self::EarlyPhase1 => "early-phase-1",
            Self::NA => "n-a",
            Self::Phase1 => "phase-1",
            Self::Phase1Phase2 => "phase-1-phase-2",
            Self::Phase2 => "phase-2",
            Self::Phase2Phase3 => "phase-2-phase-3",
            Self::Phase3 => "phase-3",
            Self::Phase4 => "phase-4",
        }
    }
}
impl<'de> Deserialize<'de> for ResearchStudyPhase {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyPhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResearchStudyPrimaryPurposeType`. Codes for the main intent of the study.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyPrimaryPurposeType {
    /** # basic-science

Basic Science. One or more interventions for examining the basic mechanism of action (for example, physiology or biomechanics of an intervention). */
    BasicScience,
    /** # device-feasibility

Device Feasibility. An intervention of a device product is being evaluated to determine the feasibility of the product or to test a prototype device and not health outcomes. Such studies are conducted to confirm the design and operating specifications of a device before beginning a full clinical trial. */
    DeviceFeasibility,
    /** # diagnostic

Diagnostic. One or more interventions are being evaluated for identifying a disease or health condition. */
    Diagnostic,
    /** # health-services-research

Health Services Research. One or more interventions for evaluating the delivery, processes, management, organization, or financing of healthcare. */
    HealthServicesResearch,
    /** # prevention

Prevention. One or more interventions are being assessed for preventing the development of a specific disease or health condition. */
    Prevention,
    /** # screening

Screening. One or more interventions are assessed or examined for identifying a condition, or risk factors for a condition, in people who are not yet known to have the condition or risk factor. */
    Screening,
    /** # supportive-care

Supportive Care. One or more interventions are evaluated for maximizing comfort, minimizing side effects, or mitigating against a decline in the participant's health or function. */
    SupportiveCare,
    /** # treatment

Treatment. One or more interventions are being evaluated for treating a disease, syndrome, or condition. */
    Treatment,
}
impl ::core::str::FromStr for ResearchStudyPrimaryPurposeType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "basic-science" => Ok(Self::BasicScience),
            "device-feasibility" => Ok(Self::DeviceFeasibility),
            "diagnostic" => Ok(Self::Diagnostic),
            "health-services-research" => Ok(Self::HealthServicesResearch),
            "prevention" => Ok(Self::Prevention),
            "screening" => Ok(Self::Screening),
            "supportive-care" => Ok(Self::SupportiveCare),
            "treatment" => Ok(Self::Treatment),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyPrimaryPurposeType {
    fn as_ref(&self) -> &str {
        match self {
            Self::BasicScience => "basic-science",
            Self::DeviceFeasibility => "device-feasibility",
            Self::Diagnostic => "diagnostic",
            Self::HealthServicesResearch => "health-services-research",
            Self::Prevention => "prevention",
            Self::Screening => "screening",
            Self::SupportiveCare => "supportive-care",
            Self::Treatment => "treatment",
        }
    }
}
impl<'de> Deserialize<'de> for ResearchStudyPrimaryPurposeType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyPrimaryPurposeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResearchStudyReasonStopped`. Codes for why the study ended prematurely.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyReasonStopped {
    /** # accrual-goal-met

Accrual Goal Met. The study prematurely ended because the accrual goal was met. */
    AccrualGoalMet,
    /** # closed-due-to-lack-of-study-progress

Closed due to lack of study progress. The study prematurely ended due to lack of study progress. */
    ClosedDueToLackOfStudyProgress,
    /** # closed-due-to-toxicity

Closed due to toxicity. The study prematurely ended due to toxicity. */
    ClosedDueToToxicity,
    /** # temporarily-closed-per-study-design

Temporarily closed per study design. The study prematurely ended temporarily per study design. */
    TemporarilyClosedPerStudyDesign,
}
impl ::core::str::FromStr for ResearchStudyReasonStopped {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accrual-goal-met" => Ok(Self::AccrualGoalMet),
            "closed-due-to-lack-of-study-progress" => {
                Ok(Self::ClosedDueToLackOfStudyProgress)
            }
            "closed-due-to-toxicity" => Ok(Self::ClosedDueToToxicity),
            "temporarily-closed-per-study-design" => {
                Ok(Self::TemporarilyClosedPerStudyDesign)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyReasonStopped {
    fn as_ref(&self) -> &str {
        match self {
            Self::AccrualGoalMet => "accrual-goal-met",
            Self::ClosedDueToLackOfStudyProgress => {
                "closed-due-to-lack-of-study-progress"
            }
            Self::ClosedDueToToxicity => "closed-due-to-toxicity",
            Self::TemporarilyClosedPerStudyDesign => {
                "temporarily-closed-per-study-design"
            }
        }
    }
}
impl<'de> Deserialize<'de> for ResearchStudyReasonStopped {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyReasonStopped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResearchStudyStatus`. Codes that convey the current status of the research study.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchStudyStatus {
    /** # active

Active. Study is opened for accrual. */
    Active,
    /** # administratively-completed

Administratively Completed. Study is completed prematurely and will not resume; patients are no longer examined nor treated. */
    AdministrativelyCompleted,
    /** # approved

Approved. Protocol is approved by the review board. */
    Approved,
    /** # closed-to-accrual

Closed to Accrual. Study is closed for accrual; patients can be examined and treated. */
    ClosedToAccrual,
    /** # closed-to-accrual-and-intervention

Closed to Accrual and Intervention. Study is closed to accrual and intervention, i.e. the study is closed to enrollment, all study subjects have completed treatment or intervention but are still being followed according to the primary objective of the study. */
    ClosedToAccrualAndIntervention,
    /** # completed

Completed. Study is closed to accrual and intervention, i.e. the study is closed to enrollment, all study subjects have completed treatment
or intervention but are still being followed according to the primary objective of the study. */
    Completed,
    /** # disapproved

Disapproved. Protocol was disapproved by the review board. */
    Disapproved,
    /** # in-review

In Review. Protocol is submitted to the review board for approval. */
    InReview,
    /** # temporarily-closed-to-accrual

Temporarily Closed to Accrual. Study is temporarily closed for accrual; can be potentially resumed in the future; patients can be examined and treated. */
    TemporarilyClosedToAccrual,
    /** # temporarily-closed-to-accrual-and-intervention

Temporarily Closed to Accrual and Intervention. Study is temporarily closed for accrual and intervention and potentially can be resumed in the future. */
    TemporarilyClosedToAccrualAndIntervention,
    /** # withdrawn

Withdrawn. Protocol was withdrawn by the lead organization. */
    Withdrawn,
}
impl ::core::str::FromStr for ResearchStudyStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "administratively-completed" => Ok(Self::AdministrativelyCompleted),
            "approved" => Ok(Self::Approved),
            "closed-to-accrual" => Ok(Self::ClosedToAccrual),
            "closed-to-accrual-and-intervention" => {
                Ok(Self::ClosedToAccrualAndIntervention)
            }
            "completed" => Ok(Self::Completed),
            "disapproved" => Ok(Self::Disapproved),
            "in-review" => Ok(Self::InReview),
            "temporarily-closed-to-accrual" => Ok(Self::TemporarilyClosedToAccrual),
            "temporarily-closed-to-accrual-and-intervention" => {
                Ok(Self::TemporarilyClosedToAccrualAndIntervention)
            }
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchStudyStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::AdministrativelyCompleted => "administratively-completed",
            Self::Approved => "approved",
            Self::ClosedToAccrual => "closed-to-accrual",
            Self::ClosedToAccrualAndIntervention => "closed-to-accrual-and-intervention",
            Self::Completed => "completed",
            Self::Disapproved => "disapproved",
            Self::InReview => "in-review",
            Self::TemporarilyClosedToAccrual => "temporarily-closed-to-accrual",
            Self::TemporarilyClosedToAccrualAndIntervention => {
                "temporarily-closed-to-accrual-and-intervention"
            }
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl<'de> Deserialize<'de> for ResearchStudyStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchStudyStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResearchSubjectStatus`. Indicates the progression of a study subject through a study.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResearchSubjectStatus {
    /** # candidate

Candidate. An identified person that can be considered for inclusion in a study. */
    Candidate,
    /** # eligible

Eligible. A person that has met the eligibility criteria for inclusion in a study. */
    Eligible,
    /** # follow-up

Follow-up. A person is no longer receiving study intervention and/or being evaluated with tests and procedures according to the protocol, but they are being monitored on a protocol-prescribed schedule. */
    FollowUp,
    /** # ineligible

Ineligible. A person who did not meet one or more criteria required for participation in a study is considered to have failed screening or
is ineligible for the study. */
    Ineligible,
    /** # not-registered

Not Registered. A person for whom registration was not completed. */
    NotRegistered,
    /** # off-study

Off-study. A person that has ended their participation on a study either because their treatment/observation is complete or through not
responding, withdrawal, non-compliance and/or adverse event. */
    OffStudy,
    /** # on-study

On-study. A person that is enrolled or registered on a study. */
    OnStudy,
    /** # on-study-intervention

On-study-intervention. The person is receiving the treatment or participating in an activity (e.g. yoga, diet, etc.) that the study is evaluating. */
    OnStudyIntervention,
    /** # on-study-observation

On-study-observation. The subject is being evaluated via tests and assessments according to the study calendar, but is not receiving any intervention. Note that this state is study-dependent and might not exist in all studies.  A synonym for this is "short-term follow-up". */
    OnStudyObservation,
    /** # pending-on-study

Pending on-study. A person is pre-registered for a study. */
    PendingOnStudy,
    /** # potential-candidate

Potential Candidate. A person that is potentially eligible for participation in the study. */
    PotentialCandidate,
    /** # screening

Screening. A person who is being evaluated for eligibility for a study. */
    Screening,
    /** # withdrawn

Withdrawn. The person has withdrawn their participation in the study before registration. */
    Withdrawn,
}
impl ::core::str::FromStr for ResearchSubjectStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "candidate" => Ok(Self::Candidate),
            "eligible" => Ok(Self::Eligible),
            "follow-up" => Ok(Self::FollowUp),
            "ineligible" => Ok(Self::Ineligible),
            "not-registered" => Ok(Self::NotRegistered),
            "off-study" => Ok(Self::OffStudy),
            "on-study" => Ok(Self::OnStudy),
            "on-study-intervention" => Ok(Self::OnStudyIntervention),
            "on-study-observation" => Ok(Self::OnStudyObservation),
            "pending-on-study" => Ok(Self::PendingOnStudy),
            "potential-candidate" => Ok(Self::PotentialCandidate),
            "screening" => Ok(Self::Screening),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResearchSubjectStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Candidate => "candidate",
            Self::Eligible => "eligible",
            Self::FollowUp => "follow-up",
            Self::Ineligible => "ineligible",
            Self::NotRegistered => "not-registered",
            Self::OffStudy => "off-study",
            Self::OnStudy => "on-study",
            Self::OnStudyIntervention => "on-study-intervention",
            Self::OnStudyObservation => "on-study-observation",
            Self::PendingOnStudy => "pending-on-study",
            Self::PotentialCandidate => "potential-candidate",
            Self::Screening => "screening",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl<'de> Deserialize<'de> for ResearchSubjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResearchSubjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResourceSecurityCategory`. Codes indicating how resources behave from a security perspective

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ResourceSecurityCategory {
    /** # anonymous

Anonymous READ Access Resource. These resources tend to not contain any individual data, or business sensitive data. Most often these Resources will be available for anonymous access, meaning there is no access control based on the user or system requesting. However these Resources do tend to contain important information that must be authenticated back to the source publishing them, and protected from integrity failures in communication. For this reason server authenticated https (TLS) is recommended to provide authentication of the server and integrity protection in transit. This is normal web-server use of https. */
    Anonymous,
    /** # business

Business Sensitive Resource. These Resources tend to not contain any individual data, but do have data that describe business or service sensitive data. The use of the term Business is not intended to only mean an incorporated business, but rather the more broad concept of an organization, location, or other group that is not identifable as individuals. Often these resources will require some for of client authentication to assure that only authorized access is given. The client access control may be to individuals, or may be to system identity. For this purpose possible client authentication methods such as: mutual-authenticated-TLS, APIKey, App signed JWT, or App OAuth client-id JWT For example: a App that uses a Business protected Provider Directory to determine other business endpoint details. */
    Business,
    /** # individual

Individual Sensitive Resource. These Resources do NOT contain Patient data, but do contain individual information about other participants. These other individuals are Practitioners, PractitionerRole, CareTeam, or other users. These identities are needed to enable the practice of healthcare. These identities are identities under general privacy regulations, and thus must consider Privacy risk. Often access to these other identities are covered by business relationships. For this purpose access to these Resources will tend to be Role specific using methods such as RBAC or ABAC. */
    Individual,
    /** # not-classified

Not classified. Some Resources can be used for a wide scope of use-cases that span very sensitive to very non-sensitive. These Resources do not fall into any of the above classifications, as their sensitivity is highly variable. These Resources will need special handling. These Resources often contain metadata that describes the content in a way that can be used for Access Control decisions. */
    NotClassified,
    /** # patient

Patient Sensitive. These Resources make up the bulk of FHIR and therefore are the most commonly understood. These Resources contain highly sesitive health information, or are closely linked to highly sensitive health information. These Resources will often use the security labels to differentiate various confidentiality levels within this broad group of Patient Sensitive data. Access to these Resources often requires a declared Purpose Of Use. Access to these Resources is often controlled by a Privacy Consent. */
    Patient,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ResourceSecurityCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "anonymous" => Ok(Self::Anonymous),
            "business" => Ok(Self::Business),
            "individual" => Ok(Self::Individual),
            "not-classified" => Ok(Self::NotClassified),
            "patient" => Ok(Self::Patient),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ResourceSecurityCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::Anonymous => "anonymous",
            Self::Business => "business",
            Self::Individual => "individual",
            Self::NotClassified => "not-classified",
            Self::Patient => "patient",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ResourceSecurityCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceSecurityCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResourceType`. One of the resource types defined as part of this version of FHIR.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ResourceType {
    /** # Account

Account. A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc. */
    Account,
    /** # ActivityDefinition

ActivityDefinition. This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context. */
    ActivityDefinition,
    /** # AdministrableProductDefinition

AdministrableProductDefinition. A medicinal product in the final form which is suitable for administering to a patient (after any mixing of multiple components, dissolution etc. has been performed). */
    AdministrableProductDefinition,
    /** # AdverseEvent

AdverseEvent. Actual or  potential/avoided event causing unintended physical injury resulting from or contributed to by medical care, a research study or other healthcare setting factors that requires additional monitoring, treatment, or hospitalization, or that results in death. */
    AdverseEvent,
    /** # AllergyIntolerance

AllergyIntolerance. Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance. */
    AllergyIntolerance,
    /** # Appointment

Appointment. A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s). */
    Appointment,
    /** # AppointmentResponse

AppointmentResponse. A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection. */
    AppointmentResponse,
    /** # AuditEvent

AuditEvent. A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage. */
    AuditEvent,
    /** # Basic

Basic. Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don't map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification. */
    Basic,
    /** # Binary

Binary. A resource that represents the data of a single raw artifact as digital content accessible in its native format.  A Binary resource can contain any content, whether text, image, pdf, zip archive, etc. */
    Binary,
    /** # BiologicallyDerivedProduct

BiologicallyDerivedProduct. A material substance originating from a biological entity intended to be transplanted or infused
into another (possibly the same) biological entity. */
    BiologicallyDerivedProduct,
    /** # BodyStructure

BodyStructure. Record details about an anatomical structure.  This resource may be used when a coded concept does not provide the necessary detail needed for the use case. */
    BodyStructure,
    /** # Bundle

Bundle. A container for a collection of resources. */
    Bundle,
    /** # CapabilityStatement

CapabilityStatement. A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server for a particular version of FHIR that may be used as a statement of actual server functionality or a statement of required or desired server implementation. */
    CapabilityStatement,
    /** # CarePlan

CarePlan. Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions. */
    CarePlan,
    /** # CareTeam

CareTeam. The Care Team includes all the people and organizations who plan to participate in the coordination and delivery of care for a patient. */
    CareTeam,
    /** # CatalogEntry

CatalogEntry. Catalog entries are wrappers that contextualize items included in a catalog. */
    CatalogEntry,
    /** # ChargeItem

ChargeItem. The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation. */
    ChargeItem,
    /** # ChargeItemDefinition

ChargeItemDefinition. The ChargeItemDefinition resource provides the properties that apply to the (billing) codes necessary to calculate costs and prices. The properties may differ largely depending on type and realm, therefore this resource gives only a rough structure and requires profiling for each type of billing code system. */
    ChargeItemDefinition,
    /** # Citation

Citation. The Citation Resource enables reference to any knowledge artifact for purposes of identification and attribution. The Citation Resource supports existing reference structures and developing publication practices such as versioning, expressing complex contributorship roles, and referencing computable resources. */
    Citation,
    /** # Claim

Claim. A provider issued list of professional services and products which have been provided, or are to be provided, to a patient which is sent to an insurer for reimbursement. */
    Claim,
    /** # ClaimResponse

ClaimResponse. This resource provides the adjudication details from the processing of a Claim resource. */
    ClaimResponse,
    /** # ClinicalImpression

ClinicalImpression. A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score. */
    ClinicalImpression,
    /** # ClinicalUseDefinition

ClinicalUseDefinition. A single issue - either an indication, contraindication, interaction or an undesirable effect for a medicinal product, medication, device or procedure. */
    ClinicalUseDefinition,
    /** # CodeSystem

CodeSystem. The CodeSystem resource is used to declare the existence of and describe a code system or code system supplement and its key properties, and optionally define a part or all of its content. */
    CodeSystem,
    /** # Communication

Communication. An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency that was notified about a reportable condition. */
    Communication,
    /** # CommunicationRequest

CommunicationRequest. A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition. */
    CommunicationRequest,
    /** # CompartmentDefinition

CompartmentDefinition. A compartment definition that defines how resources are accessed on a server. */
    CompartmentDefinition,
    /** # Composition

Composition. A set of healthcare-related information that is assembled together into a single logical package that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. A Composition defines the structure and narrative content necessary for a document. However, a Composition alone does not constitute a document. Rather, the Composition must be the first entry in a Bundle where Bundle.type=document, and any other resources referenced from Composition must be included as subsequent entries in the Bundle (for example Patient, Practitioner, Encounter, etc.). */
    Composition,
    /** # ConceptMap

ConceptMap. A statement of relationships from one set of concepts to one or more other concepts - either concepts in code systems, or data element/data element concepts, or classes in class models. */
    ConceptMap,
    /** # Condition

Condition. A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern. */
    Condition,
    /** # Consent

Consent. A record of a healthcare consumer’s  choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time. */
    Consent,
    /** # Contract

Contract. Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement. */
    Contract,
    /** # Coverage

Coverage. Financial instrument which may be used to reimburse or pay for health care products and services. Includes both insurance and self-payment. */
    Coverage,
    /** # CoverageEligibilityRequest

CoverageEligibilityRequest. The CoverageEligibilityRequest provides patient and insurance coverage information to an insurer for them to respond, in the form of an CoverageEligibilityResponse, with information regarding whether the stated coverage is valid and in-force and optionally to provide the insurance details of the policy. */
    CoverageEligibilityRequest,
    /** # CoverageEligibilityResponse

CoverageEligibilityResponse. This resource provides eligibility and plan details from the processing of an CoverageEligibilityRequest resource. */
    CoverageEligibilityResponse,
    /** # DetectedIssue

DetectedIssue. Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc. */
    DetectedIssue,
    /** # Device

Device. A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device. */
    Device,
    /** # DeviceDefinition

DeviceDefinition. The characteristics, operational status and capabilities of a medical-related component of a medical device. */
    DeviceDefinition,
    /** # DeviceMetric

DeviceMetric. Describes a measurement, calculation or setting capability of a medical device. */
    DeviceMetric,
    /** # DeviceRequest

DeviceRequest. Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker. */
    DeviceRequest,
    /** # DeviceUseStatement

DeviceUseStatement. A record of a device being used by a patient where the record is the result of a report from the patient or another clinician. */
    DeviceUseStatement,
    /** # DiagnosticReport

DiagnosticReport. The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports. */
    DiagnosticReport,
    /** # DocumentManifest

DocumentManifest. A collection of documents compiled for a purpose together with metadata that applies to the collection. */
    DocumentManifest,
    /** # DocumentReference

DocumentReference. A reference to a document of any kind for any purpose. Provides metadata about the document so that the document can be discovered and managed. The scope of a document is any seralized object with a mime-type, so includes formal patient centric documents (CDA), cliical notes, scanned paper, and non-patient specific documents like policy text. */
    DocumentReference,
    /** # DomainResource

DomainResource. --- Abstract Type! ---A resource that includes narrative, extensions, and contained resources. */
    DomainResource,
    /** # Encounter

Encounter. An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient. */
    Encounter,
    /** # Endpoint

Endpoint. The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information. */
    Endpoint,
    /** # EnrollmentRequest

EnrollmentRequest. This resource provides the insurance enrollment details to the insurer regarding a specified coverage. */
    EnrollmentRequest,
    /** # EnrollmentResponse

EnrollmentResponse. This resource provides enrollment and plan details from the processing of an EnrollmentRequest resource. */
    EnrollmentResponse,
    /** # EpisodeOfCare

EpisodeOfCare. An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time. */
    EpisodeOfCare,
    /** # EventDefinition

EventDefinition. The EventDefinition resource provides a reusable description of when a particular event can occur. */
    EventDefinition,
    /** # Evidence

Evidence. The Evidence Resource provides a machine-interpretable expression of an evidence concept including the evidence variables (eg population, exposures/interventions, comparators, outcomes, measured variables, confounding variables), the statistics, and the certainty of this evidence. */
    Evidence,
    /** # EvidenceReport

EvidenceReport. The EvidenceReport Resource is a specialized container for a collection of resources and codable concepts, adapted to support compositions of Evidence, EvidenceVariable, and Citation resources and related concepts. */
    EvidenceReport,
    /** # EvidenceVariable

EvidenceVariable. The EvidenceVariable resource describes an element that knowledge (Evidence) is about. */
    EvidenceVariable,
    /** # ExampleScenario

ExampleScenario. Example of workflow instance. */
    ExampleScenario,
    /** # ExplanationOfBenefit

ExplanationOfBenefit. This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided. */
    ExplanationOfBenefit,
    /** # FamilyMemberHistory

FamilyMemberHistory. Significant health conditions for a person related to the patient relevant in the context of care for the patient. */
    FamilyMemberHistory,
    /** # Flag

Flag. Prospective warnings of potential issues when providing care to the patient. */
    Flag,
    /** # Goal

Goal. Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc. */
    Goal,
    /** # GraphDefinition

GraphDefinition. A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set. */
    GraphDefinition,
    /** # Group

Group. Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively, and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization. */
    Group,
    /** # GuidanceResponse

GuidanceResponse. A guidance response is the formal response to a guidance request, including any output parameters returned by the evaluation, as well as the description of any proposed actions to be taken. */
    GuidanceResponse,
    /** # HealthcareService

HealthcareService. The details of a healthcare service available at a location. */
    HealthcareService,
    /** # ImagingStudy

ImagingStudy. Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities. */
    ImagingStudy,
    /** # Immunization

Immunization. Describes the event of a patient being administered a vaccine or a record of an immunization as reported by a patient, a clinician or another party. */
    Immunization,
    /** # ImmunizationEvaluation

ImmunizationEvaluation. Describes a comparison of an immunization event against published recommendations to determine if the administration is "valid" in relation to those  recommendations. */
    ImmunizationEvaluation,
    /** # ImmunizationRecommendation

ImmunizationRecommendation. A patient's point-in-time set of recommendations (i.e. forecasting) according to a published schedule with optional supporting justification. */
    ImmunizationRecommendation,
    /** # ImplementationGuide

ImplementationGuide. A set of rules of how a particular interoperability or standards problem is solved - typically through the use of FHIR resources. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts. */
    ImplementationGuide,
    /** # Ingredient

Ingredient. An ingredient of a manufactured item or pharmaceutical product. */
    Ingredient,
    /** # InsurancePlan

InsurancePlan. Details of a Health Insurance product/plan provided by an organization. */
    InsurancePlan,
    /** # Invoice

Invoice. Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose. */
    Invoice,
    /** # Library

Library. The Library resource is a general-purpose container for knowledge asset definitions. It can be used to describe and expose existing knowledge assets such as logic libraries and information model descriptions, as well as to describe a collection of knowledge assets. */
    Library,
    /** # Linkage

Linkage. Identifies two or more records (resource instances) that refer to the same real-world "occurrence". */
    Linkage,
    /** # List

List. A list is a curated collection of resources. */
    List,
    /** # Location

Location. Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated. */
    Location,
    /** # ManufacturedItemDefinition

ManufacturedItemDefinition. The definition and characteristics of a medicinal manufactured item, such as a tablet or capsule, as contained in a packaged medicinal product. */
    ManufacturedItemDefinition,
    /** # Measure

Measure. The Measure resource provides the definition of a quality measure. */
    Measure,
    /** # MeasureReport

MeasureReport. The MeasureReport resource contains the results of the calculation of a measure; and optionally a reference to the resources involved in that calculation. */
    MeasureReport,
    /** # Media

Media. A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference. */
    Media,
    /** # Medication

Medication. This resource is primarily used for the identification and definition of a medication for the purposes of prescribing, dispensing, and administering a medication as well as for making statements about medication use. */
    Medication,
    /** # MedicationAdministration

MedicationAdministration. Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner. */
    MedicationAdministration,
    /** # MedicationDispense

MedicationDispense. Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order. */
    MedicationDispense,
    /** # MedicationKnowledge

MedicationKnowledge. Information about a medication that is used to support knowledge. */
    MedicationKnowledge,
    /** # MedicationRequest

MedicationRequest. An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns. */
    MedicationRequest,
    /** # MedicationStatement

MedicationStatement. A record of a medication that is being consumed by a patient.   A MedicationStatement may indicate that the patient may be taking the medication now or has taken the medication in the past or will be taking the medication in the future.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay.   The medication information may come from sources such as the patient's memory, from a prescription bottle,  or from a list of medications the patient, clinician or other party maintains.

The primary difference between a medication statement and a medication administration is that the medication administration has complete administration information and is based on actual administration information from the person who administered the medication.  A medication statement is often, if not always, less specific.  There is no required date/time when the medication was administered, in fact we only know that a source has reported the patient is taking this medication, where details such as time, quantity, or rate or even medication product may be incomplete or missing or less precise.  As stated earlier, the medication statement information may come from the patient's memory, from a prescription bottle or from a list of medications the patient, clinician or other party maintains.  Medication administration is more formal and is not missing detailed information. */
    MedicationStatement,
    /** # MedicinalProductDefinition

MedicinalProductDefinition. Detailed definition of a medicinal product, typically for uses other than direct patient care (e.g. regulatory use, drug catalogs, to support prescribing, adverse events management etc.). */
    MedicinalProductDefinition,
    /** # MessageDefinition

MessageDefinition. Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted. */
    MessageDefinition,
    /** # MessageHeader

MessageHeader. The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle. */
    MessageHeader,
    /** # MolecularSequence

MolecularSequence. Raw data describing a biological sequence. */
    MolecularSequence,
    /** # NamingSystem

NamingSystem. A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types. */
    NamingSystem,
    /** # NutritionOrder

NutritionOrder. A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident. */
    NutritionOrder,
    /** # NutritionProduct

NutritionProduct. A food or fluid product that is consumed by patients. */
    NutritionProduct,
    /** # Observation

Observation. Measurements and simple assertions made about a patient, device or other subject. */
    Observation,
    /** # ObservationDefinition

ObservationDefinition. Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service. */
    ObservationDefinition,
    /** # OperationDefinition

OperationDefinition. A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction). */
    OperationDefinition,
    /** # OperationOutcome

OperationOutcome. A collection of error, warning, or information messages that result from a system action. */
    OperationOutcome,
    /** # Organization

Organization. A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc. */
    Organization,
    /** # OrganizationAffiliation

OrganizationAffiliation. Defines an affiliation/assotiation/relationship between 2 distinct oganizations, that is not a part-of relationship/sub-division relationship. */
    OrganizationAffiliation,
    /** # PackagedProductDefinition

PackagedProductDefinition. A medically related item or items, in a container or package. */
    PackagedProductDefinition,
    /** # Parameters

Parameters. This resource is a non-persisted resource used to pass information into and back from an [operation](operations.html). It has no other use, and there is no RESTful endpoint associated with it. */
    Parameters,
    /** # Patient

Patient. Demographics and other administrative information about an individual or animal receiving care or other health-related services. */
    Patient,
    /** # PaymentNotice

PaymentNotice. This resource provides the status of the payment for goods and services rendered, and the request and response resource references. */
    PaymentNotice,
    /** # PaymentReconciliation

PaymentReconciliation. This resource provides the details including amount of a payment and allocates the payment items being paid. */
    PaymentReconciliation,
    /** # Person

Person. Demographics and administrative information about a person independent of a specific health-related context. */
    Person,
    /** # PlanDefinition

PlanDefinition. This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical and non-clinical artifacts such as clinical decision support rules, order sets, protocols, and drug quality specifications. */
    PlanDefinition,
    /** # Practitioner

Practitioner. A person who is directly or indirectly involved in the provisioning of healthcare. */
    Practitioner,
    /** # PractitionerRole

PractitionerRole. A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time. */
    PractitionerRole,
    /** # Procedure

Procedure. An action that is or was performed on or for a patient. This can be a physical intervention like an operation, or less invasive like long term services, counseling, or hypnotherapy. */
    Procedure,
    /** # Provenance

Provenance. Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies. */
    Provenance,
    /** # Questionnaire

Questionnaire. A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection. */
    Questionnaire,
    /** # QuestionnaireResponse

QuestionnaireResponse. A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to. */
    QuestionnaireResponse,
    /** # RegulatedAuthorization

RegulatedAuthorization. Regulatory approval, clearance or licencing related to a regulated product, treatment, facility or activity that is cited in a guidance, regulation, rule or legislative act. An example is Market Authorization relating to a Medicinal Product. */
    RegulatedAuthorization,
    /** # RelatedPerson

RelatedPerson. Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process. */
    RelatedPerson,
    /** # RequestGroup

RequestGroup. A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one". */
    RequestGroup,
    /** # ResearchDefinition

ResearchDefinition. The ResearchDefinition resource describes the conditional state (population and any exposures being compared within the population) and outcome (if specified) that the knowledge (evidence, assertion, recommendation) is about. */
    ResearchDefinition,
    /** # ResearchElementDefinition

ResearchElementDefinition. The ResearchElementDefinition resource describes a "PICO" element that knowledge (evidence, assertion, recommendation) is about. */
    ResearchElementDefinition,
    /** # ResearchStudy

ResearchStudy. A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects. */
    ResearchStudy,
    /** # ResearchSubject

ResearchSubject. A physical entity which is the primary unit of operational and/or administrative interest in a study. */
    ResearchSubject,
    /** # Resource

Resource. --- Abstract Type! ---This is the base resource type for everything. */
    Resource,
    /** # RiskAssessment

RiskAssessment. An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome. */
    RiskAssessment,
    /** # Schedule

Schedule. A container for slots of time that may be available for booking appointments. */
    Schedule,
    /** # SearchParameter

SearchParameter. A search parameter that defines a named search item that can be used to search/filter on a resource. */
    SearchParameter,
    /** # ServiceRequest

ServiceRequest. A record of a request for service such as diagnostic investigations, treatments, or operations to be performed. */
    ServiceRequest,
    /** # Slot

Slot. A slot of time on a schedule that may be available for booking appointments. */
    Slot,
    /** # Specimen

Specimen. A sample to be used for analysis. */
    Specimen,
    /** # SpecimenDefinition

SpecimenDefinition. A kind of specimen with associated set of requirements. */
    SpecimenDefinition,
    /** # StructureDefinition

StructureDefinition. A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types. */
    StructureDefinition,
    /** # StructureMap

StructureMap. A Map of relationships between 2 structures that can be used to transform data. */
    StructureMap,
    /** # Subscription

Subscription. The subscription resource is used to define a push-based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system can take an appropriate action. */
    Subscription,
    /** # SubscriptionStatus

SubscriptionStatus. The SubscriptionStatus resource describes the state of a Subscription during notifications. */
    SubscriptionStatus,
    /** # SubscriptionTopic

SubscriptionTopic. Describes a stream of resource state changes identified by trigger criteria and annotated with labels useful to filter projections from this topic. */
    SubscriptionTopic,
    /** # Substance

Substance. A homogeneous material with a definite composition. */
    Substance,
    /** # SubstanceDefinition

SubstanceDefinition. The detailed description of a substance, typically at a level beyond what is used for prescribing. */
    SubstanceDefinition,
    /** # SupplyDelivery

SupplyDelivery. Record of delivery of what is supplied. */
    SupplyDelivery,
    /** # SupplyRequest

SupplyRequest. A record of a request for a medication, substance or device used in the healthcare setting. */
    SupplyRequest,
    /** # Task

Task. A task to be performed. */
    Task,
    /** # TerminologyCapabilities

TerminologyCapabilities. A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation. */
    TerminologyCapabilities,
    /** # TestReport

TestReport. A summary of information based on the results of executing a TestScript. */
    TestReport,
    /** # TestScript

TestScript. A structured set of tests against a FHIR server or client implementation to determine compliance against the FHIR specification. */
    TestScript,
    /** # ValueSet

ValueSet. A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [[[CodeSystem]]] definitions and their use in [coded elements](terminologies.html). */
    ValueSet,
    /** # VerificationResult

VerificationResult. Describes validation requirements, source(s), status and dates for one or more elements. */
    VerificationResult,
    /** # VisionPrescription

VisionPrescription. An authorization for the provision of glasses and/or contact lenses to a patient. */
    VisionPrescription,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ResourceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Account" => Ok(Self::Account),
            "ActivityDefinition" => Ok(Self::ActivityDefinition),
            "AdministrableProductDefinition" => Ok(Self::AdministrableProductDefinition),
            "AdverseEvent" => Ok(Self::AdverseEvent),
            "AllergyIntolerance" => Ok(Self::AllergyIntolerance),
            "Appointment" => Ok(Self::Appointment),
            "AppointmentResponse" => Ok(Self::AppointmentResponse),
            "AuditEvent" => Ok(Self::AuditEvent),
            "Basic" => Ok(Self::Basic),
            "Binary" => Ok(Self::Binary),
            "BiologicallyDerivedProduct" => Ok(Self::BiologicallyDerivedProduct),
            "BodyStructure" => Ok(Self::BodyStructure),
            "Bundle" => Ok(Self::Bundle),
            "CapabilityStatement" => Ok(Self::CapabilityStatement),
            "CarePlan" => Ok(Self::CarePlan),
            "CareTeam" => Ok(Self::CareTeam),
            "CatalogEntry" => Ok(Self::CatalogEntry),
            "ChargeItem" => Ok(Self::ChargeItem),
            "ChargeItemDefinition" => Ok(Self::ChargeItemDefinition),
            "Citation" => Ok(Self::Citation),
            "Claim" => Ok(Self::Claim),
            "ClaimResponse" => Ok(Self::ClaimResponse),
            "ClinicalImpression" => Ok(Self::ClinicalImpression),
            "ClinicalUseDefinition" => Ok(Self::ClinicalUseDefinition),
            "CodeSystem" => Ok(Self::CodeSystem),
            "Communication" => Ok(Self::Communication),
            "CommunicationRequest" => Ok(Self::CommunicationRequest),
            "CompartmentDefinition" => Ok(Self::CompartmentDefinition),
            "Composition" => Ok(Self::Composition),
            "ConceptMap" => Ok(Self::ConceptMap),
            "Condition" => Ok(Self::Condition),
            "Consent" => Ok(Self::Consent),
            "Contract" => Ok(Self::Contract),
            "Coverage" => Ok(Self::Coverage),
            "CoverageEligibilityRequest" => Ok(Self::CoverageEligibilityRequest),
            "CoverageEligibilityResponse" => Ok(Self::CoverageEligibilityResponse),
            "DetectedIssue" => Ok(Self::DetectedIssue),
            "Device" => Ok(Self::Device),
            "DeviceDefinition" => Ok(Self::DeviceDefinition),
            "DeviceMetric" => Ok(Self::DeviceMetric),
            "DeviceRequest" => Ok(Self::DeviceRequest),
            "DeviceUseStatement" => Ok(Self::DeviceUseStatement),
            "DiagnosticReport" => Ok(Self::DiagnosticReport),
            "DocumentManifest" => Ok(Self::DocumentManifest),
            "DocumentReference" => Ok(Self::DocumentReference),
            "DomainResource" => Ok(Self::DomainResource),
            "Encounter" => Ok(Self::Encounter),
            "Endpoint" => Ok(Self::Endpoint),
            "EnrollmentRequest" => Ok(Self::EnrollmentRequest),
            "EnrollmentResponse" => Ok(Self::EnrollmentResponse),
            "EpisodeOfCare" => Ok(Self::EpisodeOfCare),
            "EventDefinition" => Ok(Self::EventDefinition),
            "Evidence" => Ok(Self::Evidence),
            "EvidenceReport" => Ok(Self::EvidenceReport),
            "EvidenceVariable" => Ok(Self::EvidenceVariable),
            "ExampleScenario" => Ok(Self::ExampleScenario),
            "ExplanationOfBenefit" => Ok(Self::ExplanationOfBenefit),
            "FamilyMemberHistory" => Ok(Self::FamilyMemberHistory),
            "Flag" => Ok(Self::Flag),
            "Goal" => Ok(Self::Goal),
            "GraphDefinition" => Ok(Self::GraphDefinition),
            "Group" => Ok(Self::Group),
            "GuidanceResponse" => Ok(Self::GuidanceResponse),
            "HealthcareService" => Ok(Self::HealthcareService),
            "ImagingStudy" => Ok(Self::ImagingStudy),
            "Immunization" => Ok(Self::Immunization),
            "ImmunizationEvaluation" => Ok(Self::ImmunizationEvaluation),
            "ImmunizationRecommendation" => Ok(Self::ImmunizationRecommendation),
            "ImplementationGuide" => Ok(Self::ImplementationGuide),
            "Ingredient" => Ok(Self::Ingredient),
            "InsurancePlan" => Ok(Self::InsurancePlan),
            "Invoice" => Ok(Self::Invoice),
            "Library" => Ok(Self::Library),
            "Linkage" => Ok(Self::Linkage),
            "List" => Ok(Self::List),
            "Location" => Ok(Self::Location),
            "ManufacturedItemDefinition" => Ok(Self::ManufacturedItemDefinition),
            "Measure" => Ok(Self::Measure),
            "MeasureReport" => Ok(Self::MeasureReport),
            "Media" => Ok(Self::Media),
            "Medication" => Ok(Self::Medication),
            "MedicationAdministration" => Ok(Self::MedicationAdministration),
            "MedicationDispense" => Ok(Self::MedicationDispense),
            "MedicationKnowledge" => Ok(Self::MedicationKnowledge),
            "MedicationRequest" => Ok(Self::MedicationRequest),
            "MedicationStatement" => Ok(Self::MedicationStatement),
            "MedicinalProductDefinition" => Ok(Self::MedicinalProductDefinition),
            "MessageDefinition" => Ok(Self::MessageDefinition),
            "MessageHeader" => Ok(Self::MessageHeader),
            "MolecularSequence" => Ok(Self::MolecularSequence),
            "NamingSystem" => Ok(Self::NamingSystem),
            "NutritionOrder" => Ok(Self::NutritionOrder),
            "NutritionProduct" => Ok(Self::NutritionProduct),
            "Observation" => Ok(Self::Observation),
            "ObservationDefinition" => Ok(Self::ObservationDefinition),
            "OperationDefinition" => Ok(Self::OperationDefinition),
            "OperationOutcome" => Ok(Self::OperationOutcome),
            "Organization" => Ok(Self::Organization),
            "OrganizationAffiliation" => Ok(Self::OrganizationAffiliation),
            "PackagedProductDefinition" => Ok(Self::PackagedProductDefinition),
            "Parameters" => Ok(Self::Parameters),
            "Patient" => Ok(Self::Patient),
            "PaymentNotice" => Ok(Self::PaymentNotice),
            "PaymentReconciliation" => Ok(Self::PaymentReconciliation),
            "Person" => Ok(Self::Person),
            "PlanDefinition" => Ok(Self::PlanDefinition),
            "Practitioner" => Ok(Self::Practitioner),
            "PractitionerRole" => Ok(Self::PractitionerRole),
            "Procedure" => Ok(Self::Procedure),
            "Provenance" => Ok(Self::Provenance),
            "Questionnaire" => Ok(Self::Questionnaire),
            "QuestionnaireResponse" => Ok(Self::QuestionnaireResponse),
            "RegulatedAuthorization" => Ok(Self::RegulatedAuthorization),
            "RelatedPerson" => Ok(Self::RelatedPerson),
            "RequestGroup" => Ok(Self::RequestGroup),
            "ResearchDefinition" => Ok(Self::ResearchDefinition),
            "ResearchElementDefinition" => Ok(Self::ResearchElementDefinition),
            "ResearchStudy" => Ok(Self::ResearchStudy),
            "ResearchSubject" => Ok(Self::ResearchSubject),
            "Resource" => Ok(Self::Resource),
            "RiskAssessment" => Ok(Self::RiskAssessment),
            "Schedule" => Ok(Self::Schedule),
            "SearchParameter" => Ok(Self::SearchParameter),
            "ServiceRequest" => Ok(Self::ServiceRequest),
            "Slot" => Ok(Self::Slot),
            "Specimen" => Ok(Self::Specimen),
            "SpecimenDefinition" => Ok(Self::SpecimenDefinition),
            "StructureDefinition" => Ok(Self::StructureDefinition),
            "StructureMap" => Ok(Self::StructureMap),
            "Subscription" => Ok(Self::Subscription),
            "SubscriptionStatus" => Ok(Self::SubscriptionStatus),
            "SubscriptionTopic" => Ok(Self::SubscriptionTopic),
            "Substance" => Ok(Self::Substance),
            "SubstanceDefinition" => Ok(Self::SubstanceDefinition),
            "SupplyDelivery" => Ok(Self::SupplyDelivery),
            "SupplyRequest" => Ok(Self::SupplyRequest),
            "Task" => Ok(Self::Task),
            "TerminologyCapabilities" => Ok(Self::TerminologyCapabilities),
            "TestReport" => Ok(Self::TestReport),
            "TestScript" => Ok(Self::TestScript),
            "ValueSet" => Ok(Self::ValueSet),
            "VerificationResult" => Ok(Self::VerificationResult),
            "VisionPrescription" => Ok(Self::VisionPrescription),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Account => "Account",
            Self::ActivityDefinition => "ActivityDefinition",
            Self::AdministrableProductDefinition => "AdministrableProductDefinition",
            Self::AdverseEvent => "AdverseEvent",
            Self::AllergyIntolerance => "AllergyIntolerance",
            Self::Appointment => "Appointment",
            Self::AppointmentResponse => "AppointmentResponse",
            Self::AuditEvent => "AuditEvent",
            Self::Basic => "Basic",
            Self::Binary => "Binary",
            Self::BiologicallyDerivedProduct => "BiologicallyDerivedProduct",
            Self::BodyStructure => "BodyStructure",
            Self::Bundle => "Bundle",
            Self::CapabilityStatement => "CapabilityStatement",
            Self::CarePlan => "CarePlan",
            Self::CareTeam => "CareTeam",
            Self::CatalogEntry => "CatalogEntry",
            Self::ChargeItem => "ChargeItem",
            Self::ChargeItemDefinition => "ChargeItemDefinition",
            Self::Citation => "Citation",
            Self::Claim => "Claim",
            Self::ClaimResponse => "ClaimResponse",
            Self::ClinicalImpression => "ClinicalImpression",
            Self::ClinicalUseDefinition => "ClinicalUseDefinition",
            Self::CodeSystem => "CodeSystem",
            Self::Communication => "Communication",
            Self::CommunicationRequest => "CommunicationRequest",
            Self::CompartmentDefinition => "CompartmentDefinition",
            Self::Composition => "Composition",
            Self::ConceptMap => "ConceptMap",
            Self::Condition => "Condition",
            Self::Consent => "Consent",
            Self::Contract => "Contract",
            Self::Coverage => "Coverage",
            Self::CoverageEligibilityRequest => "CoverageEligibilityRequest",
            Self::CoverageEligibilityResponse => "CoverageEligibilityResponse",
            Self::DetectedIssue => "DetectedIssue",
            Self::Device => "Device",
            Self::DeviceDefinition => "DeviceDefinition",
            Self::DeviceMetric => "DeviceMetric",
            Self::DeviceRequest => "DeviceRequest",
            Self::DeviceUseStatement => "DeviceUseStatement",
            Self::DiagnosticReport => "DiagnosticReport",
            Self::DocumentManifest => "DocumentManifest",
            Self::DocumentReference => "DocumentReference",
            Self::DomainResource => "DomainResource",
            Self::Encounter => "Encounter",
            Self::Endpoint => "Endpoint",
            Self::EnrollmentRequest => "EnrollmentRequest",
            Self::EnrollmentResponse => "EnrollmentResponse",
            Self::EpisodeOfCare => "EpisodeOfCare",
            Self::EventDefinition => "EventDefinition",
            Self::Evidence => "Evidence",
            Self::EvidenceReport => "EvidenceReport",
            Self::EvidenceVariable => "EvidenceVariable",
            Self::ExampleScenario => "ExampleScenario",
            Self::ExplanationOfBenefit => "ExplanationOfBenefit",
            Self::FamilyMemberHistory => "FamilyMemberHistory",
            Self::Flag => "Flag",
            Self::Goal => "Goal",
            Self::GraphDefinition => "GraphDefinition",
            Self::Group => "Group",
            Self::GuidanceResponse => "GuidanceResponse",
            Self::HealthcareService => "HealthcareService",
            Self::ImagingStudy => "ImagingStudy",
            Self::Immunization => "Immunization",
            Self::ImmunizationEvaluation => "ImmunizationEvaluation",
            Self::ImmunizationRecommendation => "ImmunizationRecommendation",
            Self::ImplementationGuide => "ImplementationGuide",
            Self::Ingredient => "Ingredient",
            Self::InsurancePlan => "InsurancePlan",
            Self::Invoice => "Invoice",
            Self::Library => "Library",
            Self::Linkage => "Linkage",
            Self::List => "List",
            Self::Location => "Location",
            Self::ManufacturedItemDefinition => "ManufacturedItemDefinition",
            Self::Measure => "Measure",
            Self::MeasureReport => "MeasureReport",
            Self::Media => "Media",
            Self::Medication => "Medication",
            Self::MedicationAdministration => "MedicationAdministration",
            Self::MedicationDispense => "MedicationDispense",
            Self::MedicationKnowledge => "MedicationKnowledge",
            Self::MedicationRequest => "MedicationRequest",
            Self::MedicationStatement => "MedicationStatement",
            Self::MedicinalProductDefinition => "MedicinalProductDefinition",
            Self::MessageDefinition => "MessageDefinition",
            Self::MessageHeader => "MessageHeader",
            Self::MolecularSequence => "MolecularSequence",
            Self::NamingSystem => "NamingSystem",
            Self::NutritionOrder => "NutritionOrder",
            Self::NutritionProduct => "NutritionProduct",
            Self::Observation => "Observation",
            Self::ObservationDefinition => "ObservationDefinition",
            Self::OperationDefinition => "OperationDefinition",
            Self::OperationOutcome => "OperationOutcome",
            Self::Organization => "Organization",
            Self::OrganizationAffiliation => "OrganizationAffiliation",
            Self::PackagedProductDefinition => "PackagedProductDefinition",
            Self::Parameters => "Parameters",
            Self::Patient => "Patient",
            Self::PaymentNotice => "PaymentNotice",
            Self::PaymentReconciliation => "PaymentReconciliation",
            Self::Person => "Person",
            Self::PlanDefinition => "PlanDefinition",
            Self::Practitioner => "Practitioner",
            Self::PractitionerRole => "PractitionerRole",
            Self::Procedure => "Procedure",
            Self::Provenance => "Provenance",
            Self::Questionnaire => "Questionnaire",
            Self::QuestionnaireResponse => "QuestionnaireResponse",
            Self::RegulatedAuthorization => "RegulatedAuthorization",
            Self::RelatedPerson => "RelatedPerson",
            Self::RequestGroup => "RequestGroup",
            Self::ResearchDefinition => "ResearchDefinition",
            Self::ResearchElementDefinition => "ResearchElementDefinition",
            Self::ResearchStudy => "ResearchStudy",
            Self::ResearchSubject => "ResearchSubject",
            Self::Resource => "Resource",
            Self::RiskAssessment => "RiskAssessment",
            Self::Schedule => "Schedule",
            Self::SearchParameter => "SearchParameter",
            Self::ServiceRequest => "ServiceRequest",
            Self::Slot => "Slot",
            Self::Specimen => "Specimen",
            Self::SpecimenDefinition => "SpecimenDefinition",
            Self::StructureDefinition => "StructureDefinition",
            Self::StructureMap => "StructureMap",
            Self::Subscription => "Subscription",
            Self::SubscriptionStatus => "SubscriptionStatus",
            Self::SubscriptionTopic => "SubscriptionTopic",
            Self::Substance => "Substance",
            Self::SubstanceDefinition => "SubstanceDefinition",
            Self::SupplyDelivery => "SupplyDelivery",
            Self::SupplyRequest => "SupplyRequest",
            Self::Task => "Task",
            Self::TerminologyCapabilities => "TerminologyCapabilities",
            Self::TestReport => "TestReport",
            Self::TestScript => "TestScript",
            Self::ValueSet => "ValueSet",
            Self::VerificationResult => "VerificationResult",
            Self::VisionPrescription => "VisionPrescription",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ResourceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResourceValidationMode`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ResourceValidationMode {
    /** # create

Validate for Create. The server checks the content, and then checks that the content would be acceptable as a create (e.g. that the content would not violate any uniqueness constraints). */
    Create,
    /** # delete

Validate for Delete. The server ignores the content and checks that the nominated resource is allowed to be deleted (e.g. checking referential integrity rules). */
    Delete,
    /** # profile

Validate Against a Profile. The server checks an existing resource (must be nominated by id, not provided as a parameter) as valid against the nominated profile. */
    Profile,
    /** # update

Validate for Update. The server checks the content, and then checks that it would accept it as an update against the nominated specific resource (e.g. that there are no changes to immutable fields the server does not allow to change and checking version integrity if appropriate). */
    Update,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ResourceValidationMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "create" => Ok(Self::Create),
            "delete" => Ok(Self::Delete),
            "profile" => Ok(Self::Profile),
            "update" => Ok(Self::Update),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ResourceValidationMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Create => "create",
            Self::Delete => "delete",
            Self::Profile => "profile",
            Self::Update => "update",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ResourceValidationMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceValidationMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResourceVersionPolicy`. How the system supports versioning for a resource.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResourceVersionPolicy {
    /** # no-version

No VersionId Support. VersionId meta-property is not supported (server) or used (client). */
    NoVersion,
    /** # versioned

Versioned. VersionId meta-property is supported (server) or used (client). */
    Versioned,
    /** # versioned-update

VersionId tracked fully. VersionId must be correct for updates (server) or will be specified (If-match header) for updates (client). */
    VersionedUpdate,
}
impl ::core::str::FromStr for ResourceVersionPolicy {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "no-version" => Ok(Self::NoVersion),
            "versioned" => Ok(Self::Versioned),
            "versioned-update" => Ok(Self::VersionedUpdate),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResourceVersionPolicy {
    fn as_ref(&self) -> &str {
        match self {
            Self::NoVersion => "no-version",
            Self::Versioned => "versioned",
            Self::VersionedUpdate => "versioned-update",
        }
    }
}
impl<'de> Deserialize<'de> for ResourceVersionPolicy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResourceVersionPolicy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ResponseType`. The kind of response to a message.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ResponseType {
    /** # fatal-error

Fatal Error. The message was rejected because of a problem with the content. There is no point in re-sending without change. The response narrative SHALL describe the issue. */
    FatalError,
    /** # ok

OK. The message was accepted and processed without error. */
    Ok,
    /** # transient-error

Transient Error. Some internal unexpected error occurred - wait and try again. Note - this is usually used for things like database unavailable, which may be expected to resolve, though human intervention may be required. */
    TransientError,
}
impl ::core::str::FromStr for ResponseType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fatal-error" => Ok(Self::FatalError),
            "ok" => Ok(Self::Ok),
            "transient-error" => Ok(Self::TransientError),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ResponseType {
    fn as_ref(&self) -> &str {
        match self {
            Self::FatalError => "fatal-error",
            Self::Ok => "ok",
            Self::TransientError => "transient-error",
        }
    }
}
impl<'de> Deserialize<'de> for ResponseType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ResponseType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RestfulCapabilityMode`. The mode of a RESTful capability statement.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RestfulCapabilityMode {
    /** # client

Client. The application acts as a client for this resource. */
    Client,
    /** # server

Server. The application acts as a server for this resource. */
    Server,
}
impl ::core::str::FromStr for RestfulCapabilityMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client" => Ok(Self::Client),
            "server" => Ok(Self::Server),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RestfulCapabilityMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Client => "client",
            Self::Server => "server",
        }
    }
}
impl<'de> Deserialize<'de> for RestfulCapabilityMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RestfulCapabilityMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RestfulSecurityService`. Types of security services used with FHIR.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum RestfulSecurityService {
    /** # Basic

Basic. Basic authentication defined in HTTP specification. */
    Basic,
    /** # Certificates

Certificates. SSL where client must have a certificate registered with the server. */
    Certificates,
    /** # Kerberos

Kerberos. see http://www.ietf.org/rfc/rfc4120.txt. */
    Kerberos,
    /** # NTLM

NTLM. Microsoft NTLM Authentication. */
    Ntlm,
    /** # OAuth

OAuth. OAuth (unspecified version see oauth.net). */
    Oauth,
    /** # SMART-on-FHIR

SMART-on-FHIR. OAuth2 using SMART-on-FHIR profile (see http://docs.smarthealthit.org/). */
    SmartOnFHIR,
}
impl ::core::str::FromStr for RestfulSecurityService {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Basic" => Ok(Self::Basic),
            "Certificates" => Ok(Self::Certificates),
            "Kerberos" => Ok(Self::Kerberos),
            "NTLM" => Ok(Self::Ntlm),
            "OAuth" => Ok(Self::Oauth),
            "SMART-on-FHIR" => Ok(Self::SmartOnFHIR),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for RestfulSecurityService {
    fn as_ref(&self) -> &str {
        match self {
            Self::Basic => "Basic",
            Self::Certificates => "Certificates",
            Self::Kerberos => "Kerberos",
            Self::Ntlm => "NTLM",
            Self::Oauth => "OAuth",
            Self::SmartOnFHIR => "SMART-on-FHIR",
        }
    }
}
impl<'de> Deserialize<'de> for RestfulSecurityService {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RestfulSecurityService {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `RiskProbability`. Codes representing the likelihood of a particular outcome in a risk assessment.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum RiskProbability {
    /** # certain

Certain. The specified outcome is effectively guaranteed. */
    Certain,
    /** # high

High likelihood. The specified outcome is more likely to occur than not. */
    High,
    /** # low

Low likelihood. The specified outcome is possible but unlikely. */
    Low,
    /** # moderate

Moderate likelihood. The specified outcome has a reasonable likelihood of occurrence. */
    Moderate,
    /** # negligible

Negligible likelihood. The specified outcome is exceptionally unlikely. */
    Negligible,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for RiskProbability {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "certain" => Ok(Self::Certain),
            "high" => Ok(Self::High),
            "low" => Ok(Self::Low),
            "moderate" => Ok(Self::Moderate),
            "negligible" => Ok(Self::Negligible),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for RiskProbability {
    fn as_ref(&self) -> &str {
        match self {
            Self::Certain => "certain",
            Self::High => "high",
            Self::Low => "low",
            Self::Moderate => "moderate",
            Self::Negligible => "negligible",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for RiskProbability {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for RiskProbability {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SearchComparator`. What Search Comparator Codes are supported in search.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SearchComparator {
    /** # ap

Approximately. the value for the parameter in the resource is approximately the same to the provided value. */
    Ap,
    /** # eb

Ends Before. the value for the parameter in the resource ends before the provided value. */
    Eb,
    /** # eq

Equals. the value for the parameter in the resource is equal to the provided value. */
    Eq,
    /** # ge

Greater or Equals. the value for the parameter in the resource is greater or equal to the provided value. */
    Ge,
    /** # gt

Greater Than. the value for the parameter in the resource is greater than the provided value. */
    Gt,
    /** # le

Less of Equal. the value for the parameter in the resource is less or equal to the provided value. */
    Le,
    /** # lt

Less Than. the value for the parameter in the resource is less than the provided value. */
    Lt,
    /** # ne

Not Equals. the value for the parameter in the resource is not equal to the provided value. */
    Ne,
    /** # sa

Starts After. the value for the parameter in the resource starts after the provided value. */
    Sa,
}
impl ::core::str::FromStr for SearchComparator {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ap" => Ok(Self::Ap),
            "eb" => Ok(Self::Eb),
            "eq" => Ok(Self::Eq),
            "ge" => Ok(Self::Ge),
            "gt" => Ok(Self::Gt),
            "le" => Ok(Self::Le),
            "lt" => Ok(Self::Lt),
            "ne" => Ok(Self::Ne),
            "sa" => Ok(Self::Sa),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchComparator {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ap => "ap",
            Self::Eb => "eb",
            Self::Eq => "eq",
            Self::Ge => "ge",
            Self::Gt => "gt",
            Self::Le => "le",
            Self::Lt => "lt",
            Self::Ne => "ne",
            Self::Sa => "sa",
        }
    }
}
impl<'de> Deserialize<'de> for SearchComparator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchComparator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SearchEntryMode`. Why an entry is in the result set - whether it's included as a match or because of an _include requirement, or to convey information or warning information about the search process.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SearchEntryMode {
    /** # include

Include. This resource is returned because it is referred to from another resource in the search set. */
    Include,
    /** # match

Match. This resource matched the search specification. */
    Match,
    /** # outcome

Outcome. An OperationOutcome that provides additional information about the processing of a search. */
    Outcome,
}
impl ::core::str::FromStr for SearchEntryMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "include" => Ok(Self::Include),
            "match" => Ok(Self::Match),
            "outcome" => Ok(Self::Outcome),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchEntryMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Include => "include",
            Self::Match => "match",
            Self::Outcome => "outcome",
        }
    }
}
impl<'de> Deserialize<'de> for SearchEntryMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchEntryMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SearchModifierCode`. A supported modifier for a search parameter.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SearchModifierCode {
    /** # above

Above. The search parameter tests whether the value in a resource subsumes the specified value (is-a, or hierarchical relationships). */
    Above,
    /** # below

Below. The search parameter tests whether the value in a resource is subsumed by the specified value (is-a, or hierarchical relationships). */
    Below,
    /** # contains

Contains. The search parameter returns resources that include the supplied parameter value anywhere within the field being searched. */
    Contains,
    /** # exact

Exact. The search parameter returns resources that have a value that exactly matches the supplied parameter (the whole string, including casing and accents). */
    Exact,
    /** # identifier

Identifier. The search parameter applies to the identifier on the resource, not the reference. */
    Identifier,
    /** # in

In. The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is in the specified value set. */
    In,
    /** # missing

Missing. The search parameter returns resources that have a value or not. */
    Missing,
    /** # not

Not. The search parameter returns resources that do not contain a match. */
    Not,
    /** # not-in

Not In. The search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the coding is not in the specified value set. */
    NotIn,
    /** # ofType

Of Type. The search parameter has the format system|code|value, where the system and code refer to an Identifier.type.coding.system and .code, and match if any of the type codes match. All 3 parts must be present. */
    OfType,
    /** # text

Text. The search parameter is processed as a string that searches text associated with the code/value - either CodeableConcept.text, Coding.display, or Identifier.type.text. */
    Text,
    /** # type

Type. The search parameter only applies to the Resource Type specified as a modifier (e.g. the modifier is not actually :type, but :Patient etc.). */
    Type,
}
impl ::core::str::FromStr for SearchModifierCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "above" => Ok(Self::Above),
            "below" => Ok(Self::Below),
            "contains" => Ok(Self::Contains),
            "exact" => Ok(Self::Exact),
            "identifier" => Ok(Self::Identifier),
            "in" => Ok(Self::In),
            "missing" => Ok(Self::Missing),
            "not" => Ok(Self::Not),
            "not-in" => Ok(Self::NotIn),
            "ofType" => Ok(Self::OfType),
            "text" => Ok(Self::Text),
            "type" => Ok(Self::Type),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchModifierCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Above => "above",
            Self::Below => "below",
            Self::Contains => "contains",
            Self::Exact => "exact",
            Self::Identifier => "identifier",
            Self::In => "in",
            Self::Missing => "missing",
            Self::Not => "not",
            Self::NotIn => "not-in",
            Self::OfType => "ofType",
            Self::Text => "text",
            Self::Type => "type",
        }
    }
}
impl<'de> Deserialize<'de> for SearchModifierCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchModifierCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SearchParamType`. Data types allowed to be used for search parameters.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SearchParamType {
    /** # composite

Composite. A composite search parameter that combines a search on two values together. */
    Composite,
    /** # date

Date/DateTime. Search parameter is on a date/time. The date format is the standard XML format, though other formats may be supported. */
    Date,
    /** # number

Number. Search parameter SHALL be a number (a whole number, or a decimal). */
    Number,
    /** # quantity

Quantity. A search parameter that searches on a quantity. */
    Quantity,
    /** # reference

Reference. A reference to another resource (Reference or canonical). */
    Reference,
    /** # special

Special. Special logic applies to this parameter per the description of the search parameter. */
    Special,
    /** # string

String. Search parameter is a simple string, like a name part. Search is case-insensitive and accent-insensitive. May match just the start of a string. String parameters may contain spaces. */
    String,
    /** # token

Token. Search parameter on a coded element or identifier. May be used to search through the text, display, code and code/codesystem (for codes) and label, system and key (for identifier). Its value is either a string or a pair of namespace and value, separated by a "|", depending on the modifier used. */
    Token,
    /** # uri

URI. A search parameter that searches on a URI (RFC 3986). */
    Uri,
}
impl ::core::str::FromStr for SearchParamType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "composite" => Ok(Self::Composite),
            "date" => Ok(Self::Date),
            "number" => Ok(Self::Number),
            "quantity" => Ok(Self::Quantity),
            "reference" => Ok(Self::Reference),
            "special" => Ok(Self::Special),
            "string" => Ok(Self::String),
            "token" => Ok(Self::Token),
            "uri" => Ok(Self::Uri),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SearchParamType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Composite => "composite",
            Self::Date => "date",
            Self::Number => "number",
            Self::Quantity => "quantity",
            Self::Reference => "reference",
            Self::Special => "special",
            Self::String => "string",
            Self::Token => "token",
            Self::Uri => "uri",
        }
    }
}
impl<'de> Deserialize<'de> for SearchParamType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SearchParamType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SecurityRoleType`. This CodeSystem contains Additional FHIR-defined Security Role types not defined elsewhere

FHIR version: 4.3.0-cibuild.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SecurityRoleType {
    /** # authserver

authorization server. An entity providing authorization services to enable the electronic sharing of health-related information based on resource owner's preapproved permissions. For example, an UMA Authorization Server[UMA] */
    Authserver,
    /** # datacollector

data collector. An entity that collects information over which the data subject may have certain rights under policy or law to control that information's management and distribution by data collectors, including the right to access, retrieve, distribute, or delete that information. */
    Datacollector,
    /** # dataprocessor

data processor. An entity that processes collected information over which the data subject may have certain rights under policy or law to control that information's management and distribution by data processors, including the right to access, retrieve, distribute, or delete that information. */
    Dataprocessor,
    /** # datasubject

data subject. A person whose personal information is collected or processed, and who may have certain rights under policy or law to control that information's management and distribution by data collectors or processors, including the right to access, retrieve, distribute, or delete that information. */
    Datasubject,
    /** # humanuser

human user. The human user that has participated. */
    Humanuser,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SecurityRoleType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "authserver" => Ok(Self::Authserver),
            "datacollector" => Ok(Self::Datacollector),
            "dataprocessor" => Ok(Self::Dataprocessor),
            "datasubject" => Ok(Self::Datasubject),
            "humanuser" => Ok(Self::Humanuser),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SecurityRoleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Authserver => "authserver",
            Self::Datacollector => "datacollector",
            Self::Dataprocessor => "dataprocessor",
            Self::Datasubject => "datasubject",
            Self::Humanuser => "humanuser",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for SecurityRoleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SecurityRoleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ServiceCategory`. This value set defines an example set of codes that can be used to classify groupings of service-types/specialties.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ServiceCategory {
    /** # 1

Adoption. Adoption */
    N1,
    /** # 10

Dental. Dental */
    N10,
    /** # 11

Disability Support. Disability Support */
    N11,
    /** # 12

Drug/Alcohol. Drug/Alcohol */
    N12,
    /** # 13

Education & Learning. Education & Learning */
    N13,
    /** # 14

Emergency Department. Emergency Department */
    N14,
    /** # 15

Employment. Employment */
    N15,
    /** # 16

Financial & Material Aid. Financial & Material aid */
    N16,
    /** # 17

General Practice. General Practice/GP (doctor) */
    N17,
    /** # 18

Housing/Homelessness. Housing/Homelessness */
    N18,
    /** # 19

Interpreting. Interpreting */
    N19,
    /** # 2

Aged Care. Aged Care */
    N2,
    /** # 20

Justice. Justice */
    N20,
    /** # 21

Legal. Legal */
    N21,
    /** # 22

Mental Health. Mental Health */
    N22,
    /** # 23

Physical Activity & Recreation. Physical Activity & Recreation */
    N23,
    /** # 24

Regulation. Regulation */
    N24,
    /** # 25

Respite/Carer Support. Respite/Carer Support */
    N25,
    /** # 26

Specialist Clinical Pathology. Specialist Clinical Pathology - requires referral */
    N26,
    /** # 27

Specialist Medical. Specialist Medical - requires referral */
    N27,
    /** # 28

Specialist Obstetrics & Gynecology. Specialist Obstetrics & Gynecology - requires referral */
    N28,
    /** # 29

Specialist Paediatric. Specialist Paediatric - requires referral */
    N29,
    /** # 3

Alternative/Complementary Therapies. Alternative & Complementary Therapies */
    N3,
    /** # 30

Specialist Radiology/Imaging. Specialist Radiology/Imaging - requires referral */
    N30,
    /** # 31

Specialist Surgical. Specialist Surgical - requires referral */
    N31,
    /** # 32

Support Group/s. Support group/s */
    N32,
    /** # 33

Transport. Transport */
    N33,
    /** # 34

Allied Health. Allied Health */
    N34,
    /** # 35

Hospital. Hospital */
    N35,
    /** # 36

Crisis Line (GPAH use only). Crisis Line (GPAH use only) */
    N36,
    /** # 37

Test Message (HSD admin). Test Message (HSD admin use only) */
    N37,
    /** # 38

NDIA. NDIA */
    N38,
    /** # 4

Child Care /Kindergarten. Child Care and/or Kindergarten */
    N4,
    /** # 5

Child Development. Child Development */
    N5,
    /** # 6

Child Protection & Family Services. Child Protection & Family Services */
    N6,
    /** # 7

Community Health Care. Community Health Care */
    N7,
    /** # 8

Counselling. Counselling */
    N8,
    /** # 9

Death Services. Death Services */
    N9,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ServiceCategory {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "10" => Ok(Self::N10),
            "11" => Ok(Self::N11),
            "12" => Ok(Self::N12),
            "13" => Ok(Self::N13),
            "14" => Ok(Self::N14),
            "15" => Ok(Self::N15),
            "16" => Ok(Self::N16),
            "17" => Ok(Self::N17),
            "18" => Ok(Self::N18),
            "19" => Ok(Self::N19),
            "2" => Ok(Self::N2),
            "20" => Ok(Self::N20),
            "21" => Ok(Self::N21),
            "22" => Ok(Self::N22),
            "23" => Ok(Self::N23),
            "24" => Ok(Self::N24),
            "25" => Ok(Self::N25),
            "26" => Ok(Self::N26),
            "27" => Ok(Self::N27),
            "28" => Ok(Self::N28),
            "29" => Ok(Self::N29),
            "3" => Ok(Self::N3),
            "30" => Ok(Self::N30),
            "31" => Ok(Self::N31),
            "32" => Ok(Self::N32),
            "33" => Ok(Self::N33),
            "34" => Ok(Self::N34),
            "35" => Ok(Self::N35),
            "36" => Ok(Self::N36),
            "37" => Ok(Self::N37),
            "38" => Ok(Self::N38),
            "4" => Ok(Self::N4),
            "5" => Ok(Self::N5),
            "6" => Ok(Self::N6),
            "7" => Ok(Self::N7),
            "8" => Ok(Self::N8),
            "9" => Ok(Self::N9),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ServiceCategory {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N10 => "10",
            Self::N11 => "11",
            Self::N12 => "12",
            Self::N13 => "13",
            Self::N14 => "14",
            Self::N15 => "15",
            Self::N16 => "16",
            Self::N17 => "17",
            Self::N18 => "18",
            Self::N19 => "19",
            Self::N2 => "2",
            Self::N20 => "20",
            Self::N21 => "21",
            Self::N22 => "22",
            Self::N23 => "23",
            Self::N24 => "24",
            Self::N25 => "25",
            Self::N26 => "26",
            Self::N27 => "27",
            Self::N28 => "28",
            Self::N29 => "29",
            Self::N3 => "3",
            Self::N30 => "30",
            Self::N31 => "31",
            Self::N32 => "32",
            Self::N33 => "33",
            Self::N34 => "34",
            Self::N35 => "35",
            Self::N36 => "36",
            Self::N37 => "37",
            Self::N38 => "38",
            Self::N4 => "4",
            Self::N5 => "5",
            Self::N6 => "6",
            Self::N7 => "7",
            Self::N8 => "8",
            Self::N9 => "9",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ServiceCategory {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ServiceCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ServiceProvisionConditions`. The code(s) that detail the conditions under which the healthcare service is available/offered.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum ServiceProvisionConditions {
    /** # cost

Fees apply. Fees apply for this service. */
    Cost,
    /** # disc

Discounts Available. There are discounts available on this service for qualifying patients. */
    Disc,
    /** # free

Free. This service is available for no patient cost. */
    Free,
}
impl ::core::str::FromStr for ServiceProvisionConditions {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "cost" => Ok(Self::Cost),
            "disc" => Ok(Self::Disc),
            "free" => Ok(Self::Free),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for ServiceProvisionConditions {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cost => "cost",
            Self::Disc => "disc",
            Self::Free => "free",
        }
    }
}
impl<'de> Deserialize<'de> for ServiceProvisionConditions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ServiceProvisionConditions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `ServiceType`. This value set defines an example set of codes that can be used to classify groupings of service-types/specialties.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ServiceType {
    /** # 1

Adoption/Permanent Care Info/Support. Adoption & permanent care information/support */
    N1,
    /** # 10

Personal Alarms/Alerts. Personal alarms/alerts */
    N10,
    /** # 100

Disability Information/Referral. Disability information/referral */
    N100,
    /** # 101

Disability Support Packages. Disability support packages */
    N101,
    /** # 102

Disability Supported Accommodation. Disability supported accommodation */
    N102,
    /** # 103

Early Childhood Intervention. Early childhood intervention */
    N103,
    /** # 104

Hearing Aids & Equipment. Hearing aids & equipment */
    N104,
    /** # 105

Drug and/or Alcohol Counselling. Drug and/or alcohol counselling */
    N105,
    /** # 106

Drug/Alcohol Information/Referral. Drug and/or alcohol information/referral */
    N106,
    /** # 107

Needle & Syringe Exchange. Needle & Syringe exchange */
    N107,
    /** # 108

Non-resid. Alcohol/Drug Treatment. Non-residential alcohol and/or drug dependence treatment */
    N108,
    /** # 109

Pharmacotherapy. Pharmacotherapy (eg. methadone) program */
    N109,
    /** # 11

Personal Care for Older Persons. Personal care for older persons */
    N11,
    /** # 110

Quit Program. Quit program */
    N110,
    /** # 111

Residential Alcohol/Drug Treatment. Residential alcohol and/or drug dependence treatment */
    N111,
    /** # 112

Adult/Community Education. Adult/community education */
    N112,
    /** # 113

Higher Education. Higher education */
    N113,
    /** # 114

Primary Education. Primary education */
    N114,
    /** # 115

Secondary Education. Secondary education */
    N115,
    /** # 116

Training & Vocational Education. Training & vocational education */
    N116,
    /** # 117

Emergency Medical. Emergency medical */
    N117,
    /** # 118

Employment Placement and/or Support. Employment placement and/or support */
    N118,
    /** # 119

Vocational Rehabilitation. Vocational Rehabilitation */
    N119,
    /** # 12

Planned Activity Groups. Planned activity groups */
    N12,
    /** # 120

Work Safety/Accident Prevention. Workplace safety and/or accident prevention */
    N120,
    /** # 121

Financial Assistance. Financial assistance */
    N121,
    /** # 122

Financial Information/Advice. Financial information/advice */
    N122,
    /** # 123

Material Aid. Material aid */
    N123,
    /** # 124

General Practice. General Practice/GP (doctor) */
    N124,
    /** # 125

Accommodation Placement/Support. Accommodation placement and/or support */
    N125,
    /** # 126

Crisis/Emergency Accommodation. Crisis/emergency accommodation */
    N126,
    /** # 127

Homelessness Support. Homelessness support */
    N127,
    /** # 128

Housing Information/Referral. Housing information/referral */
    N128,
    /** # 129

Public Rental Housing. Public rental housing */
    N129,
    /** # 13

Acupuncture. Acupuncture */
    N13,
    /** # 130

Interpreting/Multilingual Service. Interpreting/Multilingual/Language service */
    N130,
    /** # 131

Juvenile Justice. Juvenile Justice */
    N131,
    /** # 132

Legal Advocacy. Legal advocacy */
    N132,
    /** # 133

Legal Information/Advice/Referral. Legal information/advice/referral */
    N133,
    /** # 134

Mental Health Advocacy. Mental health advocacy */
    N134,
    /** # 135

Mental Health Assess/Triage/Crisis Response. Mental health assessment/triage/crisis response */
    N135,
    /** # 136

Mental Health Case Management. Mental health case management/continuing care */
    N136,
    /** # 137

Mental Health Information/Referral. Mental health information/referral */
    N137,
    /** # 138

Mental Health Inpatient Services. Mental health inpatient services (hospital psychiatric unit) - requires referral */
    N138,
    /** # 139

Mental Health Non-residential Rehab. Mental health non-residential rehabilitation */
    N139,
    /** # 14

Alexander Technique Therapy. Alexander technique therapy */
    N14,
    /** # 140

Mental Health Residential Rehab/CCU. Mental health residential rehabilitation/community care unit */
    N140,
    /** # 141

Psychiatry (Requires Referral). Psychiatry (requires referral) */
    N141,
    /** # 142

Psychology. Psychology */
    N142,
    /** # 143

Martial Arts. Martial arts */
    N143,
    /** # 144

Personal Fitness Training. Personal fitness training */
    N144,
    /** # 145

Physical Activity Group. Physical activity group */
    N145,
    /** # 146

Physical Activity Programs. Physical activity programs */
    N146,
    /** # 147

Physical Fitness Testing. Physical fitness testing */
    N147,
    /** # 148

Pilates. Pilates */
    N148,
    /** # 149

Self-Defence. Self defence */
    N149,
    /** # 15

Aromatherapy. Aromatherapy */
    N15,
    /** # 150

Sporting Club. Sporting club */
    N150,
    /** # 151

Yoga. Yoga */
    N151,
    /** # 152

Food Safety. Food safety */
    N152,
    /** # 153

Health Regulatory /Inspection /Cert.. Health regulatory, inspection and/or certification */
    N153,
    /** # 154

Work Health/Safety Inspection/Cert.. Workplace health and/or safety inspection and/or certification */
    N154,
    /** # 155

Carer Support. Carer support */
    N155,
    /** # 156

Respite Care. Respite care */
    N156,
    /** # 157

Anatomical Pathology. Anatomical Pathology (including Cytopathology & Forensic Pathology) */
    N157,
    /** # 158

Pathology - Clinical Chemistry. Pathology - Clinical Chemistry */
    N158,
    /** # 159

Pathology - General. Pathology - General */
    N159,
    /** # 16

Biorhythm Services. Biorhythm services */
    N16,
    /** # 160

Pathology - Genetics. Pathology - Genetics */
    N160,
    /** # 161

Pathology - Haematology. Pathology - Haematology */
    N161,
    /** # 162

Pathology - Immunology. Pathology - Immunology */
    N162,
    /** # 163

Pathology - Microbiology. Pathology - Microbiology */
    N163,
    /** # 164

Anaesthesiology - Pain Medicine. Anaesthesiology - Pain Medicine */
    N164,
    /** # 165

Cardiology. Cardiology */
    N165,
    /** # 166

Clinical Genetics. Clinical Genetics */
    N166,
    /** # 167

Clinical Pharmacology. Clinical Pharmacology */
    N167,
    /** # 168

Dermatology. Dermatology */
    N168,
    /** # 169

Endocrinology. Endocrinology */
    N169,
    /** # 17

Bowen Therapy. Bowen therapy */
    N17,
    /** # 170

Gastroenterology & Hepatology. Gastroenterology & Hepatology */
    N170,
    /** # 171

Geriatric Medicine. Geriatric medicine */
    N171,
    /** # 172

Immunology & Allergy. Immunology & Allergy */
    N172,
    /** # 173

Infectious Diseases. Infectious diseases */
    N173,
    /** # 174

Intensive Care Medicine. Intensive care medicine */
    N174,
    /** # 175

Medical Oncology. Medical Oncology */
    N175,
    /** # 176

Nephrology. Nephrology */
    N176,
    /** # 177

Neurology. Neurology */
    N177,
    /** # 178

Occupational Medicine. Occupational Medicine */
    N178,
    /** # 179

Palliative Medicine. Palliative Medicine */
    N179,
    /** # 18

Chinese Herbal Medicine. Chinese herbal medicine */
    N18,
    /** # 180

Public Health Medicine. Public Health Medicine */
    N180,
    /** # 181

Rehabilitation Medicine. Rehabilitation Medicine */
    N181,
    /** # 182

Rheumatology. Rheumatology */
    N182,
    /** # 183

Sleep Medicine. Sleep Medicine */
    N183,
    /** # 184

Thoracic Medicine. Thoracic medicine */
    N184,
    /** # 185

Gynaecological Oncology. Gynaecological Oncology */
    N185,
    /** # 186

Obstetrics & Gynaecology. Obstetrics & Gynaecology */
    N186,
    /** # 187

Reproductive Endocrinology/Infertility. Reproductive Endocrinology & Infertility */
    N187,
    /** # 188

Urogynaecology. Urogynaecology */
    N188,
    /** # 189

Neonatology & Perinatology. Neonatology & Perinatology */
    N189,
    /** # 19

Feldenkrais. Feldenkrais */
    N19,
    /** # 190

Paediatric Cardiology. Paediatric Cardiology */
    N190,
    /** # 191

Paediatric Clinical Genetics. Paediatric Clinical Genetics */
    N191,
    /** # 192

Paediatric Clinical Pharmacology. Paediatric Clinical Pharmacology */
    N192,
    /** # 193

Paediatric Endocrinology. Paediatric Endocrinology */
    N193,
    /** # 194

Paed. Gastroenterology/Hepatology. Paediatric Gastroenterology & Hepatology */
    N194,
    /** # 195

Paediatric Haematology. Paediatric Haematology */
    N195,
    /** # 196

Paediatric Immunology & Allergy. Paediatric Immunology & Allergy */
    N196,
    /** # 197

Paediatric Infectious Diseases. Paediatric Infectious diseases */
    N197,
    /** # 198

Paediatric Intensive Care Medicine. Paediatric intensive care medicine */
    N198,
    /** # 199

Paediatric Medical Oncology. Paediatric Medical Oncology */
    N199,
    /** # 2

Aged Care Assessment. Aged care assessment */
    N2,
    /** # 20

Homoeopathy. Homoeopathy */
    N20,
    /** # 200

Paediatric Medicine. Paediatric Medicine */
    N200,
    /** # 201

Paediatric Nephrology. Paediatric Nephrology */
    N201,
    /** # 202

Paediatric Neurology. Paediatric Neurology */
    N202,
    /** # 203

Paediatric Nuclear Medicine. Paediatric Nuclear Medicine */
    N203,
    /** # 204

Paediatric Rehabilitation Medicine. Paediatric Rehabilitation Medicine */
    N204,
    /** # 205

Paediatric Rheumatology. Paediatric Rheumatology */
    N205,
    /** # 206

Paediatric Sleep Medicine. Paediatric Sleep Medicine */
    N206,
    /** # 207

Paediatric Surgery. Paediatric Surgery */
    N207,
    /** # 208

Paediatric Thoracic Medicine. Paediatric Thoracic Medicine */
    N208,
    /** # 209

Diag. Radiology /Xray /CT /Fluoroscopy. Diagnostic Radiology/Xray/CT/Fluoroscopy */
    N209,
    /** # 21

Hydrotherapy. Hydrotherapy */
    N21,
    /** # 210

Diagnostic Ultrasound. Diagnostic Ultrasound */
    N210,
    /** # 211

Magnetic Resonance Imaging (MRI). Magnetic Resonance Imaging (MRI) */
    N211,
    /** # 212

Nuclear Medicine. Nuclear Medicine */
    N212,
    /** # 213

Obstetric/Gynaecological Ultrasound. Obstetric & Gynaecological Ultrasound */
    N213,
    /** # 214

Radiation Oncology. Radiation oncology */
    N214,
    /** # 215

Cardiothoracic Surgery. Cardiothoracic surgery */
    N215,
    /** # 216

Neurosurgery. Neurosurgery */
    N216,
    /** # 217

Ophthalmology. Ophthalmology */
    N217,
    /** # 218

Orthopaedic Surgery. Orthopaedic surgery */
    N218,
    /** # 219

Otolaryngology/Head & Neck Surgery. Otolaryngology - Head & Neck Surgery */
    N219,
    /** # 22

Hypnotherapy. Hypnotherapy */
    N22,
    /** # 220

Plastic & Reconstructive Surgery. Plastic & Reconstructive Surgery */
    N220,
    /** # 221

Surgery - General. Surgery - General */
    N221,
    /** # 222

Urology. Urology */
    N222,
    /** # 223

Vascular Surgery. Vascular surgery */
    N223,
    /** # 224

Support Groups. Support groups */
    N224,
    /** # 225

Air ambulance. Air ambulance */
    N225,
    /** # 226

Ambulance. Ambulance */
    N226,
    /** # 227

Blood Transport. Blood transport */
    N227,
    /** # 228

Community Bus. Community bus */
    N228,
    /** # 229

Flying Doctor Service. Flying doctor service */
    N229,
    /** # 23

Kinesiology. Kinesiology */
    N23,
    /** # 230

Patient Transport. Patient transport */
    N230,
    /** # 231

A&E. A&E */
    N231,
    /** # 232

A&EP. A&EP */
    N232,
    /** # 233

Abuse. Abuse */
    N233,
    /** # 234

ACAS. ACAS */
    N234,
    /** # 235

Access. Access */
    N235,
    /** # 236

Accident. Accident */
    N236,
    /** # 237

Acute Inpatient Serv. Acute Inpatient Service's */
    N237,
    /** # 238

Adult Day Programs. Adult Day Programs */
    N238,
    /** # 239

Adult Mental Health Services. Adult Mental Health Services */
    N239,
    /** # 24

Magnetic Therapy. Magnetic therapy */
    N24,
    /** # 240

Advice. Advice */
    N240,
    /** # 241

Advocacy. Advocacy */
    N241,
    /** # 242

Aged Persons Mental. Aged Persons Mental Health Residential Units */
    N242,
    /** # 243

Aged Persons Mental. Aged Persons Mental Health Services */
    N243,
    /** # 244

Aged Persons Mental. Aged Persons Mental Health Teams */
    N244,
    /** # 245

Aids. Aids */
    N245,
    /** # 246

Al-Anon. Al-Anon */
    N246,
    /** # 247

Alcohol. Alcohol */
    N247,
    /** # 248

Al-Teen. Al-Teen */
    N248,
    /** # 249

Antenatal. Antenatal */
    N249,
    /** # 25

Massage Therapy. Massage therapy */
    N25,
    /** # 250

Anxiety. Anxiety */
    N250,
    /** # 251

Arthritis. Arthritis */
    N251,
    /** # 252

Assessment. Assessment */
    N252,
    /** # 253

Assistance. Assistance */
    N253,
    /** # 254

Asthma. Asthma */
    N254,
    /** # 255

ATSS. ATSS */
    N255,
    /** # 256

Attendant Care. Attendant Care */
    N256,
    /** # 257

Babies. Babies */
    N257,
    /** # 258

Bathroom Modificatio. Bathroom Modification */
    N258,
    /** # 259

Behavior. Behavior */
    N259,
    /** # 26

Meditation. Meditation */
    N26,
    /** # 260

Behavior Interventi. Behavior Intervention */
    N260,
    /** # 261

Bereavement. Bereavement */
    N261,
    /** # 262

Bipolar. Bipolar */
    N262,
    /** # 263

Birth. Birth */
    N263,
    /** # 264

Birth Control. Birth Control */
    N264,
    /** # 265

Birthing Options. Birthing Options */
    N265,
    /** # 266

BIST. BIST */
    N266,
    /** # 267

Blood. Blood */
    N267,
    /** # 268

Bone. Bone */
    N268,
    /** # 269

Bowel. Bowel */
    N269,
    /** # 27

Myotherapy. Myotherapy */
    N27,
    /** # 270

Brain. Brain */
    N270,
    /** # 271

Breast Feeding. Breast Feeding */
    N271,
    /** # 272

Breast Screen. Breast Screen */
    N272,
    /** # 273

Brokerage. Brokerage */
    N273,
    /** # 274

Cancer. Cancer */
    N274,
    /** # 275

Cancer Support. Cancer Support */
    N275,
    /** # 276

Cardiovascular Disea. Cardiovascular Disease */
    N276,
    /** # 277

Care Packages. Care Packages */
    N277,
    /** # 278

Carer. Carer */
    N278,
    /** # 279

Case Management. Case Management */
    N279,
    /** # 28

Naturopathy. Naturopathy */
    N28,
    /** # 280

Casualty. Casualty */
    N280,
    /** # 281

Centrelink. Centrelink */
    N281,
    /** # 282

Chemists. Chemists */
    N282,
    /** # 283

Child And Adolescent. Child And Adolescent Mental Health Services */
    N283,
    /** # 284

Child Care. Child Care */
    N284,
    /** # 285

Child Services. Child Services */
    N285,
    /** # 286

Children. Children */
    N286,
    /** # 287

Children's Services. Children's Services */
    N287,
    /** # 288

Cholesterol. Cholesterol */
    N288,
    /** # 289

Clothing. Clothing */
    N289,
    /** # 29

Reflexology. Reflexology */
    N29,
    /** # 290

Community Based Acco. Community Based Accommodation */
    N290,
    /** # 291

Community Care Unit. Community Care Unit */
    N291,
    /** # 292

Community Child And. Community Child And Adolescent Mental Health Services */
    N292,
    /** # 293

Community Health. Community Health */
    N293,
    /** # 294

Community Residentia. Community Residential Unit */
    N294,
    /** # 295

Community Transport. Community Transport */
    N295,
    /** # 296

Companion Visiting. Companion Visiting */
    N296,
    /** # 297

Companionship. Companionship */
    N297,
    /** # 298

Consumer Advice. Consumer Advice */
    N298,
    /** # 299

Consumer Issues. Consumer Issues */
    N299,
    /** # 3

Aged Care Information/Referral. Aged Care information/referral */
    N3,
    /** # 30

Reiki. Reiki */
    N30,
    /** # 300

Continuing Care Serv. Continuing Care Services */
    N300,
    /** # 301

Contraception Inform. Contraception Information */
    N301,
    /** # 302

Coordinating Bodies. Coordinating Bodies */
    N302,
    /** # 303

Correctional Service. Correctional Services */
    N303,
    /** # 304

Council Environmenta. Council Environmental Health */
    N304,
    /** # 305

Counselling. Counselling */
    N305,
    /** # 306

Criminal. Criminal */
    N306,
    /** # 307

Crises. Crises */
    N307,
    /** # 308

Crisis Assessment An. Crisis Assessment And Treatment Services (Cats) */
    N308,
    /** # 309

Crisis Assistance. Crisis Assistance */
    N309,
    /** # 31

Relaxation Therapy. Relaxation therapy */
    N31,
    /** # 310

Crisis Refuge. Crisis Refuge */
    N310,
    /** # 311

Day Program. Day Program */
    N311,
    /** # 312

Deaf. Deaf */
    N312,
    /** # 313

Dental Hygiene. Dental Hygiene */
    N313,
    /** # 314

Dentistry. Dentistry */
    N314,
    /** # 315

Dentures. Dentures */
    N315,
    /** # 316

Depression. Depression */
    N316,
    /** # 317

Detoxification. Detoxification */
    N317,
    /** # 318

Diabetes. Diabetes */
    N318,
    /** # 319

Diaphragm Fitting. Diaphragm Fitting */
    N319,
    /** # 32

Shiatsu. Shiatsu */
    N32,
    /** # 320

Dieticians. Dieticians */
    N320,
    /** # 321

Disabled Parking. Disabled Parking */
    N321,
    /** # 322

District Nursing. District Nursing */
    N322,
    /** # 323

Divorce. Divorce */
    N323,
    /** # 324

Doctors. Doctors */
    N324,
    /** # 325

Drink-Drive. Drink-Drive */
    N325,
    /** # 326

Dual Diagnosis Servi. Dual Diagnosis Services */
    N326,
    /** # 327

Early Choice. Early Choice */
    N327,
    /** # 328

Eating Disorder. Eating Disorder */
    N328,
    /** # 33

Western Herbal Medicine. Western herbal medicine */
    N33,
    /** # 330

Emergency Relief. Emergency Relief */
    N330,
    /** # 331

Employment And Train. Employment And Training */
    N331,
    /** # 332

Environment. Environment */
    N332,
    /** # 333

Equipment. Equipment */
    N333,
    /** # 334

Exercise. Exercise */
    N334,
    /** # 335

Facility. Facility */
    N335,
    /** # 336

Family Choice. Family Choice */
    N336,
    /** # 337

Family Law. Family Law */
    N337,
    /** # 338

Family Options. Family Options */
    N338,
    /** # 339

Family Services. Family Services */
    N339,
    /** # 34

Family Day care. Family day care */
    N34,
    /** # 340

FFYA. FFYA */
    N340,
    /** # 341

Financial Aid. Financial Aid */
    N341,
    /** # 342

Fitness. Fitness */
    N342,
    /** # 343

Flexible Care Packag. Flexible Care Packages */
    N343,
    /** # 344

Food. Food */
    N344,
    /** # 345

Food Vouchers. Food Vouchers */
    N345,
    /** # 346

Forensic Mental Heal. Forensic Mental Health Services */
    N346,
    /** # 347

Futures. Futures */
    N347,
    /** # 348

Futures For Young Ad. Futures For Young Adults */
    N348,
    /** # 349

General Practitioner. General Practitioners */
    N349,
    /** # 35

Holiday Programs. Holiday programs */
    N35,
    /** # 350

Grants. Grants */
    N350,
    /** # 351

Grief. Grief */
    N351,
    /** # 352

Grief Counselling. Grief Counselling */
    N352,
    /** # 353

HACC. HACC */
    N353,
    /** # 354

Heart Disease. Heart Disease */
    N354,
    /** # 355

Help. Help */
    N355,
    /** # 356

High Blood Pressure. High Blood Pressure */
    N356,
    /** # 357

Home Help. Home Help */
    N357,
    /** # 358

Home Nursing. Home Nursing */
    N358,
    /** # 359

Homefirst. Homefirst */
    N359,
    /** # 36

Kindergarten Inclusion Support. Kindergarten inclusion support for children with a disability */
    N36,
    /** # 360

Hospice Care. Hospice Care */
    N360,
    /** # 361

Hospital Services. Hospital Services */
    N361,
    /** # 362

Hospital To Home. Hospital To Home */
    N362,
    /** # 364

Hostel. Hostel */
    N364,
    /** # 365

Hostel Accommodation. Hostel Accommodation */
    N365,
    /** # 366

Household Items. Household Items */
    N366,
    /** # 367

Hypertension. Hypertension */
    N367,
    /** # 368

Illness. Illness */
    N368,
    /** # 369

Independent Living. Independent Living */
    N369,
    /** # 37

Kindergarten/Preschool. Kindergarten/preschool */
    N37,
    /** # 370

Information. Information */
    N370,
    /** # 371

Injury. Injury */
    N371,
    /** # 372

Intake. Intake */
    N372,
    /** # 373

Intensive Mobile You. Intensive Mobile Youth Outreach Services (Imyos) */
    N373,
    /** # 374

Intervention. Intervention */
    N374,
    /** # 375

Job Searching. Job Searching */
    N375,
    /** # 376

Justice. Justice */
    N376,
    /** # 377

Leisure. Leisure */
    N377,
    /** # 378

Loans. Loans */
    N378,
    /** # 379

Low Income Earners. Low Income Earners */
    N379,
    /** # 38

Long Day Child Care. Long day child care */
    N38,
    /** # 380

Lung. Lung */
    N380,
    /** # 381

Making A Difference. Making A Difference */
    N381,
    /** # 382

Medical Services. Medical Services */
    N382,
    /** # 383

Medical Specialists. Medical Specialists */
    N383,
    /** # 384

Medication Administr. Medication Administration */
    N384,
    /** # 385

Menstrual Informatio. Menstrual Information */
    N385,
    /** # 386

Methadone. Methadone */
    N386,
    /** # 387

Mobile Support And T. Mobile Support And Treatment Services (MSTS) */
    N387,
    /** # 388

Motor Neurone. Motor Neurone */
    N388,
    /** # 389

Multiple Sclerosis. Multiple Sclerosis */
    N389,
    /** # 39

Occasional Child Care. Occasional child care */
    N39,
    /** # 390

Neighbourhood House. Neighbourhood House */
    N390,
    /** # 391

Nursing Home. Nursing Home */
    N391,
    /** # 392

Nursing Mothers. Nursing Mothers */
    N392,
    /** # 393

Obesity. Obesity */
    N393,
    /** # 394

Occupational Health. Occupational Health & Safety */
    N394,
    /** # 395

Optometrist. Optometrist */
    N395,
    /** # 396

Oral Hygiene. Oral Hygiene */
    N396,
    /** # 397

Outpatients. Outpatients */
    N397,
    /** # 398

Outreach Service. Outreach Service */
    N398,
    /** # 399

PADP. PADP */
    N399,
    /** # 4

Aged Residential Care. Aged Residential Care */
    N4,
    /** # 40

Outside School Hours Care. Outside school hours care */
    N40,
    /** # 400

Pain. Pain */
    N400,
    /** # 401

Pap Smear. Pap Smear */
    N401,
    /** # 402

Parenting. Parenting */
    N402,
    /** # 403

Peak Organizations. Peak Organizations */
    N403,
    /** # 404

Personal Care. Personal Care */
    N404,
    /** # 405

Pharmacies. Pharmacies */
    N405,
    /** # 406

Phobias. Phobias */
    N406,
    /** # 407

Physical. Physical */
    N407,
    /** # 408

Physical Activity. Physical Activity */
    N408,
    /** # 409

Postnatal. Postnatal */
    N409,
    /** # 41

Children's Play Programs. Children's play programs */
    N41,
    /** # 410

Pregnancy. Pregnancy */
    N410,
    /** # 411

Pregnancy Tests. Pregnancy Tests */
    N411,
    /** # 412

Preschool. Preschool */
    N412,
    /** # 413

Prescriptions. Prescriptions */
    N413,
    /** # 414

Primary Mental Healt. Primary Mental Health And Early Intervention Teams */
    N414,
    /** # 415

Property Maintenance. Property Maintenance */
    N415,
    /** # 416

Prostate. Prostate */
    N416,
    /** # 417

Psychiatric. Psychiatric */
    N417,
    /** # 418

Psychiatric Disabili. Psychiatric Disability Support Services - Home-Based Outreach */
    N418,
    /** # 419

Psychiatric Disabili. Psychiatric Disability Support Services - Planned Respite */
    N419,
    /** # 42

Parenting/Family Support/Education. Parenting & family management support/education */
    N42,
    /** # 420

Psychiatric Disabili. Psychiatric Disability Support Services - Residential Rehabilitation */
    N420,
    /** # 421

Psychiatric Disabili. Psychiatric Disability Support Services Home-Based Outreach */
    N421,
    /** # 422

Psychiatric Disabili. Psychiatric Disability Support Services Mutual Support And Self Help */
    N422,
    /** # 423

Psychiatric Support. Psychiatric Support */
    N423,
    /** # 424

Recreation. Recreation */
    N424,
    /** # 425

Referral. Referral */
    N425,
    /** # 426

Refuge. Refuge */
    N426,
    /** # 427

Rent Assistance. Rent Assistance */
    N427,
    /** # 428

Residential Faciliti. Residential Facilities */
    N428,
    /** # 429

Residential Respite. Residential Respite */
    N429,
    /** # 43

Playgroup. Playgroup */
    N43,
    /** # 430

Respiratory. Respiratory */
    N430,
    /** # 431

Response. Response */
    N431,
    /** # 432

Rooming Houses. Rooming Houses */
    N432,
    /** # 433

Safe Sex. Safe Sex */
    N433,
    /** # 434

Secure Extended Care. Secure Extended Care Inpatient Services */
    N434,
    /** # 435

Self Help. Self Help */
    N435,
    /** # 436

Separation. Separation */
    N436,
    /** # 437

Services. Services */
    N437,
    /** # 438

Sex Education. Sex Education */
    N438,
    /** # 439

Sexual Abuse. Sexual Abuse */
    N439,
    /** # 44

School Nursing. School nursing */
    N44,
    /** # 440

Sexual Issues. Sexual Issues */
    N440,
    /** # 441

Sexually Transmitted. Sexually Transmitted Diseases */
    N441,
    /** # 442

SIDS. SIDS */
    N442,
    /** # 443

Social Support. Social Support */
    N443,
    /** # 444

Socialisation. Socialisation */
    N444,
    /** # 445

Special Needs. Special Needs */
    N445,
    /** # 446

Speech Therapist. Speech Therapist */
    N446,
    /** # 447

Splinting. Splinting */
    N447,
    /** # 448

Sport. Sport */
    N448,
    /** # 449

Statewide And Specia. Statewide And Specialist Services */
    N449,
    /** # 45

Toy Library. Toy library */
    N45,
    /** # 450

STD. STD */
    N450,
    /** # 451

STI. STI */
    N451,
    /** # 452

Stillbirth. Stillbirth */
    N452,
    /** # 453

Stomal Care. Stomal Care */
    N453,
    /** # 454

Stroke. Stroke */
    N454,
    /** # 455

Substance Abuse. Substance Abuse */
    N455,
    /** # 456

Support. Support */
    N456,
    /** # 457

Syringes. Syringes */
    N457,
    /** # 458

Teeth. Teeth */
    N458,
    /** # 459

Tenancy Advice. Tenancy Advice */
    N459,
    /** # 46

Child Protection/Child Abuse Report. Child protection/child abuse report */
    N46,
    /** # 460

Terminal Illness. Terminal Illness */
    N460,
    /** # 461

Therapy. Therapy */
    N461,
    /** # 462

Transcription. Transcription */
    N462,
    /** # 463

Translating Services. Translating Services */
    N463,
    /** # 464

Translator. Translator */
    N464,
    /** # 465

Transport. Transport */
    N465,
    /** # 466

Vertebrae. Vertebrae */
    N466,
    /** # 467

Violence. Violence */
    N467,
    /** # 468

Vocational Guidance. Vocational Guidance */
    N468,
    /** # 469

Weight. Weight */
    N469,
    /** # 47

Foster Care. Foster care */
    N47,
    /** # 470

Welfare Assistance. Welfare Assistance */
    N470,
    /** # 471

Welfare Counselling. Welfare Counselling */
    N471,
    /** # 472

Wheelchairs. Wheelchairs */
    N472,
    /** # 473

Wound Management. Wound Management */
    N473,
    /** # 474

Young People At Risk. Young People At Risk */
    N474,
    /** # 475

Further Desc. - Community Health Care. Further Description - Community Health Care */
    N475,
    /** # 476

Library. Library */
    N476,
    /** # 477

Community Hours. Community Hours */
    N477,
    /** # 478

Further Desc. - Specialist Medical. Further Description - Specialist Medical */
    N478,
    /** # 479

Hepatology. Hepatology */
    N479,
    /** # 48

Residential/Out-of-Home Care. Residential/ out of home care */
    N48,
    /** # 480

Gastroenterology. Gastroenterology */
    N480,
    /** # 481

Gynaecology. Gynaecology */
    N481,
    /** # 482

Obstetrics. Obstetrics */
    N482,
    /** # 483

Further Desc. - Specialist Surgical. Further Description - Specialist Surgical */
    N483,
    /** # 484

Placement Protection. Placement Protection */
    N484,
    /** # 485

Family Violence. Family Violence */
    N485,
    /** # 486

Integrated Family Services. Integrated Family Services */
    N486,
    /** # 488

Diabetes Educator. Diabetes Educator */
    N488,
    /** # 489

Kinship Care. Kinship Care */
    N489,
    /** # 49

Support - Young People Leaving Care. Support for young people leaving care */
    N49,
    /** # 490

General Mental Health Services. General Mental Health Services */
    N490,
    /** # 491

Exercise Physiology. Exercise Physiology */
    N491,
    /** # 492

Medical Research. Medical Research */
    N492,
    /** # 493

Youth. Youth */
    N493,
    /** # 494

Youth Services. Youth Services */
    N494,
    /** # 495

Youth Health. Youth Health */
    N495,
    /** # 496

Child and Family Ser. Child and Family Services */
    N496,
    /** # 497

Home Visits. Home Visits */
    N497,
    /** # 498

Mobile Services. Mobile Services */
    N498,
    /** # 5

Case Management for Older Persons. Case management for older persons */
    N5,
    /** # 50

Audiology. Audiology */
    N50,
    /** # 500

Before and/or After. Before and/or After School Care */
    N500,
    /** # 501

Cancer Services. Cancer Services */
    N501,
    /** # 502

Integrated Cancer Se. Integrated Cancer Services */
    N502,
    /** # 503

Multidisciplinary Se. Multidisciplinary Services */
    N503,
    /** # 504

Multidisciplinary Ca. Multidisciplinary Cancer Services */
    N504,
    /** # 505

Meetings. Meetings */
    N505,
    /** # 506

Blood pressure monit. Blood pressure monitoring */
    N506,
    /** # 507

Dose administration. Dose administration aid */
    N507,
    /** # 508

Medical Equipment Hi. Medical Equipment Hire */
    N508,
    /** # 509

Parenting/Family Support/Education. Parenting & family support/education */
    N509,
    /** # 51

Blood Donation. Blood donation */
    N51,
    /** # 510

Deputising Service. Deputising Service */
    N510,
    /** # 513

Cancer Support Groups. Cancer Support Groups */
    N513,
    /** # 514

Community Cancer Services. Community Cancer Services */
    N514,
    /** # 52

Chiropractic. Chiropractic */
    N52,
    /** # 53

Dietetics. Dietetics */
    N53,
    /** # 530

Disability Care Transport. Disability Care Transport */
    N530,
    /** # 531

Aged Care Transport. Aged Care Transport */
    N531,
    /** # 532

Diabetes Education s. Diabetes Education service */
    N532,
    /** # 533

Cardiac Rehabilitati. Cardiac Rehabilitation Service */
    N533,
    /** # 534

Young Adult Diabetes. Young Adult Diabetes services (YADS) */
    N534,
    /** # 535

Pulmonary Rehabilita. Pulmonary Rehabilitation Service */
    N535,
    /** # 536

Art therapy. Art therapy */
    N536,
    /** # 537

Medication Reviews. Medication Reviews */
    N537,
    /** # 538

Telephone Counselling. Telephone Counselling */
    N538,
    /** # 539

Telephone Help Line. Telephone Help Line */
    N539,
    /** # 54

Family Planning. Family planning */
    N54,
    /** # 540

Online Service. Online Service */
    N540,
    /** # 541

Crisis - Mental Health. Crisis - Mental Health */
    N541,
    /** # 542

Youth Crisis. Youth Crisis */
    N542,
    /** # 543

Sexual Assault. Sexual Assault */
    N543,
    /** # 544

GPAH Other. GPAH Other */
    N544,
    /** # 545

Paediatric Dermatology. Paediatric Dermatology */
    N545,
    /** # 546

Veterans Services. Veterans Services */
    N546,
    /** # 547

Veterans. Veterans */
    N547,
    /** # 548

Food Relief/Food/Meals. Food Relief/food/meals */
    N548,
    /** # 55

Health Advocacy/Liaison Service. Health advocacy/Liaison service */
    N55,
    /** # 550

Dementia Care. Dementia Care */
    N550,
    /** # 551

Alzheimer. Alzheimer */
    N551,
    /** # 552

Drug and/or Alcohol Support Groups. Drug and/or alcohol support groups */
    N552,
    /** # 553

1-on-1 Support /Mentoring /Coaching. One on One Support/Mentoring/Coaching */
    N553,
    /** # 554

Chronic Disease Management. Chronic Disease Management */
    N554,
    /** # 555

Liaison Services. Liaison Services */
    N555,
    /** # 556

Walk-in Centre /Non-Emergency. Walk in Centre / non emergency */
    N556,
    /** # 557

Inpatients. Inpatients */
    N557,
    /** # 558

Spiritual Counselling. Spiritual Counselling */
    N558,
    /** # 559

Women's Health. Women's Health */
    N559,
    /** # 56

Health Information/Referral. Health information/referral */
    N56,
    /** # 560

Men's Health. Men's Health */
    N560,
    /** # 561

Health Education/Awareness Program. Health education/Health awareness program */
    N561,
    /** # 562

Test Message. Test Message */
    N562,
    /** # 563

Remedial Massage. Remedial Massage */
    N563,
    /** # 564

Adolescent Mental Health Services. Adolescent Mental Health Services */
    N564,
    /** # 565

Youth Drop In/Assistance/Support. Youth drop in/assistance/support */
    N565,
    /** # 566

Aboriginal Health Worker. Aboriginal Health Worker */
    N566,
    /** # 567

Women's Health Clinic. Women's Health Clinic */
    N567,
    /** # 568

Men's Health Clinic. Men's Health Clinic */
    N568,
    /** # 569

Migrant Health Clinic. Migrant Health Clinic */
    N569,
    /** # 57

Immunization. Immunization */
    N57,
    /** # 570

Refugee Health Clinic. Refugee Health Clinic */
    N570,
    /** # 571

Aboriginal Health Clinic. Aboriginal Health Clinic */
    N571,
    /** # 572

Nurse Practitioner Lead Clinic/s. Nurse Practitioner lead Clinic/s */
    N572,
    /** # 573

Nurse Lead Clinic/s. Nurse lead Clinic/s */
    N573,
    /** # 574

Culturally Tailored Support Groups. Culturally tailored support groups */
    N574,
    /** # 575

Culturally Tailored Health Promotion. Culturally tailored health promotion */
    N575,
    /** # 576

Rehabilitation. Rehabilitation */
    N576,
    /** # 577

Education Information/Referral. Education information/referral */
    N577,
    /** # 58

Maternal & Child Health. Maternal & child health */
    N58,
    /** # 580

Social Work. Social Work */
    N580,
    /** # 581

Haematology. Haematology */
    N581,
    /** # 582

Maternity Shared Car. Maternity Shared Care */
    N582,
    /** # 583

Rehabilitation Servi. Rehabilitation Service */
    N583,
    /** # 584

Cranio-sacral Therapy. Cranio-Sacral Therapy */
    N584,
    /** # 585

Prosthetics & Orthotics. Prosthetics & Orthotics */
    N585,
    /** # 589

Home Medicine Review. Home Medicine Review */
    N589,
    /** # 59

Nursing. Nursing */
    N59,
    /** # 590

GPAH - Medical. GPAH - Medical */
    N590,
    /** # 591

Music Therapy. Music Therapy */
    N591,
    /** # 593

Falls Prevention. Falls Prevention */
    N593,
    /** # 599

Accommodation/Tenancy. Accommodation/Tenancy */
    N599,
    /** # 6

Delivered Meals (Meals On Wheels). Delivered meals (meals on wheels) */
    N6,
    /** # 60

Nutrition. Nutrition */
    N60,
    /** # 600

Assess-Skill, Ability, Needs. Assess-Skill, Ability, Needs */
    N600,
    /** # 601

Assist Access/Maintain Employ. Assist Access/Maintain Employ */
    N601,
    /** # 602

Assist Prod-Pers Care/Safety. Assist Prod-Pers Care/Safety */
    N602,
    /** # 603

Assist-Integrate School/Ed. Assist-Integrate School/Ed */
    N603,
    /** # 604

Assist-Life Stage, Transition. Assist-Life Stage, Transition */
    N604,
    /** # 605

Assist-Personal Activities. Assist-Personal Activities */
    N605,
    /** # 606

Assist-Travel/Transport. Assist-Travel/Transport */
    N606,
    /** # 607

Assistive Equip-General Tasks. Assistive Equip-General Tasks */
    N607,
    /** # 608

Assistive Equip-Recreation. Assistive Equip-Recreation */
    N608,
    /** # 609

Assistive Prod-Household Task. Assistive Prod-Household Task */
    N609,
    /** # 61

Occupational Therapy. Occupational therapy */
    N61,
    /** # 610

Behavior Support. Behavior Support */
    N610,
    /** # 611

Comms & Info Equipment. Comms & Info Equipment */
    N611,
    /** # 612

Community Nursing Care. Community Nursing Care */
    N612,
    /** # 613

Daily Tasks/Shared Living. Daily Tasks/Shared Living */
    N613,
    /** # 614

Development-Life Skills. Development-Life Skills */
    N614,
    /** # 615

Early Childhood Supports. Early Childhood Supports */
    N615,
    /** # 616

Equipment Special Assess Setup. Equipment Special Assess Setup */
    N616,
    /** # 617

Hearing Equipment. Hearing Equipment */
    N617,
    /** # 618

Home Modification. Home Modification */
    N618,
    /** # 619

Household Tasks. Household Tasks */
    N619,
    /** # 62

Optometry. Optometry */
    N62,
    /** # 620

Interpret/Translate. Interpret/Translate */
    N620,
    /** # 621

Other Innovative Supports. Other Innovative Supports */
    N621,
    /** # 622

Participate Community. Participate Community */
    N622,
    /** # 623

Personal Mobility Equipment. Personal Mobility Equipment */
    N623,
    /** # 624

Physical Wellbeing. Physical Wellbeing */
    N624,
    /** # 625

Plan Management. Plan Management */
    N625,
    /** # 626

Therapeutic Supports. Therapeutic Supports */
    N626,
    /** # 627

Training-Travel Independence. Training-Travel Independence */
    N627,
    /** # 628

Vehicle modifications. Vehicle modifications */
    N628,
    /** # 629

Vision Equipment. Vision Equipment */
    N629,
    /** # 63

Osteopathy. Osteopathy */
    N63,
    /** # 64

Pharmacy. Pharmacy */
    N64,
    /** # 65

Physiotherapy. Physiotherapy */
    N65,
    /** # 66

Podiatry. Podiatry */
    N66,
    /** # 67

Sexual Health. Sexual health */
    N67,
    /** # 68

Speech Pathology/Therapy. Speech pathology/therapy */
    N68,
    /** # 69

Bereavement Counselling. Bereavement counselling */
    N69,
    /** # 7

Friendly Visiting. Friendly visiting */
    N7,
    /** # 70

Crisis Counselling. Crisis counselling */
    N70,
    /** # 71

Family Counselling/Therapy. Family counselling and/or family therapy */
    N71,
    /** # 72

Family Violence Counselling. Family violence counselling */
    N72,
    /** # 73

Financial Counselling. Financial counselling */
    N73,
    /** # 74

Generalist Counselling. Generalist counselling */
    N74,
    /** # 75

Genetic Counselling. Genetic counselling */
    N75,
    /** # 76

Health Counselling. Health counselling */
    N76,
    /** # 77

Mediation. Mediation */
    N77,
    /** # 78

Problem Gambling Counselling. Problem gambling counselling */
    N78,
    /** # 79

Relationship Counselling. Relationship counselling */
    N79,
    /** # 8

Home Care/Housekeeping Assistance. Home care/housekeeping assistance */
    N8,
    /** # 80

Sexual Assault Counselling. Sexual assault counselling */
    N80,
    /** # 81

Trauma Counselling. Trauma counselling */
    N81,
    /** # 82

Victims of Crime Counselling. Victims of crime counselling */
    N82,
    /** # 83

Cemetery Operation. Cemetery operation */
    N83,
    /** # 84

Cremation. Cremation */
    N84,
    /** # 85

Death Service Information. Death service information */
    N85,
    /** # 86

Funeral Services. Funeral services */
    N86,
    /** # 87

Endodontic. Endodontic */
    N87,
    /** # 88

General Dental. General dental */
    N88,
    /** # 89

Oral Medicine. Oral medicine */
    N89,
    /** # 9

Home Maintenance and Repair. Home maintenance and repair */
    N9,
    /** # 90

Oral Surgery. Oral surgery */
    N90,
    /** # 91

Orthodontic. Orthodontic */
    N91,
    /** # 92

Paediatric Dentistry. Paediatric Dentistry */
    N92,
    /** # 93

Periodontic. Periodontic */
    N93,
    /** # 94

Prosthodontic. Prosthodontic */
    N94,
    /** # 95

Acquired Brain Injury Info/Referral. Acquired brain injury information/referral */
    N95,
    /** # 96

Disability Advocacy. Disability advocacy */
    N96,
    /** # 97

Disability Aids & Equipment. Disability aids & equipment */
    N97,
    /** # 98

Disability Case Management. Disability case management */
    N98,
    /** # 99

Disability Day Programs/Activities. Disability day programs & activities */
    N99,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for ServiceType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1" => Ok(Self::N1),
            "10" => Ok(Self::N10),
            "100" => Ok(Self::N100),
            "101" => Ok(Self::N101),
            "102" => Ok(Self::N102),
            "103" => Ok(Self::N103),
            "104" => Ok(Self::N104),
            "105" => Ok(Self::N105),
            "106" => Ok(Self::N106),
            "107" => Ok(Self::N107),
            "108" => Ok(Self::N108),
            "109" => Ok(Self::N109),
            "11" => Ok(Self::N11),
            "110" => Ok(Self::N110),
            "111" => Ok(Self::N111),
            "112" => Ok(Self::N112),
            "113" => Ok(Self::N113),
            "114" => Ok(Self::N114),
            "115" => Ok(Self::N115),
            "116" => Ok(Self::N116),
            "117" => Ok(Self::N117),
            "118" => Ok(Self::N118),
            "119" => Ok(Self::N119),
            "12" => Ok(Self::N12),
            "120" => Ok(Self::N120),
            "121" => Ok(Self::N121),
            "122" => Ok(Self::N122),
            "123" => Ok(Self::N123),
            "124" => Ok(Self::N124),
            "125" => Ok(Self::N125),
            "126" => Ok(Self::N126),
            "127" => Ok(Self::N127),
            "128" => Ok(Self::N128),
            "129" => Ok(Self::N129),
            "13" => Ok(Self::N13),
            "130" => Ok(Self::N130),
            "131" => Ok(Self::N131),
            "132" => Ok(Self::N132),
            "133" => Ok(Self::N133),
            "134" => Ok(Self::N134),
            "135" => Ok(Self::N135),
            "136" => Ok(Self::N136),
            "137" => Ok(Self::N137),
            "138" => Ok(Self::N138),
            "139" => Ok(Self::N139),
            "14" => Ok(Self::N14),
            "140" => Ok(Self::N140),
            "141" => Ok(Self::N141),
            "142" => Ok(Self::N142),
            "143" => Ok(Self::N143),
            "144" => Ok(Self::N144),
            "145" => Ok(Self::N145),
            "146" => Ok(Self::N146),
            "147" => Ok(Self::N147),
            "148" => Ok(Self::N148),
            "149" => Ok(Self::N149),
            "15" => Ok(Self::N15),
            "150" => Ok(Self::N150),
            "151" => Ok(Self::N151),
            "152" => Ok(Self::N152),
            "153" => Ok(Self::N153),
            "154" => Ok(Self::N154),
            "155" => Ok(Self::N155),
            "156" => Ok(Self::N156),
            "157" => Ok(Self::N157),
            "158" => Ok(Self::N158),
            "159" => Ok(Self::N159),
            "16" => Ok(Self::N16),
            "160" => Ok(Self::N160),
            "161" => Ok(Self::N161),
            "162" => Ok(Self::N162),
            "163" => Ok(Self::N163),
            "164" => Ok(Self::N164),
            "165" => Ok(Self::N165),
            "166" => Ok(Self::N166),
            "167" => Ok(Self::N167),
            "168" => Ok(Self::N168),
            "169" => Ok(Self::N169),
            "17" => Ok(Self::N17),
            "170" => Ok(Self::N170),
            "171" => Ok(Self::N171),
            "172" => Ok(Self::N172),
            "173" => Ok(Self::N173),
            "174" => Ok(Self::N174),
            "175" => Ok(Self::N175),
            "176" => Ok(Self::N176),
            "177" => Ok(Self::N177),
            "178" => Ok(Self::N178),
            "179" => Ok(Self::N179),
            "18" => Ok(Self::N18),
            "180" => Ok(Self::N180),
            "181" => Ok(Self::N181),
            "182" => Ok(Self::N182),
            "183" => Ok(Self::N183),
            "184" => Ok(Self::N184),
            "185" => Ok(Self::N185),
            "186" => Ok(Self::N186),
            "187" => Ok(Self::N187),
            "188" => Ok(Self::N188),
            "189" => Ok(Self::N189),
            "19" => Ok(Self::N19),
            "190" => Ok(Self::N190),
            "191" => Ok(Self::N191),
            "192" => Ok(Self::N192),
            "193" => Ok(Self::N193),
            "194" => Ok(Self::N194),
            "195" => Ok(Self::N195),
            "196" => Ok(Self::N196),
            "197" => Ok(Self::N197),
            "198" => Ok(Self::N198),
            "199" => Ok(Self::N199),
            "2" => Ok(Self::N2),
            "20" => Ok(Self::N20),
            "200" => Ok(Self::N200),
            "201" => Ok(Self::N201),
            "202" => Ok(Self::N202),
            "203" => Ok(Self::N203),
            "204" => Ok(Self::N204),
            "205" => Ok(Self::N205),
            "206" => Ok(Self::N206),
            "207" => Ok(Self::N207),
            "208" => Ok(Self::N208),
            "209" => Ok(Self::N209),
            "21" => Ok(Self::N21),
            "210" => Ok(Self::N210),
            "211" => Ok(Self::N211),
            "212" => Ok(Self::N212),
            "213" => Ok(Self::N213),
            "214" => Ok(Self::N214),
            "215" => Ok(Self::N215),
            "216" => Ok(Self::N216),
            "217" => Ok(Self::N217),
            "218" => Ok(Self::N218),
            "219" => Ok(Self::N219),
            "22" => Ok(Self::N22),
            "220" => Ok(Self::N220),
            "221" => Ok(Self::N221),
            "222" => Ok(Self::N222),
            "223" => Ok(Self::N223),
            "224" => Ok(Self::N224),
            "225" => Ok(Self::N225),
            "226" => Ok(Self::N226),
            "227" => Ok(Self::N227),
            "228" => Ok(Self::N228),
            "229" => Ok(Self::N229),
            "23" => Ok(Self::N23),
            "230" => Ok(Self::N230),
            "231" => Ok(Self::N231),
            "232" => Ok(Self::N232),
            "233" => Ok(Self::N233),
            "234" => Ok(Self::N234),
            "235" => Ok(Self::N235),
            "236" => Ok(Self::N236),
            "237" => Ok(Self::N237),
            "238" => Ok(Self::N238),
            "239" => Ok(Self::N239),
            "24" => Ok(Self::N24),
            "240" => Ok(Self::N240),
            "241" => Ok(Self::N241),
            "242" => Ok(Self::N242),
            "243" => Ok(Self::N243),
            "244" => Ok(Self::N244),
            "245" => Ok(Self::N245),
            "246" => Ok(Self::N246),
            "247" => Ok(Self::N247),
            "248" => Ok(Self::N248),
            "249" => Ok(Self::N249),
            "25" => Ok(Self::N25),
            "250" => Ok(Self::N250),
            "251" => Ok(Self::N251),
            "252" => Ok(Self::N252),
            "253" => Ok(Self::N253),
            "254" => Ok(Self::N254),
            "255" => Ok(Self::N255),
            "256" => Ok(Self::N256),
            "257" => Ok(Self::N257),
            "258" => Ok(Self::N258),
            "259" => Ok(Self::N259),
            "26" => Ok(Self::N26),
            "260" => Ok(Self::N260),
            "261" => Ok(Self::N261),
            "262" => Ok(Self::N262),
            "263" => Ok(Self::N263),
            "264" => Ok(Self::N264),
            "265" => Ok(Self::N265),
            "266" => Ok(Self::N266),
            "267" => Ok(Self::N267),
            "268" => Ok(Self::N268),
            "269" => Ok(Self::N269),
            "27" => Ok(Self::N27),
            "270" => Ok(Self::N270),
            "271" => Ok(Self::N271),
            "272" => Ok(Self::N272),
            "273" => Ok(Self::N273),
            "274" => Ok(Self::N274),
            "275" => Ok(Self::N275),
            "276" => Ok(Self::N276),
            "277" => Ok(Self::N277),
            "278" => Ok(Self::N278),
            "279" => Ok(Self::N279),
            "28" => Ok(Self::N28),
            "280" => Ok(Self::N280),
            "281" => Ok(Self::N281),
            "282" => Ok(Self::N282),
            "283" => Ok(Self::N283),
            "284" => Ok(Self::N284),
            "285" => Ok(Self::N285),
            "286" => Ok(Self::N286),
            "287" => Ok(Self::N287),
            "288" => Ok(Self::N288),
            "289" => Ok(Self::N289),
            "29" => Ok(Self::N29),
            "290" => Ok(Self::N290),
            "291" => Ok(Self::N291),
            "292" => Ok(Self::N292),
            "293" => Ok(Self::N293),
            "294" => Ok(Self::N294),
            "295" => Ok(Self::N295),
            "296" => Ok(Self::N296),
            "297" => Ok(Self::N297),
            "298" => Ok(Self::N298),
            "299" => Ok(Self::N299),
            "3" => Ok(Self::N3),
            "30" => Ok(Self::N30),
            "300" => Ok(Self::N300),
            "301" => Ok(Self::N301),
            "302" => Ok(Self::N302),
            "303" => Ok(Self::N303),
            "304" => Ok(Self::N304),
            "305" => Ok(Self::N305),
            "306" => Ok(Self::N306),
            "307" => Ok(Self::N307),
            "308" => Ok(Self::N308),
            "309" => Ok(Self::N309),
            "31" => Ok(Self::N31),
            "310" => Ok(Self::N310),
            "311" => Ok(Self::N311),
            "312" => Ok(Self::N312),
            "313" => Ok(Self::N313),
            "314" => Ok(Self::N314),
            "315" => Ok(Self::N315),
            "316" => Ok(Self::N316),
            "317" => Ok(Self::N317),
            "318" => Ok(Self::N318),
            "319" => Ok(Self::N319),
            "32" => Ok(Self::N32),
            "320" => Ok(Self::N320),
            "321" => Ok(Self::N321),
            "322" => Ok(Self::N322),
            "323" => Ok(Self::N323),
            "324" => Ok(Self::N324),
            "325" => Ok(Self::N325),
            "326" => Ok(Self::N326),
            "327" => Ok(Self::N327),
            "328" => Ok(Self::N328),
            "33" => Ok(Self::N33),
            "330" => Ok(Self::N330),
            "331" => Ok(Self::N331),
            "332" => Ok(Self::N332),
            "333" => Ok(Self::N333),
            "334" => Ok(Self::N334),
            "335" => Ok(Self::N335),
            "336" => Ok(Self::N336),
            "337" => Ok(Self::N337),
            "338" => Ok(Self::N338),
            "339" => Ok(Self::N339),
            "34" => Ok(Self::N34),
            "340" => Ok(Self::N340),
            "341" => Ok(Self::N341),
            "342" => Ok(Self::N342),
            "343" => Ok(Self::N343),
            "344" => Ok(Self::N344),
            "345" => Ok(Self::N345),
            "346" => Ok(Self::N346),
            "347" => Ok(Self::N347),
            "348" => Ok(Self::N348),
            "349" => Ok(Self::N349),
            "35" => Ok(Self::N35),
            "350" => Ok(Self::N350),
            "351" => Ok(Self::N351),
            "352" => Ok(Self::N352),
            "353" => Ok(Self::N353),
            "354" => Ok(Self::N354),
            "355" => Ok(Self::N355),
            "356" => Ok(Self::N356),
            "357" => Ok(Self::N357),
            "358" => Ok(Self::N358),
            "359" => Ok(Self::N359),
            "36" => Ok(Self::N36),
            "360" => Ok(Self::N360),
            "361" => Ok(Self::N361),
            "362" => Ok(Self::N362),
            "364" => Ok(Self::N364),
            "365" => Ok(Self::N365),
            "366" => Ok(Self::N366),
            "367" => Ok(Self::N367),
            "368" => Ok(Self::N368),
            "369" => Ok(Self::N369),
            "37" => Ok(Self::N37),
            "370" => Ok(Self::N370),
            "371" => Ok(Self::N371),
            "372" => Ok(Self::N372),
            "373" => Ok(Self::N373),
            "374" => Ok(Self::N374),
            "375" => Ok(Self::N375),
            "376" => Ok(Self::N376),
            "377" => Ok(Self::N377),
            "378" => Ok(Self::N378),
            "379" => Ok(Self::N379),
            "38" => Ok(Self::N38),
            "380" => Ok(Self::N380),
            "381" => Ok(Self::N381),
            "382" => Ok(Self::N382),
            "383" => Ok(Self::N383),
            "384" => Ok(Self::N384),
            "385" => Ok(Self::N385),
            "386" => Ok(Self::N386),
            "387" => Ok(Self::N387),
            "388" => Ok(Self::N388),
            "389" => Ok(Self::N389),
            "39" => Ok(Self::N39),
            "390" => Ok(Self::N390),
            "391" => Ok(Self::N391),
            "392" => Ok(Self::N392),
            "393" => Ok(Self::N393),
            "394" => Ok(Self::N394),
            "395" => Ok(Self::N395),
            "396" => Ok(Self::N396),
            "397" => Ok(Self::N397),
            "398" => Ok(Self::N398),
            "399" => Ok(Self::N399),
            "4" => Ok(Self::N4),
            "40" => Ok(Self::N40),
            "400" => Ok(Self::N400),
            "401" => Ok(Self::N401),
            "402" => Ok(Self::N402),
            "403" => Ok(Self::N403),
            "404" => Ok(Self::N404),
            "405" => Ok(Self::N405),
            "406" => Ok(Self::N406),
            "407" => Ok(Self::N407),
            "408" => Ok(Self::N408),
            "409" => Ok(Self::N409),
            "41" => Ok(Self::N41),
            "410" => Ok(Self::N410),
            "411" => Ok(Self::N411),
            "412" => Ok(Self::N412),
            "413" => Ok(Self::N413),
            "414" => Ok(Self::N414),
            "415" => Ok(Self::N415),
            "416" => Ok(Self::N416),
            "417" => Ok(Self::N417),
            "418" => Ok(Self::N418),
            "419" => Ok(Self::N419),
            "42" => Ok(Self::N42),
            "420" => Ok(Self::N420),
            "421" => Ok(Self::N421),
            "422" => Ok(Self::N422),
            "423" => Ok(Self::N423),
            "424" => Ok(Self::N424),
            "425" => Ok(Self::N425),
            "426" => Ok(Self::N426),
            "427" => Ok(Self::N427),
            "428" => Ok(Self::N428),
            "429" => Ok(Self::N429),
            "43" => Ok(Self::N43),
            "430" => Ok(Self::N430),
            "431" => Ok(Self::N431),
            "432" => Ok(Self::N432),
            "433" => Ok(Self::N433),
            "434" => Ok(Self::N434),
            "435" => Ok(Self::N435),
            "436" => Ok(Self::N436),
            "437" => Ok(Self::N437),
            "438" => Ok(Self::N438),
            "439" => Ok(Self::N439),
            "44" => Ok(Self::N44),
            "440" => Ok(Self::N440),
            "441" => Ok(Self::N441),
            "442" => Ok(Self::N442),
            "443" => Ok(Self::N443),
            "444" => Ok(Self::N444),
            "445" => Ok(Self::N445),
            "446" => Ok(Self::N446),
            "447" => Ok(Self::N447),
            "448" => Ok(Self::N448),
            "449" => Ok(Self::N449),
            "45" => Ok(Self::N45),
            "450" => Ok(Self::N450),
            "451" => Ok(Self::N451),
            "452" => Ok(Self::N452),
            "453" => Ok(Self::N453),
            "454" => Ok(Self::N454),
            "455" => Ok(Self::N455),
            "456" => Ok(Self::N456),
            "457" => Ok(Self::N457),
            "458" => Ok(Self::N458),
            "459" => Ok(Self::N459),
            "46" => Ok(Self::N46),
            "460" => Ok(Self::N460),
            "461" => Ok(Self::N461),
            "462" => Ok(Self::N462),
            "463" => Ok(Self::N463),
            "464" => Ok(Self::N464),
            "465" => Ok(Self::N465),
            "466" => Ok(Self::N466),
            "467" => Ok(Self::N467),
            "468" => Ok(Self::N468),
            "469" => Ok(Self::N469),
            "47" => Ok(Self::N47),
            "470" => Ok(Self::N470),
            "471" => Ok(Self::N471),
            "472" => Ok(Self::N472),
            "473" => Ok(Self::N473),
            "474" => Ok(Self::N474),
            "475" => Ok(Self::N475),
            "476" => Ok(Self::N476),
            "477" => Ok(Self::N477),
            "478" => Ok(Self::N478),
            "479" => Ok(Self::N479),
            "48" => Ok(Self::N48),
            "480" => Ok(Self::N480),
            "481" => Ok(Self::N481),
            "482" => Ok(Self::N482),
            "483" => Ok(Self::N483),
            "484" => Ok(Self::N484),
            "485" => Ok(Self::N485),
            "486" => Ok(Self::N486),
            "488" => Ok(Self::N488),
            "489" => Ok(Self::N489),
            "49" => Ok(Self::N49),
            "490" => Ok(Self::N490),
            "491" => Ok(Self::N491),
            "492" => Ok(Self::N492),
            "493" => Ok(Self::N493),
            "494" => Ok(Self::N494),
            "495" => Ok(Self::N495),
            "496" => Ok(Self::N496),
            "497" => Ok(Self::N497),
            "498" => Ok(Self::N498),
            "5" => Ok(Self::N5),
            "50" => Ok(Self::N50),
            "500" => Ok(Self::N500),
            "501" => Ok(Self::N501),
            "502" => Ok(Self::N502),
            "503" => Ok(Self::N503),
            "504" => Ok(Self::N504),
            "505" => Ok(Self::N505),
            "506" => Ok(Self::N506),
            "507" => Ok(Self::N507),
            "508" => Ok(Self::N508),
            "509" => Ok(Self::N509),
            "51" => Ok(Self::N51),
            "510" => Ok(Self::N510),
            "513" => Ok(Self::N513),
            "514" => Ok(Self::N514),
            "52" => Ok(Self::N52),
            "53" => Ok(Self::N53),
            "530" => Ok(Self::N530),
            "531" => Ok(Self::N531),
            "532" => Ok(Self::N532),
            "533" => Ok(Self::N533),
            "534" => Ok(Self::N534),
            "535" => Ok(Self::N535),
            "536" => Ok(Self::N536),
            "537" => Ok(Self::N537),
            "538" => Ok(Self::N538),
            "539" => Ok(Self::N539),
            "54" => Ok(Self::N54),
            "540" => Ok(Self::N540),
            "541" => Ok(Self::N541),
            "542" => Ok(Self::N542),
            "543" => Ok(Self::N543),
            "544" => Ok(Self::N544),
            "545" => Ok(Self::N545),
            "546" => Ok(Self::N546),
            "547" => Ok(Self::N547),
            "548" => Ok(Self::N548),
            "55" => Ok(Self::N55),
            "550" => Ok(Self::N550),
            "551" => Ok(Self::N551),
            "552" => Ok(Self::N552),
            "553" => Ok(Self::N553),
            "554" => Ok(Self::N554),
            "555" => Ok(Self::N555),
            "556" => Ok(Self::N556),
            "557" => Ok(Self::N557),
            "558" => Ok(Self::N558),
            "559" => Ok(Self::N559),
            "56" => Ok(Self::N56),
            "560" => Ok(Self::N560),
            "561" => Ok(Self::N561),
            "562" => Ok(Self::N562),
            "563" => Ok(Self::N563),
            "564" => Ok(Self::N564),
            "565" => Ok(Self::N565),
            "566" => Ok(Self::N566),
            "567" => Ok(Self::N567),
            "568" => Ok(Self::N568),
            "569" => Ok(Self::N569),
            "57" => Ok(Self::N57),
            "570" => Ok(Self::N570),
            "571" => Ok(Self::N571),
            "572" => Ok(Self::N572),
            "573" => Ok(Self::N573),
            "574" => Ok(Self::N574),
            "575" => Ok(Self::N575),
            "576" => Ok(Self::N576),
            "577" => Ok(Self::N577),
            "58" => Ok(Self::N58),
            "580" => Ok(Self::N580),
            "581" => Ok(Self::N581),
            "582" => Ok(Self::N582),
            "583" => Ok(Self::N583),
            "584" => Ok(Self::N584),
            "585" => Ok(Self::N585),
            "589" => Ok(Self::N589),
            "59" => Ok(Self::N59),
            "590" => Ok(Self::N590),
            "591" => Ok(Self::N591),
            "593" => Ok(Self::N593),
            "599" => Ok(Self::N599),
            "6" => Ok(Self::N6),
            "60" => Ok(Self::N60),
            "600" => Ok(Self::N600),
            "601" => Ok(Self::N601),
            "602" => Ok(Self::N602),
            "603" => Ok(Self::N603),
            "604" => Ok(Self::N604),
            "605" => Ok(Self::N605),
            "606" => Ok(Self::N606),
            "607" => Ok(Self::N607),
            "608" => Ok(Self::N608),
            "609" => Ok(Self::N609),
            "61" => Ok(Self::N61),
            "610" => Ok(Self::N610),
            "611" => Ok(Self::N611),
            "612" => Ok(Self::N612),
            "613" => Ok(Self::N613),
            "614" => Ok(Self::N614),
            "615" => Ok(Self::N615),
            "616" => Ok(Self::N616),
            "617" => Ok(Self::N617),
            "618" => Ok(Self::N618),
            "619" => Ok(Self::N619),
            "62" => Ok(Self::N62),
            "620" => Ok(Self::N620),
            "621" => Ok(Self::N621),
            "622" => Ok(Self::N622),
            "623" => Ok(Self::N623),
            "624" => Ok(Self::N624),
            "625" => Ok(Self::N625),
            "626" => Ok(Self::N626),
            "627" => Ok(Self::N627),
            "628" => Ok(Self::N628),
            "629" => Ok(Self::N629),
            "63" => Ok(Self::N63),
            "64" => Ok(Self::N64),
            "65" => Ok(Self::N65),
            "66" => Ok(Self::N66),
            "67" => Ok(Self::N67),
            "68" => Ok(Self::N68),
            "69" => Ok(Self::N69),
            "7" => Ok(Self::N7),
            "70" => Ok(Self::N70),
            "71" => Ok(Self::N71),
            "72" => Ok(Self::N72),
            "73" => Ok(Self::N73),
            "74" => Ok(Self::N74),
            "75" => Ok(Self::N75),
            "76" => Ok(Self::N76),
            "77" => Ok(Self::N77),
            "78" => Ok(Self::N78),
            "79" => Ok(Self::N79),
            "8" => Ok(Self::N8),
            "80" => Ok(Self::N80),
            "81" => Ok(Self::N81),
            "82" => Ok(Self::N82),
            "83" => Ok(Self::N83),
            "84" => Ok(Self::N84),
            "85" => Ok(Self::N85),
            "86" => Ok(Self::N86),
            "87" => Ok(Self::N87),
            "88" => Ok(Self::N88),
            "89" => Ok(Self::N89),
            "9" => Ok(Self::N9),
            "90" => Ok(Self::N90),
            "91" => Ok(Self::N91),
            "92" => Ok(Self::N92),
            "93" => Ok(Self::N93),
            "94" => Ok(Self::N94),
            "95" => Ok(Self::N95),
            "96" => Ok(Self::N96),
            "97" => Ok(Self::N97),
            "98" => Ok(Self::N98),
            "99" => Ok(Self::N99),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for ServiceType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N1 => "1",
            Self::N10 => "10",
            Self::N100 => "100",
            Self::N101 => "101",
            Self::N102 => "102",
            Self::N103 => "103",
            Self::N104 => "104",
            Self::N105 => "105",
            Self::N106 => "106",
            Self::N107 => "107",
            Self::N108 => "108",
            Self::N109 => "109",
            Self::N11 => "11",
            Self::N110 => "110",
            Self::N111 => "111",
            Self::N112 => "112",
            Self::N113 => "113",
            Self::N114 => "114",
            Self::N115 => "115",
            Self::N116 => "116",
            Self::N117 => "117",
            Self::N118 => "118",
            Self::N119 => "119",
            Self::N12 => "12",
            Self::N120 => "120",
            Self::N121 => "121",
            Self::N122 => "122",
            Self::N123 => "123",
            Self::N124 => "124",
            Self::N125 => "125",
            Self::N126 => "126",
            Self::N127 => "127",
            Self::N128 => "128",
            Self::N129 => "129",
            Self::N13 => "13",
            Self::N130 => "130",
            Self::N131 => "131",
            Self::N132 => "132",
            Self::N133 => "133",
            Self::N134 => "134",
            Self::N135 => "135",
            Self::N136 => "136",
            Self::N137 => "137",
            Self::N138 => "138",
            Self::N139 => "139",
            Self::N14 => "14",
            Self::N140 => "140",
            Self::N141 => "141",
            Self::N142 => "142",
            Self::N143 => "143",
            Self::N144 => "144",
            Self::N145 => "145",
            Self::N146 => "146",
            Self::N147 => "147",
            Self::N148 => "148",
            Self::N149 => "149",
            Self::N15 => "15",
            Self::N150 => "150",
            Self::N151 => "151",
            Self::N152 => "152",
            Self::N153 => "153",
            Self::N154 => "154",
            Self::N155 => "155",
            Self::N156 => "156",
            Self::N157 => "157",
            Self::N158 => "158",
            Self::N159 => "159",
            Self::N16 => "16",
            Self::N160 => "160",
            Self::N161 => "161",
            Self::N162 => "162",
            Self::N163 => "163",
            Self::N164 => "164",
            Self::N165 => "165",
            Self::N166 => "166",
            Self::N167 => "167",
            Self::N168 => "168",
            Self::N169 => "169",
            Self::N17 => "17",
            Self::N170 => "170",
            Self::N171 => "171",
            Self::N172 => "172",
            Self::N173 => "173",
            Self::N174 => "174",
            Self::N175 => "175",
            Self::N176 => "176",
            Self::N177 => "177",
            Self::N178 => "178",
            Self::N179 => "179",
            Self::N18 => "18",
            Self::N180 => "180",
            Self::N181 => "181",
            Self::N182 => "182",
            Self::N183 => "183",
            Self::N184 => "184",
            Self::N185 => "185",
            Self::N186 => "186",
            Self::N187 => "187",
            Self::N188 => "188",
            Self::N189 => "189",
            Self::N19 => "19",
            Self::N190 => "190",
            Self::N191 => "191",
            Self::N192 => "192",
            Self::N193 => "193",
            Self::N194 => "194",
            Self::N195 => "195",
            Self::N196 => "196",
            Self::N197 => "197",
            Self::N198 => "198",
            Self::N199 => "199",
            Self::N2 => "2",
            Self::N20 => "20",
            Self::N200 => "200",
            Self::N201 => "201",
            Self::N202 => "202",
            Self::N203 => "203",
            Self::N204 => "204",
            Self::N205 => "205",
            Self::N206 => "206",
            Self::N207 => "207",
            Self::N208 => "208",
            Self::N209 => "209",
            Self::N21 => "21",
            Self::N210 => "210",
            Self::N211 => "211",
            Self::N212 => "212",
            Self::N213 => "213",
            Self::N214 => "214",
            Self::N215 => "215",
            Self::N216 => "216",
            Self::N217 => "217",
            Self::N218 => "218",
            Self::N219 => "219",
            Self::N22 => "22",
            Self::N220 => "220",
            Self::N221 => "221",
            Self::N222 => "222",
            Self::N223 => "223",
            Self::N224 => "224",
            Self::N225 => "225",
            Self::N226 => "226",
            Self::N227 => "227",
            Self::N228 => "228",
            Self::N229 => "229",
            Self::N23 => "23",
            Self::N230 => "230",
            Self::N231 => "231",
            Self::N232 => "232",
            Self::N233 => "233",
            Self::N234 => "234",
            Self::N235 => "235",
            Self::N236 => "236",
            Self::N237 => "237",
            Self::N238 => "238",
            Self::N239 => "239",
            Self::N24 => "24",
            Self::N240 => "240",
            Self::N241 => "241",
            Self::N242 => "242",
            Self::N243 => "243",
            Self::N244 => "244",
            Self::N245 => "245",
            Self::N246 => "246",
            Self::N247 => "247",
            Self::N248 => "248",
            Self::N249 => "249",
            Self::N25 => "25",
            Self::N250 => "250",
            Self::N251 => "251",
            Self::N252 => "252",
            Self::N253 => "253",
            Self::N254 => "254",
            Self::N255 => "255",
            Self::N256 => "256",
            Self::N257 => "257",
            Self::N258 => "258",
            Self::N259 => "259",
            Self::N26 => "26",
            Self::N260 => "260",
            Self::N261 => "261",
            Self::N262 => "262",
            Self::N263 => "263",
            Self::N264 => "264",
            Self::N265 => "265",
            Self::N266 => "266",
            Self::N267 => "267",
            Self::N268 => "268",
            Self::N269 => "269",
            Self::N27 => "27",
            Self::N270 => "270",
            Self::N271 => "271",
            Self::N272 => "272",
            Self::N273 => "273",
            Self::N274 => "274",
            Self::N275 => "275",
            Self::N276 => "276",
            Self::N277 => "277",
            Self::N278 => "278",
            Self::N279 => "279",
            Self::N28 => "28",
            Self::N280 => "280",
            Self::N281 => "281",
            Self::N282 => "282",
            Self::N283 => "283",
            Self::N284 => "284",
            Self::N285 => "285",
            Self::N286 => "286",
            Self::N287 => "287",
            Self::N288 => "288",
            Self::N289 => "289",
            Self::N29 => "29",
            Self::N290 => "290",
            Self::N291 => "291",
            Self::N292 => "292",
            Self::N293 => "293",
            Self::N294 => "294",
            Self::N295 => "295",
            Self::N296 => "296",
            Self::N297 => "297",
            Self::N298 => "298",
            Self::N299 => "299",
            Self::N3 => "3",
            Self::N30 => "30",
            Self::N300 => "300",
            Self::N301 => "301",
            Self::N302 => "302",
            Self::N303 => "303",
            Self::N304 => "304",
            Self::N305 => "305",
            Self::N306 => "306",
            Self::N307 => "307",
            Self::N308 => "308",
            Self::N309 => "309",
            Self::N31 => "31",
            Self::N310 => "310",
            Self::N311 => "311",
            Self::N312 => "312",
            Self::N313 => "313",
            Self::N314 => "314",
            Self::N315 => "315",
            Self::N316 => "316",
            Self::N317 => "317",
            Self::N318 => "318",
            Self::N319 => "319",
            Self::N32 => "32",
            Self::N320 => "320",
            Self::N321 => "321",
            Self::N322 => "322",
            Self::N323 => "323",
            Self::N324 => "324",
            Self::N325 => "325",
            Self::N326 => "326",
            Self::N327 => "327",
            Self::N328 => "328",
            Self::N33 => "33",
            Self::N330 => "330",
            Self::N331 => "331",
            Self::N332 => "332",
            Self::N333 => "333",
            Self::N334 => "334",
            Self::N335 => "335",
            Self::N336 => "336",
            Self::N337 => "337",
            Self::N338 => "338",
            Self::N339 => "339",
            Self::N34 => "34",
            Self::N340 => "340",
            Self::N341 => "341",
            Self::N342 => "342",
            Self::N343 => "343",
            Self::N344 => "344",
            Self::N345 => "345",
            Self::N346 => "346",
            Self::N347 => "347",
            Self::N348 => "348",
            Self::N349 => "349",
            Self::N35 => "35",
            Self::N350 => "350",
            Self::N351 => "351",
            Self::N352 => "352",
            Self::N353 => "353",
            Self::N354 => "354",
            Self::N355 => "355",
            Self::N356 => "356",
            Self::N357 => "357",
            Self::N358 => "358",
            Self::N359 => "359",
            Self::N36 => "36",
            Self::N360 => "360",
            Self::N361 => "361",
            Self::N362 => "362",
            Self::N364 => "364",
            Self::N365 => "365",
            Self::N366 => "366",
            Self::N367 => "367",
            Self::N368 => "368",
            Self::N369 => "369",
            Self::N37 => "37",
            Self::N370 => "370",
            Self::N371 => "371",
            Self::N372 => "372",
            Self::N373 => "373",
            Self::N374 => "374",
            Self::N375 => "375",
            Self::N376 => "376",
            Self::N377 => "377",
            Self::N378 => "378",
            Self::N379 => "379",
            Self::N38 => "38",
            Self::N380 => "380",
            Self::N381 => "381",
            Self::N382 => "382",
            Self::N383 => "383",
            Self::N384 => "384",
            Self::N385 => "385",
            Self::N386 => "386",
            Self::N387 => "387",
            Self::N388 => "388",
            Self::N389 => "389",
            Self::N39 => "39",
            Self::N390 => "390",
            Self::N391 => "391",
            Self::N392 => "392",
            Self::N393 => "393",
            Self::N394 => "394",
            Self::N395 => "395",
            Self::N396 => "396",
            Self::N397 => "397",
            Self::N398 => "398",
            Self::N399 => "399",
            Self::N4 => "4",
            Self::N40 => "40",
            Self::N400 => "400",
            Self::N401 => "401",
            Self::N402 => "402",
            Self::N403 => "403",
            Self::N404 => "404",
            Self::N405 => "405",
            Self::N406 => "406",
            Self::N407 => "407",
            Self::N408 => "408",
            Self::N409 => "409",
            Self::N41 => "41",
            Self::N410 => "410",
            Self::N411 => "411",
            Self::N412 => "412",
            Self::N413 => "413",
            Self::N414 => "414",
            Self::N415 => "415",
            Self::N416 => "416",
            Self::N417 => "417",
            Self::N418 => "418",
            Self::N419 => "419",
            Self::N42 => "42",
            Self::N420 => "420",
            Self::N421 => "421",
            Self::N422 => "422",
            Self::N423 => "423",
            Self::N424 => "424",
            Self::N425 => "425",
            Self::N426 => "426",
            Self::N427 => "427",
            Self::N428 => "428",
            Self::N429 => "429",
            Self::N43 => "43",
            Self::N430 => "430",
            Self::N431 => "431",
            Self::N432 => "432",
            Self::N433 => "433",
            Self::N434 => "434",
            Self::N435 => "435",
            Self::N436 => "436",
            Self::N437 => "437",
            Self::N438 => "438",
            Self::N439 => "439",
            Self::N44 => "44",
            Self::N440 => "440",
            Self::N441 => "441",
            Self::N442 => "442",
            Self::N443 => "443",
            Self::N444 => "444",
            Self::N445 => "445",
            Self::N446 => "446",
            Self::N447 => "447",
            Self::N448 => "448",
            Self::N449 => "449",
            Self::N45 => "45",
            Self::N450 => "450",
            Self::N451 => "451",
            Self::N452 => "452",
            Self::N453 => "453",
            Self::N454 => "454",
            Self::N455 => "455",
            Self::N456 => "456",
            Self::N457 => "457",
            Self::N458 => "458",
            Self::N459 => "459",
            Self::N46 => "46",
            Self::N460 => "460",
            Self::N461 => "461",
            Self::N462 => "462",
            Self::N463 => "463",
            Self::N464 => "464",
            Self::N465 => "465",
            Self::N466 => "466",
            Self::N467 => "467",
            Self::N468 => "468",
            Self::N469 => "469",
            Self::N47 => "47",
            Self::N470 => "470",
            Self::N471 => "471",
            Self::N472 => "472",
            Self::N473 => "473",
            Self::N474 => "474",
            Self::N475 => "475",
            Self::N476 => "476",
            Self::N477 => "477",
            Self::N478 => "478",
            Self::N479 => "479",
            Self::N48 => "48",
            Self::N480 => "480",
            Self::N481 => "481",
            Self::N482 => "482",
            Self::N483 => "483",
            Self::N484 => "484",
            Self::N485 => "485",
            Self::N486 => "486",
            Self::N488 => "488",
            Self::N489 => "489",
            Self::N49 => "49",
            Self::N490 => "490",
            Self::N491 => "491",
            Self::N492 => "492",
            Self::N493 => "493",
            Self::N494 => "494",
            Self::N495 => "495",
            Self::N496 => "496",
            Self::N497 => "497",
            Self::N498 => "498",
            Self::N5 => "5",
            Self::N50 => "50",
            Self::N500 => "500",
            Self::N501 => "501",
            Self::N502 => "502",
            Self::N503 => "503",
            Self::N504 => "504",
            Self::N505 => "505",
            Self::N506 => "506",
            Self::N507 => "507",
            Self::N508 => "508",
            Self::N509 => "509",
            Self::N51 => "51",
            Self::N510 => "510",
            Self::N513 => "513",
            Self::N514 => "514",
            Self::N52 => "52",
            Self::N53 => "53",
            Self::N530 => "530",
            Self::N531 => "531",
            Self::N532 => "532",
            Self::N533 => "533",
            Self::N534 => "534",
            Self::N535 => "535",
            Self::N536 => "536",
            Self::N537 => "537",
            Self::N538 => "538",
            Self::N539 => "539",
            Self::N54 => "54",
            Self::N540 => "540",
            Self::N541 => "541",
            Self::N542 => "542",
            Self::N543 => "543",
            Self::N544 => "544",
            Self::N545 => "545",
            Self::N546 => "546",
            Self::N547 => "547",
            Self::N548 => "548",
            Self::N55 => "55",
            Self::N550 => "550",
            Self::N551 => "551",
            Self::N552 => "552",
            Self::N553 => "553",
            Self::N554 => "554",
            Self::N555 => "555",
            Self::N556 => "556",
            Self::N557 => "557",
            Self::N558 => "558",
            Self::N559 => "559",
            Self::N56 => "56",
            Self::N560 => "560",
            Self::N561 => "561",
            Self::N562 => "562",
            Self::N563 => "563",
            Self::N564 => "564",
            Self::N565 => "565",
            Self::N566 => "566",
            Self::N567 => "567",
            Self::N568 => "568",
            Self::N569 => "569",
            Self::N57 => "57",
            Self::N570 => "570",
            Self::N571 => "571",
            Self::N572 => "572",
            Self::N573 => "573",
            Self::N574 => "574",
            Self::N575 => "575",
            Self::N576 => "576",
            Self::N577 => "577",
            Self::N58 => "58",
            Self::N580 => "580",
            Self::N581 => "581",
            Self::N582 => "582",
            Self::N583 => "583",
            Self::N584 => "584",
            Self::N585 => "585",
            Self::N589 => "589",
            Self::N59 => "59",
            Self::N590 => "590",
            Self::N591 => "591",
            Self::N593 => "593",
            Self::N599 => "599",
            Self::N6 => "6",
            Self::N60 => "60",
            Self::N600 => "600",
            Self::N601 => "601",
            Self::N602 => "602",
            Self::N603 => "603",
            Self::N604 => "604",
            Self::N605 => "605",
            Self::N606 => "606",
            Self::N607 => "607",
            Self::N608 => "608",
            Self::N609 => "609",
            Self::N61 => "61",
            Self::N610 => "610",
            Self::N611 => "611",
            Self::N612 => "612",
            Self::N613 => "613",
            Self::N614 => "614",
            Self::N615 => "615",
            Self::N616 => "616",
            Self::N617 => "617",
            Self::N618 => "618",
            Self::N619 => "619",
            Self::N62 => "62",
            Self::N620 => "620",
            Self::N621 => "621",
            Self::N622 => "622",
            Self::N623 => "623",
            Self::N624 => "624",
            Self::N625 => "625",
            Self::N626 => "626",
            Self::N627 => "627",
            Self::N628 => "628",
            Self::N629 => "629",
            Self::N63 => "63",
            Self::N64 => "64",
            Self::N65 => "65",
            Self::N66 => "66",
            Self::N67 => "67",
            Self::N68 => "68",
            Self::N69 => "69",
            Self::N7 => "7",
            Self::N70 => "70",
            Self::N71 => "71",
            Self::N72 => "72",
            Self::N73 => "73",
            Self::N74 => "74",
            Self::N75 => "75",
            Self::N76 => "76",
            Self::N77 => "77",
            Self::N78 => "78",
            Self::N79 => "79",
            Self::N8 => "8",
            Self::N80 => "80",
            Self::N81 => "81",
            Self::N82 => "82",
            Self::N83 => "83",
            Self::N84 => "84",
            Self::N85 => "85",
            Self::N86 => "86",
            Self::N87 => "87",
            Self::N88 => "88",
            Self::N89 => "89",
            Self::N9 => "9",
            Self::N90 => "90",
            Self::N91 => "91",
            Self::N92 => "92",
            Self::N93 => "93",
            Self::N94 => "94",
            Self::N95 => "95",
            Self::N96 => "96",
            Self::N97 => "97",
            Self::N98 => "98",
            Self::N99 => "99",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for ServiceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for ServiceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SignatureTypeCodes`. The Digital Signature Purposes, an indication of the reason an entity signs a document. This is included in the signed information and can be used when determining accountability for various actions concerning the document. Examples include: author, transcriptionist/recorder, and witness.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SignatureTypeCodes {
    /** # 1.2.840.10065.1.12.1.1

Author's Signature. the signature of the primary or sole author of a health information document. There can be only one primary author of a health information document. */
    N128401006511211,
    /** # 1.2.840.10065.1.12.1.10

Identity Witness Signature. the signature of an individual who has witnessed another individual who is known to them signing a document. (Example the identity witness is a notary public.) */
    N1284010065112110,
    /** # 1.2.840.10065.1.12.1.11

Consent Witness Signature. the signature of an individual who has witnessed the health care provider counselling a patient. */
    N1284010065112111,
    /** # 1.2.840.10065.1.12.1.12

Interpreter Signature. the signature of an individual who has translated health care information during an event or the obtaining of consent to a treatment. */
    N1284010065112112,
    /** # 1.2.840.10065.1.12.1.13

Review Signature. the signature of a person, device, or algorithm that has reviewed or filtered data for inclusion into the patient record. ( Examples: (1) a medical records clerk who scans a document for inclusion in the medical record, enters header information, or catalogues and classifies the data, or a combination thereof; (2) a gateway that receives data from another computer system and interprets that data or changes its format, or both, before entering it into the patient record.) */
    N1284010065112113,
    /** # 1.2.840.10065.1.12.1.14

Source Signature. the signature of an automated data source. (Examples: (1) the signature for an image that is generated by a device for inclusion in the patient record; (2) the signature for an ECG derived by an ECG system for inclusion in the patient record; (3) the data from a biomedical monitoring device or system that is for inclusion in the patient record.) */
    N1284010065112114,
    /** # 1.2.840.10065.1.12.1.15

Addendum Signature. the signature on a new amended document of an individual who has corrected, edited, or amended an original health information document. An addendum signature can either be a signature type or a signature sub-type (see 8.1). Any document with an addendum signature shall have a companion document that is the original document with its original, unaltered content, and original signatures. The original document shall be referenced via an attribute in the new document, which contains, for example, the digest of the old document. Whether the original, unaltered, document is always displayed with the addended document is a local matter, but the original, unaltered, document must remain as part of the patient record and be retrievable on demand. */
    N1284010065112115,
    /** # 1.2.840.10065.1.12.1.16

Modification Signature. the signature on an original document of an individual who has generated a new amended document. This (original) document shall reference the new document via an additional signature purpose. This is the inverse of an addendum signature and provides a pointer from the original to the amended document. */
    N1284010065112116,
    /** # 1.2.840.10065.1.12.1.17

Administrative (Error/Edit) Signature. the signature of an individual who is certifying that the document is invalidated by an error(s), or is placed in the wrong chart. An administrative (error/edit) signature must include an addendum to the document and therefore shall have an addendum signature sub-type (see 8.1). This signature is reserved for the highest health information system administrative classification, since it is a statement that the entire document is invalidated by the error and that the document should no longer be used for patient care, although for legal reasons the document must remain part of the permanent patient record. */
    N1284010065112117,
    /** # 1.2.840.10065.1.12.1.18

Timestamp Signature. the signature by an entity or device trusted to provide accurate timestamps. This timestamp might be provided, for example, in the signature time attribute. */
    N1284010065112118,
    /** # 1.2.840.10065.1.12.1.2

Coauthor's Signature. the signature of a health information document coauthor. There can be multiple coauthors of a health information document. */
    N128401006511212,
    /** # 1.2.840.10065.1.12.1.3

Co-participant's Signature. the signature of an individual who is a participant in the health information document but is not an author or coauthor. (Example a surgeon who is required by institutional, regulatory, or legal rules to sign an operative report, but who was not involved in the authorship of that report.) */
    N128401006511213,
    /** # 1.2.840.10065.1.12.1.4

Transcriptionist/Recorder Signature. the signature of an individual who has transcribed a dictated document or recorded written text into a digital machine readable format. */
    N128401006511214,
    /** # 1.2.840.10065.1.12.1.5

Verification Signature. a signature verifying the information contained in a document. (Example a physician is required to countersign a verbal order that has previously been recorded in the medical record by a registered nurse who has carried out the verbal order.) */
    N128401006511215,
    /** # 1.2.840.10065.1.12.1.6

Validation Signature. a signature validating a health information document for inclusion in the patient record. (Example a medical student or resident is credentialed to perform history or physical examinations and to write progress notes. The attending physician signs the history and physical examination to validate the entry for inclusion in the patient's medical record.) */
    N128401006511216,
    /** # 1.2.840.10065.1.12.1.7

Consent Signature. the signature of an individual consenting to what is described in a health information document. */
    N128401006511217,
    /** # 1.2.840.10065.1.12.1.8

Signature Witness Signature. the signature of a witness to any other signature. */
    N128401006511218,
    /** # 1.2.840.10065.1.12.1.9

Event Witness Signature. the signature of a witness to an event. (Example the witness has observed a procedure and is attesting to this fact.) */
    N128401006511219,
}
impl ::core::str::FromStr for SignatureTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "1.2.840.10065.1.12.1.1" => Ok(Self::N128401006511211),
            "1.2.840.10065.1.12.1.10" => Ok(Self::N1284010065112110),
            "1.2.840.10065.1.12.1.11" => Ok(Self::N1284010065112111),
            "1.2.840.10065.1.12.1.12" => Ok(Self::N1284010065112112),
            "1.2.840.10065.1.12.1.13" => Ok(Self::N1284010065112113),
            "1.2.840.10065.1.12.1.14" => Ok(Self::N1284010065112114),
            "1.2.840.10065.1.12.1.15" => Ok(Self::N1284010065112115),
            "1.2.840.10065.1.12.1.16" => Ok(Self::N1284010065112116),
            "1.2.840.10065.1.12.1.17" => Ok(Self::N1284010065112117),
            "1.2.840.10065.1.12.1.18" => Ok(Self::N1284010065112118),
            "1.2.840.10065.1.12.1.2" => Ok(Self::N128401006511212),
            "1.2.840.10065.1.12.1.3" => Ok(Self::N128401006511213),
            "1.2.840.10065.1.12.1.4" => Ok(Self::N128401006511214),
            "1.2.840.10065.1.12.1.5" => Ok(Self::N128401006511215),
            "1.2.840.10065.1.12.1.6" => Ok(Self::N128401006511216),
            "1.2.840.10065.1.12.1.7" => Ok(Self::N128401006511217),
            "1.2.840.10065.1.12.1.8" => Ok(Self::N128401006511218),
            "1.2.840.10065.1.12.1.9" => Ok(Self::N128401006511219),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SignatureTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::N128401006511211 => "1.2.840.10065.1.12.1.1",
            Self::N1284010065112110 => "1.2.840.10065.1.12.1.10",
            Self::N1284010065112111 => "1.2.840.10065.1.12.1.11",
            Self::N1284010065112112 => "1.2.840.10065.1.12.1.12",
            Self::N1284010065112113 => "1.2.840.10065.1.12.1.13",
            Self::N1284010065112114 => "1.2.840.10065.1.12.1.14",
            Self::N1284010065112115 => "1.2.840.10065.1.12.1.15",
            Self::N1284010065112116 => "1.2.840.10065.1.12.1.16",
            Self::N1284010065112117 => "1.2.840.10065.1.12.1.17",
            Self::N1284010065112118 => "1.2.840.10065.1.12.1.18",
            Self::N128401006511212 => "1.2.840.10065.1.12.1.2",
            Self::N128401006511213 => "1.2.840.10065.1.12.1.3",
            Self::N128401006511214 => "1.2.840.10065.1.12.1.4",
            Self::N128401006511215 => "1.2.840.10065.1.12.1.5",
            Self::N128401006511216 => "1.2.840.10065.1.12.1.6",
            Self::N128401006511217 => "1.2.840.10065.1.12.1.7",
            Self::N128401006511218 => "1.2.840.10065.1.12.1.8",
            Self::N128401006511219 => "1.2.840.10065.1.12.1.9",
        }
    }
}
impl<'de> Deserialize<'de> for SignatureTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SignatureTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SlicingRules`. How slices are interpreted when evaluating an instance.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SlicingRules {
    /** # closed

Closed. No additional content is allowed other than that described by the slices in this profile. */
    Closed,
    /** # open

Open. Additional content is allowed anywhere in the list. */
    Open,
    /** # openAtEnd

Open at End. Additional content is allowed, but only at the end of the list. Note that using this requires that the slices be ordered, which makes it hard to share uses. This should only be done where absolutely required. */
    OpenAtEnd,
}
impl ::core::str::FromStr for SlicingRules {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "closed" => Ok(Self::Closed),
            "open" => Ok(Self::Open),
            "openAtEnd" => Ok(Self::OpenAtEnd),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SlicingRules {
    fn as_ref(&self) -> &str {
        match self {
            Self::Closed => "closed",
            Self::Open => "open",
            Self::OpenAtEnd => "openAtEnd",
        }
    }
}
impl<'de> Deserialize<'de> for SlicingRules {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SlicingRules {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SlotStatus`. The free/busy status of the slot.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SlotStatus {
    /** # busy

Busy. Indicates that the time interval is busy because one  or more events have been scheduled for that interval. */
    Busy,
    /** # busy-tentative

Busy (Tentative). Indicates that the time interval is busy because one or more events have been tentatively scheduled for that interval. */
    BusyTentative,
    /** # busy-unavailable

Busy (Unavailable). Indicates that the time interval is busy and that the interval cannot be scheduled. */
    BusyUnavailable,
    /** # entered-in-error

Entered in error. This instance should not have been part of this patient's medical record. */
    EnteredInError,
    /** # free

Free. Indicates that the time interval is free for scheduling. */
    Free,
}
impl ::core::str::FromStr for SlotStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "busy" => Ok(Self::Busy),
            "busy-tentative" => Ok(Self::BusyTentative),
            "busy-unavailable" => Ok(Self::BusyUnavailable),
            "entered-in-error" => Ok(Self::EnteredInError),
            "free" => Ok(Self::Free),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SlotStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Busy => "busy",
            Self::BusyTentative => "busy-tentative",
            Self::BusyUnavailable => "busy-unavailable",
            Self::EnteredInError => "entered-in-error",
            Self::Free => "free",
        }
    }
}
impl<'de> Deserialize<'de> for SlotStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SlotStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SmartCapabilities`. Codes that define what the server is capable of.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SmartCapabilities {
    /** # client-confidential-symmetric

Confidential Client Profile. support for SMART’s confidential client profile (symmetric client secret authentication). */
    ClientConfidentialSymmetric,
    /** # client-public

Public Client Profile. support for SMART’s public client profile (no client authentication). */
    ClientPublic,
    /** # context-ehr-encounter

Allows "Encounter Level Launch Context (EHR)". support for encounter-level launch context (requested by launch/encounter scope, conveyed via encounter token parameter). */
    ContextEhrEncounter,
    /** # context-ehr-patient

Allows "Patient Level Launch Context (EHR)". support for patient-level launch context (requested by launch/patient scope, conveyed via patient token parameter). */
    ContextEhrPatient,
    /** # context-passthrough-banner

Allows "Need Patient Banner". support for “need patient banner” launch context (conveyed via need_patient_banner token parameter). */
    ContextPassthroughBanner,
    /** # context-passthrough-style

Allows "Smart Style Style". support for “SMART style URL” launch context (conveyed via smart_style_url token parameter). */
    ContextPassthroughStyle,
    /** # context-standalone-encounter

Allows "Encounter Level Launch Context (STANDALONE)". support for encounter-level launch context (requested by launch/encounter scope, conveyed via encounter token parameter). */
    ContextStandaloneEncounter,
    /** # context-standalone-patient

Allows "Patient Level Launch Context (STANDALONE)". support for patient-level launch context (requested by launch/patient scope, conveyed via patient token parameter). */
    ContextStandalonePatient,
    /** # launch-ehr

EHR Launch Mode. support for SMART’s EHR Launch mode. */
    LaunchEhr,
    /** # launch-standalone

Standalone Launch Mode. support for SMART’s Standalone Launch mode. */
    LaunchStandalone,
    /** # permission-offline

Supports Refresh Token. support for refresh tokens (requested by offline_access scope). */
    PermissionOffline,
    /** # permission-patient

Supports Patient Level Scopes. support for patient-level scopes (e.g. patient/Observation.read). */
    PermissionPatient,
    /** # permission-user

Supports User Level Scopes. support for user-level scopes (e.g. user/Appointment.read). */
    PermissionUser,
    /** # sso-openid-connect

Supports OpenID Connect. support for SMART’s OpenID Connect profile. */
    SsoOpenidConnect,
}
impl ::core::str::FromStr for SmartCapabilities {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client-confidential-symmetric" => Ok(Self::ClientConfidentialSymmetric),
            "client-public" => Ok(Self::ClientPublic),
            "context-ehr-encounter" => Ok(Self::ContextEhrEncounter),
            "context-ehr-patient" => Ok(Self::ContextEhrPatient),
            "context-passthrough-banner" => Ok(Self::ContextPassthroughBanner),
            "context-passthrough-style" => Ok(Self::ContextPassthroughStyle),
            "context-standalone-encounter" => Ok(Self::ContextStandaloneEncounter),
            "context-standalone-patient" => Ok(Self::ContextStandalonePatient),
            "launch-ehr" => Ok(Self::LaunchEhr),
            "launch-standalone" => Ok(Self::LaunchStandalone),
            "permission-offline" => Ok(Self::PermissionOffline),
            "permission-patient" => Ok(Self::PermissionPatient),
            "permission-user" => Ok(Self::PermissionUser),
            "sso-openid-connect" => Ok(Self::SsoOpenidConnect),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SmartCapabilities {
    fn as_ref(&self) -> &str {
        match self {
            Self::ClientConfidentialSymmetric => "client-confidential-symmetric",
            Self::ClientPublic => "client-public",
            Self::ContextEhrEncounter => "context-ehr-encounter",
            Self::ContextEhrPatient => "context-ehr-patient",
            Self::ContextPassthroughBanner => "context-passthrough-banner",
            Self::ContextPassthroughStyle => "context-passthrough-style",
            Self::ContextStandaloneEncounter => "context-standalone-encounter",
            Self::ContextStandalonePatient => "context-standalone-patient",
            Self::LaunchEhr => "launch-ehr",
            Self::LaunchStandalone => "launch-standalone",
            Self::PermissionOffline => "permission-offline",
            Self::PermissionPatient => "permission-patient",
            Self::PermissionUser => "permission-user",
            Self::SsoOpenidConnect => "sso-openid-connect",
        }
    }
}
impl<'de> Deserialize<'de> for SmartCapabilities {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SmartCapabilities {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SortDirection`. The possible sort directions, ascending or descending.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SortDirection {
    /** # ascending

Ascending. Sort by the value ascending, so that lower values appear first. */
    Ascending,
    /** # descending

Descending. Sort by the value descending, so that lower values appear last. */
    Descending,
}
impl ::core::str::FromStr for SortDirection {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ascending" => Ok(Self::Ascending),
            "descending" => Ok(Self::Descending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SortDirection {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ascending => "ascending",
            Self::Descending => "descending",
        }
    }
}
impl<'de> Deserialize<'de> for SortDirection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SortDirection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SpecialArrangements`. This codesystem defines a set of codes that can be used to indicate the kinds of special arrangements in place for a patient's visit.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SpecialArrangements {
    /** # add-bed

Additional bedding. An additional bed made available for a person accompanying the patient, for example a parent accompanying a child. */
    AddBed,
    /** # att

Attendant. A person who accompanies a patient to provide assistive services necessary for the patient's care during the encounter. */
    Att,
    /** # dog

Guide dog. The patient has a guide dog and the location used for the encounter should be able to support the presence of the service animal. */
    Dog,
    /** # int

Interpreter. The patient is not fluent in the local language and requires an interpreter to be available. Refer to the Patient.Language property for the type of interpreter required. */
    Int,
    /** # wheel

Wheelchair. The patient requires a wheelchair to be made available for the encounter. */
    Wheel,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SpecialArrangements {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "add-bed" => Ok(Self::AddBed),
            "att" => Ok(Self::Att),
            "dog" => Ok(Self::Dog),
            "int" => Ok(Self::Int),
            "wheel" => Ok(Self::Wheel),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SpecialArrangements {
    fn as_ref(&self) -> &str {
        match self {
            Self::AddBed => "add-bed",
            Self::Att => "att",
            Self::Dog => "dog",
            Self::Int => "int",
            Self::Wheel => "wheel",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for SpecialArrangements {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecialArrangements {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SpecialMeasures`. Extra measures defined for a Medicinal Product, such as requirement to conduct post-authorisation studies.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SpecialMeasures {
    /** # Post-authorisationStudies

Requirement to conduct post-authorisation studies. Requirement to conduct post-authorisation studies */
    PostAuthorisationStudies,
}
impl ::core::str::FromStr for SpecialMeasures {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Post-authorisationStudies" => Ok(Self::PostAuthorisationStudies),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecialMeasures {
    fn as_ref(&self) -> &str {
        match self {
            Self::PostAuthorisationStudies => "Post-authorisationStudies",
        }
    }
}
impl<'de> Deserialize<'de> for SpecialMeasures {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecialMeasures {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SpecialValues`. A set of generally useful codes defined so they can be included in value sets.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SpecialValues {
    /** # false

false. Boolean false. */
    False,
    /** # nil-known

Nil Known. The are no known applicable values in this context. */
    NilKnown,
    /** # sufficient

Sufficient Quantity. The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material. */
    Sufficient,
    /** # trace

Trace Amount Detected. The content is greater than zero, but too small to be quantified. */
    Trace,
    /** # true

true. Boolean true. */
    True,
    /** # withdrawn

Value Withdrawn. The value is no longer available. */
    Withdrawn,
}
impl ::core::str::FromStr for SpecialValues {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "false" => Ok(Self::False),
            "nil-known" => Ok(Self::NilKnown),
            "sufficient" => Ok(Self::Sufficient),
            "trace" => Ok(Self::Trace),
            "true" => Ok(Self::True),
            "withdrawn" => Ok(Self::Withdrawn),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecialValues {
    fn as_ref(&self) -> &str {
        match self {
            Self::False => "false",
            Self::NilKnown => "nil-known",
            Self::Sufficient => "sufficient",
            Self::Trace => "trace",
            Self::True => "true",
            Self::Withdrawn => "withdrawn",
        }
    }
}
impl<'de> Deserialize<'de> for SpecialValues {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecialValues {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SpecimenContainedPreference`. Degree of preference of a type of conditioned specimen.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SpecimenContainedPreference {
    /** # alternate

Alternate. This type of conditioned specimen is an alternate. */
    Alternate,
    /** # preferred

Preferred. This type of contained specimen is preferred to collect this kind of specimen. */
    Preferred,
}
impl ::core::str::FromStr for SpecimenContainedPreference {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "alternate" => Ok(Self::Alternate),
            "preferred" => Ok(Self::Preferred),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecimenContainedPreference {
    fn as_ref(&self) -> &str {
        match self {
            Self::Alternate => "alternate",
            Self::Preferred => "preferred",
        }
    }
}
impl<'de> Deserialize<'de> for SpecimenContainedPreference {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecimenContainedPreference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SpecimenStatus`. Codes providing the status/availability of a specimen.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SpecimenStatus {
    /** # available

Available. The physical specimen is present and in good condition. */
    Available,
    /** # entered-in-error

Entered in Error. The specimen was entered in error and therefore nullified. */
    EnteredInError,
    /** # unavailable

Unavailable. There is no physical specimen because it is either lost, destroyed or consumed. */
    Unavailable,
    /** # unsatisfactory

Unsatisfactory. The specimen cannot be used because of a quality issue such as a broken container, contamination, or too old. */
    Unsatisfactory,
}
impl ::core::str::FromStr for SpecimenStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "available" => Ok(Self::Available),
            "entered-in-error" => Ok(Self::EnteredInError),
            "unavailable" => Ok(Self::Unavailable),
            "unsatisfactory" => Ok(Self::Unsatisfactory),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SpecimenStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Available => "available",
            Self::EnteredInError => "entered-in-error",
            Self::Unavailable => "unavailable",
            Self::Unsatisfactory => "unsatisfactory",
        }
    }
}
impl<'de> Deserialize<'de> for SpecimenStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SpecimenStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StandardsStatus`. Status codes indicating the 'standards' level of an artifact

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum StandardsStatus {
    /** # deprecated

Deprecated. This portion of the specification is provided for implementer assistance, and does not make rules that implementers are required to follow. Typical examples of this content in the FHIR specification are tables of contents, registries, examples, and implementer advice. */
    Deprecated,
    /** # draft

Draft. This portion of the specification is not considered to be complete enough or sufficiently reviewed to be safe for implementation. It may have known issues or still be in the "in development" stage. It is included in the publication as a place-holder, to solicit feedback from the implementation community and/or to give implementers some insight as to functionality likely to be included in future versions of the specification. Content at this level should only be implemented by the brave or desperate and is very much "use at your own risk". The content that is Draft that will usually be elevated to Trial Use once review and correction is complete after it has been subjected to ballot. */
    Draft,
    /** # external

External. This is content that is managed outside the FHIR Specification, but included for implementer convenience. */
    External,
    /** # informative

Informative. This portion of the specification is provided for implementer assistance, and does not make rules that implementers are required to follow. Typical examples of this content in the FHIR specification are tables of contents, registries, examples, and implementer advice. */
    Informative,
    /** # normative

Normative. This content has been subject to review and production implementation in a wide variety of environments. The content is considered to be stable and has been 'locked', subjecting it to FHIR Inter-version Compatibility Rules. While changes are possible, they are expected to be infrequent and are tightly constrained. Compatibility Rules. */
    Normative,
    /** # trial-use

Trial-Use. This content has been well reviewed and is considered by the authors to be ready for use in production systems. It has been subjected to ballot and approved as an official standard. However, it has not yet seen widespread use in production across the full spectrum of environments it is intended to be used in. In some cases, there may be documented known issues that require implementation experience to determine appropriate resolutions for.

Future versions of FHIR may make significant changes to Trial Use content that are not compatible with previously published content. */
    TrialUse,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for StandardsStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "deprecated" => Ok(Self::Deprecated),
            "draft" => Ok(Self::Draft),
            "external" => Ok(Self::External),
            "informative" => Ok(Self::Informative),
            "normative" => Ok(Self::Normative),
            "trial-use" => Ok(Self::TrialUse),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for StandardsStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Deprecated => "deprecated",
            Self::Draft => "draft",
            Self::External => "external",
            Self::Informative => "informative",
            Self::Normative => "normative",
            Self::TrialUse => "trial-use",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for StandardsStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StandardsStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StatisticModelCode`. The role that the assertion variable plays.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StatisticModelCode {
    /** # adjusted

Adjusted analysis. Used for adjusted analysis, paired with variable element(s) */
    Adjusted,
    /** # anova

ANOVA (ANalysis Of VAriance). Used for ANOVA method of analysis, may be paired with "value" to express degrees of freedom */
    Anova,
    /** # anovaOneWay

one-way ANOVA. Used for one-way ANOVA method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaOneWay,
    /** # anovaThreeWay

3-way ANOVA. Used for 3-way ANOVA method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaThreeWay,
    /** # anovaTwoWay

2-way ANOVA without replication. Used for 2-way ANOVA without replication method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaTwoWay,
    /** # anovaTwoWayReplication

2-way ANOVA with replication. Used for 2-way ANOVA with replication method of analysis, may be paired with "value" to express degrees of freedom */
    AnovaTwoWayReplication,
    /** # binomialDistributionRegression

Binomial Distribution for Regression. Used for Binomial Distribution for Regression, no additional elements needed */
    BinomialDistributionRegression,
    /** # chiSquareTest

Chi-square test. Used for Chi-square test, may be paired with "value" to express degrees of freedom */
    ChiSquareTest,
    /** # chiSquareTestHomogeneity

Chi-square test for homogeneity. Used for Chi-square test for homogeneity, may be paired with "value" to express degrees of freedom */
    ChiSquareTestHomogeneity,
    /** # chiSquareTestTrend

Chi-square test for trend. Used for Chi-square test for trend, may be paired with "value" to express degrees of freedom */
    ChiSquareTestTrend,
    /** # coxProportionalHazards

Cox Proportional Hazards. Used for Cox proportional hazards method of analysis, no additional elements needed */
    CoxProportionalHazards,
    /** # dersimonianLairdMethod

Dersimonian-Laird method. Used for Dersimonian-Laird method of tau estimation, no additional elements needed */
    DersimonianLairdMethod,
    /** # effectsFixed

Fixed-effects. From a fixed-effects analysis, no additional elements needed */
    EffectsFixed,
    /** # effectsRandom

Random-effects. From a random-effects analysis, no additional elements needed */
    EffectsRandom,
    /** # empiricalBayes

Empirical Bayes method. Used for Empirical Bayes method of tau estimation, no additional elements needed */
    EmpiricalBayes,
    /** # fishersExactTest

Fisher’s exact test. Used for Fisher's exact test, may be paired with "value" to express degrees of freedom */
    FishersExactTest,
    /** # friedmanTest

Friedman test. Used for Friedman test, no additional elements needed */
    FriedmanTest,
    /** # glm

GLM (Generalized Linear Model). Used for GLM (Generalized Linear Model), no additional elements needed */
    Glm,
    /** # glmGeneralizedLogit

GLM with generalized logit link. Used for GLM with generalized logit link, no additional elements needed */
    GlmGeneralizedLogit,
    /** # glmIdentity

GLM with identity link. Used for GLM with identity link, no additional elements needed */
    GlmIdentity,
    /** # glmLog

GLM with log link. Used for GLM with log link, no additional elements needed */
    GlmLog,
    /** # glmLogit

GLM with logit link. Used for GLM with logit link, no additional elements needed */
    GlmLogit,
    /** # glmProbit

GLM with probit link. Used for GLM with probit link, no additional elements needed */
    GlmProbit,
    /** # glmm

Generalized linear mixed model (GLMM). Used for Generalized linear mixed model (GLMM), no additional elements needed */
    Glmm,
    /** # glmmGeneralizedLogit

GLMM with generalized logit link. Used for GLMM with generalized logit link, no additional elements needed */
    GlmmGeneralizedLogit,
    /** # glmmIdentity

GLMM with identity link. Used for GLMM with identity link, no additional elements needed */
    GlmmIdentity,
    /** # glmmLog

GLMM with log link. Used for GLMM with log link, no additional elements needed */
    GlmmLog,
    /** # glmmLogit

GLMM with logit link. Used for GLMM with logit link, no additional elements needed */
    GlmmLogit,
    /** # glmmProbit

GLMM with probit link. Used for GLMM with probit link, no additional elements needed */
    GlmmProbit,
    /** # goodmanKruskasGamma

Goodman Kruska’s Gamma. Used for Goodman Kruska’s Gamma, no additional elements needed */
    GoodmanKruskasGamma,
    /** # hartungKnapp

Hartung-Knapp adjustment. Hartung-Knapp/Hartung-Knapp-Sidik-Jonkman adjustment used in meta-analysis, no additional elements needed */
    HartungKnapp,
    /** # hedgesMethod

Hedges method. Used for Hedges method of tau estimation, no additional elements needed */
    HedgesMethod,
    /** # hunterSchmidt

Hunter-Schmidt method. Used for Hunter-Schmidt method of tau estimation, no additional elements needed */
    HunterSchmidt,
    /** # interactionTerm

Interaction term. Used for interaction term, paired with "value" and two or more variable elements */
    InteractionTerm,
    /** # inverseVariance

Inverse variance method. Used for inverse variance method of meta-analysis, no additional elements needed */
    InverseVariance,
    /** # kendallCorrelation

Kendall correlation. Used for Kendall correlation, no additional elements needed */
    KendallCorrelation,
    /** # kruskalWallisTest

Kruskal Wallis test. Used for Kruskal Wallis test, may be paired with "value" to express degrees of freedom */
    KruskalWallisTest,
    /** # linearRegression

Linear Regression. Used for linear regression method of analysis, no additional elements needed */
    LinearRegression,
    /** # logisticRegression

Logistic Regression. Used for logistic regression method of analysis, no additional elements needed */
    LogisticRegression,
    /** # mannWhitneyUTest

Mann-Whitney U test. Used for Mann-Whitney U test, no additional elements needed */
    MannWhitneyUTest,
    /** # manova

multivariate ANOVA (MANOVA). Used for multivariate ANOVA (MANOVA) method of analysis, may be paired with "value" to express degrees of freedom */
    Manova,
    /** # manteHaenszelMethod

Mantel-Haenszel method. Used for Mantel-Haenszel method, no additional elements needed */
    ManteHaenszelMethod,
    /** # maximumLikelihood

Maximum Likelihood method. Used for Maximum Likelihood method of tau estimation, no additional elements needed */
    MaximumLikelihood,
    /** # mcnemarsTest

McNemar’s test. Used for McNemar's test, no additional elements needed */
    McnemarsTest,
    /** # metaAnalysis

Meta-analysis. Used for meta-analysis, no additional elements needed */
    MetaAnalysis,
    /** # modifiedHartungKnapp

Modified Hartung-Knapp adjustment. Modified Hartung-Knapp/Hartung-Knapp-Sidik-Jonkman adjustment used in meta-analysis, no additional elements needed */
    ModifiedHartungKnapp,
    /** # multinomialDistributionRegression

Multinomial Distribution for Regression. Used for Multinomial Distribution for Regression, no additional elements needed */
    MultinomialDistributionRegression,
    /** # negativeBinomialRegression

Negative Binomial Regression. Used for Negative Binomial Regression, no additional elements needed */
    NegativeBinomialRegression,
    /** # oneSampleTTest

1-sample t-test. Used for 1-sample t-test, may be paired with "value" to express degrees of freedom */
    OneSampleTTest,
    /** # oneTailedTest

one-tailed test (1 threshold). Used for one-tailed test (1 threshold), no additional elements needed */
    OneTailedTest,
    /** # pairedTTest

paired t-test. Used for paired t-test, may be paired with "value" to express degrees of freedom */
    PairedTTest,
    /** # pauleMandelMethod

Paule-Mandel method. Used for Paule-Mandel method of tau estimation, no additional elements needed */
    PauleMandelMethod,
    /** # pearsonCorrelation

Pearson correlation. Used for Pearson correlation, no additional elements needed */
    PearsonCorrelation,
    /** # petoMethod

Peto method. Used for Peto method of meta-analysis, no additional elements needed */
    PetoMethod,
    /** # poissonRegression

Poisson Regression. Used for Poisson Regression, no additional elements needed */
    PoissonRegression,
    /** # polynomialRegression

Polynomial Regression. Used for Polynomial regression method of analysis, no additional elements needed */
    PolynomialRegression,
    /** # poolGeneralizedLinearMixedModel

Generalized linear mixed model (GLMM). Generalized linear mixed model (GLMM) method for pooling in meta-analysis */
    PoolGeneralizedLinearMixedModel,
    /** # poolInverseVariance

Inverse variance method. Inverse variance method for pooling in meta-analysis */
    PoolInverseVariance,
    /** # poolMantelHaenzsel

Mantel-Haenszel method. Mantel-Haenszel method for pooling in meta-analysis */
    PoolMantelHaenzsel,
    /** # poolPeto

Peto method. Peto method for pooling in meta-analysis */
    PoolPeto,
    /** # restrictedLikelihood

Restricted Maximum Likelihood method. Used for Restricted Maximum Likelihood method of tau estimation, no additional elements needed */
    RestrictedLikelihood,
    /** # sidikJonkman

Sidik-Jonkman method. Used for Sidik-Jonkman method of tau estimation, no additional elements needed */
    SidikJonkman,
    /** # signTest

sign test. Used for sign test, no additional elements needed */
    SignTest,
    /** # spearmanCorrelation

Spearman correlation. Used for Spearman correlation, no additional elements needed */
    SpearmanCorrelation,
    /** # tauDersimonianLaird

Dersimonian-Laird method. Dersimonian-Laird method for tau squared */
    TauDersimonianLaird,
    /** # tauEmpiricalBayes

Empirical Bayes method. Empirical Bayes method for tau squared */
    TauEmpiricalBayes,
    /** # tauHedges

Hedges method. Hedges method for tau squared */
    TauHedges,
    /** # tauHunterSchmidt

Hunter-Schmidt method. Hunter-Schmidt method for tau squared */
    TauHunterSchmidt,
    /** # tauMaximumLikelihood

Maximum Likelihood method. Maximum Likelihood method for tau squared */
    TauMaximumLikelihood,
    /** # tauPauleMandel

Paule-Mandel method. Paule-Mandel method for tau squared */
    TauPauleMandel,
    /** # tauRestrictedMaximumLikelihood

Restricted Maximum Likelihood method. Restricted Maximum Likelihood method for tau squared */
    TauRestrictedMaximumLikelihood,
    /** # tauSidikJonkman

Sidik-Jonkman method. Sidik-Jonkman method for tau squared */
    TauSidikJonkman,
    /** # twoSampleTTest

2-sample t-test. Used for 2-sample t-test, may be paired with "value" to express degrees of freedom */
    TwoSampleTTest,
    /** # twoTailedTest

two-tailed test (2 thresholds). Used for two-tailed test (2 threshold), no additional elements needed */
    TwoTailedTest,
    /** # wilcoxonRankSumTest

Wilcoxon rank-sum test. Used for Wilcoxon rank-sum test, no additional elements needed */
    WilcoxonRankSumTest,
    /** # wilcoxonSignedRankTest

Wilcoxon signed-rank test. Used for Wilcoxon signed-rank test, no additional elements needed */
    WilcoxonSignedRankTest,
    /** # zTest

z-test. Used for z-test, no additional elements needed */
    Ztest,
    /** # zeroCellConstant

Zero-cell adjustment with constant. Zero-cell adjustment done by adding a constant to all cells of affected studies, paired with "value" to define the constant */
    ZeroCellConstant,
    /** # zeroCellContinuityCorrection

Zero-cell adjustment with continuity correction. Zero-cell adjustment done by treatment arm continuity correction, no additional elements needed */
    ZeroCellContinuityCorrection,
}
impl ::core::str::FromStr for StatisticModelCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "adjusted" => Ok(Self::Adjusted),
            "anova" => Ok(Self::Anova),
            "anovaOneWay" => Ok(Self::AnovaOneWay),
            "anovaThreeWay" => Ok(Self::AnovaThreeWay),
            "anovaTwoWay" => Ok(Self::AnovaTwoWay),
            "anovaTwoWayReplication" => Ok(Self::AnovaTwoWayReplication),
            "binomialDistributionRegression" => Ok(Self::BinomialDistributionRegression),
            "chiSquareTest" => Ok(Self::ChiSquareTest),
            "chiSquareTestHomogeneity" => Ok(Self::ChiSquareTestHomogeneity),
            "chiSquareTestTrend" => Ok(Self::ChiSquareTestTrend),
            "coxProportionalHazards" => Ok(Self::CoxProportionalHazards),
            "dersimonianLairdMethod" => Ok(Self::DersimonianLairdMethod),
            "effectsFixed" => Ok(Self::EffectsFixed),
            "effectsRandom" => Ok(Self::EffectsRandom),
            "empiricalBayes" => Ok(Self::EmpiricalBayes),
            "fishersExactTest" => Ok(Self::FishersExactTest),
            "friedmanTest" => Ok(Self::FriedmanTest),
            "glm" => Ok(Self::Glm),
            "glmGeneralizedLogit" => Ok(Self::GlmGeneralizedLogit),
            "glmIdentity" => Ok(Self::GlmIdentity),
            "glmLog" => Ok(Self::GlmLog),
            "glmLogit" => Ok(Self::GlmLogit),
            "glmProbit" => Ok(Self::GlmProbit),
            "glmm" => Ok(Self::Glmm),
            "glmmGeneralizedLogit" => Ok(Self::GlmmGeneralizedLogit),
            "glmmIdentity" => Ok(Self::GlmmIdentity),
            "glmmLog" => Ok(Self::GlmmLog),
            "glmmLogit" => Ok(Self::GlmmLogit),
            "glmmProbit" => Ok(Self::GlmmProbit),
            "goodmanKruskasGamma" => Ok(Self::GoodmanKruskasGamma),
            "hartungKnapp" => Ok(Self::HartungKnapp),
            "hedgesMethod" => Ok(Self::HedgesMethod),
            "hunterSchmidt" => Ok(Self::HunterSchmidt),
            "interactionTerm" => Ok(Self::InteractionTerm),
            "inverseVariance" => Ok(Self::InverseVariance),
            "kendallCorrelation" => Ok(Self::KendallCorrelation),
            "kruskalWallisTest" => Ok(Self::KruskalWallisTest),
            "linearRegression" => Ok(Self::LinearRegression),
            "logisticRegression" => Ok(Self::LogisticRegression),
            "mannWhitneyUTest" => Ok(Self::MannWhitneyUTest),
            "manova" => Ok(Self::Manova),
            "manteHaenszelMethod" => Ok(Self::ManteHaenszelMethod),
            "maximumLikelihood" => Ok(Self::MaximumLikelihood),
            "mcnemarsTest" => Ok(Self::McnemarsTest),
            "metaAnalysis" => Ok(Self::MetaAnalysis),
            "modifiedHartungKnapp" => Ok(Self::ModifiedHartungKnapp),
            "multinomialDistributionRegression" => {
                Ok(Self::MultinomialDistributionRegression)
            }
            "negativeBinomialRegression" => Ok(Self::NegativeBinomialRegression),
            "oneSampleTTest" => Ok(Self::OneSampleTTest),
            "oneTailedTest" => Ok(Self::OneTailedTest),
            "pairedTTest" => Ok(Self::PairedTTest),
            "pauleMandelMethod" => Ok(Self::PauleMandelMethod),
            "pearsonCorrelation" => Ok(Self::PearsonCorrelation),
            "petoMethod" => Ok(Self::PetoMethod),
            "poissonRegression" => Ok(Self::PoissonRegression),
            "polynomialRegression" => Ok(Self::PolynomialRegression),
            "poolGeneralizedLinearMixedModel" => {
                Ok(Self::PoolGeneralizedLinearMixedModel)
            }
            "poolInverseVariance" => Ok(Self::PoolInverseVariance),
            "poolMantelHaenzsel" => Ok(Self::PoolMantelHaenzsel),
            "poolPeto" => Ok(Self::PoolPeto),
            "restrictedLikelihood" => Ok(Self::RestrictedLikelihood),
            "sidikJonkman" => Ok(Self::SidikJonkman),
            "signTest" => Ok(Self::SignTest),
            "spearmanCorrelation" => Ok(Self::SpearmanCorrelation),
            "tauDersimonianLaird" => Ok(Self::TauDersimonianLaird),
            "tauEmpiricalBayes" => Ok(Self::TauEmpiricalBayes),
            "tauHedges" => Ok(Self::TauHedges),
            "tauHunterSchmidt" => Ok(Self::TauHunterSchmidt),
            "tauMaximumLikelihood" => Ok(Self::TauMaximumLikelihood),
            "tauPauleMandel" => Ok(Self::TauPauleMandel),
            "tauRestrictedMaximumLikelihood" => Ok(Self::TauRestrictedMaximumLikelihood),
            "tauSidikJonkman" => Ok(Self::TauSidikJonkman),
            "twoSampleTTest" => Ok(Self::TwoSampleTTest),
            "twoTailedTest" => Ok(Self::TwoTailedTest),
            "wilcoxonRankSumTest" => Ok(Self::WilcoxonRankSumTest),
            "wilcoxonSignedRankTest" => Ok(Self::WilcoxonSignedRankTest),
            "zTest" => Ok(Self::Ztest),
            "zeroCellConstant" => Ok(Self::ZeroCellConstant),
            "zeroCellContinuityCorrection" => Ok(Self::ZeroCellContinuityCorrection),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StatisticModelCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Adjusted => "adjusted",
            Self::Anova => "anova",
            Self::AnovaOneWay => "anovaOneWay",
            Self::AnovaThreeWay => "anovaThreeWay",
            Self::AnovaTwoWay => "anovaTwoWay",
            Self::AnovaTwoWayReplication => "anovaTwoWayReplication",
            Self::BinomialDistributionRegression => "binomialDistributionRegression",
            Self::ChiSquareTest => "chiSquareTest",
            Self::ChiSquareTestHomogeneity => "chiSquareTestHomogeneity",
            Self::ChiSquareTestTrend => "chiSquareTestTrend",
            Self::CoxProportionalHazards => "coxProportionalHazards",
            Self::DersimonianLairdMethod => "dersimonianLairdMethod",
            Self::EffectsFixed => "effectsFixed",
            Self::EffectsRandom => "effectsRandom",
            Self::EmpiricalBayes => "empiricalBayes",
            Self::FishersExactTest => "fishersExactTest",
            Self::FriedmanTest => "friedmanTest",
            Self::Glm => "glm",
            Self::GlmGeneralizedLogit => "glmGeneralizedLogit",
            Self::GlmIdentity => "glmIdentity",
            Self::GlmLog => "glmLog",
            Self::GlmLogit => "glmLogit",
            Self::GlmProbit => "glmProbit",
            Self::Glmm => "glmm",
            Self::GlmmGeneralizedLogit => "glmmGeneralizedLogit",
            Self::GlmmIdentity => "glmmIdentity",
            Self::GlmmLog => "glmmLog",
            Self::GlmmLogit => "glmmLogit",
            Self::GlmmProbit => "glmmProbit",
            Self::GoodmanKruskasGamma => "goodmanKruskasGamma",
            Self::HartungKnapp => "hartungKnapp",
            Self::HedgesMethod => "hedgesMethod",
            Self::HunterSchmidt => "hunterSchmidt",
            Self::InteractionTerm => "interactionTerm",
            Self::InverseVariance => "inverseVariance",
            Self::KendallCorrelation => "kendallCorrelation",
            Self::KruskalWallisTest => "kruskalWallisTest",
            Self::LinearRegression => "linearRegression",
            Self::LogisticRegression => "logisticRegression",
            Self::MannWhitneyUTest => "mannWhitneyUTest",
            Self::Manova => "manova",
            Self::ManteHaenszelMethod => "manteHaenszelMethod",
            Self::MaximumLikelihood => "maximumLikelihood",
            Self::McnemarsTest => "mcnemarsTest",
            Self::MetaAnalysis => "metaAnalysis",
            Self::ModifiedHartungKnapp => "modifiedHartungKnapp",
            Self::MultinomialDistributionRegression => {
                "multinomialDistributionRegression"
            }
            Self::NegativeBinomialRegression => "negativeBinomialRegression",
            Self::OneSampleTTest => "oneSampleTTest",
            Self::OneTailedTest => "oneTailedTest",
            Self::PairedTTest => "pairedTTest",
            Self::PauleMandelMethod => "pauleMandelMethod",
            Self::PearsonCorrelation => "pearsonCorrelation",
            Self::PetoMethod => "petoMethod",
            Self::PoissonRegression => "poissonRegression",
            Self::PolynomialRegression => "polynomialRegression",
            Self::PoolGeneralizedLinearMixedModel => "poolGeneralizedLinearMixedModel",
            Self::PoolInverseVariance => "poolInverseVariance",
            Self::PoolMantelHaenzsel => "poolMantelHaenzsel",
            Self::PoolPeto => "poolPeto",
            Self::RestrictedLikelihood => "restrictedLikelihood",
            Self::SidikJonkman => "sidikJonkman",
            Self::SignTest => "signTest",
            Self::SpearmanCorrelation => "spearmanCorrelation",
            Self::TauDersimonianLaird => "tauDersimonianLaird",
            Self::TauEmpiricalBayes => "tauEmpiricalBayes",
            Self::TauHedges => "tauHedges",
            Self::TauHunterSchmidt => "tauHunterSchmidt",
            Self::TauMaximumLikelihood => "tauMaximumLikelihood",
            Self::TauPauleMandel => "tauPauleMandel",
            Self::TauRestrictedMaximumLikelihood => "tauRestrictedMaximumLikelihood",
            Self::TauSidikJonkman => "tauSidikJonkman",
            Self::TwoSampleTTest => "twoSampleTTest",
            Self::TwoTailedTest => "twoTailedTest",
            Self::WilcoxonRankSumTest => "wilcoxonRankSumTest",
            Self::WilcoxonSignedRankTest => "wilcoxonSignedRankTest",
            Self::Ztest => "zTest",
            Self::ZeroCellConstant => "zeroCellConstant",
            Self::ZeroCellContinuityCorrection => "zeroCellContinuityCorrection",
        }
    }
}
impl<'de> Deserialize<'de> for StatisticModelCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StatisticModelCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StatisticType`. The role that the assertion variable plays.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StatisticType {
    /** # 0000100

Standardized Mean Difference. Computed by forming the difference between two means, divided by an estimate of the within-group standard deviation. It is used to provide an estimatation of the effect size between two treatments when the predictor (independent variable) is categorical and the response(dependent) variable is continuous */
    N0000100,
    /** # 0000301

Covariance. The strength of correlation between a set (2 or more) of random variables. The covariance is obtained by forming: cov(x,y)=e([x-e(x)][y-e(y)] where e(x), e(y) is the expected value (mean) of variable x and y respectively. Covariance is symmetric so cov(x,y)=cov(y,x). The covariance is usefull when looking at the variance of the sum of the 2 random variables since: var(x+y) = var(x) +var(y) +2cov(x,y) the covariance cov(x,y) is used to obtain the coefficient of correlation cor(x,y) by normalizing (dividing) cov(x,y) but the product of the standard deviations of x and y. */
    N0000301,
    /** # 0000424

Risk Difference. Difference between the observed risks (proportions of individuals with the outcome of interest) in the two groups. The risk difference is straightforward to interpret: it describes the actual difference in the observed risk of events between experimental and control interventions. */
    N0000424,
    /** # 0000457

Mean Difference. The mean difference, or difference in means, measures the absolute difference between the mean value in two different groups. */
    N0000457,
    /** # 0000565

Regression Coefficient. Generated by a type of data transformation called a regression, which aims to model a response variable by expression the predictor variables as part of a function where variable terms are modified by a number. A regression coefficient is one such number. */
    N0000565,
    /** # C16726

Incidence. The relative frequency of occurrence of something. */
    C16726,
    /** # C16932

Odds Ratio. The ratio of the odds of an event occurring in one group to the odds of it occurring in another group, or to a sample-based estimate of that ratio. */
    C16932,
    /** # C17010

Prevalence. The ratio (for a given time period) of the number of occurrences of a disease or event to the number of units at risk in the population. */
    C17010,
    /** # C25463

Count. The number or amount of something */
    C25463,
    /** # C25564

Maximum. The largest possible quantity or degree. */
    C25564,
    /** # C25570

Minimum. The smallest possible quantity. */
    C25570,
    /** # C28007

Median. The value which has an equal number of values greater and less than it. */
    C28007,
    /** # C44256

Proportion. Quotient of quantities of the same kind for different components within the same system. [Use for univariate outcomes within an individual.] */
    C44256,
    /** # C53319

Mean. The sum of a set of values divided by the number of values in the set. */
    C53319,
    /** # C65171

Spearman Rank-Order Correlation . A distribution-free analog of correlation analysis. Like regression, it can be applied to compare two independent random variables, each at several levels (which may be discrete or continuous). Unlike regression, Spearman's rank correlation works on ranked (relative) data, rather than directly on the data itself. */
    C65171,
    /** # C65172

Pearson Correlation Coefficient. A measure of the correlation of two variables X and Y measured on the same object or organism, that is, a measure of the tendency of the variables to increase or decrease together. It is defined as the sum of the products of the standard scores of the two measures divided by the degrees of freedom. */
    C65172,
    /** # C93150

Hazard Ratio. A measure of how often a particular event happens in one group compared to how often it happens in another group, over time. In cancer research, hazard ratios are often used in clinical trials to measure survival at any point in time in a group of patients who have been given a specific treatment compared to a control group given another treatment or a placebo. A hazard ratio of one means that there is no difference in survival between the two groups. A hazard ratio of greater than one or less than one means that survival was better in one of the groups. */
    C93150,
    /** # C93152

Relative Risk.  A measure of the risk of a certain event happening in one group compared to the risk of the same event happening in another group. In cancer research, risk ratios are used in prospective (forward looking) studies, such as cohort studies and clinical trials. A risk ratio of one means there is no difference between two groups in terms of their risk of cancer, based on whether or not they were exposed to a certain substance or factor, or how they responded to two treatments being compared. A risk ratio of greater than one or of less than one usually means that being exposed to a certain substance or factor either increases (risk ratio greater than one) or decreases (risk ratio less than one) the risk of cancer, or that the treatments being compared do not have the same effects. */
    C93152,
    /** # absolute-MedianDiff

Absolute Median Difference. Computed by forming the difference between two medians. */
    AbsoluteMedianDiff,
    /** # descriptive

Descriptive. Descriptive measure reported as narrative. */
    Descriptive,
    /** # predictedRisk

Predicted Risk. A special use case where the proportion is derived from a formula rather than derived from summary evidence. */
    PredictedRisk,
    /** # rate-ratio

Incidence Rate Ratio. A type of relative effect estimate that compares rates over time (eg events per person-years). */
    RateRatio,
}
impl ::core::str::FromStr for StatisticType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "0000100" => Ok(Self::N0000100),
            "0000301" => Ok(Self::N0000301),
            "0000424" => Ok(Self::N0000424),
            "0000457" => Ok(Self::N0000457),
            "0000565" => Ok(Self::N0000565),
            "C16726" => Ok(Self::C16726),
            "C16932" => Ok(Self::C16932),
            "C17010" => Ok(Self::C17010),
            "C25463" => Ok(Self::C25463),
            "C25564" => Ok(Self::C25564),
            "C25570" => Ok(Self::C25570),
            "C28007" => Ok(Self::C28007),
            "C44256" => Ok(Self::C44256),
            "C53319" => Ok(Self::C53319),
            "C65171" => Ok(Self::C65171),
            "C65172" => Ok(Self::C65172),
            "C93150" => Ok(Self::C93150),
            "C93152" => Ok(Self::C93152),
            "absolute-MedianDiff" => Ok(Self::AbsoluteMedianDiff),
            "descriptive" => Ok(Self::Descriptive),
            "predictedRisk" => Ok(Self::PredictedRisk),
            "rate-ratio" => Ok(Self::RateRatio),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StatisticType {
    fn as_ref(&self) -> &str {
        match self {
            Self::N0000100 => "0000100",
            Self::N0000301 => "0000301",
            Self::N0000424 => "0000424",
            Self::N0000457 => "0000457",
            Self::N0000565 => "0000565",
            Self::C16726 => "C16726",
            Self::C16932 => "C16932",
            Self::C17010 => "C17010",
            Self::C25463 => "C25463",
            Self::C25564 => "C25564",
            Self::C25570 => "C25570",
            Self::C28007 => "C28007",
            Self::C44256 => "C44256",
            Self::C53319 => "C53319",
            Self::C65171 => "C65171",
            Self::C65172 => "C65172",
            Self::C93150 => "C93150",
            Self::C93152 => "C93152",
            Self::AbsoluteMedianDiff => "absolute-MedianDiff",
            Self::Descriptive => "descriptive",
            Self::PredictedRisk => "predictedRisk",
            Self::RateRatio => "rate-ratio",
        }
    }
}
impl<'de> Deserialize<'de> for StatisticType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StatisticType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StatisticsCode`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum StatisticsCode {
    /** # 20-percent

20th Percentile. The 20th [Percentile](https://en.wikipedia.org/wiki/Percentile) of N measurements over the stated period. */
    N20Percent,
    /** # 4-dev

Quartile Deviation. The difference between the upper and lower [Quartiles](https://en.wikipedia.org/wiki/Quartile) is called the Interquartile range. (IQR = Q3-Q1) Quartile deviation or Semi-interquartile range is one-half the difference between the first and the third quartiles. */
    N4Dev,
    /** # 4-lower

Lower Quartile. The lower [Quartile](https://en.wikipedia.org/wiki/Quartile) Boundary of N measurements over the stated period. */
    N4Lower,
    /** # 4-upper

Upper Quartile. The upper [Quartile](https://en.wikipedia.org/wiki/Quartile) Boundary of N measurements over the stated period. */
    N4Upper,
    /** # 5-1

1st Quintile. The lowest of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N51,
    /** # 5-2

2nd Quintile. The second of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N52,
    /** # 5-3

3rd Quintile. The third of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N53,
    /** # 5-4

4th Quintile. The fourth of four values that divide the N measurements into a frequency distribution of five classes with each containing one fifth of the total population. */
    N54,
    /** # 80-percent

80th Percentile. The 80th [Percentile](https://en.wikipedia.org/wiki/Percentile) of N measurements over the stated period. */
    N80Percent,
    /** # average

Average. The [mean](https://en.wikipedia.org/wiki/Arithmetic_mean) of N measurements over the stated period. */
    Average,
    /** # count

Count. The [number] of valid measurements over the stated period that contributed to the other statistical outputs. */
    Count,
    /** # kurtosis

Kurtosis. Kurtosis  is a measure of the "tailedness" of the probability distribution of a real-valued random variable.   Source: [Wikipedia](https://en.wikipedia.org/wiki/Kurtosis). */
    Kurtosis,
    /** # maximum

Maximum. The [maximum](https://en.wikipedia.org/wiki/Maximal_element) value of N measurements over the stated period. */
    Maximum,
    /** # median

Median. The [median](https://en.wikipedia.org/wiki/Median) of N measurements over the stated period. */
    Median,
    /** # minimum

Minimum. The [minimum](https://en.wikipedia.org/wiki/Minimal_element) value of N measurements over the stated period. */
    Minimum,
    /** # regression

Regression. Linear regression is an approach for modeling two-dimensional sample points with one independent variable and one dependent variable (conventionally, the x and y coordinates in a Cartesian coordinate system) and finds a linear function (a non-vertical straight line) that, as accurately as possible, predicts the dependent variable values as a function of the independent variables. Source: [Wikipedia](https://en.wikipedia.org/wiki/Simple_linear_regression)  This Statistic code will return both a gradient and an intercept value. */
    Regression,
    /** # skew

Skew. Skewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean. The skewness value can be positive or negative, or even undefined.  Source: [Wikipedia](https://en.wikipedia.org/wiki/Skewness). */
    Skew,
    /** # std-dev

Standard Deviation. The [standard deviation](https://en.wikipedia.org/wiki/Standard_deviation) of N measurements over the stated period. */
    StdDev,
    /** # sum

Sum. The [sum](https://en.wikipedia.org/wiki/Summation) of N measurements over the stated period. */
    Sum,
    /** # total-count

Total Count. The total [number] of valid measurements over the stated period, including observations that were ignored because they did not contain valid result values. */
    TotalCount,
    /** # variance

Variance. The [variance](https://en.wikipedia.org/wiki/Variance) of N measurements over the stated period. */
    Variance,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for StatisticsCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "20-percent" => Ok(Self::N20Percent),
            "4-dev" => Ok(Self::N4Dev),
            "4-lower" => Ok(Self::N4Lower),
            "4-upper" => Ok(Self::N4Upper),
            "5-1" => Ok(Self::N51),
            "5-2" => Ok(Self::N52),
            "5-3" => Ok(Self::N53),
            "5-4" => Ok(Self::N54),
            "80-percent" => Ok(Self::N80Percent),
            "average" => Ok(Self::Average),
            "count" => Ok(Self::Count),
            "kurtosis" => Ok(Self::Kurtosis),
            "maximum" => Ok(Self::Maximum),
            "median" => Ok(Self::Median),
            "minimum" => Ok(Self::Minimum),
            "regression" => Ok(Self::Regression),
            "skew" => Ok(Self::Skew),
            "std-dev" => Ok(Self::StdDev),
            "sum" => Ok(Self::Sum),
            "total-count" => Ok(Self::TotalCount),
            "variance" => Ok(Self::Variance),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for StatisticsCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::N20Percent => "20-percent",
            Self::N4Dev => "4-dev",
            Self::N4Lower => "4-lower",
            Self::N4Upper => "4-upper",
            Self::N51 => "5-1",
            Self::N52 => "5-2",
            Self::N53 => "5-3",
            Self::N54 => "5-4",
            Self::N80Percent => "80-percent",
            Self::Average => "average",
            Self::Count => "count",
            Self::Kurtosis => "kurtosis",
            Self::Maximum => "maximum",
            Self::Median => "median",
            Self::Minimum => "minimum",
            Self::Regression => "regression",
            Self::Skew => "skew",
            Self::StdDev => "std-dev",
            Self::Sum => "sum",
            Self::TotalCount => "total-count",
            Self::Variance => "variance",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for StatisticsCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StatisticsCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StrengthOfRecommendationRating`. A rating system that describes the strength of the recommendation, such as the GRADE, DynaMed, or HGPS systems.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StrengthOfRecommendationRating {
    /** # strong

Strong. Strong recommendation. */
    Strong,
    /** # weak

Weak. Weak recommendation. */
    Weak,
}
impl ::core::str::FromStr for StrengthOfRecommendationRating {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "strong" => Ok(Self::Strong),
            "weak" => Ok(Self::Weak),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StrengthOfRecommendationRating {
    fn as_ref(&self) -> &str {
        match self {
            Self::Strong => "strong",
            Self::Weak => "weak",
        }
    }
}
impl<'de> Deserialize<'de> for StrengthOfRecommendationRating {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StrengthOfRecommendationRating {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StructureDefinitionKind`. Defines the type of structure that a definition is describing.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureDefinitionKind {
    /** # complex-type

Complex Data Type. A  complex structure that defines a set of data elements that is suitable for use in 'resources'. The base specification defines a number of complex types, and other specifications can define additional types. These structures do not have a maintained identity. */
    ComplexType,
    /** # logical

Logical. A pattern or a template that is not intended to be a real resource or complex type. */
    Logical,
    /** # primitive-type

Primitive Data Type. A primitive type that has a value and an extension. These can be used throughout complex datatype, Resource and extension definitions. Only the base specification can define primitive types. */
    PrimitiveType,
    /** # resource

Resource. A 'resource' - a directed acyclic graph of elements that aggregrates other types into an identifiable entity. The base FHIR resources are defined by the FHIR specification itself but other 'resources' can be defined in additional specifications (though these will not be recognised as 'resources' by the FHIR specification (i.e. they do not get end-points etc, or act as the targets of references in FHIR defined resources - though other specificatiosn can treat them this way). */
    Resource,
}
impl ::core::str::FromStr for StructureDefinitionKind {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "complex-type" => Ok(Self::ComplexType),
            "logical" => Ok(Self::Logical),
            "primitive-type" => Ok(Self::PrimitiveType),
            "resource" => Ok(Self::Resource),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureDefinitionKind {
    fn as_ref(&self) -> &str {
        match self {
            Self::ComplexType => "complex-type",
            Self::Logical => "logical",
            Self::PrimitiveType => "primitive-type",
            Self::Resource => "resource",
        }
    }
}
impl<'de> Deserialize<'de> for StructureDefinitionKind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureDefinitionKind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StructureMapContextType`. How to interpret the context.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapContextType {
    /** # type

Type. The context specifies a type. */
    Type,
    /** # variable

Variable. The context specifies a variable. */
    Variable,
}
impl ::core::str::FromStr for StructureMapContextType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "type" => Ok(Self::Type),
            "variable" => Ok(Self::Variable),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapContextType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Type => "type",
            Self::Variable => "variable",
        }
    }
}
impl<'de> Deserialize<'de> for StructureMapContextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapContextType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StructureMapGroupTypeMode`. If this is the default rule set to apply for the source type, or this combination of types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapGroupTypeMode {
    /** # none

Not a Default. This group is not a default group for the types. */
    None,
    /** # type-and-types

Default for type + combination. This group is a default mapping group for the specified types. */
    TypeAndTypes,
    /** # types

Default for Type Combination. This group is a default mapping group for the specified types and for the primary source type. */
    Types,
}
impl ::core::str::FromStr for StructureMapGroupTypeMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "none" => Ok(Self::None),
            "type-and-types" => Ok(Self::TypeAndTypes),
            "types" => Ok(Self::Types),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapGroupTypeMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::None => "none",
            Self::TypeAndTypes => "type-and-types",
            Self::Types => "types",
        }
    }
}
impl<'de> Deserialize<'de> for StructureMapGroupTypeMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapGroupTypeMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StructureMapInputMode`. Mode for this instance of data.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapInputMode {
    /** # source

Source Instance. Names an input instance used a source for mapping. */
    Source,
    /** # target

Target Instance. Names an instance that is being populated. */
    Target,
}
impl ::core::str::FromStr for StructureMapInputMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "source" => Ok(Self::Source),
            "target" => Ok(Self::Target),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapInputMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Source => "source",
            Self::Target => "target",
        }
    }
}
impl<'de> Deserialize<'de> for StructureMapInputMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapInputMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StructureMapModelMode`. How the referenced structure is used in this mapping.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapModelMode {
    /** # produced

Produced Structure Definition. This structure describes an instance that the mapping engine may ask to create that is used a target of data. */
    Produced,
    /** # queried

Queried Structure Definition. This structure describes an instance that the mapping engine may ask for that is used a source of data. */
    Queried,
    /** # source

Source Structure Definition. This structure describes an instance passed to the mapping engine that is used a source of data. */
    Source,
    /** # target

Target Structure Definition. This structure describes an instance passed to the mapping engine that is used a target of data. */
    Target,
}
impl ::core::str::FromStr for StructureMapModelMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "produced" => Ok(Self::Produced),
            "queried" => Ok(Self::Queried),
            "source" => Ok(Self::Source),
            "target" => Ok(Self::Target),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapModelMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Produced => "produced",
            Self::Queried => "queried",
            Self::Source => "source",
            Self::Target => "target",
        }
    }
}
impl<'de> Deserialize<'de> for StructureMapModelMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapModelMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StructureMapSourceListMode`. If field is a list, how to manage the source.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapSourceListMode {
    /** # first

First. Only process this rule for the first in the list. */
    First,
    /** # last

Last. Only process this rule for the last in the list. */
    Last,
    /** # not_first

All but the first. Process this rule for all but the first. */
    NotFirst,
    /** # not_last

All but the last. Process this rule for all but the last. */
    NotLast,
    /** # only_one

Enforce only one. Only process this rule is there is only item. */
    OnlyOne,
}
impl ::core::str::FromStr for StructureMapSourceListMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "first" => Ok(Self::First),
            "last" => Ok(Self::Last),
            "not_first" => Ok(Self::NotFirst),
            "not_last" => Ok(Self::NotLast),
            "only_one" => Ok(Self::OnlyOne),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapSourceListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::First => "first",
            Self::Last => "last",
            Self::NotFirst => "not_first",
            Self::NotLast => "not_last",
            Self::OnlyOne => "only_one",
        }
    }
}
impl<'de> Deserialize<'de> for StructureMapSourceListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapSourceListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StructureMapTargetListMode`. If field is a list, how to manage the production.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapTargetListMode {
    /** # collate

Collate. re-use the first item in the list, and keep adding content to it. */
    Collate,
    /** # first

First. when the target list is being assembled, the items for this rule go first. If more than one rule defines a first item (for a given instance of mapping) then this is an error. */
    First,
    /** # last

Last. when the target list is being assembled, the items for this rule go last. If more than one rule defines a last item (for a given instance of mapping) then this is an error. */
    Last,
    /** # share

Share. the target instance is shared with the target instances generated by another rule (up to the first common n items, then create new ones). */
    Share,
}
impl ::core::str::FromStr for StructureMapTargetListMode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "collate" => Ok(Self::Collate),
            "first" => Ok(Self::First),
            "last" => Ok(Self::Last),
            "share" => Ok(Self::Share),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapTargetListMode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Collate => "collate",
            Self::First => "first",
            Self::Last => "last",
            Self::Share => "share",
        }
    }
}
impl<'de> Deserialize<'de> for StructureMapTargetListMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapTargetListMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StructureMapTransform`. How data is copied/created.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StructureMapTransform {
    /** # append

append. append(source...) - source is element or string. */
    Append,
    /** # c

c. Create a Coding. Parameters = (system. Code[, display]). */
    C,
    /** # cast

cast. cast(source, type?) - case source from one type to another. target type can be left as implicit if there is one and only one target type known. */
    Cast,
    /** # cc

cc. Create a CodeableConcept. Parameters = (text) or (system. Code[, display]). */
    Cc,
    /** # copy

copy. copy(source). */
    Copy,
    /** # cp

cp. Create a contact details. Parameters = (value) or (system, value). If no system is provided, the system should be inferred from the content of the value. */
    Cp,
    /** # create

create. create(type : string) - type is passed through to the application on the standard API, and must be known by it. */
    Create,
    /** # dateOp

dateOp. Perform a date operation. *Parameters to be documented*. */
    DateOp,
    /** # escape

escape. escape(source, fmt1, fmt2) - change source from one kind of escaping to another (plain, java, xml, json). note that this is for when the string itself is escaped. */
    Escape,
    /** # evaluate

evaluate. Execute the supplied FHIRPath expression and use the value returned by that. */
    Evaluate,
    /** # id

id. Create an identifier. Parameters = (system, value[, type]) where type is a code from the identifier type value set. */
    Id,
    /** # pointer

pointer. Return the appropriate string to put in a reference that refers to the resource provided as a parameter. */
    Pointer,
    /** # qty

qty. Create a quantity. Parameters = (text) or (value, unit, [system, code]) where text is the natural representation e.g. [comparator]value[space]unit. */
    Qty,
    /** # reference

reference. reference(source : object) - return a string that references the provided tree properly. */
    Reference,
    /** # translate

translate. translate(source, uri_of_map) - use the translate operation. */
    Translate,
    /** # truncate

truncate. truncate(source, length) - source must be stringy type. */
    Truncate,
    /** # uuid

uuid. Generate a random UUID (in lowercase). No Parameters. */
    Uuid,
}
impl ::core::str::FromStr for StructureMapTransform {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "append" => Ok(Self::Append),
            "c" => Ok(Self::C),
            "cast" => Ok(Self::Cast),
            "cc" => Ok(Self::Cc),
            "copy" => Ok(Self::Copy),
            "cp" => Ok(Self::Cp),
            "create" => Ok(Self::Create),
            "dateOp" => Ok(Self::DateOp),
            "escape" => Ok(Self::Escape),
            "evaluate" => Ok(Self::Evaluate),
            "id" => Ok(Self::Id),
            "pointer" => Ok(Self::Pointer),
            "qty" => Ok(Self::Qty),
            "reference" => Ok(Self::Reference),
            "translate" => Ok(Self::Translate),
            "truncate" => Ok(Self::Truncate),
            "uuid" => Ok(Self::Uuid),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StructureMapTransform {
    fn as_ref(&self) -> &str {
        match self {
            Self::Append => "append",
            Self::C => "c",
            Self::Cast => "cast",
            Self::Cc => "cc",
            Self::Copy => "copy",
            Self::Cp => "cp",
            Self::Create => "create",
            Self::DateOp => "dateOp",
            Self::Escape => "escape",
            Self::Evaluate => "evaluate",
            Self::Id => "id",
            Self::Pointer => "pointer",
            Self::Qty => "qty",
            Self::Reference => "reference",
            Self::Translate => "translate",
            Self::Truncate => "truncate",
            Self::Uuid => "uuid",
        }
    }
}
impl<'de> Deserialize<'de> for StructureMapTransform {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StructureMapTransform {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `StudyType`. The type of study the evidence was derived from.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum StudyType {
    /** # CCT

controlled trial (non-randomized). controlled (but not randomized) trial. */
    Cct,
    /** # RCT

randomized trial. randomized controlled trial. */
    Rct,
    /** # case-control

case-control study. case-control study. */
    CaseControl,
    /** # case-report

case report. a single case report. */
    CaseReport,
    /** # cohort

comparative cohort study. observational study comparing cohorts. */
    Cohort,
    /** # mixed

mixed methods. a combination of 1 or more types of studies. */
    Mixed,
    /** # series

uncontrolled cohort or case series. uncontrolled cohort or case series. */
    Series,
}
impl ::core::str::FromStr for StudyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CCT" => Ok(Self::Cct),
            "RCT" => Ok(Self::Rct),
            "case-control" => Ok(Self::CaseControl),
            "case-report" => Ok(Self::CaseReport),
            "cohort" => Ok(Self::Cohort),
            "mixed" => Ok(Self::Mixed),
            "series" => Ok(Self::Series),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for StudyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cct => "CCT",
            Self::Rct => "RCT",
            Self::CaseControl => "case-control",
            Self::CaseReport => "case-report",
            Self::Cohort => "cohort",
            Self::Mixed => "mixed",
            Self::Series => "series",
        }
    }
}
impl<'de> Deserialize<'de> for StudyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for StudyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubscriberRelationshipCodes`. This value set includes codes for the relationship between the Subscriber and the Beneficiary (insured/covered party/patient).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SubscriberRelationshipCodes {
    /** # child

Child. The Beneficiary is a child of the Subscriber */
    Child,
    /** # common

Common Law Spouse. The Beneficiary is a common law spouse or equivalent of the Subscriber */
    Common,
    /** # injured

Injured Party. The Beneficiary is covered under insurance of the subscriber due to an injury. */
    Injured,
    /** # other

Other. The Beneficiary has some other relationship the Subscriber */
    Other,
    /** # parent

Parent. The Beneficiary is a parent of the Subscriber */
    Parent,
    /** # self

Self. The Beneficiary is the Subscriber */
    _Self,
    /** # spouse

Spouse. The Beneficiary is a spouse or equivalent of the Subscriber */
    Spouse,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SubscriberRelationshipCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "child" => Ok(Self::Child),
            "common" => Ok(Self::Common),
            "injured" => Ok(Self::Injured),
            "other" => Ok(Self::Other),
            "parent" => Ok(Self::Parent),
            "self" => Ok(Self::_Self),
            "spouse" => Ok(Self::Spouse),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SubscriberRelationshipCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Child => "child",
            Self::Common => "common",
            Self::Injured => "injured",
            Self::Other => "other",
            Self::Parent => "parent",
            Self::_Self => "self",
            Self::Spouse => "spouse",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for SubscriberRelationshipCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriberRelationshipCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubscriptionChannelType`. The type of method used to execute a subscription.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubscriptionChannelType {
    /** # email

Email. The channel is executed by sending an email to the email addressed in the URI (which must be a mailto:). */
    Email,
    /** # message

Message. The channel is executed by sending a message (e.g. a Bundle with a MessageHeader resource etc.) to the application identified in the URI. */
    Message,
    /** # rest-hook

Rest Hook. The channel is executed by making a post to the URI. If a payload is included, the URL is interpreted as the service base, and an update (PUT) is made. */
    RestHook,
    /** # sms

SMS. The channel is executed by sending an SMS message to the phone number identified in the URL (tel:). */
    Sms,
    /** # websocket

Websocket. The channel is executed by sending a packet across a web socket connection maintained by the client. The URL identifies the websocket, and the client binds to this URL. */
    Websocket,
}
impl ::core::str::FromStr for SubscriptionChannelType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "email" => Ok(Self::Email),
            "message" => Ok(Self::Message),
            "rest-hook" => Ok(Self::RestHook),
            "sms" => Ok(Self::Sms),
            "websocket" => Ok(Self::Websocket),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionChannelType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Email => "email",
            Self::Message => "message",
            Self::RestHook => "rest-hook",
            Self::Sms => "sms",
            Self::Websocket => "websocket",
        }
    }
}
impl<'de> Deserialize<'de> for SubscriptionChannelType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionChannelType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubscriptionNotificationType`. The type of notification represented by the status message.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubscriptionNotificationType {
    /** # event-notification

Event Notification. The status was generated for an event to the subscriber. */
    EventNotification,
    /** # handshake

Handshake. The status was generated as part of the setup or verification of a communications channel. */
    Handshake,
    /** # heartbeat

Heartbeat. The status was generated to perform a heartbeat notification to the subscriber. */
    Heartbeat,
    /** # query-event

Query Event. The status was generated in response to an event query/request. */
    QueryEvent,
    /** # query-status

Query Status. The status was generated in response to a status query/request. */
    QueryStatus,
}
impl ::core::str::FromStr for SubscriptionNotificationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "event-notification" => Ok(Self::EventNotification),
            "handshake" => Ok(Self::Handshake),
            "heartbeat" => Ok(Self::Heartbeat),
            "query-event" => Ok(Self::QueryEvent),
            "query-status" => Ok(Self::QueryStatus),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionNotificationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::EventNotification => "event-notification",
            Self::Handshake => "handshake",
            Self::Heartbeat => "heartbeat",
            Self::QueryEvent => "query-event",
            Self::QueryStatus => "query-status",
        }
    }
}
impl<'de> Deserialize<'de> for SubscriptionNotificationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionNotificationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubscriptionSearchModifer`. This codesystem defines a set of codes that can be used to filter Subscription triggers.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SubscriptionSearchModifer {
    /** # =

=. Used to match a value according to FHIR Search rules (e.g., Patient/123, Encounter/2002). */
    Equal,
    /** # above

Above. The search parameter is a concept with the form [system]|[code], and the search parameter tests whether the coding in a resource subsumes the specified search code. */
    Above,
    /** # ap

Approximately. The value for the parameter in the resource is approximately the same to the provided value. Note that the recommended value for the approximation is 10% of the stated value (or for a date, 10% of the gap between now and the date), but systems may choose other values where appropriate. */
    Ap,
    /** # below

Below. The search parameter is a concept with the form [system]|[code], and the search parameter tests whether the coding in a resource is subsumed by the specified search code. */
    Below,
    /** # eb

Ends Before. The value for the parameter in the resource ends before the provided value. */
    Eb,
    /** # eq

Equal. The value for the parameter in the resource is equal to the provided value. */
    Eq,
    /** # ge

Greater Than or Equal. The value for the parameter in the resource is greater or equal to the provided value. */
    Ge,
    /** # gt

Greater Than. The value for the parameter in the resource is greater than the provided value. */
    Gt,
    /** # in

In. The search parameter is a member of a Group or List, or the search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the value is present in the specified Group, List, or Value Set. */
    In,
    /** # le

Less Than or Equal. The value for the parameter in the resource is less or equal to the provided value. */
    Le,
    /** # lt

Less Than. The value for the parameter in the resource is less than the provided value. */
    Lt,
    /** # ne

Not Equal. The value for the parameter in the resource is not equal to the provided value. */
    Ne,
    /** # not-in

Not In. The search parameter is a member of a Group or List, or the search parameter is a URI (relative or absolute) that identifies a value set, and the search parameter tests whether the value is NOT present in the specified Group, List, or Value Set. */
    NotIn,
    /** # of-type

Of Type. The search parameter has the format system|code|value, where the system and code refer to a Identifier.type.coding.system and .code, and match if any of the type codes match. All 3 parts must be present. */
    OfType,
    /** # sa

Starts After. The value for the parameter in the resource starts after the provided value. */
    Sa,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SubscriptionSearchModifer {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "=" => Ok(Self::Equal),
            "above" => Ok(Self::Above),
            "ap" => Ok(Self::Ap),
            "below" => Ok(Self::Below),
            "eb" => Ok(Self::Eb),
            "eq" => Ok(Self::Eq),
            "ge" => Ok(Self::Ge),
            "gt" => Ok(Self::Gt),
            "in" => Ok(Self::In),
            "le" => Ok(Self::Le),
            "lt" => Ok(Self::Lt),
            "ne" => Ok(Self::Ne),
            "not-in" => Ok(Self::NotIn),
            "of-type" => Ok(Self::OfType),
            "sa" => Ok(Self::Sa),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SubscriptionSearchModifer {
    fn as_ref(&self) -> &str {
        match self {
            Self::Equal => "=",
            Self::Above => "above",
            Self::Ap => "ap",
            Self::Below => "below",
            Self::Eb => "eb",
            Self::Eq => "eq",
            Self::Ge => "ge",
            Self::Gt => "gt",
            Self::In => "in",
            Self::Le => "le",
            Self::Lt => "lt",
            Self::Ne => "ne",
            Self::NotIn => "not-in",
            Self::OfType => "of-type",
            Self::Sa => "sa",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for SubscriptionSearchModifer {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionSearchModifer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubscriptionStatus`. The status of a subscription.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubscriptionStatus {
    /** # active

Active. The subscription is active. */
    Active,
    /** # error

Error. The server has an error executing the notification. */
    Error,
    /** # off

Off. Too many errors have occurred or the subscription has expired. */
    Off,
    /** # requested

Requested. The client has requested the subscription, and the server has not yet set it up. */
    Requested,
}
impl ::core::str::FromStr for SubscriptionStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "error" => Ok(Self::Error),
            "off" => Ok(Self::Off),
            "requested" => Ok(Self::Requested),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubscriptionStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Error => "error",
            Self::Off => "off",
            Self::Requested => "requested",
        }
    }
}
impl<'de> Deserialize<'de> for SubscriptionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubscriptionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceAmountType`. The type of a numeric quantity measurement.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceAmountType {
    /** # Approximately

Approximately. */
    Approximately,
    /** # Average

Average. */
    Average,
    /** # LessThan

Less Than. */
    LessThan,
    /** # MoreThan

More Than. */
    MoreThan,
}
impl ::core::str::FromStr for SubstanceAmountType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Approximately" => Ok(Self::Approximately),
            "Average" => Ok(Self::Average),
            "LessThan" => Ok(Self::LessThan),
            "MoreThan" => Ok(Self::MoreThan),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceAmountType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Approximately => "Approximately",
            Self::Average => "Average",
            Self::LessThan => "LessThan",
            Self::MoreThan => "MoreThan",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceAmountType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceAmountType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceGrade`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceGrade {
    /** # BP

British Pharmacopoeia. */
    Bp,
    /** # CompanyStandard

Company Standard. */
    CompanyStandard,
    /** # JP

Japanese Pharmacopoeia. */
    Jp,
    /** # Ph.Eur

European Pharmacopoeia. */
    PhEur,
    /** # USP-NF

USP/NF United States Pharmacopeia (USP) and the National Formulary (NF). */
    UspNf,
}
impl ::core::str::FromStr for SubstanceGrade {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BP" => Ok(Self::Bp),
            "CompanyStandard" => Ok(Self::CompanyStandard),
            "JP" => Ok(Self::Jp),
            "Ph.Eur" => Ok(Self::PhEur),
            "USP-NF" => Ok(Self::UspNf),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceGrade {
    fn as_ref(&self) -> &str {
        match self {
            Self::Bp => "BP",
            Self::CompanyStandard => "CompanyStandard",
            Self::Jp => "JP",
            Self::PhEur => "Ph.Eur",
            Self::UspNf => "USP-NF",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceGrade {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceGrade {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceNameAuthority`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceNameAuthority {
    /** # BAN

BAN. */
    Ban,
    /** # COSING

COSING. */
    Cosing,
    /** # FCC

FCC. */
    Fcc,
    /** # HAB

HAB. */
    Hab,
    /** # INCI

INCI. */
    Inci,
    /** # INN

INN. */
    Inn,
    /** # IUIS

IUIS. */
    Iuis,
    /** # JAN

JAN. */
    Jan,
    /** # JECFA

JECFA. */
    Jecfa,
    /** # MARTINDALE

MARTINDALE. */
    Martindale,
    /** # PHF

PHF. */
    Phf,
    /** # Ph.Eur.

Ph.Eur.. */
    PhEur,
    /** # PhF

PhF (Pharmacopée française). */
    PhF,
    /** # USAN

USAN. */
    Usan,
    /** # USP

USP. */
    Usp,
}
impl ::core::str::FromStr for SubstanceNameAuthority {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "BAN" => Ok(Self::Ban),
            "COSING" => Ok(Self::Cosing),
            "FCC" => Ok(Self::Fcc),
            "HAB" => Ok(Self::Hab),
            "INCI" => Ok(Self::Inci),
            "INN" => Ok(Self::Inn),
            "IUIS" => Ok(Self::Iuis),
            "JAN" => Ok(Self::Jan),
            "JECFA" => Ok(Self::Jecfa),
            "MARTINDALE" => Ok(Self::Martindale),
            "PHF" => Ok(Self::Phf),
            "Ph.Eur." => Ok(Self::PhEur),
            "PhF" => Ok(Self::PhF),
            "USAN" => Ok(Self::Usan),
            "USP" => Ok(Self::Usp),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceNameAuthority {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ban => "BAN",
            Self::Cosing => "COSING",
            Self::Fcc => "FCC",
            Self::Hab => "HAB",
            Self::Inci => "INCI",
            Self::Inn => "INN",
            Self::Iuis => "IUIS",
            Self::Jan => "JAN",
            Self::Jecfa => "JECFA",
            Self::Martindale => "MARTINDALE",
            Self::Phf => "PHF",
            Self::PhEur => "Ph.Eur.",
            Self::PhF => "PhF",
            Self::Usan => "USAN",
            Self::Usp => "USP",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceNameAuthority {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceNameAuthority {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceNameDomain`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceNameDomain {
    /** # ActiveIngredient

Active Ingredient. */
    ActiveIngredient,
    /** # FoodColorAdditive

Food Color Additive. */
    FoodColorAdditive,
}
impl ::core::str::FromStr for SubstanceNameDomain {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActiveIngredient" => Ok(Self::ActiveIngredient),
            "FoodColorAdditive" => Ok(Self::FoodColorAdditive),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceNameDomain {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActiveIngredient => "ActiveIngredient",
            Self::FoodColorAdditive => "FoodColorAdditive",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceNameDomain {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceNameDomain {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceNameType`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceNameType {
    /** # Brand

brand. */
    Brand,
    /** # Scientific

scientific. */
    Scientific,
    /** # Systematic

systematic. */
    Systematic,
}
impl ::core::str::FromStr for SubstanceNameType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Brand" => Ok(Self::Brand),
            "Scientific" => Ok(Self::Scientific),
            "Systematic" => Ok(Self::Systematic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceNameType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Brand => "Brand",
            Self::Scientific => "Scientific",
            Self::Systematic => "Systematic",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceNameType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceNameType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceOpticalActivity`. The optical rotation type of a substance.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceOpticalActivity {
    /** # +

dextrorotary. */
    Plus,
    /** # -

levorotary. */
    Minus,
}
impl ::core::str::FromStr for SubstanceOpticalActivity {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "+" => Ok(Self::Plus),
            "-" => Ok(Self::Minus),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceOpticalActivity {
    fn as_ref(&self) -> &str {
        match self {
            Self::Plus => "+",
            Self::Minus => "-",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceOpticalActivity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceOpticalActivity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceRelationshipType`. The relationship between two substance types.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceRelationshipType {
    /** # ActiveMoiety

Active moiety. */
    ActiveMoiety,
    /** # Impurity

Impurity of. */
    Impurity,
    /** # Polymorph

Polymorph of. */
    Polymorph,
    /** # Salt

Salt to parent. */
    Salt,
    /** # StartingMaterial

Starting material for. */
    StartingMaterial,
}
impl ::core::str::FromStr for SubstanceRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ActiveMoiety" => Ok(Self::ActiveMoiety),
            "Impurity" => Ok(Self::Impurity),
            "Polymorph" => Ok(Self::Polymorph),
            "Salt" => Ok(Self::Salt),
            "StartingMaterial" => Ok(Self::StartingMaterial),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ActiveMoiety => "ActiveMoiety",
            Self::Impurity => "Impurity",
            Self::Polymorph => "Polymorph",
            Self::Salt => "Salt",
            Self::StartingMaterial => "StartingMaterial",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceRepresentationFormat`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceRepresentationFormat {
    /** # CDX

CDX. */
    Cdx,
    /** # InChI

InChI. */
    InChI,
    /** # MOLFILE

MOLFILE. */
    Molfile,
    /** # PDB

PDB. */
    Pdb,
    /** # SDF

SDF. */
    Sdf,
    /** # SMILES

SMILES. */
    Smiles,
    /** # mmCIF

mmCIF. */
    MmCIF,
}
impl ::core::str::FromStr for SubstanceRepresentationFormat {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "CDX" => Ok(Self::Cdx),
            "InChI" => Ok(Self::InChI),
            "MOLFILE" => Ok(Self::Molfile),
            "PDB" => Ok(Self::Pdb),
            "SDF" => Ok(Self::Sdf),
            "SMILES" => Ok(Self::Smiles),
            "mmCIF" => Ok(Self::MmCIF),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceRepresentationFormat {
    fn as_ref(&self) -> &str {
        match self {
            Self::Cdx => "CDX",
            Self::InChI => "InChI",
            Self::Molfile => "MOLFILE",
            Self::Pdb => "PDB",
            Self::Sdf => "SDF",
            Self::Smiles => "SMILES",
            Self::MmCIF => "mmCIF",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceRepresentationFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceRepresentationFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceRepresentationType`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceRepresentationType {
    /** # Brand

brand. */
    Brand,
    /** # Scientific

scientific. */
    Scientific,
    /** # Systematic

systematic. */
    Systematic,
}
impl ::core::str::FromStr for SubstanceRepresentationType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Brand" => Ok(Self::Brand),
            "Scientific" => Ok(Self::Scientific),
            "Systematic" => Ok(Self::Systematic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceRepresentationType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Brand => "Brand",
            Self::Scientific => "Scientific",
            Self::Systematic => "Systematic",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceRepresentationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceRepresentationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceSourceMaterialGenus`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialGenus {
    /** # Ginkgo

Ginkgo. */
    Ginkgo,
    /** # InfluenzavirusA

Influenza A virus. */
    InfluenzavirusA,
    /** # Mycobacterium

Mycobacterium. */
    Mycobacterium,
}
impl ::core::str::FromStr for SubstanceSourceMaterialGenus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Ginkgo" => Ok(Self::Ginkgo),
            "InfluenzavirusA" => Ok(Self::InfluenzavirusA),
            "Mycobacterium" => Ok(Self::Mycobacterium),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialGenus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Ginkgo => "Ginkgo",
            Self::InfluenzavirusA => "InfluenzavirusA",
            Self::Mycobacterium => "Mycobacterium",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialGenus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialGenus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceSourceMaterialPart`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialPart {
    /** # Animal

animal. */
    Animal,
    /** # Mineral

mineral. */
    Mineral,
    /** # Plant

plant. */
    Plant,
}
impl ::core::str::FromStr for SubstanceSourceMaterialPart {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Animal" => Ok(Self::Animal),
            "Mineral" => Ok(Self::Mineral),
            "Plant" => Ok(Self::Plant),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialPart {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "Animal",
            Self::Mineral => "Mineral",
            Self::Plant => "Plant",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceSourceMaterialSpecies`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialSpecies {
    /** # GinkgoBiloba

Ginkgo biloba. */
    GinkgoBiloba,
    /** # OleaEuropaea

Olea europaea. */
    OleaEuropaea,
}
impl ::core::str::FromStr for SubstanceSourceMaterialSpecies {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "GinkgoBiloba" => Ok(Self::GinkgoBiloba),
            "OleaEuropaea" => Ok(Self::OleaEuropaea),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialSpecies {
    fn as_ref(&self) -> &str {
        match self {
            Self::GinkgoBiloba => "GinkgoBiloba",
            Self::OleaEuropaea => "OleaEuropaea",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialSpecies {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialSpecies {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceSourceMaterialType`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceSourceMaterialType {
    /** # Animal

animal. */
    Animal,
    /** # Mineral

mineral. */
    Mineral,
    /** # Plant

plant. */
    Plant,
}
impl ::core::str::FromStr for SubstanceSourceMaterialType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Animal" => Ok(Self::Animal),
            "Mineral" => Ok(Self::Mineral),
            "Plant" => Ok(Self::Plant),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceSourceMaterialType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Animal => "Animal",
            Self::Mineral => "Mineral",
            Self::Plant => "Plant",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceSourceMaterialType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceSourceMaterialType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceStereochemistry`. The stereochemistry type of a substance.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceStereochemistry {
    /** # ConstitutionalIsomer

constitutional isomer. */
    ConstitutionalIsomer,
    /** # Enantiomer

enantiomer. */
    Enantiomer,
    /** # Stereoisomer

stereoisomer. */
    Stereoisomer,
}
impl ::core::str::FromStr for SubstanceStereochemistry {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "ConstitutionalIsomer" => Ok(Self::ConstitutionalIsomer),
            "Enantiomer" => Ok(Self::Enantiomer),
            "Stereoisomer" => Ok(Self::Stereoisomer),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceStereochemistry {
    fn as_ref(&self) -> &str {
        match self {
            Self::ConstitutionalIsomer => "ConstitutionalIsomer",
            Self::Enantiomer => "Enantiomer",
            Self::Stereoisomer => "Stereoisomer",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceStereochemistry {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceStereochemistry {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceStructureTechnique`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceStructureTechnique {
    /** # HPLC

HPLC. */
    Hplc,
    /** # LigandBindingAssay

Ligand binding assay. */
    LigandBindingAssay,
    /** # NMR

NMR. */
    Nmr,
    /** # PeptideMapping

Peptide mapping. */
    PeptideMapping,
    /** # X-Ray

X-ray. */
    XRay,
}
impl ::core::str::FromStr for SubstanceStructureTechnique {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "HPLC" => Ok(Self::Hplc),
            "LigandBindingAssay" => Ok(Self::LigandBindingAssay),
            "NMR" => Ok(Self::Nmr),
            "PeptideMapping" => Ok(Self::PeptideMapping),
            "X-Ray" => Ok(Self::XRay),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceStructureTechnique {
    fn as_ref(&self) -> &str {
        match self {
            Self::Hplc => "HPLC",
            Self::LigandBindingAssay => "LigandBindingAssay",
            Self::Nmr => "NMR",
            Self::PeptideMapping => "PeptideMapping",
            Self::XRay => "X-Ray",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceStructureTechnique {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceStructureTechnique {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceWeightMethod`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceWeightMethod {
    /** # Calculated

calculated. */
    Calculated,
    /** # End-groupAnalysis

End-group analysis. */
    EndGroupAnalysis,
    /** # End-groupTitration

End-group titration. */
    EndGroupTitration,
    /** # GelPermeationCentrifugation

gel permeation centrifugation. */
    GelPermeationCentrifugation,
    /** # LighScattering

light scattering. */
    LighScattering,
    /** # SDS-PAGE

SDS-PAGE (sodium dodecyl sulfate-polyacrylamide gel electrophoresis). */
    SdsPage,
    /** # Size-ExclusionChromatography

Size-exclusion chromatography. */
    SizeExclusionChromatography,
    /** # Viscosity

viscosity. */
    Viscosity,
}
impl ::core::str::FromStr for SubstanceWeightMethod {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Calculated" => Ok(Self::Calculated),
            "End-groupAnalysis" => Ok(Self::EndGroupAnalysis),
            "End-groupTitration" => Ok(Self::EndGroupTitration),
            "GelPermeationCentrifugation" => Ok(Self::GelPermeationCentrifugation),
            "LighScattering" => Ok(Self::LighScattering),
            "SDS-PAGE" => Ok(Self::SdsPage),
            "Size-ExclusionChromatography" => Ok(Self::SizeExclusionChromatography),
            "Viscosity" => Ok(Self::Viscosity),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceWeightMethod {
    fn as_ref(&self) -> &str {
        match self {
            Self::Calculated => "Calculated",
            Self::EndGroupAnalysis => "End-groupAnalysis",
            Self::EndGroupTitration => "End-groupTitration",
            Self::GelPermeationCentrifugation => "GelPermeationCentrifugation",
            Self::LighScattering => "LighScattering",
            Self::SdsPage => "SDS-PAGE",
            Self::SizeExclusionChromatography => "Size-ExclusionChromatography",
            Self::Viscosity => "Viscosity",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceWeightMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceWeightMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SubstanceWeightType`.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SubstanceWeightType {
    /** # Average

number average. */
    Average,
    /** # Exact

exact. */
    Exact,
    /** # WeightAverage

weight average. */
    WeightAverage,
}
impl ::core::str::FromStr for SubstanceWeightType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Average" => Ok(Self::Average),
            "Exact" => Ok(Self::Exact),
            "WeightAverage" => Ok(Self::WeightAverage),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SubstanceWeightType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Average => "Average",
            Self::Exact => "Exact",
            Self::WeightAverage => "WeightAverage",
        }
    }
}
impl<'de> Deserialize<'de> for SubstanceWeightType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SubstanceWeightType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SupplyDeliveryStatus`. Status of the supply delivery.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SupplyDeliveryStatus {
    /** # abandoned

Abandoned. Delivery was not completed. */
    Abandoned,
    /** # completed

Delivered. Supply has been delivered ("completed"). */
    Completed,
    /** # entered-in-error

Entered In Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it. (If real-world activity has occurred, the status should be "abandoned" rather than "entered-in-error".). */
    EnteredInError,
    /** # in-progress

In Progress. Supply has been requested, but not delivered. */
    InProgress,
}
impl ::core::str::FromStr for SupplyDeliveryStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abandoned" => Ok(Self::Abandoned),
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyDeliveryStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abandoned => "abandoned",
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
        }
    }
}
impl<'de> Deserialize<'de> for SupplyDeliveryStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyDeliveryStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SupplyItemType`. This value sets refers to a specific supply item.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SupplyItemType {
    /** # device

Device. What is supplied (or requested) is a device. */
    Device,
    /** # medication

Medication. Supply is a kind of medication. */
    Medication,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SupplyItemType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "device" => Ok(Self::Device),
            "medication" => Ok(Self::Medication),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SupplyItemType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Device => "device",
            Self::Medication => "medication",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for SupplyItemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SupplyRequestReason`. The reason why the supply item was requested.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SupplyRequestReason {
    /** # patient-care

Patient Care. The supply has been requested for use in direct patient care. */
    PatientCare,
    /** # ward-stock

Ward Stock. The supply has been requested for creating or replenishing ward stock. */
    WardStock,
}
impl ::core::str::FromStr for SupplyRequestReason {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "patient-care" => Ok(Self::PatientCare),
            "ward-stock" => Ok(Self::WardStock),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyRequestReason {
    fn as_ref(&self) -> &str {
        match self {
            Self::PatientCare => "patient-care",
            Self::WardStock => "ward-stock",
        }
    }
}
impl<'de> Deserialize<'de> for SupplyRequestReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyRequestReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SupplyRequestStatus`. Status of the supply request.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SupplyRequestStatus {
    /** # active

Active. The request is ready to be acted upon. */
    Active,
    /** # cancelled

Cancelled. The authorization/request to act has been terminated prior to the full completion of the intended actions.  No further activity should occur. */
    Cancelled,
    /** # completed

Completed. Activity against the request has been sufficiently completed to the satisfaction of the requester. */
    Completed,
    /** # draft

Draft. The request has been created but is not yet complete or ready for action. */
    Draft,
    /** # entered-in-error

Entered in Error. This electronic record should never have existed, though it is possible that real-world decisions were based on it.  (If real-world activity has occurred, the status should be "cancelled" rather than "entered-in-error".). */
    EnteredInError,
    /** # suspended

Suspended. The authorization/request to act has been temporarily withdrawn but is expected to resume in the future. */
    Suspended,
    /** # unknown

Unknown. The authoring/source system does not know which of the status values currently applies for this observation. Note: This concept is not to be used for "other" - one of the listed statuses is presumed to apply, but the authoring/source system does not know which. */
    Unknown,
}
impl ::core::str::FromStr for SupplyRequestStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "suspended" => Ok(Self::Suspended),
            "unknown" => Ok(Self::Unknown),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SupplyRequestStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Suspended => "suspended",
            Self::Unknown => "unknown",
        }
    }
}
impl<'de> Deserialize<'de> for SupplyRequestStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyRequestStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SupplyType`. This value sets refers to a Category of supply.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SupplyType {
    /** # central

Central Supply. Supply is stored and requested from central supply. */
    Central,
    /** # nonstock

Non-Stock. Supply is not onsite and must be requested from an outside vendor using a non-stock requisition. */
    Nonstock,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SupplyType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "central" => Ok(Self::Central),
            "nonstock" => Ok(Self::Nonstock),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SupplyType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Central => "central",
            Self::Nonstock => "nonstock",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for SupplyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SupplyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SurfaceCodes`. This value set includes a smattering of FDI tooth surface codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SurfaceCodes {
    /** # B

Buccal. The surface of a posterior tooth facing the cheeks. */
    B,
    /** # D

Distal. The surface of a tooth that faces away from the midline of the face. */
    D,
    /** # DI

Distoincisal. The Distoincisal surfaces of a tooth. */
    Di,
    /** # DO

Distoclusal. The Distoclusal surfaces of a tooth. */
    Do,
    /** # I

Incisal. The biting edge of anterior teeth. */
    I,
    /** # L

Lingual. The surface of a tooth facing the tongue. */
    L,
    /** # M

Mesial. The surface of a tooth that is closest to the midline (middle) of the face. */
    M,
    /** # MO

Mesioclusal. The Mesioclusal surfaces of a tooth. */
    Mo,
    /** # MOD

Mesioclusodistal. The Mesioclusodistal surfaces of a tooth. */
    Mod,
    /** # O

Occlusal. The chewing surface of posterior teeth. */
    O,
    /** # V

Ventral. The surface of a tooth facing the lips. */
    V,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for SurfaceCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "B" => Ok(Self::B),
            "D" => Ok(Self::D),
            "DI" => Ok(Self::Di),
            "DO" => Ok(Self::Do),
            "I" => Ok(Self::I),
            "L" => Ok(Self::L),
            "M" => Ok(Self::M),
            "MO" => Ok(Self::Mo),
            "MOD" => Ok(Self::Mod),
            "O" => Ok(Self::O),
            "V" => Ok(Self::V),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for SurfaceCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::B => "B",
            Self::D => "D",
            Self::Di => "DI",
            Self::Do => "DO",
            Self::I => "I",
            Self::L => "L",
            Self::M => "M",
            Self::Mo => "MO",
            Self::Mod => "MOD",
            Self::O => "O",
            Self::V => "V",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for SurfaceCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SurfaceCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `SynthesisType`. Types of combining results from a body of evidence (eg. summary data meta-analysis).

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum SynthesisType {
    /** # IPD-MA

individual patient data meta-analysis. A meta-analysis of the individual participant data from individual studies or data sets. */
    IpdMa,
    /** # NotApplicable

not applicable. Not applicable because the evidence is not from a synthesis but from a single study. Used fo explicitly state that it's not a synthesis. */
    NotApplicable,
    /** # classification

classifcation of results. An approach describing a body of evidence by categorically classifying individual studies (eg 3 studies showed beneft and 2 studied found no effect). */
    Classification,
    /** # combined-NMA

combined direct plus indirect network meta-analysis. An composite meta-analysis derived from direct comparisons and indirect comparisons in a network meta-analysis. */
    CombinedNMA,
    /** # indirect-NMA

indirect network meta-analysis. An indirect meta-analysis derived from 2 or more direct comparisons in a network meta-analysis. */
    IndirectNMA,
    /** # range

range of results. A range of results across a body of evidence. */
    Range,
    /** # std-MA

summary data meta-analysis. A meta-analysis of the summary data of estimates from individual studies or data sets. */
    StdMA,
}
impl ::core::str::FromStr for SynthesisType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "IPD-MA" => Ok(Self::IpdMa),
            "NotApplicable" => Ok(Self::NotApplicable),
            "classification" => Ok(Self::Classification),
            "combined-NMA" => Ok(Self::CombinedNMA),
            "indirect-NMA" => Ok(Self::IndirectNMA),
            "range" => Ok(Self::Range),
            "std-MA" => Ok(Self::StdMA),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for SynthesisType {
    fn as_ref(&self) -> &str {
        match self {
            Self::IpdMa => "IPD-MA",
            Self::NotApplicable => "NotApplicable",
            Self::Classification => "classification",
            Self::CombinedNMA => "combined-NMA",
            Self::IndirectNMA => "indirect-NMA",
            Self::Range => "range",
            Self::StdMA => "std-MA",
        }
    }
}
impl<'de> Deserialize<'de> for SynthesisType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for SynthesisType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TargetSpecies`. A species for which a medicinal product is intended.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TargetSpecies {
    /** # 100000108874

Dove. */
    N100000108874,
    /** # 100000108875

Quail. */
    N100000108875,
    /** # 100000108876

Snipe. */
    N100000108876,
    /** # 100000108877

Sparrow. */
    N100000108877,
    /** # 100000108878

Starling. */
    N100000108878,
    /** # 100000108879

Swan. */
    N100000108879,
    /** # 100000108880

Turkey hen. */
    N100000108880,
    /** # 100000108881

Turkey cock. */
    N100000108881,
    /** # 100000108882

Turkeys. */
    N100000108882,
    /** # 100000108883

Turkey for reproduction. */
    N100000108883,
    /** # 100000108884

Poult. */
    N100000108884,
    /** # 100000108885

Turtle dove. */
    N100000108885,
    /** # 100000108886

Bison. */
    N100000108886,
    /** # 100000108887

Buffalo. */
    N100000108887,
    /** # 100000108888

Cows. */
    N100000108888,
    /** # 100000108889

Cow for reproduction. */
    N100000108889,
    /** # 100000108890

Bull for reproduction. */
    N100000108890,
    /** # 100000108891

Ox. */
    N100000108891,
    /** # 100000108892

Bullock. */
    N100000108892,
    /** # 100000108893

Cattle. */
    N100000108893,
    /** # 100000108894

Beef cattle. */
    N100000108894,
    /** # 100000108895

Dairy cattle. */
    N100000108895,
    /** # 100000108896

Dry cow. */
    N100000108896,
    /** # 100000108897

Bull. */
    N100000108897,
    /** # 100000108898

Lactating cow. */
    N100000108898,
    /** # 100000108899

All other food producing species. */
    N100000108899,
    /** # 100000108900

All non-food producing species. */
    N100000108900,
    /** # 100000108901

All species  . */
    N100000108901,
    /** # 100000108902

Carnivores. */
    N100000108902,
    /** # 100000108903

Domestic animals. */
    N100000108903,
    /** # 100000108904

Fur animals. */
    N100000108904,
    /** # 100000108905

Game animals. */
    N100000108905,
    /** # 100000108906

Laboratory animals. */
    N100000108906,
    /** # 100000108907

Major species. */
    N100000108907,
    /** # 100000108908

Minor species. */
    N100000108908,
    /** # 100000108909

Ruminant. */
    N100000108909,
    /** # 100000108910

Ruminant and porcine. */
    N100000108910,
    /** # 100000108911

Small animals. */
    N100000108911,
    /** # 100000108912

Crocodile. */
    N100000108912,
    /** # 100000108913

Frog. */
    N100000108913,
    /** # 100000108914

Iguana. */
    N100000108914,
    /** # 100000108915

Lizard. */
    N100000108915,
    /** # 100000108916

Amphibians. */
    N100000108916,
    /** # 100000108917

Reptiles. */
    N100000108917,
    /** # 100000108918

Reptiles for production. */
    N100000108918,
    /** # 100000108919

Snake. */
    N100000108919,
    /** # 100000108920

Tortoise. */
    N100000108920,
    /** # 100000108921

Turtle. */
    N100000108921,
    /** # 100000108922

Honey bees. */
    N100000108922,
    /** # 100000108923

Crustacean. */
    N100000108923,
    /** # 100000108924

Spider. */
    N100000108924,
    /** # 100000108925

Indian hen. */
    N100000108925,
    /** # 100000108926

African Goshawk. */
    N100000108926,
    /** # 100000108927

Black Kite. */
    N100000108927,
    /** # 100000108928

Budgerigar. */
    N100000108928,
    /** # 100000108929

Bustard. */
    N100000108929,
    /** # 100000108930

Buzzard. */
    N100000108930,
    /** # 100000108931

Hen. */
    N100000108931,
    /** # 100000108932

Layer hen. */
    N100000108932,
    /** # 100000108933

Cock. */
    N100000108933,
    /** # 100000108934

Broiler. */
    N100000108934,
    /** # 100000108935

Chickens. */
    N100000108935,
    /** # 100000108936

Chicken embryonated eggs. */
    N100000108936,
    /** # 100000108937

Chicken for reproduction. */
    N100000108937,
    /** # 100000108938

Replacement chick. */
    N100000108938,
    /** # 100000108939

Chick. */
    N100000108939,
    /** # 100000108940

Pullet. */
    N100000108940,
    /** # 100000108941

Cockatiel. */
    N100000108941,
    /** # 100000108942

Cockatoo. */
    N100000108942,
    /** # 100000108943

Common canary. */
    N100000108943,
    /** # 100000108944

Crow. */
    N100000108944,
    /** # 100000108945

Duck. */
    N100000108945,
    /** # 100000108946

Duck broiler. */
    N100000108946,
    /** # 100000108947

Duckling. */
    N100000108947,
    /** # 100000108948

Eagle. */
    N100000108948,
    /** # 100000108949

Emu. */
    N100000108949,
    /** # 100000108950

Goose. */
    N100000108950,
    /** # 100000108951

Guinea fowl. */
    N100000108951,
    /** # 100000108952

Kestrel. */
    N100000108952,
    /** # 100000108953

Kite. */
    N100000108953,
    /** # 100000108954

Macaw. */
    N100000108954,
    /** # 100000108955

Ostrich. */
    N100000108955,
    /** # 100000108956

Birds. */
    N100000108956,
    /** # 100000108957

Fowls. */
    N100000108957,
    /** # 100000108958

Finch. */
    N100000108958,
    /** # 100000108959

Galliformes. */
    N100000108959,
    /** # 100000108960

Game birds. */
    N100000108960,
    /** # 100000108961

Pekin duck. */
    N100000108961,
    /** # 100000108962

Ornamental birds. */
    N100000108962,
    /** # 100000108963

Poultry. */
    N100000108963,
    /** # 100000108964

Owl. */
    N100000108964,
    /** # 100000108965

Parakeet. */
    N100000108965,
    /** # 100000108966

Parrot. */
    N100000108966,
    /** # 100000108967

Partridge. */
    N100000108967,
    /** # 100000108968

Peregrine Falcon. */
    N100000108968,
    /** # 100000108969

Pheasants. */
    N100000108969,
    /** # 100000108970

Carrier pigeon. */
    N100000108970,
    /** # 100000108971

Newborn calves. */
    N100000108971,
    /** # 100000108972

Pregnant cow. */
    N100000108972,
    /** # 100000108973

Pregnant heifer. */
    N100000108973,
    /** # 100000108974

Pre-ruminant cattle. */
    N100000108974,
    /** # 100000108975

Ruminant cattle. */
    N100000108975,
    /** # 100000108976

Wild cattle. */
    N100000108976,
    /** # 100000108977

Calf. */
    N100000108977,
    /** # 100000108978

Heifers. */
    N100000108978,
    /** # 100000108979

Other Bovids. */
    N100000108979,
    /** # 100000108980

Alpaca. */
    N100000108980,
    /** # 100000108981

Camel. */
    N100000108981,
    /** # 100000108982

Llama. */
    N100000108982,
    /** # 100000108983

Other Camelids. */
    N100000108983,
    /** # 100000108984

Bitch. */
    N100000108984,
    /** # 100000108985

Bitch for reproduction. */
    N100000108985,
    /** # 100000108986

Adult male dog. */
    N100000108986,
    /** # 100000108987

Adult male dog for reproduction. */
    N100000108987,
    /** # 100000108988

Dogs. */
    N100000108988,
    /** # 100000108989

Lactating bitch. */
    N100000108989,
    /** # 100000108990

Large dog. */
    N100000108990,
    /** # 100000108991

Medium dog. */
    N100000108991,
    /** # 100000108992

Pregnant bitch. */
    N100000108992,
    /** # 100000108993

Small dog. */
    N100000108993,
    /** # 100000108994

Very large dog. */
    N100000108994,
    /** # 100000108995

Very small dog. */
    N100000108995,
    /** # 100000108996

Puppy. */
    N100000108996,
    /** # 100000108997

Foxes. */
    N100000108997,
    /** # 100000108998

Jackal. */
    N100000108998,
    /** # 100000108999

Other Canids. */
    N100000108999,
    /** # 100000109000

Raccoon dogs. */
    N100000109000,
    /** # 100000109001

Wolf. */
    N100000109001,
    /** # 100000109002

Chamois. */
    N100000109002,
    /** # 100000109003

Other Caprines. */
    N100000109003,
    /** # 100000109004

Adult female goat. */
    N100000109004,
    /** # 100000109005

Adult male goat. */
    N100000109005,
    /** # 100000109006

Dry adult female goat. */
    N100000109006,
    /** # 100000109007

Goats. */
    N100000109007,
    /** # 100000109008

Lactating adult female goat. */
    N100000109008,
    /** # 100000109009

Pregnant adult female goat. */
    N100000109009,
    /** # 100000109010

Pre-ruminant goat. */
    N100000109010,
    /** # 100000109011

Ruminant goat. */
    N100000109011,
    /** # 100000109012

Wild goat. */
    N100000109012,
    /** # 100000109013

Kid. */
    N100000109013,
    /** # 100000109014

Other Ovids. */
    N100000109014,
    /** # 100000109015

Ewe. */
    N100000109015,
    /** # 100000109016

Ram. */
    N100000109016,
    /** # 100000109017

Dry ewe. */
    N100000109017,
    /** # 100000109018

Lactating ewe. */
    N100000109018,
    /** # 100000109019

Pregnant ewe. */
    N100000109019,
    /** # 100000109020

Pre-ruminant sheep. */
    N100000109020,
    /** # 100000109021

Ruminant sheep. */
    N100000109021,
    /** # 100000109022

Sheep. */
    N100000109022,
    /** # 100000109023

Sheep for meat production. */
    N100000109023,
    /** # 100000109024

Dairy sheep. */
    N100000109024,
    /** # 100000109025

Wild sheep. */
    N100000109025,
    /** # 100000109026

Lamb. */
    N100000109026,
    /** # 100000109027

Elk. */
    N100000109027,
    /** # 100000109028

Fallow deer. */
    N100000109028,
    /** # 100000109029

Moose. */
    N100000109029,
    /** # 100000109030

Antelope. */
    N100000109030,
    /** # 100000109031

Cervid. */
    N100000109031,
    /** # 100000109032

Deer. */
    N100000109032,
    /** # 100000109033

Other Deer. */
    N100000109033,
    /** # 100000109034

Red deer. */
    N100000109034,
    /** # 100000109035

Reindeer. */
    N100000109035,
    /** # 100000109036

Roe deer. */
    N100000109036,
    /** # 100000109037

Donkey. */
    N100000109037,
    /** # 100000109038

Mare. */
    N100000109038,
    /** # 100000109039

Gelding. */
    N100000109039,
    /** # 100000109040

Horses. */
    N100000109040,
    /** # 100000109041

Stallion. */
    N100000109041,
    /** # 100000109042

Pony. */
    N100000109042,
    /** # 100000109043

Pregnant mare. */
    N100000109043,
    /** # 100000109044

Non food-producing horse. */
    N100000109044,
    /** # 100000109045

Suckling colt. */
    N100000109045,
    /** # 100000109046

Colt. */
    N100000109046,
    /** # 100000109047

Mule. */
    N100000109047,
    /** # 100000109048

Equid. */
    N100000109048,
    /** # 100000109049

Female equid. */
    N100000109049,
    /** # 100000109050

Other Equids. */
    N100000109050,
    /** # 100000109051

Zebra. */
    N100000109051,
    /** # 100000109052

Bobcat. */
    N100000109052,
    /** # 100000109053

Adult female cat. */
    N100000109053,
    /** # 100000109054

Adult female cat for reproduction. */
    N100000109054,
    /** # 100000109055

Adult male cat. */
    N100000109055,
    /** # 100000109056

Cats. */
    N100000109056,
    /** # 100000109057

Lactating cat. */
    N100000109057,
    /** # 100000109058

Large cat. */
    N100000109058,
    /** # 100000109059

Medium cat. */
    N100000109059,
    /** # 100000109060

Pregnant cat. */
    N100000109060,
    /** # 100000109061

Small cat. */
    N100000109061,
    /** # 100000109062

Kitten. */
    N100000109062,
    /** # 100000109063

Cougar. */
    N100000109063,
    /** # 100000109064

Jaguar. */
    N100000109064,
    /** # 100000109065

Leopard. */
    N100000109065,
    /** # 100000109066

Lion. */
    N100000109066,
    /** # 100000109067

Lynx. */
    N100000109067,
    /** # 100000109068

Other Felids. */
    N100000109068,
    /** # 100000109069

Tiger. */
    N100000109069,
    /** # 100000109070

Tsushima wild cat. */
    N100000109070,
    /** # 100000109071

Other Leporids. */
    N100000109071,
    /** # 100000109072

Hare. */
    N100000109072,
    /** # 100000109073

Female rabbit for reproduction. */
    N100000109073,
}
impl ::core::str::FromStr for TargetSpecies {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "100000108874" => Ok(Self::N100000108874),
            "100000108875" => Ok(Self::N100000108875),
            "100000108876" => Ok(Self::N100000108876),
            "100000108877" => Ok(Self::N100000108877),
            "100000108878" => Ok(Self::N100000108878),
            "100000108879" => Ok(Self::N100000108879),
            "100000108880" => Ok(Self::N100000108880),
            "100000108881" => Ok(Self::N100000108881),
            "100000108882" => Ok(Self::N100000108882),
            "100000108883" => Ok(Self::N100000108883),
            "100000108884" => Ok(Self::N100000108884),
            "100000108885" => Ok(Self::N100000108885),
            "100000108886" => Ok(Self::N100000108886),
            "100000108887" => Ok(Self::N100000108887),
            "100000108888" => Ok(Self::N100000108888),
            "100000108889" => Ok(Self::N100000108889),
            "100000108890" => Ok(Self::N100000108890),
            "100000108891" => Ok(Self::N100000108891),
            "100000108892" => Ok(Self::N100000108892),
            "100000108893" => Ok(Self::N100000108893),
            "100000108894" => Ok(Self::N100000108894),
            "100000108895" => Ok(Self::N100000108895),
            "100000108896" => Ok(Self::N100000108896),
            "100000108897" => Ok(Self::N100000108897),
            "100000108898" => Ok(Self::N100000108898),
            "100000108899" => Ok(Self::N100000108899),
            "100000108900" => Ok(Self::N100000108900),
            "100000108901" => Ok(Self::N100000108901),
            "100000108902" => Ok(Self::N100000108902),
            "100000108903" => Ok(Self::N100000108903),
            "100000108904" => Ok(Self::N100000108904),
            "100000108905" => Ok(Self::N100000108905),
            "100000108906" => Ok(Self::N100000108906),
            "100000108907" => Ok(Self::N100000108907),
            "100000108908" => Ok(Self::N100000108908),
            "100000108909" => Ok(Self::N100000108909),
            "100000108910" => Ok(Self::N100000108910),
            "100000108911" => Ok(Self::N100000108911),
            "100000108912" => Ok(Self::N100000108912),
            "100000108913" => Ok(Self::N100000108913),
            "100000108914" => Ok(Self::N100000108914),
            "100000108915" => Ok(Self::N100000108915),
            "100000108916" => Ok(Self::N100000108916),
            "100000108917" => Ok(Self::N100000108917),
            "100000108918" => Ok(Self::N100000108918),
            "100000108919" => Ok(Self::N100000108919),
            "100000108920" => Ok(Self::N100000108920),
            "100000108921" => Ok(Self::N100000108921),
            "100000108922" => Ok(Self::N100000108922),
            "100000108923" => Ok(Self::N100000108923),
            "100000108924" => Ok(Self::N100000108924),
            "100000108925" => Ok(Self::N100000108925),
            "100000108926" => Ok(Self::N100000108926),
            "100000108927" => Ok(Self::N100000108927),
            "100000108928" => Ok(Self::N100000108928),
            "100000108929" => Ok(Self::N100000108929),
            "100000108930" => Ok(Self::N100000108930),
            "100000108931" => Ok(Self::N100000108931),
            "100000108932" => Ok(Self::N100000108932),
            "100000108933" => Ok(Self::N100000108933),
            "100000108934" => Ok(Self::N100000108934),
            "100000108935" => Ok(Self::N100000108935),
            "100000108936" => Ok(Self::N100000108936),
            "100000108937" => Ok(Self::N100000108937),
            "100000108938" => Ok(Self::N100000108938),
            "100000108939" => Ok(Self::N100000108939),
            "100000108940" => Ok(Self::N100000108940),
            "100000108941" => Ok(Self::N100000108941),
            "100000108942" => Ok(Self::N100000108942),
            "100000108943" => Ok(Self::N100000108943),
            "100000108944" => Ok(Self::N100000108944),
            "100000108945" => Ok(Self::N100000108945),
            "100000108946" => Ok(Self::N100000108946),
            "100000108947" => Ok(Self::N100000108947),
            "100000108948" => Ok(Self::N100000108948),
            "100000108949" => Ok(Self::N100000108949),
            "100000108950" => Ok(Self::N100000108950),
            "100000108951" => Ok(Self::N100000108951),
            "100000108952" => Ok(Self::N100000108952),
            "100000108953" => Ok(Self::N100000108953),
            "100000108954" => Ok(Self::N100000108954),
            "100000108955" => Ok(Self::N100000108955),
            "100000108956" => Ok(Self::N100000108956),
            "100000108957" => Ok(Self::N100000108957),
            "100000108958" => Ok(Self::N100000108958),
            "100000108959" => Ok(Self::N100000108959),
            "100000108960" => Ok(Self::N100000108960),
            "100000108961" => Ok(Self::N100000108961),
            "100000108962" => Ok(Self::N100000108962),
            "100000108963" => Ok(Self::N100000108963),
            "100000108964" => Ok(Self::N100000108964),
            "100000108965" => Ok(Self::N100000108965),
            "100000108966" => Ok(Self::N100000108966),
            "100000108967" => Ok(Self::N100000108967),
            "100000108968" => Ok(Self::N100000108968),
            "100000108969" => Ok(Self::N100000108969),
            "100000108970" => Ok(Self::N100000108970),
            "100000108971" => Ok(Self::N100000108971),
            "100000108972" => Ok(Self::N100000108972),
            "100000108973" => Ok(Self::N100000108973),
            "100000108974" => Ok(Self::N100000108974),
            "100000108975" => Ok(Self::N100000108975),
            "100000108976" => Ok(Self::N100000108976),
            "100000108977" => Ok(Self::N100000108977),
            "100000108978" => Ok(Self::N100000108978),
            "100000108979" => Ok(Self::N100000108979),
            "100000108980" => Ok(Self::N100000108980),
            "100000108981" => Ok(Self::N100000108981),
            "100000108982" => Ok(Self::N100000108982),
            "100000108983" => Ok(Self::N100000108983),
            "100000108984" => Ok(Self::N100000108984),
            "100000108985" => Ok(Self::N100000108985),
            "100000108986" => Ok(Self::N100000108986),
            "100000108987" => Ok(Self::N100000108987),
            "100000108988" => Ok(Self::N100000108988),
            "100000108989" => Ok(Self::N100000108989),
            "100000108990" => Ok(Self::N100000108990),
            "100000108991" => Ok(Self::N100000108991),
            "100000108992" => Ok(Self::N100000108992),
            "100000108993" => Ok(Self::N100000108993),
            "100000108994" => Ok(Self::N100000108994),
            "100000108995" => Ok(Self::N100000108995),
            "100000108996" => Ok(Self::N100000108996),
            "100000108997" => Ok(Self::N100000108997),
            "100000108998" => Ok(Self::N100000108998),
            "100000108999" => Ok(Self::N100000108999),
            "100000109000" => Ok(Self::N100000109000),
            "100000109001" => Ok(Self::N100000109001),
            "100000109002" => Ok(Self::N100000109002),
            "100000109003" => Ok(Self::N100000109003),
            "100000109004" => Ok(Self::N100000109004),
            "100000109005" => Ok(Self::N100000109005),
            "100000109006" => Ok(Self::N100000109006),
            "100000109007" => Ok(Self::N100000109007),
            "100000109008" => Ok(Self::N100000109008),
            "100000109009" => Ok(Self::N100000109009),
            "100000109010" => Ok(Self::N100000109010),
            "100000109011" => Ok(Self::N100000109011),
            "100000109012" => Ok(Self::N100000109012),
            "100000109013" => Ok(Self::N100000109013),
            "100000109014" => Ok(Self::N100000109014),
            "100000109015" => Ok(Self::N100000109015),
            "100000109016" => Ok(Self::N100000109016),
            "100000109017" => Ok(Self::N100000109017),
            "100000109018" => Ok(Self::N100000109018),
            "100000109019" => Ok(Self::N100000109019),
            "100000109020" => Ok(Self::N100000109020),
            "100000109021" => Ok(Self::N100000109021),
            "100000109022" => Ok(Self::N100000109022),
            "100000109023" => Ok(Self::N100000109023),
            "100000109024" => Ok(Self::N100000109024),
            "100000109025" => Ok(Self::N100000109025),
            "100000109026" => Ok(Self::N100000109026),
            "100000109027" => Ok(Self::N100000109027),
            "100000109028" => Ok(Self::N100000109028),
            "100000109029" => Ok(Self::N100000109029),
            "100000109030" => Ok(Self::N100000109030),
            "100000109031" => Ok(Self::N100000109031),
            "100000109032" => Ok(Self::N100000109032),
            "100000109033" => Ok(Self::N100000109033),
            "100000109034" => Ok(Self::N100000109034),
            "100000109035" => Ok(Self::N100000109035),
            "100000109036" => Ok(Self::N100000109036),
            "100000109037" => Ok(Self::N100000109037),
            "100000109038" => Ok(Self::N100000109038),
            "100000109039" => Ok(Self::N100000109039),
            "100000109040" => Ok(Self::N100000109040),
            "100000109041" => Ok(Self::N100000109041),
            "100000109042" => Ok(Self::N100000109042),
            "100000109043" => Ok(Self::N100000109043),
            "100000109044" => Ok(Self::N100000109044),
            "100000109045" => Ok(Self::N100000109045),
            "100000109046" => Ok(Self::N100000109046),
            "100000109047" => Ok(Self::N100000109047),
            "100000109048" => Ok(Self::N100000109048),
            "100000109049" => Ok(Self::N100000109049),
            "100000109050" => Ok(Self::N100000109050),
            "100000109051" => Ok(Self::N100000109051),
            "100000109052" => Ok(Self::N100000109052),
            "100000109053" => Ok(Self::N100000109053),
            "100000109054" => Ok(Self::N100000109054),
            "100000109055" => Ok(Self::N100000109055),
            "100000109056" => Ok(Self::N100000109056),
            "100000109057" => Ok(Self::N100000109057),
            "100000109058" => Ok(Self::N100000109058),
            "100000109059" => Ok(Self::N100000109059),
            "100000109060" => Ok(Self::N100000109060),
            "100000109061" => Ok(Self::N100000109061),
            "100000109062" => Ok(Self::N100000109062),
            "100000109063" => Ok(Self::N100000109063),
            "100000109064" => Ok(Self::N100000109064),
            "100000109065" => Ok(Self::N100000109065),
            "100000109066" => Ok(Self::N100000109066),
            "100000109067" => Ok(Self::N100000109067),
            "100000109068" => Ok(Self::N100000109068),
            "100000109069" => Ok(Self::N100000109069),
            "100000109070" => Ok(Self::N100000109070),
            "100000109071" => Ok(Self::N100000109071),
            "100000109072" => Ok(Self::N100000109072),
            "100000109073" => Ok(Self::N100000109073),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TargetSpecies {
    fn as_ref(&self) -> &str {
        match self {
            Self::N100000108874 => "100000108874",
            Self::N100000108875 => "100000108875",
            Self::N100000108876 => "100000108876",
            Self::N100000108877 => "100000108877",
            Self::N100000108878 => "100000108878",
            Self::N100000108879 => "100000108879",
            Self::N100000108880 => "100000108880",
            Self::N100000108881 => "100000108881",
            Self::N100000108882 => "100000108882",
            Self::N100000108883 => "100000108883",
            Self::N100000108884 => "100000108884",
            Self::N100000108885 => "100000108885",
            Self::N100000108886 => "100000108886",
            Self::N100000108887 => "100000108887",
            Self::N100000108888 => "100000108888",
            Self::N100000108889 => "100000108889",
            Self::N100000108890 => "100000108890",
            Self::N100000108891 => "100000108891",
            Self::N100000108892 => "100000108892",
            Self::N100000108893 => "100000108893",
            Self::N100000108894 => "100000108894",
            Self::N100000108895 => "100000108895",
            Self::N100000108896 => "100000108896",
            Self::N100000108897 => "100000108897",
            Self::N100000108898 => "100000108898",
            Self::N100000108899 => "100000108899",
            Self::N100000108900 => "100000108900",
            Self::N100000108901 => "100000108901",
            Self::N100000108902 => "100000108902",
            Self::N100000108903 => "100000108903",
            Self::N100000108904 => "100000108904",
            Self::N100000108905 => "100000108905",
            Self::N100000108906 => "100000108906",
            Self::N100000108907 => "100000108907",
            Self::N100000108908 => "100000108908",
            Self::N100000108909 => "100000108909",
            Self::N100000108910 => "100000108910",
            Self::N100000108911 => "100000108911",
            Self::N100000108912 => "100000108912",
            Self::N100000108913 => "100000108913",
            Self::N100000108914 => "100000108914",
            Self::N100000108915 => "100000108915",
            Self::N100000108916 => "100000108916",
            Self::N100000108917 => "100000108917",
            Self::N100000108918 => "100000108918",
            Self::N100000108919 => "100000108919",
            Self::N100000108920 => "100000108920",
            Self::N100000108921 => "100000108921",
            Self::N100000108922 => "100000108922",
            Self::N100000108923 => "100000108923",
            Self::N100000108924 => "100000108924",
            Self::N100000108925 => "100000108925",
            Self::N100000108926 => "100000108926",
            Self::N100000108927 => "100000108927",
            Self::N100000108928 => "100000108928",
            Self::N100000108929 => "100000108929",
            Self::N100000108930 => "100000108930",
            Self::N100000108931 => "100000108931",
            Self::N100000108932 => "100000108932",
            Self::N100000108933 => "100000108933",
            Self::N100000108934 => "100000108934",
            Self::N100000108935 => "100000108935",
            Self::N100000108936 => "100000108936",
            Self::N100000108937 => "100000108937",
            Self::N100000108938 => "100000108938",
            Self::N100000108939 => "100000108939",
            Self::N100000108940 => "100000108940",
            Self::N100000108941 => "100000108941",
            Self::N100000108942 => "100000108942",
            Self::N100000108943 => "100000108943",
            Self::N100000108944 => "100000108944",
            Self::N100000108945 => "100000108945",
            Self::N100000108946 => "100000108946",
            Self::N100000108947 => "100000108947",
            Self::N100000108948 => "100000108948",
            Self::N100000108949 => "100000108949",
            Self::N100000108950 => "100000108950",
            Self::N100000108951 => "100000108951",
            Self::N100000108952 => "100000108952",
            Self::N100000108953 => "100000108953",
            Self::N100000108954 => "100000108954",
            Self::N100000108955 => "100000108955",
            Self::N100000108956 => "100000108956",
            Self::N100000108957 => "100000108957",
            Self::N100000108958 => "100000108958",
            Self::N100000108959 => "100000108959",
            Self::N100000108960 => "100000108960",
            Self::N100000108961 => "100000108961",
            Self::N100000108962 => "100000108962",
            Self::N100000108963 => "100000108963",
            Self::N100000108964 => "100000108964",
            Self::N100000108965 => "100000108965",
            Self::N100000108966 => "100000108966",
            Self::N100000108967 => "100000108967",
            Self::N100000108968 => "100000108968",
            Self::N100000108969 => "100000108969",
            Self::N100000108970 => "100000108970",
            Self::N100000108971 => "100000108971",
            Self::N100000108972 => "100000108972",
            Self::N100000108973 => "100000108973",
            Self::N100000108974 => "100000108974",
            Self::N100000108975 => "100000108975",
            Self::N100000108976 => "100000108976",
            Self::N100000108977 => "100000108977",
            Self::N100000108978 => "100000108978",
            Self::N100000108979 => "100000108979",
            Self::N100000108980 => "100000108980",
            Self::N100000108981 => "100000108981",
            Self::N100000108982 => "100000108982",
            Self::N100000108983 => "100000108983",
            Self::N100000108984 => "100000108984",
            Self::N100000108985 => "100000108985",
            Self::N100000108986 => "100000108986",
            Self::N100000108987 => "100000108987",
            Self::N100000108988 => "100000108988",
            Self::N100000108989 => "100000108989",
            Self::N100000108990 => "100000108990",
            Self::N100000108991 => "100000108991",
            Self::N100000108992 => "100000108992",
            Self::N100000108993 => "100000108993",
            Self::N100000108994 => "100000108994",
            Self::N100000108995 => "100000108995",
            Self::N100000108996 => "100000108996",
            Self::N100000108997 => "100000108997",
            Self::N100000108998 => "100000108998",
            Self::N100000108999 => "100000108999",
            Self::N100000109000 => "100000109000",
            Self::N100000109001 => "100000109001",
            Self::N100000109002 => "100000109002",
            Self::N100000109003 => "100000109003",
            Self::N100000109004 => "100000109004",
            Self::N100000109005 => "100000109005",
            Self::N100000109006 => "100000109006",
            Self::N100000109007 => "100000109007",
            Self::N100000109008 => "100000109008",
            Self::N100000109009 => "100000109009",
            Self::N100000109010 => "100000109010",
            Self::N100000109011 => "100000109011",
            Self::N100000109012 => "100000109012",
            Self::N100000109013 => "100000109013",
            Self::N100000109014 => "100000109014",
            Self::N100000109015 => "100000109015",
            Self::N100000109016 => "100000109016",
            Self::N100000109017 => "100000109017",
            Self::N100000109018 => "100000109018",
            Self::N100000109019 => "100000109019",
            Self::N100000109020 => "100000109020",
            Self::N100000109021 => "100000109021",
            Self::N100000109022 => "100000109022",
            Self::N100000109023 => "100000109023",
            Self::N100000109024 => "100000109024",
            Self::N100000109025 => "100000109025",
            Self::N100000109026 => "100000109026",
            Self::N100000109027 => "100000109027",
            Self::N100000109028 => "100000109028",
            Self::N100000109029 => "100000109029",
            Self::N100000109030 => "100000109030",
            Self::N100000109031 => "100000109031",
            Self::N100000109032 => "100000109032",
            Self::N100000109033 => "100000109033",
            Self::N100000109034 => "100000109034",
            Self::N100000109035 => "100000109035",
            Self::N100000109036 => "100000109036",
            Self::N100000109037 => "100000109037",
            Self::N100000109038 => "100000109038",
            Self::N100000109039 => "100000109039",
            Self::N100000109040 => "100000109040",
            Self::N100000109041 => "100000109041",
            Self::N100000109042 => "100000109042",
            Self::N100000109043 => "100000109043",
            Self::N100000109044 => "100000109044",
            Self::N100000109045 => "100000109045",
            Self::N100000109046 => "100000109046",
            Self::N100000109047 => "100000109047",
            Self::N100000109048 => "100000109048",
            Self::N100000109049 => "100000109049",
            Self::N100000109050 => "100000109050",
            Self::N100000109051 => "100000109051",
            Self::N100000109052 => "100000109052",
            Self::N100000109053 => "100000109053",
            Self::N100000109054 => "100000109054",
            Self::N100000109055 => "100000109055",
            Self::N100000109056 => "100000109056",
            Self::N100000109057 => "100000109057",
            Self::N100000109058 => "100000109058",
            Self::N100000109059 => "100000109059",
            Self::N100000109060 => "100000109060",
            Self::N100000109061 => "100000109061",
            Self::N100000109062 => "100000109062",
            Self::N100000109063 => "100000109063",
            Self::N100000109064 => "100000109064",
            Self::N100000109065 => "100000109065",
            Self::N100000109066 => "100000109066",
            Self::N100000109067 => "100000109067",
            Self::N100000109068 => "100000109068",
            Self::N100000109069 => "100000109069",
            Self::N100000109070 => "100000109070",
            Self::N100000109071 => "100000109071",
            Self::N100000109072 => "100000109072",
            Self::N100000109073 => "100000109073",
        }
    }
}
impl<'de> Deserialize<'de> for TargetSpecies {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TargetSpecies {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TaskCode`. Codes indicating the type of action that is expected to be performed

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TaskCode {
    /** # abort

Mark the focal resource as no longer active. Abort, cancel or withdraw the focal resource, as appropriate for the type of resource. */
    Abort,
    /** # approve

Activate/approve the focal resource. Take what actions are needed to transition the focus resource from 'draft' to 'active' or 'in-progress', as appropriate for the resource type.  This may involve additing additional content, approval, validation, etc. */
    Approve,
    /** # change

Change the focal resource. Update the focal resource of the owning system to reflect the content specified as the Task.focus */
    Change,
    /** # fulfill

Fulfill the focal request. Act to perform the actions defined in the focus request.  This might result in a 'more assertive' request (order for a plan or proposal, filler order for a placer order), but is intend to eventually result in events.  The degree of fulfillment requested might be limited by Task.restriction. */
    Fulfill,
    /** # replace

Replace the focal resource with the input resource. Replace the focal resource with the specified input resource */
    Replace,
    /** # resume

Re-activate the focal resource. Transition the focal resource from 'suspended' to 'active' or 'in-progress' as appropriate for the resource type. */
    Resume,
    /** # suspend

Suspend the focal resource. Transition the focal resource from 'active' or 'in-progress' to 'suspended' */
    Suspend,
}
impl ::core::str::FromStr for TaskCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "abort" => Ok(Self::Abort),
            "approve" => Ok(Self::Approve),
            "change" => Ok(Self::Change),
            "fulfill" => Ok(Self::Fulfill),
            "replace" => Ok(Self::Replace),
            "resume" => Ok(Self::Resume),
            "suspend" => Ok(Self::Suspend),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TaskCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Abort => "abort",
            Self::Approve => "approve",
            Self::Change => "change",
            Self::Fulfill => "fulfill",
            Self::Replace => "replace",
            Self::Resume => "resume",
            Self::Suspend => "suspend",
        }
    }
}
impl<'de> Deserialize<'de> for TaskCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TaskIntent`. Distinguishes whether the task is a proposal, plan or full order.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TaskIntent {
    /** # unknown

Unknown. The intent is not known.  When dealing with Task, it's not always known (or relevant) how the task was initiated - i.e. whether it was proposed, planned, ordered or just done spontaneously. */
    Unknown,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TaskIntent {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "unknown" => Ok(Self::Unknown),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TaskIntent {
    fn as_ref(&self) -> &str {
        match self {
            Self::Unknown => "unknown",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for TaskIntent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TaskStatus`. The current status of the task.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TaskStatus {
    /** # accepted

Accepted. The potential performer has agreed to execute the task but has not yet started work. */
    Accepted,
    /** # cancelled

Cancelled. The task was not completed. */
    Cancelled,
    /** # completed

Completed. The task has been completed. */
    Completed,
    /** # draft

Draft. The task is not yet ready to be acted upon. */
    Draft,
    /** # entered-in-error

Entered in Error. The task should never have existed and is retained only because of the possibility it may have used. */
    EnteredInError,
    /** # failed

Failed. The task was attempted but could not be completed due to some error. */
    Failed,
    /** # in-progress

In Progress. The task has been started but is not yet complete. */
    InProgress,
    /** # on-hold

On Hold. The task has been started but work has been paused. */
    OnHold,
    /** # ready

Ready. The task is ready to be performed, but no action has yet been taken.  Used in place of requested/received/accepted/rejected when request assignment and acceptance is a given. */
    Ready,
    /** # received

Received. A potential performer has claimed ownership of the task and is evaluating whether to perform it. */
    Received,
    /** # rejected

Rejected. The potential performer who claimed ownership of the task has decided not to execute it prior to performing any action. */
    Rejected,
    /** # requested

Requested. The task is ready to be acted upon and action is sought. */
    Requested,
}
impl ::core::str::FromStr for TaskStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "accepted" => Ok(Self::Accepted),
            "cancelled" => Ok(Self::Cancelled),
            "completed" => Ok(Self::Completed),
            "draft" => Ok(Self::Draft),
            "entered-in-error" => Ok(Self::EnteredInError),
            "failed" => Ok(Self::Failed),
            "in-progress" => Ok(Self::InProgress),
            "on-hold" => Ok(Self::OnHold),
            "ready" => Ok(Self::Ready),
            "received" => Ok(Self::Received),
            "rejected" => Ok(Self::Rejected),
            "requested" => Ok(Self::Requested),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TaskStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Accepted => "accepted",
            Self::Cancelled => "cancelled",
            Self::Completed => "completed",
            Self::Draft => "draft",
            Self::EnteredInError => "entered-in-error",
            Self::Failed => "failed",
            Self::InProgress => "in-progress",
            Self::OnHold => "on-hold",
            Self::Ready => "ready",
            Self::Received => "received",
            Self::Rejected => "rejected",
            Self::Requested => "requested",
        }
    }
}
impl<'de> Deserialize<'de> for TaskStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TaskStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TemplateStatusCodeLifeCycle`. Life cycle of the Status Code of a Template Design (Version)

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TemplateStatusCodeLifeCycle {
    /** # active

active. Design has been deemed fit for the intended purpose and is published by the governance      group. */
    Active,
    /** # cancelled

Cancelled. A drafted design is determined to be erroneous or not fit for intended purpose and is      discontinued before ever being published in an active state. */
    Cancelled,
    /** # draft

Draft. Design is under development (nascent). */
    Draft,
    /** # pending

Under pre-publication review. Design is completed and is being reviewed. */
    Pending,
    /** # rejected

Rejected. A previously drafted design is determined to be erroneous or not fit for intended purpose      and is discontinued before ever being published for consideration in a pending state. */
    Rejected,
    /** # retired

retired. A previously active design is discontinued from use. It should no longer be used for future      designs, but for historical purposes may be used to process data previously recorded using      this design. A newer design may or may not exist. The design is published in the retired      state. */
    Retired,
    /** # review

In Review. Design is active, but is under review. The review may result in a change to the design.      The change may necessitate a new version to be created. This in turn may result in the      prior version of the template to be retired. Alternatively, the review may result in a      change to the design that does not require a new version to be created, or it may result      in no change to the design at all. */
    Review,
    /** # terminated

Terminated. A design is determined to be erroneous or not fit for the intended purpose and should      no longer be used, even for historical purposes. No new designs can be developed for this      template. The associated template no longer needs to be published, but if published, is      shown in the terminated state. */
    Terminated,
}
impl ::core::str::FromStr for TemplateStatusCodeLifeCycle {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "active" => Ok(Self::Active),
            "cancelled" => Ok(Self::Cancelled),
            "draft" => Ok(Self::Draft),
            "pending" => Ok(Self::Pending),
            "rejected" => Ok(Self::Rejected),
            "retired" => Ok(Self::Retired),
            "review" => Ok(Self::Review),
            "terminated" => Ok(Self::Terminated),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TemplateStatusCodeLifeCycle {
    fn as_ref(&self) -> &str {
        match self {
            Self::Active => "active",
            Self::Cancelled => "cancelled",
            Self::Draft => "draft",
            Self::Pending => "pending",
            Self::Rejected => "rejected",
            Self::Retired => "retired",
            Self::Review => "review",
            Self::Terminated => "terminated",
        }
    }
}
impl<'de> Deserialize<'de> for TemplateStatusCodeLifeCycle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TemplateStatusCodeLifeCycle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TestReportActionResult`. The results of executing an action.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestReportActionResult {
    /** # error

Error. The action encountered a fatal error and the engine was unable to process. */
    Error,
    /** # fail

Fail. The action failed. */
    Fail,
    /** # pass

Pass. The action was successful. */
    Pass,
    /** # skip

Skip. The action was skipped. */
    Skip,
    /** # warning

Warning. The action passed but with warnings. */
    Warning,
}
impl ::core::str::FromStr for TestReportActionResult {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "error" => Ok(Self::Error),
            "fail" => Ok(Self::Fail),
            "pass" => Ok(Self::Pass),
            "skip" => Ok(Self::Skip),
            "warning" => Ok(Self::Warning),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportActionResult {
    fn as_ref(&self) -> &str {
        match self {
            Self::Error => "error",
            Self::Fail => "fail",
            Self::Pass => "pass",
            Self::Skip => "skip",
            Self::Warning => "warning",
        }
    }
}
impl<'de> Deserialize<'de> for TestReportActionResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportActionResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TestReportParticipantType`. The type of participant.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestReportParticipantType {
    /** # client

Client. A FHIR Client. */
    Client,
    /** # server

Server. A FHIR Server. */
    Server,
    /** # test-engine

Test Engine. The test execution engine. */
    TestEngine,
}
impl ::core::str::FromStr for TestReportParticipantType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "client" => Ok(Self::Client),
            "server" => Ok(Self::Server),
            "test-engine" => Ok(Self::TestEngine),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportParticipantType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Client => "client",
            Self::Server => "server",
            Self::TestEngine => "test-engine",
        }
    }
}
impl<'de> Deserialize<'de> for TestReportParticipantType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportParticipantType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TestReportResult`. The reported execution result.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestReportResult {
    /** # fail

Fail. One or more test operations failed one or more asserts. */
    Fail,
    /** # pass

Pass. All test operations successfully passed all asserts. */
    Pass,
    /** # pending

Pending. One or more test operations is pending execution completion. */
    Pending,
}
impl ::core::str::FromStr for TestReportResult {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "fail" => Ok(Self::Fail),
            "pass" => Ok(Self::Pass),
            "pending" => Ok(Self::Pending),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportResult {
    fn as_ref(&self) -> &str {
        match self {
            Self::Fail => "fail",
            Self::Pass => "pass",
            Self::Pending => "pending",
        }
    }
}
impl<'de> Deserialize<'de> for TestReportResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TestReportStatus`. The current status of the test report.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestReportStatus {
    /** # completed

Completed. All test operations have completed. */
    Completed,
    /** # entered-in-error

Entered In Error. This test report was entered or created in error. */
    EnteredInError,
    /** # in-progress

In Progress. A test operations is currently executing. */
    InProgress,
    /** # stopped

Stopped. The test script execution was manually stopped. */
    Stopped,
    /** # waiting

Waiting. A test operation is waiting for an external client request. */
    Waiting,
}
impl ::core::str::FromStr for TestReportStatus {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "completed" => Ok(Self::Completed),
            "entered-in-error" => Ok(Self::EnteredInError),
            "in-progress" => Ok(Self::InProgress),
            "stopped" => Ok(Self::Stopped),
            "waiting" => Ok(Self::Waiting),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestReportStatus {
    fn as_ref(&self) -> &str {
        match self {
            Self::Completed => "completed",
            Self::EnteredInError => "entered-in-error",
            Self::InProgress => "in-progress",
            Self::Stopped => "stopped",
            Self::Waiting => "waiting",
        }
    }
}
impl<'de> Deserialize<'de> for TestReportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestReportStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TestScriptOperationCodes`. This value set defines a set of codes that are used to indicate the supported operations of a testing engine or tool.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TestScriptOperationCodes {
    /** # apply

$apply. Realizes an ActivityDefinition in a specific context */
    Apply,
    /** # batch

Batch. Update, create or delete a set of resources as independent actions. */
    Batch,
    /** # capabilities

Capabilities. Get a capability statement for the system. */
    Capabilities,
    /** # closure

$closure. Closure Table Maintenance */
    Closure,
    /** # conforms

$conforms. Compare two systems CapabilityStatements */
    Conforms,
    /** # create

Create. Create a new resource with a server assigned id. */
    Create,
    /** # data-requirements

$data-requirements. Aggregates and returns the parameters and data requirements for a resource and all its dependencies as a single module definition */
    DataRequirements,
    /** # delete

Delete. Delete a resource. */
    Delete,
    /** # deleteCondMultiple

Conditional Delete Multiple. Conditionally delete one or more resources based on search parameters. */
    DeleteCondMultiple,
    /** # deleteCondSingle

Conditional Delete Single. Conditionally delete a single resource based on search parameters. */
    DeleteCondSingle,
    /** # document

$document. Generate a Document */
    Document,
    /** # evaluate

$evaluate. Request clinical decision support guidance based on a specific decision support module */
    Evaluate,
    /** # evaluate-measure

$evaluate-measure. Invoke an eMeasure and obtain the results */
    EvaluateMeasure,
    /** # everything

$everything. Return all the related information as described in the Encounter or Patient */
    Everything,
    /** # expand

$expand. Value Set Expansion */
    Expand,
    /** # find

$find. Find a functional list */
    Find,
    /** # find-matches

$find-matches. Finding Codes based on supplied properties */
    FindMatches,
    /** # graphql

$graphql. Invoke a GraphQL query */
    Graphql,
    /** # history

History. Retrieve the change history for a particular resource or resource type. */
    History,
    /** # implements

$implements. Test if a server implements a client's required operations */
    Implements,
    /** # lastn

$lastn. Last N Observations Query */
    Lastn,
    /** # lookup

$lookup. Concept Look Up and Decomposition */
    Lookup,
    /** # match

$match. Find patient matches using MPI based logic */
    Match,
    /** # meta

$meta. Access a list of profiles, tags, and security labels */
    Meta,
    /** # meta-add

$meta-add. Add profiles, tags, and security labels to a resource */
    MetaAdd,
    /** # meta-delete

$meta-delete. Delete profiles, tags, and security labels for a resource */
    MetaDelete,
    /** # patch

Patch. Patch an existing resource by its id. */
    Patch,
    /** # populate

$populate. Populate Questionnaire */
    Populate,
    /** # populatehtml

$populatehtml. Generate HTML for Questionnaire */
    Populatehtml,
    /** # populatelink

$populatelink. Generate a link to a Questionnaire completion webpage */
    Populatelink,
    /** # process-message

$process-message. Process a message according to the defined event */
    ProcessMessage,
    /** # questionnaire

$questionnaire. Build Questionnaire */
    Questionnaire,
    /** # read

Read. Read the current state of the resource. */
    Read,
    /** # search

Search. Search based on some filter criteria. */
    Search,
    /** # stats

$stats. Observation Statistics */
    Stats,
    /** # subset

$subset. Fetch a subset of the CapabilityStatement resource */
    Subset,
    /** # subsumes

$subsumes. CodeSystem Subsumption Testing */
    Subsumes,
    /** # transaction

Transaction. Update, create or delete a set of resources as a single transaction. */
    Transaction,
    /** # transform

$transform. Model Instance Transformation */
    Transform,
    /** # translate

$translate. Concept Translation */
    Translate,
    /** # update

Update. Update an existing resource by its id. */
    Update,
    /** # updateCreate

Create using Update. Update an existing resource by its id (or create it if it is new). */
    UpdateCreate,
    /** # validate

$validate. Validate a resource */
    Validate,
    /** # validate-code

$validate-code. ValueSet based Validation */
    ValidateCode,
    /** # vread

Version Read. Read the state of a specific version of the resource. */
    Vread,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TestScriptOperationCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "apply" => Ok(Self::Apply),
            "batch" => Ok(Self::Batch),
            "capabilities" => Ok(Self::Capabilities),
            "closure" => Ok(Self::Closure),
            "conforms" => Ok(Self::Conforms),
            "create" => Ok(Self::Create),
            "data-requirements" => Ok(Self::DataRequirements),
            "delete" => Ok(Self::Delete),
            "deleteCondMultiple" => Ok(Self::DeleteCondMultiple),
            "deleteCondSingle" => Ok(Self::DeleteCondSingle),
            "document" => Ok(Self::Document),
            "evaluate" => Ok(Self::Evaluate),
            "evaluate-measure" => Ok(Self::EvaluateMeasure),
            "everything" => Ok(Self::Everything),
            "expand" => Ok(Self::Expand),
            "find" => Ok(Self::Find),
            "find-matches" => Ok(Self::FindMatches),
            "graphql" => Ok(Self::Graphql),
            "history" => Ok(Self::History),
            "implements" => Ok(Self::Implements),
            "lastn" => Ok(Self::Lastn),
            "lookup" => Ok(Self::Lookup),
            "match" => Ok(Self::Match),
            "meta" => Ok(Self::Meta),
            "meta-add" => Ok(Self::MetaAdd),
            "meta-delete" => Ok(Self::MetaDelete),
            "patch" => Ok(Self::Patch),
            "populate" => Ok(Self::Populate),
            "populatehtml" => Ok(Self::Populatehtml),
            "populatelink" => Ok(Self::Populatelink),
            "process-message" => Ok(Self::ProcessMessage),
            "questionnaire" => Ok(Self::Questionnaire),
            "read" => Ok(Self::Read),
            "search" => Ok(Self::Search),
            "stats" => Ok(Self::Stats),
            "subset" => Ok(Self::Subset),
            "subsumes" => Ok(Self::Subsumes),
            "transaction" => Ok(Self::Transaction),
            "transform" => Ok(Self::Transform),
            "translate" => Ok(Self::Translate),
            "update" => Ok(Self::Update),
            "updateCreate" => Ok(Self::UpdateCreate),
            "validate" => Ok(Self::Validate),
            "validate-code" => Ok(Self::ValidateCode),
            "vread" => Ok(Self::Vread),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TestScriptOperationCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Apply => "apply",
            Self::Batch => "batch",
            Self::Capabilities => "capabilities",
            Self::Closure => "closure",
            Self::Conforms => "conforms",
            Self::Create => "create",
            Self::DataRequirements => "data-requirements",
            Self::Delete => "delete",
            Self::DeleteCondMultiple => "deleteCondMultiple",
            Self::DeleteCondSingle => "deleteCondSingle",
            Self::Document => "document",
            Self::Evaluate => "evaluate",
            Self::EvaluateMeasure => "evaluate-measure",
            Self::Everything => "everything",
            Self::Expand => "expand",
            Self::Find => "find",
            Self::FindMatches => "find-matches",
            Self::Graphql => "graphql",
            Self::History => "history",
            Self::Implements => "implements",
            Self::Lastn => "lastn",
            Self::Lookup => "lookup",
            Self::Match => "match",
            Self::Meta => "meta",
            Self::MetaAdd => "meta-add",
            Self::MetaDelete => "meta-delete",
            Self::Patch => "patch",
            Self::Populate => "populate",
            Self::Populatehtml => "populatehtml",
            Self::Populatelink => "populatelink",
            Self::ProcessMessage => "process-message",
            Self::Questionnaire => "questionnaire",
            Self::Read => "read",
            Self::Search => "search",
            Self::Stats => "stats",
            Self::Subset => "subset",
            Self::Subsumes => "subsumes",
            Self::Transaction => "transaction",
            Self::Transform => "transform",
            Self::Translate => "translate",
            Self::Update => "update",
            Self::UpdateCreate => "updateCreate",
            Self::Validate => "validate",
            Self::ValidateCode => "validate-code",
            Self::Vread => "vread",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for TestScriptOperationCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptOperationCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TestScriptProfileDestinationTypes`. This value set defines a set of codes that are used to indicate the profile type of a test system when acting as the destination within a TestScript.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TestScriptProfileDestinationTypes {
    /** # FHIR-SDC-FormManager

FHIR SDC FormManager. A FHIR server acting as a Structured Data Capture Form Manager. */
    FhirSdcFormManager,
    /** # FHIR-SDC-FormProcessor

FHIR SDC FormProcessor. A FHIR server acting as a Structured Data Capture Form Processor. */
    FhirSdcFormProcessor,
    /** # FHIR-SDC-FormReceiver

FHIR SDC FormReceiver. A FHIR server acting as a Structured Data Capture Form Receiver. */
    FhirSdcFormReceiver,
    /** # FHIR-Server

FHIR Server. General FHIR server used to respond to operations sent from a FHIR client. */
    FhirServer,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TestScriptProfileDestinationTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "FHIR-SDC-FormManager" => Ok(Self::FhirSdcFormManager),
            "FHIR-SDC-FormProcessor" => Ok(Self::FhirSdcFormProcessor),
            "FHIR-SDC-FormReceiver" => Ok(Self::FhirSdcFormReceiver),
            "FHIR-Server" => Ok(Self::FhirServer),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TestScriptProfileDestinationTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::FhirSdcFormManager => "FHIR-SDC-FormManager",
            Self::FhirSdcFormProcessor => "FHIR-SDC-FormProcessor",
            Self::FhirSdcFormReceiver => "FHIR-SDC-FormReceiver",
            Self::FhirServer => "FHIR-Server",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for TestScriptProfileDestinationTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptProfileDestinationTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TestScriptProfileOriginTypes`. This value set defines a set of codes that are used to indicate the profile type of a test system when acting as the origin within a TestScript.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TestScriptProfileOriginTypes {
    /** # FHIR-Client

FHIR Client. General FHIR client used to initiate operations against a FHIR server. */
    FhirClient,
    /** # FHIR-SDC-FormFiller

FHIR SDC FormFiller. A FHIR client acting as a Structured Data Capture Form Filler. */
    FhirSdcFormFiller,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for TestScriptProfileOriginTypes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "FHIR-Client" => Ok(Self::FhirClient),
            "FHIR-SDC-FormFiller" => Ok(Self::FhirSdcFormFiller),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for TestScriptProfileOriginTypes {
    fn as_ref(&self) -> &str {
        match self {
            Self::FhirClient => "FHIR-Client",
            Self::FhirSdcFormFiller => "FHIR-SDC-FormFiller",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for TestScriptProfileOriginTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptProfileOriginTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TestScriptRequestMethodCode`. The allowable request method or HTTP operation codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TestScriptRequestMethodCode {
    /** # delete

DELETE. HTTP DELETE operation. */
    Delete,
    /** # get

GET. HTTP GET operation. */
    Get,
    /** # head

HEAD. HTTP HEAD operation. */
    Head,
    /** # options

OPTIONS. HTTP OPTIONS operation. */
    Options,
    /** # patch

PATCH. HTTP PATCH operation. */
    Patch,
    /** # post

POST. HTTP POST operation. */
    Post,
    /** # put

PUT. HTTP PUT operation. */
    Put,
}
impl ::core::str::FromStr for TestScriptRequestMethodCode {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "delete" => Ok(Self::Delete),
            "get" => Ok(Self::Get),
            "head" => Ok(Self::Head),
            "options" => Ok(Self::Options),
            "patch" => Ok(Self::Patch),
            "post" => Ok(Self::Post),
            "put" => Ok(Self::Put),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TestScriptRequestMethodCode {
    fn as_ref(&self) -> &str {
        match self {
            Self::Delete => "delete",
            Self::Get => "get",
            Self::Head => "head",
            Self::Options => "options",
            Self::Patch => "patch",
            Self::Post => "post",
            Self::Put => "put",
        }
    }
}
impl<'de> Deserialize<'de> for TestScriptRequestMethodCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TestScriptRequestMethodCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TherapyRelationshipType`. Classification of relationship between a therapy and a contraindication or an indication.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TherapyRelationshipType {
    /** # contraindicated-except-with

Contraindicated unless the other therapy is given. Contraindicated unless the other therapy is given */
    ContraindicatedExceptWith,
    /** # contraindicated-only-with

Only contraindicated if the other therapy is given. Only contraindicated if the other therapy is given */
    ContraindicatedOnlyWith,
    /** # indicated-except-with

Indicated except when the other therapy is given. Indicated except when the other therapy is given */
    IndicatedExceptWith,
    /** # indicated-only-before

Indicated only if the other therapy is planned to be given afterwards (prep). Indicated only if the other therapy is planned to be given afterwards (prep) */
    IndicatedOnlyBefore,
    /** # indicated-only-with

Indicated only when the other therapy is given (co-occurrent). Indicated only when the other therapy is given (co-occurrent) */
    IndicatedOnlyWith,
    /** # replace-other-therapy

Indicated to replace the other therapy. Indicated to replace the other therapy */
    ReplaceOtherTherapy,
    /** # replace-other-therapy-contraindicated

Indicated to replace the other contraindicated therapy. Indicated to replace the other contraindicated therapy. */
    ReplaceOtherTherapyContraindicated,
    /** # replace-other-therapy-not-effective

Indicated to replace the other therapy not effective on patient. Indicated to replace the other therapy not effective on patient */
    ReplaceOtherTherapyNotEffective,
    /** # replace-other-therapy-not-tolerated

Indicated to replace the other therapy not well tolerated by patient. Indicated to replace the other therapy not well tolerated by patient */
    ReplaceOtherTherapyNotTolerated,
}
impl ::core::str::FromStr for TherapyRelationshipType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "contraindicated-except-with" => Ok(Self::ContraindicatedExceptWith),
            "contraindicated-only-with" => Ok(Self::ContraindicatedOnlyWith),
            "indicated-except-with" => Ok(Self::IndicatedExceptWith),
            "indicated-only-before" => Ok(Self::IndicatedOnlyBefore),
            "indicated-only-with" => Ok(Self::IndicatedOnlyWith),
            "replace-other-therapy" => Ok(Self::ReplaceOtherTherapy),
            "replace-other-therapy-contraindicated" => {
                Ok(Self::ReplaceOtherTherapyContraindicated)
            }
            "replace-other-therapy-not-effective" => {
                Ok(Self::ReplaceOtherTherapyNotEffective)
            }
            "replace-other-therapy-not-tolerated" => {
                Ok(Self::ReplaceOtherTherapyNotTolerated)
            }
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TherapyRelationshipType {
    fn as_ref(&self) -> &str {
        match self {
            Self::ContraindicatedExceptWith => "contraindicated-except-with",
            Self::ContraindicatedOnlyWith => "contraindicated-only-with",
            Self::IndicatedExceptWith => "indicated-except-with",
            Self::IndicatedOnlyBefore => "indicated-only-before",
            Self::IndicatedOnlyWith => "indicated-only-with",
            Self::ReplaceOtherTherapy => "replace-other-therapy",
            Self::ReplaceOtherTherapyContraindicated => {
                "replace-other-therapy-contraindicated"
            }
            Self::ReplaceOtherTherapyNotEffective => {
                "replace-other-therapy-not-effective"
            }
            Self::ReplaceOtherTherapyNotTolerated => {
                "replace-other-therapy-not-tolerated"
            }
        }
    }
}
impl<'de> Deserialize<'de> for TherapyRelationshipType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TherapyRelationshipType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TitleType`. Used to express the reason and specific aspect for the variant title, such as language and specific language.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TitleType {
    /** # acronym

Acronym. Abbreviation used as title */
    Acronym,
    /** # autotranslated

Different language derived from autotranslation. Machine translated form of title in a different language, language element codes the language into which it was translated by machine. */
    Autotranslated,
    /** # duplicate-uid

Different text for the same object with a different identifier. An alternative form of the title in two or more entries, e.g. in multiple medline entries */
    DuplicateUid,
    /** # earlier-title

Different text in an earlier version. Alternative form of title in an earlier version such as epub ahead of print. */
    EarlierTitle,
    /** # human-use

Human use. Human-friendly title */
    HumanUse,
    /** # language

Different language. Additional form of title in a different language. */
    Language,
    /** # machine-use

Machine use. Machine-friendly title */
    MachineUse,
    /** # official

Official title. The official or authoritative title. */
    Official,
    /** # plain-language

Plain language title. Title using language common to lay public discourse. */
    PlainLanguage,
    /** # primary

Primary title. Main title for common use. The primary title used for representation if multiple titles exist. */
    Primary,
    /** # scientific

Scientific title. Title using scientific terminology. */
    Scientific,
    /** # short-title

Short title. Brief title (e.g. 'running title' or title used in page headers) */
    ShortTitle,
    /** # subtitle

Subtitle. Subtitle or secondary title. */
    Subtitle,
}
impl ::core::str::FromStr for TitleType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "acronym" => Ok(Self::Acronym),
            "autotranslated" => Ok(Self::Autotranslated),
            "duplicate-uid" => Ok(Self::DuplicateUid),
            "earlier-title" => Ok(Self::EarlierTitle),
            "human-use" => Ok(Self::HumanUse),
            "language" => Ok(Self::Language),
            "machine-use" => Ok(Self::MachineUse),
            "official" => Ok(Self::Official),
            "plain-language" => Ok(Self::PlainLanguage),
            "primary" => Ok(Self::Primary),
            "scientific" => Ok(Self::Scientific),
            "short-title" => Ok(Self::ShortTitle),
            "subtitle" => Ok(Self::Subtitle),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TitleType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Acronym => "acronym",
            Self::Autotranslated => "autotranslated",
            Self::DuplicateUid => "duplicate-uid",
            Self::EarlierTitle => "earlier-title",
            Self::HumanUse => "human-use",
            Self::Language => "language",
            Self::MachineUse => "machine-use",
            Self::Official => "official",
            Self::PlainLanguage => "plain-language",
            Self::Primary => "primary",
            Self::Scientific => "scientific",
            Self::ShortTitle => "short-title",
            Self::Subtitle => "subtitle",
        }
    }
}
impl<'de> Deserialize<'de> for TitleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TitleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TriggerType`. The type of trigger.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TriggerType {
    /** # data-access-ended

Data Access Ended. The trigger occurs whenever access to data of a particular type is completed. */
    DataAccessEnded,
    /** # data-accessed

Data Accessed. The trigger occurs whenever data of a particular type is accessed. */
    DataAccessed,
    /** # data-added

Data Added. The trigger occurs whenever data of a particular type is added. */
    DataAdded,
    /** # data-changed

Data Changed. The trigger occurs whenever data of a particular type is changed in any way, either added, modified, or removed. */
    DataChanged,
    /** # data-modified

Data Updated. The trigger occurs whenever data of a particular type is modified. */
    DataModified,
    /** # data-removed

Data Removed. The trigger occurs whenever data of a particular type is removed. */
    DataRemoved,
    /** # named-event

Named Event. The trigger occurs in response to a specific named event, and no other information about the trigger is specified. Named events are completely pre-coordinated, and the formal semantics of the trigger are not provided. */
    NamedEvent,
    /** # periodic

Periodic. The trigger occurs at a specific time or periodically as described by a timing or schedule. A periodic event cannot have any data elements, but may have a name assigned as a shorthand for the event. */
    Periodic,
}
impl ::core::str::FromStr for TriggerType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "data-access-ended" => Ok(Self::DataAccessEnded),
            "data-accessed" => Ok(Self::DataAccessed),
            "data-added" => Ok(Self::DataAdded),
            "data-changed" => Ok(Self::DataChanged),
            "data-modified" => Ok(Self::DataModified),
            "data-removed" => Ok(Self::DataRemoved),
            "named-event" => Ok(Self::NamedEvent),
            "periodic" => Ok(Self::Periodic),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TriggerType {
    fn as_ref(&self) -> &str {
        match self {
            Self::DataAccessEnded => "data-access-ended",
            Self::DataAccessed => "data-accessed",
            Self::DataAdded => "data-added",
            Self::DataChanged => "data-changed",
            Self::DataModified => "data-modified",
            Self::DataRemoved => "data-removed",
            Self::NamedEvent => "named-event",
            Self::Periodic => "periodic",
        }
    }
}
impl<'de> Deserialize<'de> for TriggerType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TriggerType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `TypeDerivationRule`. How a type relates to its baseDefinition.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum TypeDerivationRule {
    /** # constraint

Constraint. This definition adds additional rules to an existing concrete type. */
    Constraint,
    /** # specialization

Specialization. This definition defines a new type that adds additional elements to the base type. */
    Specialization,
}
impl ::core::str::FromStr for TypeDerivationRule {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "constraint" => Ok(Self::Constraint),
            "specialization" => Ok(Self::Specialization),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for TypeDerivationRule {
    fn as_ref(&self) -> &str {
        match self {
            Self::Constraint => "constraint",
            Self::Specialization => "specialization",
        }
    }
}
impl<'de> Deserialize<'de> for TypeDerivationRule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for TypeDerivationRule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `UndesirablEffectFrequency`. A categorisation for a frequency of occurence of an undesirable effect.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum UndesirablEffectFrequency {
    /** # Common

Common. */
    Common,
    /** # Rare

Rare. */
    Rare,
    /** # Uncommon

Uncommon. */
    Uncommon,
}
impl ::core::str::FromStr for UndesirablEffectFrequency {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "Common" => Ok(Self::Common),
            "Rare" => Ok(Self::Rare),
            "Uncommon" => Ok(Self::Uncommon),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UndesirablEffectFrequency {
    fn as_ref(&self) -> &str {
        match self {
            Self::Common => "Common",
            Self::Rare => "Rare",
            Self::Uncommon => "Uncommon",
        }
    }
}
impl<'de> Deserialize<'de> for UndesirablEffectFrequency {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UndesirablEffectFrequency {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `UnitOfPresentation`. The presentation type in which an administrable medicinal product is given to a patient.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum UnitOfPresentation {
    /** # 200000002108

Barrel. */
    N200000002108,
    /** # 200000002109

Blister. */
    N200000002109,
    /** # 200000002110

Block. */
    N200000002110,
    /** # 200000002111

Bottle. */
    N200000002111,
    /** # 200000002112

Cachet. */
    N200000002112,
    /** # 200000002113

Capsule. */
    N200000002113,
    /** # 200000002114

Cartridge. */
    N200000002114,
    /** # 200000002115

Collar. */
    N200000002115,
    /** # 200000002116

Container. */
    N200000002116,
    /** # 200000002117

Cup. */
    N200000002117,
    /** # 200000002118

Cylinder. */
    N200000002118,
    /** # 200000002119

Dart. */
    N200000002119,
    /** # 200000002120

Dressing. */
    N200000002120,
    /** # 200000002121

Drop. */
    N200000002121,
    /** # 200000002122

Film. */
    N200000002122,
    /** # 200000002123

Chewing gum. */
    N200000002123,
    /** # 200000002124

Implant. */
    N200000002124,
    /** # 200000002125

Inhaler. */
    N200000002125,
    /** # 200000002126

Insert. */
    N200000002126,
    /** # 200000002127

Jar. */
    N200000002127,
    /** # 200000002128

Lozenge. */
    N200000002128,
    /** # 200000002129

Lyophilisate. */
    N200000002129,
    /** # 200000002130

Matrix. */
    N200000002130,
    /** # 200000002131

Pad. */
    N200000002131,
    /** # 200000002132

Paper. */
    N200000002132,
    /** # 200000002133

Pastille. */
    N200000002133,
    /** # 200000002134

Patch. */
    N200000002134,
    /** # 200000002135

Pen. */
    N200000002135,
    /** # 200000002136

Pendant. */
    N200000002136,
    /** # 200000002137

Pessary. */
    N200000002137,
    /** # 200000002138

Pillule. */
    N200000002138,
    /** # 200000002139

Pipette. */
    N200000002139,
    /** # 200000002140

Plaster. */
    N200000002140,
    /** # 200000002141

Plug. */
    N200000002141,
    /** # 200000002142

Pouch. */
    N200000002142,
    /** # 200000002143

Sachet. */
    N200000002143,
    /** # 200000002144

Sponge. */
    N200000002144,
    /** # 200000002145

Spoonful. */
    N200000002145,
    /** # 200000002146

Stick. */
    N200000002146,
    /** # 200000002147

Straw. */
    N200000002147,
    /** # 200000002148

Strip. */
    N200000002148,
    /** # 200000002149

Suppository. */
    N200000002149,
    /** # 200000002150

Syringe. */
    N200000002150,
    /** # 200000002151

System. */
    N200000002151,
    /** # 200000002152

Tablet. */
    N200000002152,
    /** # 200000002153

Tag. */
    N200000002153,
    /** # 200000002154

Tampon. */
    N200000002154,
    /** # 200000002155

Thread. */
    N200000002155,
    /** # 200000002156

Tube. */
    N200000002156,
    /** # 200000002157

Vessel. */
    N200000002157,
    /** # 200000002158

Vial. */
    N200000002158,
    /** # 200000002159

Puff. */
    N200000002159,
    /** # 200000002163

Actuation. */
    N200000002163,
    /** # 200000002164

Ampoule. */
    N200000002164,
    /** # 200000002165

Applicator. */
    N200000002165,
    /** # 200000002166

Bag. */
    N200000002166,
}
impl ::core::str::FromStr for UnitOfPresentation {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "200000002108" => Ok(Self::N200000002108),
            "200000002109" => Ok(Self::N200000002109),
            "200000002110" => Ok(Self::N200000002110),
            "200000002111" => Ok(Self::N200000002111),
            "200000002112" => Ok(Self::N200000002112),
            "200000002113" => Ok(Self::N200000002113),
            "200000002114" => Ok(Self::N200000002114),
            "200000002115" => Ok(Self::N200000002115),
            "200000002116" => Ok(Self::N200000002116),
            "200000002117" => Ok(Self::N200000002117),
            "200000002118" => Ok(Self::N200000002118),
            "200000002119" => Ok(Self::N200000002119),
            "200000002120" => Ok(Self::N200000002120),
            "200000002121" => Ok(Self::N200000002121),
            "200000002122" => Ok(Self::N200000002122),
            "200000002123" => Ok(Self::N200000002123),
            "200000002124" => Ok(Self::N200000002124),
            "200000002125" => Ok(Self::N200000002125),
            "200000002126" => Ok(Self::N200000002126),
            "200000002127" => Ok(Self::N200000002127),
            "200000002128" => Ok(Self::N200000002128),
            "200000002129" => Ok(Self::N200000002129),
            "200000002130" => Ok(Self::N200000002130),
            "200000002131" => Ok(Self::N200000002131),
            "200000002132" => Ok(Self::N200000002132),
            "200000002133" => Ok(Self::N200000002133),
            "200000002134" => Ok(Self::N200000002134),
            "200000002135" => Ok(Self::N200000002135),
            "200000002136" => Ok(Self::N200000002136),
            "200000002137" => Ok(Self::N200000002137),
            "200000002138" => Ok(Self::N200000002138),
            "200000002139" => Ok(Self::N200000002139),
            "200000002140" => Ok(Self::N200000002140),
            "200000002141" => Ok(Self::N200000002141),
            "200000002142" => Ok(Self::N200000002142),
            "200000002143" => Ok(Self::N200000002143),
            "200000002144" => Ok(Self::N200000002144),
            "200000002145" => Ok(Self::N200000002145),
            "200000002146" => Ok(Self::N200000002146),
            "200000002147" => Ok(Self::N200000002147),
            "200000002148" => Ok(Self::N200000002148),
            "200000002149" => Ok(Self::N200000002149),
            "200000002150" => Ok(Self::N200000002150),
            "200000002151" => Ok(Self::N200000002151),
            "200000002152" => Ok(Self::N200000002152),
            "200000002153" => Ok(Self::N200000002153),
            "200000002154" => Ok(Self::N200000002154),
            "200000002155" => Ok(Self::N200000002155),
            "200000002156" => Ok(Self::N200000002156),
            "200000002157" => Ok(Self::N200000002157),
            "200000002158" => Ok(Self::N200000002158),
            "200000002159" => Ok(Self::N200000002159),
            "200000002163" => Ok(Self::N200000002163),
            "200000002164" => Ok(Self::N200000002164),
            "200000002165" => Ok(Self::N200000002165),
            "200000002166" => Ok(Self::N200000002166),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UnitOfPresentation {
    fn as_ref(&self) -> &str {
        match self {
            Self::N200000002108 => "200000002108",
            Self::N200000002109 => "200000002109",
            Self::N200000002110 => "200000002110",
            Self::N200000002111 => "200000002111",
            Self::N200000002112 => "200000002112",
            Self::N200000002113 => "200000002113",
            Self::N200000002114 => "200000002114",
            Self::N200000002115 => "200000002115",
            Self::N200000002116 => "200000002116",
            Self::N200000002117 => "200000002117",
            Self::N200000002118 => "200000002118",
            Self::N200000002119 => "200000002119",
            Self::N200000002120 => "200000002120",
            Self::N200000002121 => "200000002121",
            Self::N200000002122 => "200000002122",
            Self::N200000002123 => "200000002123",
            Self::N200000002124 => "200000002124",
            Self::N200000002125 => "200000002125",
            Self::N200000002126 => "200000002126",
            Self::N200000002127 => "200000002127",
            Self::N200000002128 => "200000002128",
            Self::N200000002129 => "200000002129",
            Self::N200000002130 => "200000002130",
            Self::N200000002131 => "200000002131",
            Self::N200000002132 => "200000002132",
            Self::N200000002133 => "200000002133",
            Self::N200000002134 => "200000002134",
            Self::N200000002135 => "200000002135",
            Self::N200000002136 => "200000002136",
            Self::N200000002137 => "200000002137",
            Self::N200000002138 => "200000002138",
            Self::N200000002139 => "200000002139",
            Self::N200000002140 => "200000002140",
            Self::N200000002141 => "200000002141",
            Self::N200000002142 => "200000002142",
            Self::N200000002143 => "200000002143",
            Self::N200000002144 => "200000002144",
            Self::N200000002145 => "200000002145",
            Self::N200000002146 => "200000002146",
            Self::N200000002147 => "200000002147",
            Self::N200000002148 => "200000002148",
            Self::N200000002149 => "200000002149",
            Self::N200000002150 => "200000002150",
            Self::N200000002151 => "200000002151",
            Self::N200000002152 => "200000002152",
            Self::N200000002153 => "200000002153",
            Self::N200000002154 => "200000002154",
            Self::N200000002155 => "200000002155",
            Self::N200000002156 => "200000002156",
            Self::N200000002157 => "200000002157",
            Self::N200000002158 => "200000002158",
            Self::N200000002159 => "200000002159",
            Self::N200000002163 => "200000002163",
            Self::N200000002164 => "200000002164",
            Self::N200000002165 => "200000002165",
            Self::N200000002166 => "200000002166",
        }
    }
}
impl<'de> Deserialize<'de> for UnitOfPresentation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UnitOfPresentation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `UnitTypeCodes`. This value set includes a smattering of Unit type codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum UnitTypeCodes {
    /** # family

Family. A family, typically includes self, spouse(s) and children to a defined age */
    Family,
    /** # individual

Individual. A single individual */
    Individual,
    /// Custom code value.
    _Custom(String),
}
impl ::core::str::FromStr for UnitTypeCodes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "family" => Ok(Self::Family),
            "individual" => Ok(Self::Individual),
            _ => Ok(Self::_Custom(s.to_owned())),
        }
    }
}
impl AsRef<str> for UnitTypeCodes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Family => "family",
            Self::Individual => "individual",
            Self::_Custom(s) => s.as_str(),
        }
    }
}
impl<'de> Deserialize<'de> for UnitTypeCodes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UnitTypeCodes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `UsageContextType`. A code that specifies a type of context being specified by a usage context.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum UsageContextType {
    /** # age

Age Range. The age of the patient. For this context type, the value could be a range that specifies the applicable ages or a code from an appropriate value set such as the MeSH value set http://terminology.hl7.org/ValueSet/v3-AgeGroupObservationValue. */
    Age,
    /** # focus

Clinical Focus. The clinical concept(s) addressed by the artifact. For example, disease, diagnostic test interpretation, medication ordering as in http://hl7.org/fhir/ValueSet/condition-code. */
    Focus,
    /** # gender

Gender. The gender of the patient. For this context type, appropriate values can be found in the http://hl7.org/fhir/ValueSet/administrative-gender value set. */
    Gender,
    /** # program

Program. A program/project of work for which this artifact is applicable. */
    Program,
    /** # species

Species. The species to which an artifact applies. For example, SNOMED - 387961004 | Kingdom Animalia (organism). */
    Species,
    /** # task

Workflow Task. The context for the clinical task(s) represented by this artifact. For example, this could be any task context represented by the HL7 ActTaskCode value set http://terminology.hl7.org/ValueSet/v3-ActTaskCode. General categories include: order entry, patient documentation and patient information review. */
    Task,
    /** # user

User Type. The clinical specialty of the context in which the patient is being treated - For example, PCP, Patient, Cardiologist, Behavioral Professional, Oral Health Professional, Prescriber, etc... taken from a specialty value set such as the NUCC Health Care provider taxonomy value set http://hl7.org/fhir/ValueSet/provider-taxonomy. */
    User,
    /** # venue

Clinical Venue. The venue in which an artifact could be used. For example, Outpatient, Inpatient, Home, Nursing home. The code value may originate from the HL7 ServiceDeliveryLocationRoleType value set (http://terminology.hl7.org/ValueSet/v3-ServiceDeliveryLocationRoleType). */
    Venue,
    /** # workflow

Workflow Setting. The settings in which the artifact is intended for use. For example, admission, pre-op, etc. For example, the ActEncounterCode value set http://terminology.hl7.org/ValueSet/v3-ActEncounterCode. */
    Workflow,
}
impl ::core::str::FromStr for UsageContextType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "age" => Ok(Self::Age),
            "focus" => Ok(Self::Focus),
            "gender" => Ok(Self::Gender),
            "program" => Ok(Self::Program),
            "species" => Ok(Self::Species),
            "task" => Ok(Self::Task),
            "user" => Ok(Self::User),
            "venue" => Ok(Self::Venue),
            "workflow" => Ok(Self::Workflow),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for UsageContextType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Age => "age",
            Self::Focus => "focus",
            Self::Gender => "gender",
            Self::Program => "program",
            Self::Species => "species",
            Self::Task => "task",
            Self::User => "user",
            Self::Venue => "venue",
            Self::Workflow => "workflow",
        }
    }
}
impl<'de> Deserialize<'de> for UsageContextType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for UsageContextType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `Use`. The purpose of the Claim: predetermination, preauthorization, claim.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum Use {
    /** # claim

Claim. The treatment is complete and this represents a Claim for the services. */
    Claim,
    /** # preauthorization

Preauthorization. The treatment is proposed and this represents a Pre-authorization for the services. */
    Preauthorization,
    /** # predetermination

Predetermination. The treatment is proposed and this represents a Pre-determination for the services. */
    Predetermination,
}
impl ::core::str::FromStr for Use {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "claim" => Ok(Self::Claim),
            "preauthorization" => Ok(Self::Preauthorization),
            "predetermination" => Ok(Self::Predetermination),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for Use {
    fn as_ref(&self) -> &str {
        match self {
            Self::Claim => "claim",
            Self::Preauthorization => "preauthorization",
            Self::Predetermination => "predetermination",
        }
    }
}
impl<'de> Deserialize<'de> for Use {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for Use {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `VisionBase`. A coded concept listing the base codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum VisionBase {
    /** # down

Down. bottom. */
    Down,
    /** # in

In. inner edge. */
    In,
    /** # out

Out. outer edge. */
    Out,
    /** # up

Up. top. */
    Up,
}
impl ::core::str::FromStr for VisionBase {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "down" => Ok(Self::Down),
            "in" => Ok(Self::In),
            "out" => Ok(Self::Out),
            "up" => Ok(Self::Up),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VisionBase {
    fn as_ref(&self) -> &str {
        match self {
            Self::Down => "down",
            Self::In => "in",
            Self::Out => "out",
            Self::Up => "up",
        }
    }
}
impl<'de> Deserialize<'de> for VisionBase {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VisionBase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `VisionEyes`. A coded concept listing the eye codes.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum VisionEyes {
    /** # left

Left Eye. Left Eye. */
    Left,
    /** # right

Right Eye. Right Eye. */
    Right,
}
impl ::core::str::FromStr for VisionEyes {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for VisionEyes {
    fn as_ref(&self) -> &str {
        match self {
            Self::Left => "left",
            Self::Right => "right",
        }
    }
}
impl<'de> Deserialize<'de> for VisionEyes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for VisionEyes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
/**FHIR Code `WarningType`. Classification of warning type.

FHIR version: 4.3.0.*/
#[derive(Debug, PartialEq, Eq, Clone)]
#[derive(Copy)]
pub enum WarningType {
    /** # P313

Get medical advice/attention.. Get medical advice/attention. */
    P313,
    /** # P314

Get medical advice/attention if you feel unwell.. Get medical advice/attention if you feel unwell. */
    P314,
    /** # P315

Get immediate medical advice/attention.. Get immediate medical advice/attention. */
    P315,
    /** # P320

Specific treatment is urgent (see ... on this label).. Specific treatment is urgent (see ... on this label). */
    P320,
    /** # P321

Specific treatment (see ... on this label).. Specific treatment (see ... on this label). */
    P321,
    /** # P322

Specific measures (see ... on this label).. Specific measures (see ... on this label). */
    P322,
    /** # P330

Rinse mouth.. Rinse mouth. */
    P330,
    /** # P331

Do NOT induce vomiting.. Do NOT induce vomiting. */
    P331,
    /** # P361

Remove/Take off immediately all contaminated clothing.. Remove/Take off immediately all contaminated clothing. */
    P361,
    /** # P363

Wash contaminated clothing before reuse... Wash contaminated clothing before reuse. */
    P363,
}
impl ::core::str::FromStr for WarningType {
    type Err = String;
    #[allow(clippy::match_single_binding)]
    fn from_str(s: &str) -> ::core::result::Result<Self, Self::Err> {
        match s {
            "P313" => Ok(Self::P313),
            "P314" => Ok(Self::P314),
            "P315" => Ok(Self::P315),
            "P320" => Ok(Self::P320),
            "P321" => Ok(Self::P321),
            "P322" => Ok(Self::P322),
            "P330" => Ok(Self::P330),
            "P331" => Ok(Self::P331),
            "P361" => Ok(Self::P361),
            "P363" => Ok(Self::P363),
            _ => Err(format!("Unknown value: {s}")),
        }
    }
}
impl AsRef<str> for WarningType {
    fn as_ref(&self) -> &str {
        match self {
            Self::P313 => "P313",
            Self::P314 => "P314",
            Self::P315 => "P315",
            Self::P320 => "P320",
            Self::P321 => "P321",
            Self::P322 => "P322",
            Self::P330 => "P330",
            Self::P331 => "P331",
            Self::P361 => "P361",
            Self::P363 => "P363",
        }
    }
}
impl<'de> Deserialize<'de> for WarningType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::Error;
        let string = String::deserialize(deserializer)?;
        string.parse().map_err(D::Error::custom)
    }
}
impl Serialize for WarningType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.as_ref().serialize(serializer)
    }
}
